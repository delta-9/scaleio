// Domain Public by Eric Wendelin http://eriwen.com/ (2008)
//                  Luke Smith http://lucassmith.name/ (2008)
//                  Loic Dachary <loic@dachary.org> (2008)
//                  Johan Euphrosine <proppy@aminche.com> (2008)
//                  Oyvind Sean Kinsey http://kinsey.no/blog (2010)
//                  Victor Homyakov <victor-homyakov@users.sourceforge.net> (2010)

/**
 * Main function giving a function stack trace with a forced or passed in Error
 *
 * @cfg {Error} e The error to create a stacktrace from (optional)
 * @cfg {Boolean} guess If we should try to resolve the names of anonymous functions
 * @return {Array} of Strings with functions, lines, files, and arguments where possible
 */
function printStackTrace(options) {
    options = options || {guess: true};
    var ex = options.e || null, guess = !!options.guess;
    var p = new printStackTrace.implementation(), result = p.run(ex);
    var res = (guess) ? p.guessAnonymousFunctions(result) : result;
	for (var k = 0; k < 4; k++) {
		res.shift();
	}
	return res;
}

printStackTrace.implementation = function() {
};

printStackTrace.implementation.prototype = {
    run: function(ex) {
        ex = ex || this.createException();
        // Do not use the stored mode: different exceptions in Chrome
        // may or may not have arguments or stack
        var mode = this.mode(ex);
        // Use either the stored mode, or resolve it
        //var mode = this._mode || this.mode(ex);
        if (mode === 'other') {
            return this.other(arguments.callee);
        } else {
            return this[mode](ex);
        }
    },

    createException: function() {
        try {
            this.undef();
            return null;
        } catch (e) {
            return e;
        }
    },

    /**
     * @return {String} mode of operation for the environment in question.
     */
    mode: function(e) {
        if (e['arguments'] && e.stack) {
            return (this._mode = 'chrome');
        } else if (e.message && typeof window !== 'undefined' && window.opera) {
            return (this._mode = e.stacktrace ? 'opera10' : 'opera');
        } else if (e.stack) {
            return (this._mode = 'firefox');
        }
        return (this._mode = 'other');
    },

    /**
     * Given a context, function name, and callback function, overwrite it so that it calls
     * printStackTrace() first with a callback and then runs the rest of the body.
     *
     * @param {Object} context of execution (e.g. window)
     * @param {String} functionName to instrument
     * @param {Function} function to call with a stack trace on invocation
     */
    instrumentFunction: function(context, functionName, callback) {
        context = context || window;
        var original = context[functionName];
        context[functionName] = function instrumented() {
            callback.call(this, printStackTrace().slice(4));
            return context[functionName]._instrumented.apply(this, arguments);
        };
        context[functionName]._instrumented = original;
    },

    /**
     * Given a context and function name of a function that has been
     * instrumented, revert the function to it's original (non-instrumented)
     * state.
     *
     * @param {Object} context of execution (e.g. window)
     * @param {String} functionName to de-instrument
     */
    deinstrumentFunction: function(context, functionName) {
        if (context[functionName].constructor === Function &&
                context[functionName]._instrumented &&
                context[functionName]._instrumented.constructor === Function) {
            context[functionName] = context[functionName]._instrumented;
        }
    },

    /**
     * Given an Error object, return a formatted Array based on Chrome's stack string.
     *
     * @param e - Error object to inspect
     * @return Array<String> of function calls, files and line numbers
     */
    chrome: function(e) {
        var stack = (e.stack + '\n').replace(/^\S[^\(]+?[\n$]/gm, '').
          replace(/^\s+at\s+/gm, '').
          replace(/^([^\(]+?)([\n$])/gm, '{anonymous}()@$1$2').
          replace(/^Object.<anonymous>\s*\(([^\)]+)\)/gm, '{anonymous}()@$1').split('\n');
        stack.pop();
        return stack;
    },

    /**
     * Given an Error object, return a formatted Array based on Firefox's stack string.
     *
     * @param e - Error object to inspect
     * @return Array<String> of function calls, files and line numbers
     */
    firefox: function(e) {
        return e.stack.replace(/(?:\n@:0)?\s+$/m, '').replace(/^\(/gm, '{anonymous}(').split('\n');
    },

    /**
     * Given an Error object, return a formatted Array based on Opera 10's stacktrace string.
     *
     * @param e - Error object to inspect
     * @return Array<String> of function calls, files and line numbers
     */
    opera10: function(e) {
        var stack = e.stacktrace;
        var lines = stack.split('\n'), ANON = '{anonymous}', lineRE = /.*line (\d+), column (\d+) in ((<anonymous function\:?\s*(\S+))|([^\(]+)\([^\)]*\))(?: in )?(.*)\s*$/i, i, j, len;
        for (i = 2, j = 0, len = lines.length; i < len - 2; i++) {
            if (lineRE.test(lines[i])) {
                var location = RegExp.$6 + ':' + RegExp.$1 + ':' + RegExp.$2;
                var fnName = RegExp.$3;
                fnName = fnName.replace(/<anonymous function\:?\s?(\S+)?>/g, ANON);
                lines[j++] = fnName + '@' + location;
            }
        }

        lines.splice(j, lines.length - j);
        return lines;
    },

    // Opera 7.x-9.x only!
    opera: function(e) {
        var lines = e.message.split('\n'), ANON = '{anonymous}', lineRE = /Line\s+(\d+).*script\s+(http\S+)(?:.*in\s+function\s+(\S+))?/i, i, j, len;

        for (i = 4, j = 0, len = lines.length; i < len; i += 2) {
            //TODO: RegExp.exec() would probably be cleaner here
            if (lineRE.test(lines[i])) {
                lines[j++] = (RegExp.$3 ? RegExp.$3 + '()@' + RegExp.$2 + RegExp.$1 : ANON + '()@' + RegExp.$2 + ':' + RegExp.$1) + ' -- ' + lines[i + 1].replace(/^\s+/, '');
            }
        }

        lines.splice(j, lines.length - j);
        return lines;
    },

    // Safari, IE, and others
    other: function(curr) {
        var ANON = '{anonymous}', fnRE = /function\s*([\w\-$]+)?\s*\(/i, stack = [], fn, args, maxStackSize = 10;
        while (curr && stack.length < maxStackSize) {
            fn = fnRE.test(curr.toString()) ? RegExp.$1 || ANON : ANON;
            args = Array.prototype.slice.call(curr['arguments'] || []);
            stack[stack.length] = fn + '(' + this.stringifyArguments(args) + ')';
            curr = curr.caller;
        }
        return stack;
    },

    /**
     * Given arguments array as a String, subsituting type names for non-string types.
     *
     * @param {Arguments} object
     * @return {Array} of Strings with stringified arguments
     */
    stringifyArguments: function(args) {
        var slice = Array.prototype.slice;
        for (var i = 0; i < args.length; ++i) {
            var arg = args[i];
            if (arg === undefined) {
                args[i] = 'undefined';
            } else if (arg === null) {
                args[i] = 'null';
            } else if (arg.constructor) {
                if (arg.constructor === Array) {
                    if (arg.length < 3) {
                        args[i] = '[' + this.stringifyArguments(arg) + ']';
                    } else {
                        args[i] = '[' + this.stringifyArguments(slice.call(arg, 0, 1)) + '...' + this.stringifyArguments(slice.call(arg, -1)) + ']';
                    }
                } else if (arg.constructor === Object) {
                    args[i] = '#object';
                } else if (arg.constructor === Function) {
                    args[i] = '#function';
                } else if (arg.constructor === String) {
                    args[i] = '"' + arg + '"';
                }
            }
        }
        return args.join(',');
    },

    sourceCache: {},

    /**
     * @return {*} the text from a given URL.
     */
    ajax: function(url) {
        var req = this.createXMLHTTPObject();
        if (!req) {
            return;
        }
        req.open('GET', url, false);
        //req.setRequestHeader('User-Agent', 'XMLHTTP/1.0');
        req.send('');
        return req.responseText;
    },

    /**
     * Try XHR methods in order and store XHR factory.
     *
     * @return <Function> XHR function or equivalent
     */
    createXMLHTTPObject: function() {
        var xmlhttp, XMLHttpFactories = [
            function() {
                return new XMLHttpRequest();
            }, function() {
                return new ActiveXObject('Msxml2.XMLHTTP');
            }, function() {
                return new ActiveXObject('Msxml3.XMLHTTP');
            }, function() {
                return new ActiveXObject('Microsoft.XMLHTTP');
            }
        ];
        for (var i = 0; i < XMLHttpFactories.length; i++) {
            try {
                xmlhttp = XMLHttpFactories[i]();
                // Use memoization to cache the factory
                this.createXMLHTTPObject = XMLHttpFactories[i];
                return xmlhttp;
            } catch (e) {
            }
        }
    },

    /**
     * Given a URL, check if it is in the same domain (so we can get the source
     * via Ajax).
     *
     * @param url <String> source url
     * @return False if we need a cross-domain request
     */
    isSameDomain: function(url) {
        return url.indexOf(location.hostname) !== -1;
    },

    /**
     * Get source code from given URL if in the same domain.
     *
     * @param url <String> JS source URL
     * @return <Array> Array of source code lines
     */
    getSource: function(url) {
        if (!(url in this.sourceCache)) {
            this.sourceCache[url] = this.ajax(url).split('\n');
        }
        return this.sourceCache[url];
    },

    guessAnonymousFunctions: function(stack) {
        for (var i = 0; i < stack.length; ++i) {
            var reStack = /\{anonymous\}\(.*\)@(\w+:\/\/([\-\w\.]+)+(:\d+)?[^:]+):(\d+):?(\d+)?/;
            var frame = stack[i], m = reStack.exec(frame);
            if (m) {
                var file = m[1], lineno = m[4], charno = m[7] || 0; //m[7] is character position in Chrome
                if (file && this.isSameDomain(file) && lineno) {
                    var functionName = this.guessAnonymousFunction(file, lineno, charno);
                    stack[i] = frame.replace('{anonymous}', functionName);
                }
            }
        }
        return stack;
    },

    guessAnonymousFunction: function(url, lineNo, charNo) {
        var ret;
        try {
            ret = this.findFunctionName(this.getSource(url), lineNo);
        } catch (e) {
            ret = 'getSource failed with url: ' + url + ', exception: ' + e.toString();
        }
        return ret;
    },

    findFunctionName: function(source, lineNo) {
        // FIXME findFunctionName fails for compressed source
        // (more than one function on the same line)
        // TODO use captured args
        // function {name}({args}) m[1]=name m[2]=args
        var reFunctionDeclaration = /function\s+([^(]*?)\s*\(([^)]*)\)/;
        // {name} = function ({args}) TODO args capture
        // /['"]?([0-9A-Za-z_]+)['"]?\s*[:=]\s*function(?:[^(]*)/
        var reFunctionExpression = /['"]?([0-9A-Za-z_]+)['"]?\s*[:=]\s*function\b/;
        // {name} = eval()
        var reFunctionEvaluation = /['"]?([0-9A-Za-z_]+)['"]?\s*[:=]\s*(?:eval|new Function)\b/;
        // Walk backwards in the source lines until we find
        // the line which matches one of the patterns above
        var code = "", line, maxLines = 10, m;
        for (var i = 0; i < maxLines; ++i) {
            // FIXME lineNo is 1-based, source[] is 0-based
            line = source[lineNo - i];
            if (line) {
                code = line + code;

                m = reFunctionExpression.exec(code);
                if (m && m[1]) {
                    return m[1];
                }
                m = reFunctionDeclaration.exec(code);
                if (m && m[1]) {
                    //return m[1] + "(" + (m[2] || "") + ")";
                    return m[1];
                }
                m = reFunctionEvaluation.exec(code);
                if (m && m[1]) {
                    return m[1];
                }
            }
        }
        return '(?)';
    }
};
/************************/
/* Isogenic Game Engine */
/************************/
ige = null;

// When setting a new version please use this format:
// v{MAJOR}.{MINOR}.{SUB}@{YYYY-MM-DD}.{REVISION}
//
// For example, to tag version 1.1.2 on 25th April 2013
// as the third revision of the day:
// v1.1.2@2013-04-25.003
igeVersion = 'v1.6.0@2015-04-29.001';

// Define the global storage object for classes
igeClassStore = {};

igeConfig = {
	debug: {
		_enabled: true,
		_node: typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined',
		_level: ['log', 'warning', 'error'],
		_stacks: true,
		_throwErrors: true,
		_timing: true,
		enabled: function (val) {
			if (val !== undefined) {
				this._enabled = val;
	
				if (!val) {
					this._timing = false;
	
					// Check if the engine exists
					if (ige) {
						// Turn off stats display in the engine
						ige.showStats(0);
					}
				}
	
				return this;
			}
	
			return this._enabled;
		}
	}
};

if (igeConfig.debug._node) {
	igeConfig.debug._util = require('util');
}

/**
 * Make property non-enumerable.
 */
Object.defineProperty(Object.prototype, 'tween', {
	enumerable:false,
	writable:true,
	configurable:true
});

/**
 * Augments all objects with the tween() method. Creates a new IgeTween
 * with the passed parameters that will act upon the object's properties.
 * The returned tween will not start tweening until a call to start() is
 * made.
 * @param {Object} props
 * @param {Number} durationMs
 * @param {Object=} options
 * @return {IgeTween}
 */
Object.prototype.tween = function (props, durationMs, options) {
	var newTween = new IgeTween()
		.targetObj(this)
		.properties(props)
		.duration(durationMs);

	if (options) {
		if (options.beforeTween) { newTween.beforeTween(options.beforeTween); }
		if (options.afterTween) { newTween.afterTween(options.afterTween); }
		if (options.easing) { newTween.easing(options.easing); }
		if (options.startTime) { newTween.startTime(options.startTime); }
	}

	return newTween;
};

/**
 * Make property non-enumerable.
 */
Object.defineProperty(Object.prototype, 'theSameAs', {
	enumerable:false,
	writable:true,
	configurable:true
});

/**
 * Augments all objects with the theSameAs() method. Checks if the
 * property values of this object are equal to the property values
 * of the passed object. If they are the same then this method will
 * return true. Objects must not contain circular references!
 * @param {Object} obj The object to compare this one to.
 * @return {Boolean}
 */
Object.prototype.theSameAs = function (obj) {
	return JSON.stringify(this) === JSON.stringify(obj);
};

/**
 * Make property non-enumerable.
 */
Object.defineProperty(Array.prototype, 'clone', {
	enumerable:false,
	writable:true,
	configurable:true
});

/**
 * Clones the array and returns a new non-referenced
 * array.
 * @return {*}
 */
Array.prototype.clone = function () {
	var i, newArray = [];
	for (i in this) {
		if (this.hasOwnProperty(i)) {
			if (this[i] instanceof Array) {
				newArray[i] = this[i].clone();
			} else {
				newArray[i] = this[i];
			}
		}
	}

	return newArray;
};

/**
 * Make property non-enumerable.
 */
Object.defineProperty(Array.prototype, 'pull', {
	enumerable:false,
	writable:true,
	configurable:true
});

/**
 * Removes the passed item from an array, the opposite of push().
 * @param item
 * @return {*}
 */
Array.prototype.pull = function (item) {
	var index = this.indexOf(item);
	if (index > -1) {
		this.splice(index, 1);
		return index;
	} else {
		return -1;
	}
};

/**
 * Make property non-enumerable.
 */
Object.defineProperty(Array.prototype, 'pushUnique', {
	enumerable:false,
	writable:true,
	configurable:true
});

/**
 * Adds an item to an array, only if it does not already exist in the array.
 * @param item
 * @return {Boolean} True if the item was added, false if it already exists.
 */
Array.prototype.pushUnique = function (item) {
	var index = this.indexOf(item);
	if (index === -1) {
		this.push(item);
		return true;
	}
	
	return false;
};

/**
 * Make property non-enumerable.
 */
Object.defineProperty(Array.prototype, 'each', {
	enumerable:false,
	writable:true,
	configurable:true
});

/**
 * Iterates through an array's items and calls the callback method
 * passing each item one by one.
 * @param {Function} callback
 */
Array.prototype.each = function (callback) {
	var len = this.length,
		i;

	for (i = 0; i < len; i++) {
		callback(this[i]);
	}
};

/**
 * Make property non-enumerable.
 */
Object.defineProperty(Array.prototype, 'eachReverse', {
	enumerable:false,
	writable:true,
	configurable:true
});

/**
 * Iterates through an array's items and calls the callback method
 * passing each item one by one in reverse order.
 * @param {Function} callback
 */
Array.prototype.eachReverse = function (callback) {
	var arrCount = this.length,
		i;

	for (i = arrCount - 1; i >= 0; i--) {
		callback(this[i]);
	}
};

/**
 * Make property non-enumerable.
 */
Object.defineProperty(Array.prototype, 'destroyAll', {
	enumerable:false,
	writable:true,
	configurable:true
});

/**
 * Iterates through an array's items and calls each item's
 * destroy() method if it exists. Useful for destroying an
 * array of IgeEntity instances.
 */
Array.prototype.destroyAll = function () {
	var arrCount = this.length,
		i;

	for (i = arrCount - 1; i >= 0; i--) {
		if (typeof(this[i].destroy) === 'function') {
			this[i].destroy();
		}
	}
};

/**
 * Make property non-enumerable.
 */
Object.defineProperty(Array.prototype, 'eachIsolated', {
	enumerable:false,
	writable:true,
	configurable:true
});

/**
 * Iterates through an array's items and calls the callback method
 * passing each item one by one. Altering the array's structure
 * during the callback method will not affect the iteration of the
 * items.
 *
 * @param {Function} callback
 */
Array.prototype.eachIsolated = function (callback) {
	var arr = [],
		arrCount = arr.length,
		i;

	// Create a copy of the array
	for (i = 0; i < arrCount; i++) {
		arr[i] = this[i];
	}

	// Now iterate the array, passing the copied
	// array value at the index(i). Any changes to
	// "this" will not affect the index(i) values.
	for (i = 0; i < arrCount; i++) {
		callback(arr[i]);
	}
};

/**
 * Make property non-enumerable.
 */
Object.defineProperty(Math, 'PI180', {
	enumerable:false,
	writable:true,
	configurable:true
});

/**
 * Stores a pre-calculated PI / 180 value.
 * @type {Number}
 */
Math.PI180 = Math.PI / 180;

/**
 * Make property non-enumerable.
 */
Object.defineProperty(Math, 'PI180R', {
	enumerable:false,
	writable:true,
	configurable:true
});

/**
 * Stores a pre-calculated 180 / PI value.
 * @type {Number}
 */
Math.PI180R = 180 / Math.PI;

/**
 * Make property non-enumerable.
 */
Object.defineProperty(Math, 'toIso', {
	enumerable:false,
	writable:true,
	configurable:true
});

Math.toIso = function (x, y, z) {
	var sx = x - y,
		sy = (-z) * 1.2247 + (x + y) * 0.5;

	return {x: sx, y: sy};
};

/**
 * Make property non-enumerable.
 */
Object.defineProperty(Math, 'radians', {
	enumerable:false,
	writable:true,
	configurable:true
});

/**
 * Converts degrees to radians.
 * @param {Number} degrees
 * @return {Number} radians
 */
Math.radians = function (degrees) {
	return degrees * Math.PI180;
};

/**
 * Make property non-enumerable.
 */
Object.defineProperty(Math, 'degrees', {
	enumerable:false,
	writable:true,
	configurable:true
});

/**
 * Converts radians to degrees.
 * @param {Number} radians
 * @return {Number} degrees
 */
Math.degrees = function (radians) {
	return radians * Math.PI180R;
};

/**
 * Make property non-enumerable.
 */
Object.defineProperty(Math, 'distance', {
	enumerable:false,
	writable:true,
	configurable:true
});

/**
 * Calculates the distance from the first point to the second point.
 * @param x1
 * @param y1
 * @param x2
 * @param y2
 * @return {Number}
 */
Math.distance = function (x1, y1, x2, y2) {
	return Math.sqrt(((x1 - x2) * (x1 - x2)) + ((y1 - y2) * (y1 - y2)));
};

if (typeof(CanvasRenderingContext2D) !== 'undefined') {
	// Extend the canvas context to add some helper methods
	/**
	 * Make property non-enumerable.
	 */
	Object.defineProperty(CanvasRenderingContext2D.prototype, 'circle', {
		enumerable:false,
		writable:true,
		configurable:true
	});

	Object.defineProperty(CanvasRenderingContext2D.prototype, 'strokeCircle', {
		enumerable:false,
		writable:true,
		configurable:true
	});

	Object.defineProperty(CanvasRenderingContext2D.prototype, 'fillCircle', {
		enumerable:false,
		writable:true,
		configurable:true
	});

	CanvasRenderingContext2D.prototype.circle = function (x, y, radius) {
		this.arc(x, y, radius, 0, 2 * Math.PI, false);
	};

	CanvasRenderingContext2D.prototype.strokeCircle = function (x, y, radius) {
		this.save();
		this.beginPath();
		this.arc(x, y, radius, 0, 2 * Math.PI, false);
		this.stroke();
		this.restore();
	};

	CanvasRenderingContext2D.prototype.fillCircle = function (x, y, radius) {
		this.save();
		this.beginPath();
		this.arc(x, y, radius, 0, 2 * Math.PI, false);
		this.fill();
		this.restore();
	};
}

if (typeof(ImageData) !== 'undefined') {
	/**
	 * Make property non-enumerable.
	 */
	Object.defineProperty(ImageData.prototype, 'pixelAt', {
		enumerable:false,
		writable:true,
		configurable:true
	});

	/**
	 * Augments the canvas context getImageData() object "ImageData" with the
	 * pixelAt() method. Gets the pixel color data for the given pixel at the
	 * x, y co-ordinates specified.
	 * @param {Number} x The x co-ordinate of the pixel.
	 * @param {Number} y The y co-ordinate of the pixel.
	 * @return {Object} An object containing the pixel color data in properties
	 * {r, g, b, a}.
	 */
	ImageData.prototype.pixelAt = function (x, y) {
		var data = this.data,
			pixelStart = (y * this.width * 4) + (x * 4);

		return {
			r: data[pixelStart],
			g: data[pixelStart + 1],
			b: data[pixelStart + 2],
			a: data[pixelStart + 3]
		};
	};

	/**
	 * Make property non-enumerable.
	 */
	Object.defineProperty(ImageData.prototype, 'isTransparent', {
		enumerable:false,
		writable:true,
		configurable:true
	});

	/**
	 * Augments the canvas context getImageData() object "ImageData" with the
	 * isTransparent() method. Determines if the pixel at the passed x, y is
	 * fully transparent or not.
	 * @param {Number} x The x co-ordinate of the pixel.
	 * @param {Number} y The y co-ordinate of the pixel.
	 * @return {Boolean} True if fully transparent, false if not.
	 */
	ImageData.prototype.isTransparent = function (x, y) {
		var data = this.data,
			pixelStart = (y * this.width * 4) + (x * 4);

		return data[pixelStart + 3] === 0;
	};

	/**
	 * Make property non-enumerable.
	 */
	Object.defineProperty(ImageData.prototype, 'makeTransparent', {
		enumerable:false,
		writable:true,
		configurable:true
	});

	/**
	 * Augments the canvas context getImageData() object "ImageData" with the
	 * makeTransparent() method. Makes the pixel at the passed x, y fully
	 * transparent.
	 * @param {Number} x The x co-ordinate of the pixel.
	 * @param {Number} y The y co-ordinate of the pixel.
	 */
	ImageData.prototype.makeTransparent = function (x, y) {
		var data = this.data,
			pixelStart = (y * this.width * 4) + (x * 4);

		data[pixelStart + 3] = 0;
	};
}

/**
 * Turn off the right-click default behaviour in the browser for the passed element.
 * @param obj
 */
var disableContextMenu = function (obj) {
	if (obj !== null) {
		//this.log('Disabling context menus for ' + obj, 'info');
		obj.oncontextmenu = function () { return false; };
	}
};

/**
 * Adds the indexOf method to all array objects if it does not already exist which
 * would you believe can still happen even in 2012!
 */
if(!Array.prototype.indexOf){
	/**
	 * Make property non-enumerable.
	 */
	Object.defineProperty(Array.prototype, 'indexOf', {
		enumerable:false,
		writable:true,
		configurable:true
	});

	/**
	 * Get the index of the passed item.
	 * @param {*} obj The item to find the index for.
	 * @return {Number} The index of the passed item or -1 if not found.
	 */
	Array.prototype.indexOf = function(obj) {
		var i, l = this.length;
		for (i = 0; i < l; i++) {
			if(this[i] === obj){
				return i;
			}
		}
		return -1;
	};
}

if (typeof(window) !== 'undefined') {
	/**
	 * A cross-browser/platform requestAnimationFrame method.
	 */
	/*window.requestAnimFrame = (function(){
		return function(callback, element){
			setTimeout(function () { callback(new Date().getTime()); }, 1000 / 60);
		};
	}());*/

	requestAnimFrame = (function(){
		return  window.requestAnimationFrame       ||
				window.webkitRequestAnimationFrame ||
				window.mozRequestAnimationFrame    ||
				window.oRequestAnimationFrame      ||
				window.msRequestAnimationFrame     ||
		function(callback, element){
			setTimeout(function () { callback(new Date().getTime()); }, 1000 / 60);
		};
	}());
} else {
	/**
	 * A cross-browser/platform requestAnimationFrame method.
	 */
	requestAnimFrame = (function(){
		return function(callback, element){
			setTimeout(function () { callback(new Date().getTime()); }, 1000 / 60);
		};
	}());
}

// Check console method existence
if (typeof(console) === 'object') {
	if (typeof(console.log) === 'function') {
		if (typeof(console.info) === 'undefined') {
			// We have console.log but not console.info so add it as a replica of console.log
			console.info = console.log;
		}

		if (typeof(console.warn) === 'undefined') {
			// We have console.log but not console.warn so add it as a replica of console.log
			console.warn = console.log;
		}
	}
} else {
	// Create dummy console
	console = {
		log: function () {},
		warn: function () {},
		info: function () {},
		error: function () {}
	};
}
/**
 * The base class system.
 */
var IgeClass = (function () {
	var initializing = false,
		fnTest = /xyz/.test(function () {xyz;}) ? /\b_super\b/ : /.*/,

		// The base Class implementation (does nothing)
		IgeClass = function () {},
		
		/**
		 * Provides logging capabilities to all IgeClass instances.
		 * @param {String} text The text to log.
		 * @param {String} type The type of log to output, can be 'log',
		 * 'info', 'warning' or 'error'.
		 * @param {Object=} obj An optional object that will be output
		 * before the log text is output.
		 * @example #Log a message
		 *     var entity = new IgeEntity();
		 *     
		 *     // Will output:
		 *     //     IGE *log* [IgeEntity] : hello
		 *     entity.log('Hello');
		 * @example #Log an info message with an optional parameter
		 *     var entity = new IgeEntity(),
		 *         param = 'moo';
		 *	
		 *     // Will output:
		 *     //    moo
		 *     //    IGE *log* [IgeEntity] : hello
		 *     entity.log('Hello', 'info', param);
		 * @example #Log a warning message (which will cause a stack trace to be shown)
		 *     var entity = new IgeEntity();
		 *	
		 *     // Will output (stack trace is just an example here, real one will be more useful):
		 *     //    Stack: {anonymous}()@<anonymous>:2:8
		 *     //    ---- Object.InjectedScript._evaluateOn (<anonymous>:444:39)
		 *     //    ---- Object.InjectedScript._evaluateAndWrap (<anonymous>:403:52)
		 *     //    ---- Object.InjectedScript.evaluate (<anonymous>:339:21)
		 *     //    IGE *warning* [IgeEntity] : A test warning
		 *     entity.log('A test warning', 'warning');
		 * @example #Log an error message (which will cause an exception to be raised and a stack trace to be shown)
		 *     var entity = new IgeEntity();
		 *	
		 *     // Will output (stack trace is just an example here, real one will be more useful):
		 *     //    Stack: {anonymous}()@<anonymous>:2:8
		 *     //    ---- Object.InjectedScript._evaluateOn (<anonymous>:444:39)
		 *     //    ---- Object.InjectedScript._evaluateAndWrap (<anonymous>:403:52)
		 *     //    ---- Object.InjectedScript.evaluate (<anonymous>:339:21)
		 *     //    IGE *error* [IgeEntity] : An error message
		 *     entity.log('An error message', 'error');
		 */
		log = function (text, type, obj) {
			if (igeConfig.debug._enabled) {
				var indent = '',
					stack,
					thisId;
				
				if (typeof(this._id) !== 'undefined') {
					thisId = ':' + this._id;
				} else {
					thisId = '';
				}

				type = type || 'log';

				if (obj !== undefined) {
					console.warn(obj);
				}

				if (type === 'warning' || type === 'error') {
					if (igeConfig.debug._stacks) {
						if (igeConfig.debug._node) {
							if (console.trace) {
								console.trace();
							} else {
								stack = new Error().stack;
								//console.log(color.magenta('Stack:'), color.red(stack));
								console.log('Stack:', stack);
							}
						} else {
							if (typeof(printStackTrace) === 'function') {
								console.log('Stack:', printStackTrace().join('\n ---- '));
							}
						}
					}
				}

				if (type === 'error') {
					if (typeof(ige) !== 'undefined') {
						console.log(indent + 'IGE *' + type + '* [' + (this._classId || this.prototype._classId) + thisId + '] : ' + 'Error encountered, stopping engine to prevent console spamming...');
						ige.stop();
					}
					
					if (igeConfig.debug._throwErrors) {
						throw(indent + 'IGE *' + type + '* [' + (this._classId || this.prototype._classId) + thisId + '] : ' + text);
					} else {
						console.log(indent + 'IGE *' + type + '* [' + (this._classId || this.prototype._classId) + thisId + '] : ' + text);
					}
				} else {
					console.log(indent + 'IGE *' + type + '* [' + (this._classId || this.prototype._classId) + thisId + '] : ' + text);
				}
			}

			return this;
		},

		/**
		 * Returns the class id. Primarily used to help identify
		 * what class an instance was instantiated with and is also
		 * output during the ige.scenegraph() method's console logging
		 * to show what class an object belongs to.
		 * @example #Get the class id of an object
		 *     var entity = new IgeEntity();
		 *	
		 *     // Will output "IgeEntity"
		 *     console.log(entity.classId());
		 */
		classId = function () {
			return this._classId;
		},

		/**
		 * Creates a new instance of the component argument passing
		 * the options argument to the component as it is initialised.
		 * The new component instance is then added to "this" via
		 * a property name that is defined in the component class as
		 * "componentId".
		 * @param {IgeClass} component The class definition of the component.
		 * @param {Object=} options An options parameter to pass to the component
		 * on init.
		 * @example #Add the velocity component to an entity
		 *     var entity = new IgeEntity();
		 *     entity.addComponent(IgeVelocityComponent);
		 *     
		 *     // Now that the component is added, we can access
		 *     // the component via it's namespace. Call the 
		 *     // "byAngleAndPower" method of the velocity component:
		 *     entity.velocity.byAngleAndPower(Math.radians(20), 0.1);
		 */
		addComponent = function (component, options) {
			var newComponent = new component(this, options);
			this[newComponent.componentId] = newComponent;

			// Add the component reference to the class component array
			this._components = this._components || [];
			this._components.push(newComponent);

			return this;
		},

		/**
		 * Removes a component by it's id.
		 * @param {String} componentId The id of the component to remove.
		 * @example #Remove a component by it's id (namespace)
		 *     var entity = new IgeEntity();
		 *     
		 *     // Let's add the velocity component
		 *     entity.addComponent(IgeVelocityComponent);
		 *	
		 *     // Now that the component is added, let's remove
		 *     // it via it's id ("velocity")
		 *     entity.removeComponent('velocity');
		 */
		removeComponent = function (componentId) {
			// If the component has a destroy method, call it
			if (this[componentId] && this[componentId].destroy) {
				this[componentId].destroy();
			}

			// Remove the component from the class component array
			if (this._components) {
				this._components.pull(this[componentId]);
			}

			// Remove the component namespace from the class object
			delete this[componentId];
			return this;
		},

		/**
		 * Copies all properties and methods from the classObj object
		 * to "this". If the overwrite flag is not set or set to false,
		 * only properties and methods that don't already exists in
		 * "this" will be copied. If overwrite is true, they will be
		 * copied regardless.
		 * @param {Function} classObj
		 * @param {Boolean} overwrite
		 * @example #Implement all the methods of an object into another object
		 *     // Create a couple of test entities with ids
		 *     var entity1 = new IgeEntity().id('entity1'),
		 *         entity2 = new IgeEntity().id('entity2');
		 *	
		 *     // Let's define an object with a couple of methods
		 *     var obj = {
		 *         newMethod1: function () {
		 *             console.log('method1 called on object: ' + this.id());
		 *         },
		 *         
		 *         newMethod2: function () {
		 *             console.log('method2 called on object: ' + this.id());
		 *         }
		 *     };
		 *	
		 *     // Now let's implement the methods on our entities
		 *     entity1.implement(obj);
		 *     entity2.implement(obj);
		 *     
		 *     // The entities now have the newMethod1 and newMethod2
		 *     // methods as part of their instance so we can call them:
		 *     entity1.newMethod1();
		 *     
		 *     // The output to the console is:
		 *     //    method1 called on object: entity1
		 *     
		 *     // Now let's call newMethod2 on entity2:
		 *     entity2.newMethod2();
		 *	
		 *     // The output to the console is:
		 *     //    method2 called on object: entity2
		 *     
		 *     // As you can see, this is a great way to add extra modular
		 *     // functionality to objects / entities at runtime.
		 */
		implement = function (classObj, overwrite) {
			var i, obj = classObj.prototype || classObj;

			// Copy the class object's properties to (this)
			for (i in obj) {
				// Only copy the property if this doesn't already have it
				if (obj.hasOwnProperty(i) && (overwrite || this[i] === undefined)) {
					this[i] = obj[i];
				}
			}
			return this;
		},

		/**
		 * Gets / sets a key / value pair in the object's data object. Useful for
		 * storing arbitrary game data in the object.
		 * @param {String} key The key under which the data resides.
		 * @param {*=} value The data to set under the specified key.
		 * @example #Set some arbitrary data key value pair
		 *     var entity = new IgeEntity();
		 *     entity.data('playerScore', 100);
		 *     entity.data('playerName', 'iRock');
		 * @example #Get the value of a data key
		 *     console.log(entity.data('playerScore'));
		 *     console.log(entity.data('playerName'));
		 * @return {*}
		 */
		data = function (key, value) {
			if (key !== undefined) {
				if (value !== undefined) {
					this._data = this._data || {};
					this._data[key] = value;

					return this;
				}
				
				if (this._data) {
					return this._data[key];
				} else {
					return null;
				}
			}
		};

	/**
	 * Create a new IgeClass that inherits from this class
	 * @name extend
	 * @example #Creating a new class by extending an existing one
	 *     var NewClass = IgeClass.extend({
	 *         // Init is your constructor
	 *         init: function () {
	 *             console.log('I\'m alive!');
	 *         }
	 *     });
	 * 
	 * Further reading: [Extending Classes](http://www.isogenicengine.com/documentation/isogenic-game-engine/versions/1-1-0/manual/engine-fundamentals/classes/extending-classes/)
	 * @return {Function}
	 */
	IgeClass.extend = function () {
		var name,
			prototype,
			// Set prop to the last argument passed
			prop = arguments[arguments.length - 1],
			extensionArray = arguments[0],
			extensionItem,
			extensionOverwrite,
			extensionIndex,
			propertyIndex,
			propertyObject;

		// Check that the class has been assigned a classId and bug out if not
		if (!prop.classId) {
			console.log(prop);
			throw('Cannot create a new class without giving the class a classId property!');
		}

		// Check that the classId is not already in use
		if (igeClassStore[prop.classId]) {
			// This classId has already been used, bug out
			throw('Cannot create class with classId "' + prop.classId + '" because a class with that ID has already been created!');
		}

		// Instantiate a base class (but only create the instance,
		// don't run the init constructor)
		initializing = true;
		prototype = new this();
		initializing = false;

		// Copy the properties over onto the new prototype
		for (name in prop) {
			if (prop.hasOwnProperty(name)) {
				// Copy the property
				prototype[name] = prop[name];
			}
		}

		// Now implement any other extensions
		if (arguments.length > 1) {
			if (extensionArray && extensionArray.length) {
				for (extensionIndex = 0; extensionIndex < extensionArray.length; extensionIndex++) {
					extensionItem = extensionArray[extensionIndex];
					propertyObject = extensionItem.extension.prototype || extensionItem.extension;
					extensionOverwrite = extensionItem.overwrite;

					// Copy the class object's properties to (this)
					for (propertyIndex in propertyObject) {
						// Only copy the property if this doesn't already have it or
						// the extension is set to overwrite any existing properties
						if (propertyObject.hasOwnProperty(propertyIndex) && (extensionOverwrite || prototype[propertyIndex] === undefined)) {
							prototype[propertyIndex] = propertyObject[propertyIndex];
						}
					}
				}
			}
		}
		
		//prototype._superClass = this.prototype;
		//console.log(prop.classId, 'extends', this.prototype._classId);

		// The dummy class constructor
		function IgeClass() {
			if (!initializing && this.init) {
				// Call the class init method
				this.init.apply(this, arguments);
			}
		}

		// Populate our constructed prototype object
		IgeClass.prototype = prototype;

		// Enforce the constructor to be what we expect
		IgeClass.prototype.constructor = IgeClass;

		// And make this class extensible
		IgeClass.extend = arguments.callee;

		// Add log capability
		IgeClass.prototype.log = log;

		// Add data capability
		IgeClass.prototype.data = data;

		// Add class name capability
		IgeClass.prototype.classId = classId; // This is a method that returns _classId
		IgeClass.prototype._classId = prop.classId || 'IgeClass';

		// Add the addComponent method
		IgeClass.prototype.addComponent = addComponent;

		// Add the removeComponent method
		IgeClass.prototype.removeComponent = removeComponent;

		// Add the implement method
		IgeClass.prototype.implement = implement;
		
		// Add editor settings
		IgeClass.prototype.__igeEditor = prop.editorOptions;

		// Register the class with the class store
		igeClassStore[prop.classId] = IgeClass;

		return IgeClass;
	};

	/**
	 * Test method
	 * @param prop
	 * @return {Function}
	 */
	IgeClass.vanilla = function (prop) {
		var IgeClass = prop.init || function () {},
			prototype = new this();
		
		// Copy the properties over onto the new prototype
		for (name in prop) {
			if (prop.hasOwnProperty(name) && name !== 'init') {
				// Copy the property
				prototype[name] = prop[name];
			}
		}
		
		// Populate our constructed prototype object
		IgeClass.prototype = prototype;

		// Enforce the constructor to be what we expect
		IgeClass.prototype.constructor = IgeClass;
		
		// And make this class extensible
		IgeClass.extend = this.extend;
		
		// Add log capability
		IgeClass.prototype.log = log;

		// Add data capability
		IgeClass.prototype.data = data;

		// Add class name capability
		IgeClass.prototype.classId = classId; // This is a method that returns _classId
		IgeClass.prototype._classId = prop.classId || 'IgeClass';

		// Add the addComponent method
		IgeClass.prototype.addComponent = addComponent;

		// Add the removeComponent method
		IgeClass.prototype.removeComponent = removeComponent;

		// Add the implement method
		IgeClass.prototype.implement = implement;

		// Register the class with the class store
		igeClassStore[prop.classId] = IgeClass;
		
		return IgeClass;
	};

	IgeClass.prototype._classId = 'IgeClass';

	return IgeClass;
}());


if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = IgeClass; }
/**
 * Creates a new class with the capability to emit events.
 */
var IgeEventingClass = IgeClass.extend({
	classId: 'IgeEventingClass',

	/**
	 * Add an event listener method for an event.
	 * @param {String || Array} eventName The name of the event to listen for (string), or an array of events to listen for.
	 * @param {Function} call The method to call when the event listener is triggered.
	 * @param {Object=} context The context in which the call to the listening method will be made (sets the 'this' variable in the method to the object passed as this parameter).
	 * @param {Boolean=} oneShot If set, will instruct the listener to only listen to the event being fired once and will not fire again.
	 * @param {Boolean=} sendEventName If set, will instruct the emitter to send the event name as the argument instead of any emitted arguments.
	 * @return {Object} The event listener object. Hold this value if you later want to turn off the event listener.
	 * @example #Add an Event Listener
	 *     // Register event lister and store in "evt"
	 *     var evt = myEntity.on('mouseDown', function () { console.log('down'); });
	 * @example #Listen for Event Data
	 *     // Set a listener to listen for the data (multiple values emitted
	 *     // from an event are passed as function arguments)
	 *     myEntity.on('hello', function (arg1, arg2) {
	 *         console.log(arg1, arg2);
	 *     }
	 *     
	 *     // Emit the event named "hello"
	 *     myEntity.emit('hello', ['data1', 'data2']);
	 *     
	 *     // The console output is:
	 *     //    data1, data2
	 */
	on: function (eventName, call, context, oneShot, sendEventName) {
		var self = this,
			newListener,
			addListener,
			existingIndex,
			elArr,
			multiEvent,
			eventIndex,
			eventData,
			eventObj,
			multiEventName,
			i;

		// Check that we have an event listener object
		this._eventListeners = this._eventListeners || {};

		if (typeof call === 'function') {
			if (typeof eventName === 'string') {
				// Compose the new listener
				newListener = {
					call: call,
					context: context,
					oneShot: oneShot,
					sendEventName: sendEventName
				};

				elArr = this._eventListeners[eventName] = this._eventListeners[eventName] || [];

				// Check if we already have this listener in the list
				addListener = true;

				// TO-DO - Could this do with using indexOf? Would that work? Would be faster?
				existingIndex = elArr.indexOf(newListener);
				if (existingIndex > -1) {
					addListener = false;
				}

				// Add this new listener
				if (addListener) {
					elArr.push(newListener);
				}

				return newListener;
			} else {
				// The eventName is an array of names, creating a group of events
				// that must be fired to fire this event callback
				if (eventName.length) {
					// Loop the event array
					multiEvent = [];
					multiEvent[0] = 0; // This will hold our event count total
					multiEvent[1] = 0; // This will hold our number of events fired

					// Define the multi event callback
					multiEvent[3] = function (firedEventName) {
						multiEvent[1]++;

						if (multiEvent[0] === multiEvent[1]) {
							// All the multi-event events have fired
							// so fire the callback
							call.apply(context || self);
						}
					};

					for (eventIndex in eventName) {
						if (eventName.hasOwnProperty(eventIndex)) {
							eventData = eventName[eventIndex];
							eventObj = eventData[0];
							multiEventName = eventData[1];

							// Increment the event listening count total
							multiEvent[0]++;

							// Register each event against the event object with a callback
							eventObj.on(multiEventName, multiEvent[3], null, true, true);
						}
					}
				}
			}
		} else {
			if (typeof(eventName) !== 'string') {
				eventName = '*Multi-Event*';
			}
			this.log('Cannot register event listener for event "' + eventName + '" because the passed callback is not a function!', 'error');
		}
	},
	
	/**
	 * Remove an event listener. If the _processing flag is true
	 * then the removal will be placed in the removals array to be
	 * processed after the event loop has completed in the emit()
	 * method.
	 * @param {Boolean} eventName The name of the event you originally registered to listen for.
	 * @param {Object} evtListener The event listener object to cancel. This object is the one
	 * returned when calling the on() method. It is NOT the method you passed as the second argument
	 * to the on() method.
	 * @param {Function} callback The callback method to call when the event listener has been
	 * successfully removed. If you attempt to remove a listener during the event firing loop
	 * then the listener will not immediately be removed but will be queued for removal before
	 * the next listener loop is fired. In this case you may like to be informed via callback
	 * when the listener has been fully removed in which case, provide a method for this argument.
	 * 
	 * The callback will be passed a single boolean argument denoting if the removal was successful
	 * (true) or the listener did not exist to remove (false).
	 * @example #Switch off an Event Listener
	 *     // Register event lister and store in "evt"
	 *     var evt = myEntity.on('mouseDown', function () { console.log('down'); });
	 *     
	 *     // Switch off event listener
	 *     myEntity.off('mouseDown', evt);
	 * @return {Boolean}
	 */
	off: function (eventName, evtListener, callback) {
		if (this._eventListeners) {
			if (!this._eventListeners._processing) {
				if (this._eventListeners[eventName]) {
					// Find this listener in the list
					var evtListIndex = this._eventListeners[eventName].indexOf(evtListener);
					if (evtListIndex > -1) {
						// Remove the listener from the event listener list
						this._eventListeners[eventName].splice(evtListIndex, 1);
						if (callback) {
							callback(true);
						}
						return true;
					} else {
						this.log('Failed to cancel event listener for event named "' + eventName + '" !', 'warning', evtListener);
					}
				} else {
					this.log('Failed to cancel event listener!');
				}
			} else {
				// Add the removal to a remove queue since we are processing
				// listeners at the moment and removing one would mess up the
				// loop!
				this._eventListeners._removeQueue = this._eventListeners._removeQueue || [];
				this._eventListeners._removeQueue.push([eventName, evtListener, callback]);

				return -1;
			}
		}

		if (callback) {
			callback(false);
		}
		return false;
	},

	/**
	 * Emit an event by name.
	 * @param {Object} eventName The name of the event to emit.
	 * @param {Object || Array} args The arguments to send to any listening methods.
	 * If you are sending multiple arguments, use an array containing each argument.
	 * @return {Number}
	 * @example #Emit an Event
	 *     // Emit the event named "hello"
	 *     myEntity.emit('hello');
	 * @example #Emit an Event With Data Object
	 *     // Emit the event named "hello"
	 *     myEntity.emit('hello', {moo: true});
	 * @example #Emit an Event With Multiple Data Values
	 *     // Emit the event named "hello"
	 *     myEntity.emit('hello', [{moo: true}, 'someString']);
	 * @example #Listen for Event Data
	 *     // Set a listener to listen for the data (multiple values emitted
	 *     // from an event are passed as function arguments)
	 *     myEntity.on('hello', function (arg1, arg2) {
	 *         console.log(arg1, arg2);
	 *     }
	 *     
	 *     // Emit the event named "hello"
	 *     myEntity.emit('hello', ['data1', 'data2']);
	 *     
	 *     // The console output is:
	 *     //    data1, data2
	 */
	emit: function (eventName, args) {
		if (this._eventListeners) {
			// Check if the event has any listeners
			if (this._eventListeners[eventName]) {

				// Fire the listeners for this event
				var eventCount = this._eventListeners[eventName].length,
					eventCount2 = this._eventListeners[eventName].length - 1,
					finalArgs, i, cancelFlag, eventIndex, tempEvt, retVal;

				// If there are some events, ensure that the args is ready to be used
				if (eventCount) {
					finalArgs = [];
					if (typeof(args) === 'object' && args !== null && args[0] !== null && args[0] !== undefined) {
						for (i in args) {
							if (args.hasOwnProperty(i)) {
								finalArgs[i] = args[i];
							}
						}
					} else {
						finalArgs = [args];
					}

					// Loop and emit!
					cancelFlag = false;

					this._eventListeners._processing = true;
					while (eventCount--) {
						eventIndex = eventCount2 - eventCount;
						tempEvt = this._eventListeners[eventName][eventIndex];


						// If the sendEventName flag is set, overwrite the arguments with the event name
						if (tempEvt.sendEventName) { finalArgs = [eventName]; }

						// Call the callback
						retVal = tempEvt.call.apply(tempEvt.context || this, finalArgs);

						// If the retVal === true then store the cancel flag and return to the emitting method
						if (retVal === true) {
							// The receiver method asked us to send a cancel request back to the emitter
							cancelFlag = true;
						}

						// Check if we should now cancel the event
						if (tempEvt.oneShot) {
							// The event has a oneShot flag so since we have fired the event,
							// lets cancel the listener now
							if (this.off(eventName, tempEvt) === true) {
								eventCount2--;	
							}
						}
					}

					// Check that the array still exists because an event
					// could have triggered a method that destroyed our object
					// which would have deleted the array!
					if (this._eventListeners) {
						this._eventListeners._processing = false;

						// Now process any event removal
						this._processRemovals();
					}

					if (cancelFlag) {
						return 1;
					}

				}

			}
		}
	},

	/**
	 * Returns an object containing the current event listeners.
	 * @return {Object}
	 */
	eventList: function () {
		return this._eventListeners;
	},
	
	/**
	 * Loops the removals array and processes off() calls for
	 * each array item.
	 * @private
	 */
	_processRemovals: function () {
		if (this._eventListeners) {
			var remArr = this._eventListeners._removeQueue,
				arrCount,
				item,
				result;

			// If the removal array exists
			if (remArr) {
				// Get the number of items in the removal array
				arrCount = remArr.length;

				// Loop the array
				while (arrCount--) {
					item = remArr[arrCount];

					// Call the off() method for this item
					result = this.off(item[0], item[1]);

					// Check if there is a callback
					if (typeof remArr[2] === 'function') {
						// Call the callback with the removal result
						remArr[2](result);
					}
				}
			}

			// Remove the removal array
			delete this._eventListeners._removeQueue;
		}
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = IgeEventingClass; }
/**
 * Creates a new 2d point (x, y).
 */
var IgePoint2d = IgeClass.extend({
	classId: 'IgePoint2d',

	init: function (x, y, floor) {
		// Set values to the passed parameters or
		// zero if they are undefined
		// Commented for increase performance over stability checks
		/*if (x === undefined) { debugger; }
		if (y === undefined) { debugger; }*/
		this.x = x = x !== undefined ? x : 0;
		this.y = y = y !== undefined ? y : 0;
		
		this._floor = floor !== undefined;
		
		if (this._floor) {
			this.x2 = Math.floor(x / 2);
			this.y2 = Math.floor(y / 2);
		} else {
			this.x2 = x / 2;
			this.y2 = y / 2;
		}

		return this;
	},

	/**
	 * Gets / sets the floor mode of this point. If set to true the point's
	 * data will be mathematically floored when they are assigned.
	 * @param val
	 * @return {*}
	 */
	floor: function (val) {
		if (val !== undefined) {
			this._floor = val;
			return this;
		}

		return this._floor;
	},

	/**
	 * Compares this point's x, y data with the passed point and returns
	 * true if they are the same and false if any is different.
	 * @param {IgePoint2d} point The point to compare data with.
	 * @return {Boolean}
	 */
	compare: function (point) {
		return point && this.x === point.x && this.y === point.y;
	},

	/**
	 * Copies the x, y data from the passed point and overwrites this
	 * point's data with those values.
	 * @param {IgePoint2d} point The point to copy values from.
	 * @returns {*}
	 */
	copy: function (point) {
		this.x = point.x;
		this.y = point.y;
		this.z = point.z;
		
		return this;
	},

	/**
	 * Converts the point's x, y to an isometric x, y 2d co-ordinate
	 * and returns an object whose x, y values are the result.
	 * @return {Object}
	 */
	toIso: function () {
		var sx = this.x - this.y,
			sy = (this.x + this.y) * 0.5;

		return {x: sx, y: sy};
	},

	/**
	 * Converts this point's x, y data into isometric co-ordinate space
	 * and overwrites the previous x, y values with the result.
	 * @return {*}
	 */
	thisToIso: function () {
		var val = this.toIso();
		this.x = val.x;
		this.y = val.y;

		return this;
	},

	/**
	 * Converts this point's x, y data into 2d co-ordinate space
	 * and returns an object whose x, y values are the result.
	 * @return {Object}
	 */
	to2d: function () {
		var sx = this.y + this.x / 2,
			sy = this.y - this.x / 2;

		return {x: sx, y: sy};
	},

	/**
	 * Converts this point's x, y data into 2d co-ordinate space
	 * and overwrites the previous x, y values with the result.
	 * @return {*}
	 */
	thisTo2d: function () {
		var val = this.to2d();
		this.x = val.x;
		this.y = val.y;

		return this;
	},

	/**
	 * Adds this point's data by the x, y, values specified
	 * and returns a new IgePoint2d whose values are the result.
	 * @param point
	 * @return {*}
	 */
	addPoint: function (point) {
		return new IgePoint2d(this.x + point.x, this.y + point.y);
	},

	/**
	 * Adds this point's data by the x, y values specified and
	 * overwrites the previous x, y values with the result.
	 * @param point
	 * @return {*}
	 */
	thisAddPoint: function (point) {
		this.x += point.x;
		this.y += point.y;

		return this;
	},

	/**
	 * Minuses this point's data by the x, y values specified
	 * and returns a new IgePoint2d whose values are the result.
	 * @param point
	 * @return {*}
	 */
	minusPoint: function (point) {
		return new IgePoint2d(this.x - point.x, this.y - point.y);
	},

	/**
	 * Minuses this point's data by the x, y values specified and
	 * overwrites the previous x, y values with the result.
	 * @param point
	 * @return {*}
	 */
	thisMinusPoint: function (point) {
		this.x -= point.x;
		this.y -= point.y;

		return this;
	},

	/**
	 * Multiplies this point's data by the x, y values specified
	 * and returns a new IgePoint2d whose values are the result.
	 * @param x
	 * @param y
	 * @return {*}
	 */
	multiply: function (x, y) {
		return new IgePoint2d(this.x * x, this.y * y);
	},

	/**
	 * Multiplies this point's data by the point specified
	 * and returns a new IgePoint2d whose values are the result.
	 * @param {IgePoint2d} point
	 * @return {*}
	 */
	multiplyPoint: function (point) {
		return new IgePoint2d(this.x * point.x, this.y * point.y);
	},

	/**
	 * Multiplies this point's data by the x, y values specified and
	 * overwrites the previous x, y values with the result.
	 * @param x
	 * @param y
	 * @param z
	 * @return {*}
	 */
	thisMultiply: function (x, y) {
		this.x *= x;
		this.y *= y;

		return this;
	},

	/**
	 * Divides this point's data by the x, y values specified
	 * and returns a new IgePoint2d whose values are the result.
	 * @param x
	 * @param y
	 * @return {*}
	 */
	divide: function (x, y) {
		return new IgePoint2d(this.x / x, this.y / y);
	},
	
	/**
	 * Divides this point's data by the point specified
	 * and returns a new IgePoint2d whose values are the result.
	 * @param {IgePoint2d} point
	 * @return {*}
	 */
	dividePoint: function (point) {
		var newX = this.x,
			newY = this.y;
		
		if (point.x) { newX = this.x / point.x; }
		if (point.y) { newY = this.y / point.y; }
		
		return new IgePoint2d(newX, newY);
	},

	/**
	 * Divides this point's data by the x, y values specified and
	 * overwrites the previous x, y values with the result.
	 * @param x
	 * @param y
	 * @return {*}
	 */
	thisDivide: function (x, y) {
		this.x /= x;
		this.y /= y;

		return this;
	},

	/**
	 * Returns a clone of this IgePoint2d's data as a new instance.
	 * @return {*}
	 */
	clone: function () {
		return new IgePoint2d(this.x, this.y);
	},

	/**
	 * Interpolates the x, y values of this point towards the endPoint's
	 * x, y values based on the passed time variables and returns a new
	 * IgePoint2d whose values are the result.
	 * @param endPoint
	 * @param startTime
	 * @param currentTime
	 * @param endTime
	 * @return {*}
	 */
	interpolate: function (endPoint, startTime, currentTime, endTime) {
		var totalX = endPoint.x - this.x,
			totalY = endPoint.y - this.y,
			totalTime = endTime - startTime,
			deltaTime = totalTime - (currentTime - startTime),
			timeRatio = deltaTime / totalTime;

		return new IgePoint2d(endPoint.x - (totalX * timeRatio), endPoint.y - (totalY * timeRatio));
	},

	/**
	 * Rotates the point by the given radians.
	 * @param {Number} radians Radians to rotate by.
	 * @return {IgePoint2d} A new point with the rotated x, y.
	 */
	rotate: function (radians) {
		var s = Math.sin(radians),
			c = Math.cos(radians),
			x = c * this.x - s * this.y,
			y = s * this.x - c * this.y;
		
		return new IgePoint2d(x, y);
	},
	
	/**
	 * Rotates the point by the given radians and updates this point
	 * to the new x, y values.
	 * @param {Number} radians Radians to rotate by.
	 * @return {IgePoint2d} This point.
	 */
	thisRotate: function (radians) {
		var s = Math.sin(radians),
			c = Math.cos(radians),
			x = this.x,
			y = this.y;
		
		this.x = c * x - s * y;
		this.y = s * x - c * y;
		
		return this;
	},

	/**
	 * Returns a string representation of the point's x, y
	 * converting floating point values into fixed using the
	 * passed precision parameter. If no precision is specified
	 * then the precision defaults to 2.
	 * @param {Number=} precision
	 * @return {String}
	 */
	toString: function (precision) {
		if (precision === undefined) { precision = 2; }
		return this.x.toFixed(precision) + ',' + this.y.toFixed(precision);
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = IgePoint2d; }
/**
 * Creates a new 3d point (x, y, z).
 */
var IgePoint3d = IgeClass.extend({
	classId: 'IgePoint3d',

	init: function (x, y, z, floor) {
		// Set values to the passed parameters or
		// zero if they are undefined
		// Commented for increase performance over stability checks
		/*if (x === undefined) { debugger; }
		if (y === undefined) { debugger; }
		if (z === undefined) { debugger; }*/
		this.x = x = x !== undefined ? x : 0;
		this.y = y = y !== undefined ? y : 0;
		this.z = z = z !== undefined ? z : 0;
		
		this._floor = floor !== undefined;
		
		if (this._floor) {
			this.x2 = Math.floor(x / 2);
			this.y2 = Math.floor(y / 2);
			this.z2 = Math.floor(z / 2);
		} else {
			this.x2 = x / 2;
			this.y2 = y / 2;
			this.z2 = z / 2;
		}

		return this;
	},

	/**
	 * Gets / sets the floor mode of this point. If set to true the point's
	 * data will be mathematically floored when they are assigned.
	 * @param val
	 * @return {*}
	 */
	floor: function (val) {
		if (val !== undefined) {
			this._floor = val;
			return this;
		}

		return this._floor;
	},

	/**
	 * Compares this point's x, y, z data with the passed point and returns
	 * true if they are the same and false if any is different.
	 * @param {IgePoint3d} point The point to compare data with.
	 * @return {Boolean}
	 */
	compare: function (point) {
		return point && this.x === point.x && this.y === point.y && this.z === point.z;
	},

	/**
	 * Copies the x, y, z data from the passed point and overwrites this
	 * point's data with those values.
	 * @param {IgePoint3d} point The point to copy values from.
	 * @returns {*}
	 */
	copy: function (point) {
		this.x = point.x;
		this.y = point.y;
		this.z = point.z;
		
		return this;
	},

	/**
	 * Converts the point's x, y, z to an isometric x, y 2d co-ordinate
	 * and returns an object whose x, y values are the result.
	 * @return {Object}
	 */
	toIso: function () {
		var sx = this.x - this.y,
			sy = (-this.z) * 1.2247 + (this.x + this.y) * 0.5;

		return {x: sx, y: sy};
	},

	/**
	 * Converts this point's x, y, z data into isometric co-ordinate space
	 * and overwrites the previous x, y, z values with the result.
	 * @return {*}
	 */
	thisToIso: function () {
		var val = this.toIso();
		this.x = val.x;
		this.y = val.y;

		return this;
	},

	/**
	 * Converts this point's x, y, z data into 2d co-ordinate space
	 * and returns an object whose x, y values are the result.
	 * @return {Object}
	 */
	to2d: function () {
		var sx = this.y + this.x / 2,
			sy = this.y - this.x / 2;

		return {x: sx, y: sy};
	},

	/**
	 * Converts this point's x, y, z data into 2d co-ordinate space
	 * and overwrites the previous x, y, z values with the result.
	 * @return {*}
	 */
	thisTo2d: function () {
		var val = this.to2d();
		this.x = val.x;
		this.y = val.y;
		this.z = 0;

		return this;
	},

	/**
	 * Adds this point's data by the x, y, z, values specified
	 * and returns a new IgePoint3d whose values are the result.
	 * @param point
	 * @return {*}
	 */
	addPoint: function (point) {
		return new IgePoint3d(this.x + point.x, this.y + point.y, this.z + point.z);
	},

	/**
	 * Adds this point's data by the x, y, z values specified and
	 * overwrites the previous x, y, z values with the result.
	 * @param point
	 * @return {*}
	 */
	thisAddPoint: function (point) {
		this.x += point.x;
		this.y += point.y;
		this.z += point.z;

		return this;
	},

	/**
	 * Minuses this point's data by the x, y, z, values specified
	 * and returns a new IgePoint3d whose values are the result.
	 * @param point
	 * @return {*}
	 */
	minusPoint: function (point) {
		return new IgePoint3d(this.x - point.x, this.y - point.y, this.z - point.z);
	},

	/**
	 * Minuses this point's data by the x, y, z values specified and
	 * overwrites the previous x, y, z values with the result.
	 * @param point
	 * @return {*}
	 */
	thisMinusPoint: function (point) {
		this.x -= point.x;
		this.y -= point.y;
		this.z -= point.z;

		return this;
	},

	/**
	 * Multiplies this point's data by the x, y, z, values specified
	 * and returns a new IgePoint3d whose values are the result.
	 * @param x
	 * @param y
	 * @param z
	 * @return {*}
	 */
	multiply: function (x, y, z) {
		return new IgePoint3d(this.x * x, this.y * y, this.z * z);
	},

	/**
	 * Multiplies this point's data by the point specified
	 * and returns a new IgePoint3d whose values are the result.
	 * @param {IgePoint3d} point
	 * @return {*}
	 */
	multiplyPoint: function (point) {
		return new IgePoint3d(this.x * point.x, this.y * point.y, this.z * point.z);
	},

	/**
	 * Multiplies this point's data by the x, y, z values specified and
	 * overwrites the previous x, y, z values with the result.
	 * @param x
	 * @param y
	 * @param z
	 * @return {*}
	 */
	thisMultiply: function (x, y, z) {
		this.x *= x;
		this.y *= y;
		this.z *= z;

		return this;
	},

	/**
	 * Divides this point's data by the x, y, z, values specified
	 * and returns a new IgePoint3d whose values are the result.
	 * @param x
	 * @param y
	 * @param z
	 * @return {*}
	 */
	divide: function (x, y, z) {
		return new IgePoint3d(this.x / x, this.y / y, this.z / z);
	},
	
	/**
	 * Divides this point's data by the point specified
	 * and returns a new IgePoint3d whose values are the result.
	 * @param {IgePoint3d} point
	 * @return {*}
	 */
	dividePoint: function (point) {
		var newX = this.x,
			newY = this.y,
			newZ = this.z;
		
		if (point.x) { newX = this.x / point.x; }
		if (point.y) { newY = this.y / point.y; }
		if (point.z) { newZ = this.z / point.z; }
		
		return new IgePoint3d(newX, newY, newZ);
	},

	/**
	 * Divides this point's data by the x, y, z values specified and
	 * overwrites the previous x, y, z values with the result.
	 * @param x
	 * @param y
	 * @param z
	 * @return {*}
	 */
	thisDivide: function (x, y, z) {
		this.x /= x;
		this.y /= y;
		this.z /= z;

		return this;
	},

	/**
	 * Returns a clone of this IgePoint3d's data as a new instance.
	 * @return {*}
	 */
	clone: function () {
		return new IgePoint3d(this.x, this.y, this.z);
	},

	/**
	 * Interpolates the x, y, z values of this point towards the endPoint's
	 * x, y, z values based on the passed time variables and returns a new
	 * IgePoint3d whose values are the result.
	 * @param endPoint
	 * @param startTime
	 * @param currentTime
	 * @param endTime
	 * @return {*}
	 */
	interpolate: function (endPoint, startTime, currentTime, endTime) {
		var totalX = endPoint.x - this.x,
			totalY = endPoint.y - this.y,
			totalZ = endPoint.z - this.z,
			totalTime = endTime - startTime,
			deltaTime = totalTime - (currentTime - startTime),
			timeRatio = deltaTime / totalTime;

		return new IgePoint3d(endPoint.x - (totalX * timeRatio), endPoint.y - (totalY * timeRatio), endPoint.z - (totalZ * timeRatio));
	},

	/**
	 * Rotates the point by the given radians.
	 * @param {Number} radians Radians to rotate by.
	 * @return {IgePoint3d} A new point with the rotated x, y.
	 */
	rotate: function (radians) {
		var s = Math.sin(radians),
			c = Math.cos(radians),
			x = c * this.x - s * this.y,
			y = s * this.x - c * this.y;
		
		return new IgePoint3d(x, y, this.z);
	},
	
	/**
	 * Rotates the point by the given radians and updates this point
	 * to the new x, y values.
	 * @param {Number} radians Radians to rotate by.
	 * @return {IgePoint3d} This point.
	 */
	thisRotate: function (radians) {
		var s = Math.sin(radians),
			c = Math.cos(radians),
			x = this.x,
			y = this.y;
		
		this.x = c * x - s * y;
		this.y = s * x - c * y;
		
		return this;
	},

	/**
	 * Returns a string representation of the point's x, y, z
	 * converting floating point values into fixed using the
	 * passed precision parameter. If no precision is specified
	 * then the precision defaults to 2.
	 * @param {Number=} precision
	 * @return {String}
	 */
	toString: function (precision) {
		if (precision === undefined) { precision = 2; }
		return this.x.toFixed(precision) + ',' + this.y.toFixed(precision) + ',' + this.z.toFixed(precision);
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = IgePoint3d; }
/**
 * Creates a new 2d polygon made up of IgePoint2d instances.
 */
var IgePoly2d = IgeClass.extend({
	classId: 'IgePoly2d',

	init: function () {
		this._poly = [];
		this._scale = new IgePoint2d(1, 1);
	},

	scale: function (x, y) {
		if (x !== undefined && y !== undefined) {
			this._scale.x = x;
			this._scale.y = y;

			return this;
		}

		return this._scale;
	},

	/**
	 * Multiplies the points of the polygon by the supplied factor.
	 * @param {Number} factor The multiplication factor.
	 * @return {*}
	 */
	multiply: function (factor) {
		if (factor !== undefined) {
			var polyPoints = this._poly,
				pointCount = polyPoints.length,
				pointIndex;

			for (pointIndex = 0; pointIndex < pointCount; pointIndex++) {
				polyPoints[pointIndex].x *= factor;
				polyPoints[pointIndex].y *= factor;
			}
		}

		return this;
	},

	/**
	 * Divides the points of the polygon by the supplied value.
	 * @param {Number} value The divide value.
	 * @return {*}
	 */
	divide: function (value) {
		if (value !== undefined) {
			var polyPoints = this._poly,
				pointCount = polyPoints.length,
				pointIndex;

			for (pointIndex = 0; pointIndex < pointCount; pointIndex++) {
				polyPoints[pointIndex].x /= value;
				polyPoints[pointIndex].y /= value;
			}
		}

		return this;
	},

	/**
	 * Adds a point to the polygon relative to the polygon center at 0, 0.
	 * @param x
	 * @param y
	 */
	addPoint: function (x, y) {
		this._poly.push(new IgePoint2d(x, y));
		return this;
	},

	/**
	 * Returns the length of the poly array.
	 * @return {Number}
	 */
	length: function () {
		return this._poly.length;
	},

	/**
	 * Check if a point is inside this polygon.
	 * @param {IgePoint2d} point
	 * @return {Boolean}
	 */
	pointInPoly: function (point) {
		var polyPoints = this._poly,
			pointCount = polyPoints.length,
			pointIndex,
			oldPointIndex = pointCount - 1,
			c = 0;

		for (pointIndex = 0; pointIndex < pointCount; oldPointIndex = pointIndex++) {
			if (((polyPoints[pointIndex].y > point.y) !== (polyPoints[oldPointIndex].y > point.y)) &&
				(point.x < (polyPoints[oldPointIndex].x - polyPoints[pointIndex].x) *
					(point.y - polyPoints[pointIndex].y) / (polyPoints[oldPointIndex].y - polyPoints[pointIndex].y) +
					polyPoints[pointIndex].x)) {
				c = !c;
			}
		}

		return Boolean(c);
	},
	
	/**
	 * Check if the passed x and y are inside this polygon.
	 * @param {Number} x
	 * @param {Number} y
	 * @return {Boolean}
	 */
	xyInside: function (x, y) {
		var polyPoints = this._poly,
			pointCount = polyPoints.length,
			pointIndex,
			oldPointIndex = pointCount - 1,
			c = 0;

		for (pointIndex = 0; pointIndex < pointCount; oldPointIndex = pointIndex++) {
			if (((polyPoints[pointIndex].y > y) !== (polyPoints[oldPointIndex].y > y)) &&
				(x < (polyPoints[oldPointIndex].x - polyPoints[pointIndex].x) *
					(y - polyPoints[pointIndex].y) / (polyPoints[oldPointIndex].y - polyPoints[pointIndex].y) +
					polyPoints[pointIndex].x)) {
				c = !c;
			}
		}

		return Boolean(c);
	},
	
	aabb: function () {
		var minX,
			minY,
			maxX,
			maxY,
			xArr = [],
			yArr = [],
			arr = this._poly,
			arrIndex,
			arrCount = arr.length;
		
		for (arrIndex = 0; arrIndex < arrCount; arrIndex++) {
			xArr.push(arr[arrIndex].x);
			yArr.push(arr[arrIndex].y);
		}
		
		// Get the extents of the newly transformed poly
		minX = Math.min.apply(Math, xArr);
		minY = Math.min.apply(Math, yArr);
		maxX = Math.max.apply(Math, xArr);
		maxY = Math.max.apply(Math, yArr);
	
		return new IgeRect(minX, minY, maxX - minX, maxY - minY);
	},

	/**
	 * Returns a copy of this IgePoly2d object that is
	 * it's own version, separate from the original.
	 * @return {IgePoly2d}
	 */
	clone: function () {
		var newPoly = new IgePoly2d(),
			arr = this._poly,
			arrCount = arr.length,
			i;

		for (i = 0; i < arrCount; i++) {
			newPoly.addPoint(arr[i].x, arr[i].y);
		}

		newPoly.scale(this._scale.x, this._scale.y);

		return newPoly;
	},

	/**
	 * Determines if the polygon is clockwise or not.
	 * @return {Boolean} A boolean true if clockwise or false
	 * if not.
	 */
	clockWiseTriangle: function () {
		// Loop the polygon points and determine if they are counter-clockwise
		var arr = this._poly,
			val,
			p1, p2, p3;

		p1 = arr[0];
		p2 = arr[1];
		p3 = arr[2];

		val = (p1.x * p2.y) + (p2.x * p3.y) + (p3.x * p1.y) - (p2.y * p3.x) - (p3.y * p1.x) - (p1.y * p2.x);

		return val > 0;
	},

	makeClockWiseTriangle: function () {
		// If our data is already clockwise exit
		if (!this.clockWiseTriangle()) {
			var p0 = this._poly[0],
				p1 = this._poly[1],
				p2 = this._poly[2];

			this._poly[2] = p1;
			this._poly[1] = p2;
		}
	},

	triangulate: function () {
		// Get the indices of each new triangle
		var poly = this._poly,
			triangles = [],
			indices = this.triangulationIndices(),
			i,
			point1,
			point2,
			point3,
			newPoly;

		// Generate new polygons from the index data
		for (i = 0; i < indices.length; i += 3) {
			point1 = poly[indices[i]];
			point2 = poly[indices[i + 1]];
			point3 = poly[indices[i + 2]];
			newPoly = new IgePoly2d();

			newPoly.addPoint(point1.x, point1.y);
			newPoly.addPoint(point2.x, point2.y);
			newPoly.addPoint(point3.x, point3.y);

			// Check the new poly and make sure it's clockwise
			newPoly.makeClockWiseTriangle();
			triangles.push(newPoly);
		}

		return triangles;
	},

	triangulationIndices: function () {
		var indices = [],
			n = this._poly.length,
			v = [],
			V = [],
			nv,
			count,
			m,
			u,
			w,
			a,
			b,
			c,
			s,
			t;
		
		if (n < 3) { return indices; }

		if (this._area() > 0) {
			for (v = 0; v < n; v++) {
				V[v] = v;
			}
		} else {
			for (v = 0; v < n; v++) {
				V[v] = (n - 1) - v;
			}
		}

		nv = n;
		count = 2 * nv;
		m = 0;

		for (v = nv - 1; nv > 2; ) {
			if ((count--) <= 0) {
				return indices;
			}

			u = v;
			if (nv <= u) {
				u = 0;
			}

			v = u + 1;

			if (nv <= v) {
				v = 0;
			}

			w = v + 1;

			if (nv <= w) {
				w = 0;
			}

			if (this._snip(u, v, w, nv, V)) {
				a = V[u];
				b = V[v];
				c = V[w];
				indices.push(a);
				indices.push(b);
				indices.push(c);
				m++;
				s = v;

				for (t = v + 1; t < nv; t++) {
					V[s] = V[t];
					s++;
				}

				nv--;
				count = 2 * nv;
			}
		}

		indices.reverse();
		return indices;
	},

	_area: function () {
		var n = this._poly.length,
			a = 0.0,
			q = 0,
			p,
			pval,
			qval;

		for (p = n - 1; q < n; p = q++) {
			pval = this._poly[p];
			qval = this._poly[q];
			a += pval.x * qval.y - qval.x * pval.y;
		}

		return (a * 0.5);
	},

	_snip: function (u, v, w, n, V) {
		var p,
			A = this._poly[V[u]],
			B = this._poly[V[v]],
			C = this._poly[V[w]],
			P;

		// Replaced Math.Epsilon with 0.00001
		if (0.00001 > (((B.x - A.x) * (C.y - A.y)) - ((B.y - A.y) * (C.x - A.x)))) {
			return false;
		}

		for (p = 0; p < n; p++) {
			if ((p == u) || (p == v) || (p == w)) {
				continue;
			}

			P = this._poly[V[p]];
			if (this._insideTriangle(A, B, C, P)) {
				return false;
			}
		}

		return true;
	},

	_insideTriangle: function (A, B, C, P) {
		var ax,
			ay,
			bx,
			by,
			cx,
			cy,
			apx,
			apy,
			bpx,
			bpy,
			cpx,
			cpy,
			cCROSSap,
			bCROSScp,
			aCROSSbp;

		ax = C.x - B.x; ay = C.y - B.y;
		bx = A.x - C.x; by = A.y - C.y;
		cx = B.x - A.x; cy = B.y - A.y;
		apx = P.x - A.x; apy = P.y - A.y;
		bpx = P.x - B.x; bpy = P.y - B.y;
		cpx = P.x - C.x; cpy = P.y - C.y;

		aCROSSbp = ax * bpy - ay * bpx;
		cCROSSap = cx * apy - cy * apx;
		bCROSScp = bx * cpy - by * cpx;

		return ((aCROSSbp >= 0.0) && (bCROSScp >= 0.0) && (cCROSSap >= 0.0));
	},

	/**
	 * Draws the polygon bounding lines to the passed context.
	 * @param {CanvasRenderingContext2D} ctx
	 */
	render: function (ctx, fill) {
		var polyPoints = this._poly,
			pointCount = polyPoints.length,
			scaleX = this._scale.x,
			scaleY = this._scale.y,
			i;

		ctx.beginPath();
		ctx.moveTo(polyPoints[0].x * scaleX, polyPoints[0].y * scaleY);
		for (i = 1; i < pointCount; i++) {
			ctx.lineTo(polyPoints[i].x * scaleX, polyPoints[i].y * scaleY);
		}
		ctx.lineTo(polyPoints[0].x * scaleX, polyPoints[0].y * scaleY);
		if (fill) { ctx.fill(); }
		ctx.stroke();

		return this;
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = IgePoly2d; }
/**
 * Creates a new rectangle (x, y, width, height).
 */
var IgeRect = IgeClass.extend({
	classId: 'IgeRect',

	init: function (x, y, width, height) {
		// Set values to the passed parameters or
		// zero if they are undefined
		this.x = x = x !== undefined ? x : 0;
		this.y = y = y !== undefined ? y : 0;
		this.width = width = width !== undefined ? width : 0;
		this.height = height = height !== undefined ? height : 0;

		this.x2 = this.x / 2;
		this.y2 = this.y / 2;

		return this;
	},
	
	/**
	 * Combines the extents of the passed IgeRect with this rect
	 * to create a new rect whose bounds encapsulate both rects.
	 * @param {IgeRect} rect The rect to combine with this one.
	 * @return {IgeRect} The new rect encapsulating both rects.
	 */
	combineRect: function (rect) {
		var thisRectMaxX = this.x + this.width,
			thisRectMaxY = this.y + this.height,
			thatRectMaxX = rect.x + rect.width,
			thatRectMaxY = rect.y + rect.height,

			x = Math.min(this.x, rect.x),
			y = Math.min(this.y, rect.y),
			width = Math.max(thisRectMaxX - this.x, thatRectMaxX - this.x),
			height = Math.max(thisRectMaxY - this.y, thatRectMaxY - this.y);

		return new IgeRect(x, y, width, height);
	},

	/**
	 * Combines the extents of the passed IgeRect with this rect
	 * and replaces this rect with one whose bounds encapsulate
	 * both rects.
	 * @param {IgeRect} rect The rect to combine with this one.
	 */
	thisCombineRect: function (rect) {
		var thisRectMaxX = this.x + this.width,
			thisRectMaxY = this.y + this.height,
			thatRectMaxX = rect.x + rect.width,
			thatRectMaxY = rect.y + rect.height;

		this.x = Math.min(this.x, rect.x);
		this.y = Math.min(this.y, rect.y);

		this.width = Math.max(thisRectMaxX - this.x, thatRectMaxX - this.x);
		this.height = Math.max(thisRectMaxY - this.y, thatRectMaxY - this.y);
	},
	
	minusPoint: function (point) {
		return new IgeRect(this.x - point.x, this.y - point.y, this.width, this.height);
	},

	/**
	 * Compares this rect's dimensions with the passed rect and returns
	 * true if they are the same and false if any is different.
	 * @param {IgeRect} rect
	 * @return {Boolean}
	 */
	compare: function (rect) {
		return rect && this.x === rect.x && this.y === rect.y && this.width === rect.width && this.height === rect.height;
	},

	/**
	 * Returns boolean indicating if the passed x, y is
	 * inside the rectangle.
	 * @param x
	 * @param y
	 * @return {Boolean}
	 */
	xyInside: function (x, y) {
		return x >= this.x && y > this.y && x <= this.x + this.width && y <= this.y + this.height;
	},

	/**
	 * Returns boolean indicating if the passed point is
	 * inside the rectangle.
	 * @param {IgePoint3d} point
	 * @return {Boolean}
	 */
	pointInside: function (point) {
		return point.x >= this.x && point.y > this.y && point.x <= this.x + this.width && point.y <= this.y + this.height;
	},

	/**
	 * Returns boolean indicating if the passed IgeRect is
	 * intersecting the rectangle.
	 * @param {IgeRect} rect
	 * @return {Boolean}
	 */
	rectIntersect: function (rect) {
		this.log('rectIntersect has been renamed to "intersects". Please update your code. rectIntersect will be removed in a later version of IGE.', 'warning');
		return this.intersects(rect);
	},

	/**
	 * Returns boolean indicating if the passed IgeRect is
	 * intersecting the rectangle.
	 * @param {IgeRect} rect
	 * @return {Boolean}
	 */
	intersects: function (rect) {
		if (rect) {
			var sX1 = this.x,
				sY1 = this.y,
				sW = this.width,
				sH = this.height,

				dX1 = rect.x,
				dY1 = rect.y,
				dW = rect.width,
				dH = rect.height,

				sX2 = sX1 + sW,
				sY2 = sY1 + sH,
				dX2 = dX1 + dW,
				dY2 = dY1 + dH;

			if (sX1 < dX2 && sX2 > dX1 && sY1 < dY2 && sY2 > dY1) {
				return true;
			}
		}

		return false;
	},
	
	/**
	 * Multiplies this rect's data by the values specified
	 * and returns a new IgeRect whose values are the result.
	 * @param x1
	 * @param y1
	 * @param x2
	 * @param y2
	 * @return {*}
	 */
	multiply: function (x1, y1, x2, y2) {
		return new IgeRect(this.x * x1, this.y * y1, this.width * x2, this.height * y2);
	},
	
	/**
	 * Multiplies this rects's data by the values specified and
	 * overwrites the previous values with the result.
	 * @param x1
	 * @param y1
	 * @param x2
	 * @param y2
	 * @return {*}
	 */
	thisMultiply: function (x1, y1, x2, y2) {
		this.x *= x1;
		this.y *= y1;
		this.width *= x2;
		this.height *= y2;

		return this;
	},

	/**
	 * Returns a clone of this object that is not a reference
	 * but retains the same values.
	 * @return {IgeRect}
	 */
	clone: function () {
		return new IgeRect(this.x, this.y, this.width, this.height);
	},

	/**
	 * Returns a string representation of the rect's x, y, width,
	 * height, converting floating point values into fixed using the
	 * passed precision parameter. If no precision is specified
	 * then the precision defaults to 2.
	 * @param {Number=} precision
	 * @return {String}
	 */
	toString: function (precision) {
		if (precision === undefined) { precision = 2; }
		return this.x.toFixed(precision) + ',' + this.y.toFixed(precision) + ',' + this.width.toFixed(precision) + ',' + this.height.toFixed(precision);
	},
	
	/**
	 * Draws the polygon bounding lines to the passed context.
	 * @param {CanvasRenderingContext2D} ctx
	 */
	render: function (ctx, fill) {
		ctx.rect(this.x, this.y, this.width, this.height);
		if (fill) { ctx.fill(); }
		ctx.stroke();

		return this;
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = IgeRect; }
// TODO: Clean up the variable declarations in this file so they all run on the same var call at the top of the method.
/**
 * Creates a new transformation matrix.
 */
var IgeMatrix2d = function() {
	this.matrix = [
		1.0,0.0,0.0,
		0.0,1.0,0.0,
		0.0,0.0,1.0
	];

	this._rotateOrigin = new IgePoint3d(0, 0, 0);
	this._scaleOrigin = new IgePoint3d(0, 0, 0);
};

IgeMatrix2d.prototype = {
	matrix:	null,

	/**
	 * Transform a point by this matrix. The parameter point will be modified with the transformation values.
	 * @param {IgePoint3d} point
	 * @return {IgePoint3d} The passed point.
	 */
	transformCoord: function(point, obj) {
		var x = point.x,
			y = point.y,
			tm = this.matrix;

		point.x = x * tm[0] + y * tm[1] + tm[2];
		point.y = x * tm[3] + y * tm[4] + tm[5];
		
		/* DEXCLUDE */
		if (isNaN(tm[0]) || isNaN(tm[1]) || isNaN(tm[2]) || isNaN(tm[3]) || isNaN(tm[4]) || isNaN(tm[5])) {
			obj.log('The matrix operation produced a NaN value!', 'error');
		}
		/* DEXCLUDE */

		return point;
	},

	/**
	 * Transform a point by this matrix in inverse. The parameter point will be modified with the transformation values.
	 * @param {IgePoint3d} point.
	 * @return {IgePoint3d} The passed point.
	 */
	transformCoordInverse: function(point, obj) {
		var x = point.x,
			y = point.y,
			tm = this.matrix;

		point.x = x * tm[0] - y * tm[1] + tm[2];
		point.y = x * tm[3] + y * tm[4] - tm[5];
		
		/* DEXCLUDE */
		if (isNaN(tm[0]) || isNaN(tm[1]) || isNaN(tm[2]) || isNaN(tm[3]) || isNaN(tm[4]) || isNaN(tm[5])) {
			obj.log('The matrix operation produced a NaN value!', 'error');
		}
		/* DEXCLUDE */

		return point;
	},

	transform: function (points, obj) {
		var pointIndex,
			pointCount = points.length;

		for (pointIndex = 0; pointIndex < pointCount; pointIndex++) {
			this.transformCoord(points[pointIndex], obj);
		}

		return points;
	},

	/**
	 * Create a new rotation matrix and set it up for the specified angle in radians.
	 * @param {Number} angle
	 * @return {IgeMatrix2d} A new matrix object.
	 */
	_newRotate: function(angle) {
		var m = new IgeMatrix2d();
		m.rotateTo(angle);
		return m;
	},

	rotateBy: function(angle) {
		var m = new IgeMatrix2d();

		m.translateBy(this._rotateOrigin.x, this._rotateOrigin.y);
		m.rotateTo(angle);
		m.translateBy(-this._rotateOrigin.x, -this._rotateOrigin.y);

		this.multiply(m);

		return this;
	},

	rotateTo: function (angle) {
		var tm = this.matrix,
			c = Math.cos(angle),
			s = Math.sin(angle);

		tm[0] = c;
		tm[1] = -s;
		tm[3] = s;
		tm[4] = c;
		
		/* DEXCLUDE */
		if (isNaN(tm[0]) || isNaN(tm[1]) || isNaN(tm[2]) || isNaN(tm[3]) || isNaN(tm[4]) || isNaN(tm[5])) {
			console.log('The matrix operation produced a NaN value!', 'error');
		}
		/* DEXCLUDE */

		return this;
	},

	/**
	 * Gets the rotation from the matrix and returns it in
	 * radians.
	 * @return {Number}
	 */
	rotationRadians: function () {
		return Math.asin(this.matrix[3]);
	},

	/**
	 * Gets the rotation from the matrix and returns it in
	 * degrees.
	 * @return {Number}
	 */
	rotationDegrees: function () {
		return Math.degrees(Math.acos(this.matrix[0]));
	},

	/**
	 * Create a scale matrix.
	 * @param {Number} x X scale magnitude.
	 * @param {Number} y Y scale magnitude.
	 *
	 * @return {IgeMatrix2d} a matrix object.
	 *
	 * @static
	 */
	_newScale: function(x, y) {
		var m = new IgeMatrix2d();

		m.matrix[0] = x;
		m.matrix[4] = y;

		return m;
	},

	scaleBy: function(x, y) {
		var m = new IgeMatrix2d();

		m.matrix[0] = x;
		m.matrix[4] = y;

		this.multiply(m);

		return this;
	},

	scaleTo: function(x, y) {
		var tm = this.matrix;
		//this.identity();
		tm[0] = x;
		tm[4] = y;
		
		/* DEXCLUDE */
		if (isNaN(tm[0]) || isNaN(tm[1]) || isNaN(tm[2]) || isNaN(tm[3]) || isNaN(tm[4]) || isNaN(tm[5])) {
			this.log('The matrix operation produced a NaN value!', 'error');
		}
		/* DEXCLUDE */

		return this;
	},

	/**
	 * Create a translation matrix.
	 * @param {Number} x X translation magnitude.
	 * @param {Number} y Y translation magnitude.
	 * @return {IgeMatrix2d} A new matrix object.
	 */
	_newTranslate: function (x, y) {
		var m = new IgeMatrix2d();

		m.matrix[2] = x;
		m.matrix[5] = y;

		return m;
	},

	translateBy: function (x, y) {
		var m = new IgeMatrix2d();

		m.matrix[2] = x;
		m.matrix[5] = y;

		this.multiply(m);

		return this;
	},

	/**
	 * Sets this matrix as a translation matrix.
	 * @param x
	 * @param y
	 */
	translateTo: function (x, y) {
		var tm = this.matrix;
		
		tm[2] = x;
		tm[5] = y;
		
		/* DEXCLUDE */
		if (isNaN(tm[0]) || isNaN(tm[1]) || isNaN(tm[2]) || isNaN(tm[3]) || isNaN(tm[4]) || isNaN(tm[5])) {
			this.log('The matrix operation produced a NaN value!', 'error');
		}
		/* DEXCLUDE */

		return this;
	},

	/**
	 * Copy into this matrix the given matrix values.
	 * @param {IgeMatrix2d} matrix 
	 * @return {Object} "this".
	 */
	copy: function (matrix) {
		matrix = matrix.matrix;

		var tmatrix = this.matrix;
		tmatrix[0] = matrix[0];
		tmatrix[1] = matrix[1];
		tmatrix[2] = matrix[2];
		tmatrix[3] = matrix[3];
		tmatrix[4] = matrix[4];
		tmatrix[5] = matrix[5];
		tmatrix[6] = matrix[6];
		tmatrix[7] = matrix[7];
		tmatrix[8] = matrix[8];

		return this;
	},
	
	compare: function (matrix) {
		var thisMatrix = this.matrix,
			thatMatrix = matrix.matrix;
		
		for (var i = 0; i < 9; i++) {
			if (thisMatrix[i] !== thatMatrix[i]) {
				return false;
			}
		}
		
		return true;
	},

	/**
	 * Set this matrix to the identity matrix.
	 * @return {Object} "this".
	 */
	identity: function() {

		var m = this.matrix;
		m[0] = 1.0;
		m[1] = 0.0;
		m[2] = 0.0;

		m[3] = 0.0;
		m[4] = 1.0;
		m[5] = 0.0;

		m[6] = 0.0;
		m[7] = 0.0;
		m[8] = 1.0;

		return this;
	},

	/**
	 * Multiply this matrix by a given matrix.
	 * @param {IgeMatrix2d} m The IgeMatrix2d to multiply the
	 * current matrix by.
	 * @return {Object} "this".
	 */
	multiply: function (m) {
		var tm = this.matrix,
			mm = m.matrix,

			tm0 = tm[0],
			tm1 = tm[1],
			tm2 = tm[2],
			tm3 = tm[3],
			tm4 = tm[4],
			tm5 = tm[5],
			tm6 = tm[6],
			tm7 = tm[7],
			tm8 = tm[8],

			mm0 = mm[0],
			mm1 = mm[1],
			mm2 = mm[2],
			mm3 = mm[3],
			mm4 = mm[4],
			mm5 = mm[5],
			mm6 = mm[6],
			mm7 = mm[7],
			mm8 = mm[8];

		tm[0] = tm0*mm0 + tm1*mm3 + tm2*mm6;
		tm[1] = tm0*mm1 + tm1*mm4 + tm2*mm7;
		tm[2] = tm0*mm2 + tm1*mm5 + tm2*mm8;
		tm[3] = tm3*mm0 + tm4*mm3 + tm5*mm6;
		tm[4] = tm3*mm1 + tm4*mm4 + tm5*mm7;
		tm[5] = tm3*mm2 + tm4*mm5 + tm5*mm8;
		tm[6] = tm6*mm0 + tm7*mm3 + tm8*mm6;
		tm[7] = tm6*mm1 + tm7*mm4 + tm8*mm7;
		tm[8] = tm6*mm2 + tm7*mm5 + tm8*mm8;

		return this;
	},

	/**
	 * Premultiply this matrix by a given matrix.
	 * @param {IgeMatrix2d} m The IgeMatrix2d to premultiply the
	 * current matrix by.
	 * @return {Object} "this".
	 */
	premultiply: function(m) {

		var m00 = m.matrix[0]*this.matrix[0] + m.matrix[1]*this.matrix[3] + m.matrix[2]*this.matrix[6];
		var m01 = m.matrix[0]*this.matrix[1] + m.matrix[1]*this.matrix[4] + m.matrix[2]*this.matrix[7];
		var m02 = m.matrix[0]*this.matrix[2] + m.matrix[1]*this.matrix[5] + m.matrix[2]*this.matrix[8];

		var m10 = m.matrix[3]*this.matrix[0] + m.matrix[4]*this.matrix[3] + m.matrix[5]*this.matrix[6];
		var m11 = m.matrix[3]*this.matrix[1] + m.matrix[4]*this.matrix[4] + m.matrix[5]*this.matrix[7];
		var m12 = m.matrix[3]*this.matrix[2] + m.matrix[4]*this.matrix[5] + m.matrix[5]*this.matrix[8];

		var m20 = m.matrix[6]*this.matrix[0] + m.matrix[7]*this.matrix[3] + m.matrix[8]*this.matrix[6];
		var m21 = m.matrix[6]*this.matrix[1] + m.matrix[7]*this.matrix[4] + m.matrix[8]*this.matrix[7];
		var m22 = m.matrix[6]*this.matrix[2] + m.matrix[7]*this.matrix[5] + m.matrix[8]*this.matrix[8];

		this.matrix[0] = m00;
		this.matrix[1] = m01;
		this.matrix[2] = m02;

		this.matrix[3] = m10;
		this.matrix[4] = m11;
		this.matrix[5] = m12;

		this.matrix[6] = m20;
		this.matrix[7] = m21;
		this.matrix[8] = m22;


		return this;
	},

	/**
	 * Creates a new inverse matrix from this matrix.
	 * @return {IgeMatrix2d} An inverse matrix.
	 */
	getInverse: function() {
		var tm = this.matrix;

		var m00 = tm[0],
			m01 = tm[1],
			m02 = tm[2],
			m10 = tm[3],
			m11 = tm[4],
			m12 = tm[5],
			m20 = tm[6],
			m21 = tm[7],
			m22 = tm[8],

			newMatrix = new IgeMatrix2d(),
			determinant = m00* (m11*m22 - m21*m12) - m10*(m01*m22 - m21*m02) + m20 * (m01*m12 - m11*m02);

		if  (determinant===0) {
			return null;
		}

		var m = newMatrix.matrix;

		m[0] = m11*m22-m12*m21;
		m[1] = m02*m21-m01*m22;
		m[2] = m01*m12-m02*m11;

		m[3] = m12*m20-m10*m22;
		m[4] = m00*m22-m02*m20;
		m[5] = m02*m10-m00*m12;

		m[6] = m10*m21-m11*m20;
		m[7] = m01*m20-m00*m21;
		m[8] = m00*m11-m01*m10;

		newMatrix.multiplyScalar (1/determinant);

		return newMatrix;
	},

	/**
	 * Multiply this matrix by a scalar.
	 * @param scalar {number} Scalar value.
	 * @return this
	 */
	multiplyScalar: function (scalar) {
		var i;

		for (i=0; i<9; i++) {
			this.matrix[i]*=scalar;
		}

		return this;
	},

	/**
	 * Transforms the passed rendering context by the current matrix
	 * data using the setTransform() method so that the matrix data
	 * is set non-cumulative with the previous matrix data.
	 * @param {CanvasRenderingContext2d} ctx The rendering context to
	 * set the transform matrix for.
	 */
	transformRenderingContextSet: function(ctx) {
		var m = this.matrix;
		ctx.setTransform (m[0], m[3], m[1], m[4], m[2], m[5]);
		return this;
	},

	/**
	 * Transforms the passed rendering context by the current matrix
	 * data using the transform() method so that the matrix data
	 * is set cumulative with the previous matrix data.
	 * @param {CanvasRenderingContext2d} ctx The rendering context to
	 * set the transform matrix for.
	 */
	transformRenderingContext: function(ctx) {
		var m = this.matrix;
		ctx.transform(m[0], m[3], m[1], m[4], m[2], m[5]);
		return this;
	}
};

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = IgeMatrix2d; }
var IgeTimeComponent = IgeEventingClass.extend({
	classId: 'IgeTimeComponent',
	componentId: 'time',
	
	/**
	 * @constructor
	 * @param {Object} entity The parent object that this component is being added to.
	 * @param {Object=} options An optional object that is passed to the component when it is being initialised.
	 */
	init: function (entity, options) {
		this._entity = entity;
		this._timers = [];
		this._additions = [];
		this._removals = [];

		// Add the animation behaviour to the entity
		entity.addBehaviour('time', this._update);
	},
	
	addTimer: function (timer) {
		if (timer) {
			if (!this._updating) {
				this._timers.push(timer);
			} else {
				this._additions.push(timer);
			}
		}
		
		return this;
	},
	
	removeTimer: function (timer) {
		if (timer) {
			if (!this._updating) {
				this._timers.pull(timer);
			} else {
				this._removals.push(timer);
			}
		}
		
		return this;
	},
	
	_update: function () {
		// Get the ige tick delta and tell our timers / intervals that an update has occurred
		var self = ige.time,
			delta = ige._tickDelta,
			arr = self._timers,
			arrCount = arr.length;
		
		while (arrCount--) {
			arr[arrCount]
				.addTime(delta)
				.update();
		}
		
		// Process removing any timers that were scheduled for removal
		self._processRemovals();
		
		// Now process any additions to the timers that were scheduled to be added
		self._processAdditions();
		
		return self;
	},
	
	_processAdditions: function () {
		var arr = this._additions,
			arrCount = arr.length;
		
		if (arrCount) {
			while (arrCount--) {
				this._timers.push(arr[arrCount]);
			}
			
			this._additions = [];
		}
		
		return this;
	},
	
	_processRemovals: function () {
		var arr = this._removals,
			arrCount = arr.length;
		
		if (arrCount) {
			while (arrCount--) {
				this._timers.pull(arr[arrCount]);
			}
			
			this._removals = [];
		}
		
		return this;
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = IgeTimeComponent; }
/**
 * The animation component class. Handles defining and controlling
 * frame-based animations based on cells from a texture.
 * @event started - The animation starts.
 * @event stopped - The animation ends or is stopped.
 * @event loopComplete - The animation has completed a full cycle (shown all frames).
 * @event complete - The animation has completed all assigned loop cycles.
 */
var IgeAnimationComponent = IgeEventingClass.extend({
	classId: 'IgeAnimationComponent',
	componentId: 'animation',

	/**
	 * @constructor
	 * @param {Object} entity The parent object that this component is being added to.
	 * @param {Object=} options An optional object that is passed to the component when it is being initialised.
	 */
	init: function (entity, options) {
		this._entity = entity;
		this._anims = {};

		// Add the animation behaviour to the entity
		entity.addBehaviour('tween', this._update);
	},

	/**
	 * Defines an animation specifying the frames to use, the
	 * frames per second to animate at and if the animation
	 * should loop and if so, how many times.
	 * @param {String} id The unique animation id.
	 * @param {Array} frames An array of cell numbers to animate through.
	 * @param {Number} fps The speed of the animation (frames per second).
	 * @param {Number} loop The number of times to loop the animation, or -1 to loop forever. Defaults to -1.
	 * @param {Boolean} convertIdsToIndex If true will convert cell ids to cell indexes to speed
	 * up animation processing. This is true by default but should be disabled if you intend to
	 * change the assigned texture of the entity that this animation is applied to after you have
	 * defined the animation since the frame indexes will likely map to incorrect cells on a
	 * different texture.
	 * @example #Define an animation
	 *     // Create an entity, add the animation component and define
	 *     // an animation using frames 1, 2, 3 and 4, with an FPS of
	 *     // 25 and looping forever (-1)
	 *     var entity = new IgeEntity()
	 *         .addComponent(IgeAnimationComponent)
	 *         .animation.define('anim1', [1, 2, 3, 4], 25, -1);
	 * @return {*}
	 */
	define: function (id, frames, fps, loop, convertIdsToIndex) {
		if (frames && frames.length) {
			var i, frame;
			this._anims.length = this._anims.length || 0;

			if (convertIdsToIndex === undefined) {
				convertIdsToIndex = true; // Default the flag to true if undefined
			}

			if (convertIdsToIndex) {
				// Check each frame for string values
				for (i = 0; i < frames.length; i++) {
					frame = frames[i];
					
					if (typeof(frame) === 'string') {
						if (this._entity._texture) {
							// The frame has a cell id so convert to an index
							frame = this._entity._texture.cellIdToIndex(frame);
							frames[i] = frame;
						} else {
							this.log('You can increase the performance of id-based cell animations by specifying the animation.define AFTER you have assigned your sprite sheet to the entity on entity with ID: ' + this._entity.id(), 'warning');
							break;
						}
					}
				}
			}

			// Store the animation
			var frameTime = ((1000 / fps)|0);
			this._anims[id] = {
				frames: frames,
				frameTime: frameTime,
				loop: loop !== undefined ? loop : -1, // Default to infinite loop (-1)
				frameCount: frames.length,
				totalTime: frames.length * frameTime,
				currentDelta: 0,
				currentLoop: 0
			};

			this._anims.length++;
		} else {
			this.log('Cannot define an animation without a frame array!', 'error');
		}
		return this._entity;
	},
	
	addFrame: function (id, frameId) {
		if (this._anims[id]) {
			var anim = this._anims[id];
			
			if (typeof(frameId) === 'string') {
				frameId = this._entity._texture.cellIdToIndex(frameId);
			}
			
			anim.frames.push(frameId);
			anim.frameCount++;
			anim.totalTime = anim.frames.length * anim.frameTime;
		}
	},
	
	removeFrame: function (id, frameIndex) {
		if (this._anims[id]) {
			var anim = this._anims[id];
			
			anim.frames.splice(frameIndex, 1);
			anim.frameCount--;
			anim.totalTime = anim.frames.length * anim.frameTime;
		}
	},

	/**
	 * Removes a previously defined animation from the entity.
	 * @param {String} id The id of the animation to remove.
	 * @returns {*}
	 */
	remove: function (id) {
		delete this._anims[id];
		this._anims.length--;
		
		return this._entity;
	},

	/**
	 * Returns true if the specified animation has been defined.
	 * @param {String} id The id of the animation to check for.
	 * @returns {Boolean} True if the animation has been defined.
	 */
	defined: function (id) {
		return Boolean(this._anims[id]);
	},

	/**
	 * Sets the specified animation's FPS.
	 * @param {String} id The ID of the animation to alter the FPS for.
	 * @param {Number=} fps The number of frames per second the animation
	 * should play at.
	 * @example #Set the specified animation's FPS
	 *     // Create an entity, add the animation component and define
	 *     // an animation with an FPS of 25
	 *     var entity = new IgeEntity()
	 *         .addComponent(IgeAnimationComponent)
	 *         .animation.define('anim1', [1, 2, 3, 4], 25, -1);
	 *     
	 *     // Change the FPS to 12
	 *     entity.animation.setFps('anim1', 12);
	 * @return {*}
	 */
	setFps: function (id, fps) {
		if (this._anims) {
			var anim = this._anims[id];
			
			if (anim) {
				anim.frameTime = ((1000 / fps)|0);
				anim.totalTime = anim.frameCount * anim.frameTime;
			}
		}
		
		return this._entity;
	},
	
	/**
	 * Sets all the animations assigned to an entity to the specified FPS.
	 * @param {Number=} fps The number of frames per second the animations
	 * should play at.
	 * @example #Set all entity animations to specified FPS
	 *     // Create an entity, add the animation component and define
	 *     // a couple of animations with an FPS of 25
	 *     var entity = new IgeEntity()
	 *         .addComponent(IgeAnimationComponent)
	 *         .animation.define('anim1', [1, 2, 3, 4], 25, -1);
	 *         .animation.define('anim2', [5, 6, 7, 8], 25, -1);
	 *     
	 *     // Change the FPS of all animations to 12
	 *     entity.animation.setAllFps(12);
	 * @return {*}
	 */
	setAllFps: function (fps) {
		if (this._anims) {
			for (id in this._anims) {
				if (this._anims.hasOwnProperty(id)) {
					this.setFps(id, fps);
				}
			}
		}
		
		return this._entity;
	},

	/**
	 * Checks the current animation state, either started
	 * or stopped. 
	 * @return {Boolean} True if an animation is currently playing
	 * or false if not.
	 */
	playing: function () {
		return this._playing;
	},

	/**
	 * Starts an animation from the beginning frame.
	 * @param {String} animId The id of the animation to start.
	 * @param {Object=} options An object with some option properties.
	 * @example #Start an animation
	 *     // Create an entity, add the animation component, define
	 *     // an animation and then start it
	 *     var entity = new IgeEntity()
	 *         .addComponent(IgeAnimationComponent)
	 *         .animation.define('anim1', [1, 2, 3, 4], 25, -1);
	 *         
	 *     entity.animation.start('anim1');
	 *     
	 * @example #Start an animation with callbacks for animation events
	 *     // Create an entity, add the animation component, define
	 *     // an animation and then start it
	 *     var entity = new IgeEntity()
	 *         .addComponent(IgeAnimationComponent)
	 *         .animation.define('anim1', [1, 2, 3, 4], 25, -1);
	 *         
	 *     // In each animation callback...
	 *     // this = the entity's animation component instance
	 *     // anim = the animation component's _anim object
	 *     // this._entity = the entity the animation is attached to
	 *     
	 *     entity.animation.start('anim1', {
	 *     		onLoop: function (anim) {
	 *     			console.log('Animation looped', this, anim);	
	 *     		},
	 *     		onStopped: function (anim) {
	 *     			console.log('Animation stopped', this, anim);	
	 *     		},
	 *     		onComplete: function (anim) {
	 *     			console.log('Animation completed', this, anim);	
	 *     		}
	 *     });
	 *     
	 * @example #Start an animation with callbacks for animation events via event listeners
	 *     // Create an entity, add the animation component, define
	 *     // an animation and then start it
	 *     var entity = new IgeEntity()
	 *         .addComponent(IgeAnimationComponent)
	 *         .animation.define('anim1', [1, 2, 3, 4], 25, -1);
	 *     
	 *     // In each animation callback...
	 *     // this = the entity's animation component instance
	 *     // anim = the animation component's _anim object
	 *     // this._entity = the entity the animation is attached to
	 *     
	 *     entity.animation.on('started', function (anim) {
	 *     		console.log('Animation started', this, anim);	
	 *     });
	 *     
	 *     entity.animation.on('loopComplete', function (anim) {
	 *     		console.log('Animation looped', this, anim);	
	 *     });
	 *     
	 *     entity.animation.on('stopped', function (anim) {
	 *     		console.log('Animation stopped', this, anim);	
	 *     });
	 *     
	 *     entity.animation.on('complete', function (anim) {
	 *     		console.log('Animation complete', this, anim);	
	 *     });
	 *     
	 *     entity.animation.start('anim1');
	 * @return {*}
	 */
	start: function (animId, options) {
		if (this._anims) {
			var anim = this._anims[animId];

			if (anim) {
				anim.currentDelta = 0;
				anim.currentLoop = 0;
				anim.startTime = ige._currentTime;

				this._anim = anim;
				this._animId = animId;
				
				// Check for any callbacks in the options object
				if (options !== undefined) {
					this._completeCallback = options.onComplete;
					this._loopCallback = options.onLoop;
					this._stoppedCallback = options.onStopped;
				}
				
				this._playing = true;

				this.emit('started', anim);
			} else {
				this.log('Cannot set animation to "' + animId + '" because the animation does not exist!', 'warning');
			}
		} else {
			this.log('Cannot set animation to "' + animId + '" because no animations have been defined with defineAnim(...);', 'warning');
		}

		return this._entity;
	},

	/**
	 * Starts an animation only if the passed animation is not already
	 * started.
	 * @param {String} animId The id of the animation to start.
	 * @param {Object=} options An object with some option properties.
	 * @example #Select an animation
	 *     // Create an entity, add the animation component, define
	 *     // an animation and then select it
	 *     var entity = new IgeEntity()
	 *         .addComponent(IgeAnimationComponent)
	 *         .animation.define('anim1', [1, 2, 3, 4], 25, -1);
	 *         
	 *     entity.animation.select('anim1');
	 *     
	 *     // Selecting the same animation twice will NOT reset the
	 *     // animation because it is already playing. This is how
	 *     // select() differs from start()
	 *     entity.animation.select('anim1');
	 * @return {*}
	 */
	select: function (animId, options) {
		if (this._animId !== animId) {
			this.start(animId, options);
		}

		return this._entity;
	},

	/**
	 * Stops the current animation.
	 * @example #Stop the current animation
	 *     entity.animation.stop();
	 * @return {*}
	 */
	stop: function () {
		if (this._stoppedCallback) {
			this._stoppedCallback.call(this, this._anim);
		}
		
		this.emit('stopped', this._anim);
		
		this._playing = false;

		delete this._anim;
		delete this._animId;

		delete this._completeCallback;
		delete this._loopCallback;
		delete this._stoppedCallback;

		return this._entity;
	},
	
	/**
	 * Handles the animation processing each update.
	 * @param {CanvasRenderingContext2D} ctx The rendering context to use when doing draw operations.
	 * @param {Number} tickDelta The current ige._tickDelta passed down the scenegraph.
	 */
	_update: function (ctx, tickDelta) {
		var self = this.animation;
		
		// Just in case someone forgets to pass it in their update call!
		tickDelta = tickDelta || ige._tickDelta;
		
		if (self._anim) {
			var anim = self._anim,
				multiple,
				cell,
				frame;

			// Advance the internal animation timer
			anim.currentDelta += tickDelta;

			// Check if the animation timer is greater than the total animation time
			if (anim.currentDelta > anim.totalTime) {
				// Check if we have a single loop animation
				if (!anim.loop) {
					if (self._completeCallback) {
						self._completeCallback.call(self, anim);
					}
					self.emit('complete', anim);
					self.stop();
				} else {
					// Check if we have an infinite loop
					if (anim.loop === -1) {
						// Loop back round to the beginning
						multiple = anim.currentDelta / anim.totalTime;
						if (Math.abs(multiple) > 1) {
							anim.currentDelta -= ((multiple|0) * anim.totalTime); // Bitwise floor
						}

						if (self._loopCallback) {
							self._loopCallback.call(self, anim);
						}
						self.emit('loopComplete', anim);
					} else {
						anim.currentLoop++;
						if (anim.loop > 0 && anim.currentLoop <= anim.loop) {
							// Loop back round to the beginning
							multiple = anim.currentDelta / anim.totalTime;
							if (Math.abs(multiple) > 1) {
								anim.currentDelta -= ((multiple|0) * anim.totalTime); // Bitwise floor
							}

							if (self._loopCallback) {
								self._loopCallback.call(self, anim);
							}
							self.emit('loopComplete', anim);
						} else {
							// The animation has ended
							if (self._completeCallback) {
								self._completeCallback.call(self, anim);
							}
							self.emit('complete', anim);
							self.stop();
						}
					}
				}
			}

			frame = ((anim.currentDelta / anim.frameTime)|0);

			if (frame >= anim.frameCount) {
				frame = anim.frameCount - 1;
			}

			cell = anim.frames[frame];

			// Set the current frame
			if (typeof(cell) === 'string') {
				self._entity.cellById(cell);
			} else {
				self._entity.cell(cell);
			}
		}
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = IgeAnimationComponent; }
// TODO: Doc this class!
var IgeVelocityComponent = IgeClass.extend({
	classId: 'IgeVelocityComponent',
	componentId: 'velocity',

	init: function (entity, options) {
		this._entity = entity;

		this._velocity = new IgePoint3d(0, 0, 0);
		this._friction = new IgePoint3d(1, 1, 1);

		// Add the velocity behaviour to the entity
		entity.addBehaviour('velocity', this._behaviour);
	},

	/**
	 * The behaviour method executed each tick.
	 * @param ctx
	 * @private
	 */
	_behaviour: function (ctx) {
		this.velocity.tick(ctx);
	},

	byAngleAndPower: function (radians, power, relative) {
		var vel = this._velocity,
			x = Math.cos(radians) * power,
			y = Math.sin(radians) * power,
			z = 0;

		if (!relative) {
			vel.x = x;
			vel.y = y;
			vel.z = z;
		} else {
			vel.x += x;
			vel.y += y;
			vel.z += z;
		}

		return this._entity;
	},

	xyz: function (x, y, z, relative) {
		var vel = this._velocity;

		if (!relative) {
			vel.x = x;
			vel.y = y;
			vel.z = z;
		} else {
			vel.x += x;
			vel.y += y;
			vel.z += z;
		}

		return this._entity;
	},

	x: function (x, relative) {
		var vel = this._velocity;

		if (!relative) {
			vel.x = x;
		} else {
			vel.x += x;
		}

		return this._entity;
	},

	y: function (y, relative) {
		var vel = this._velocity;

		if (!relative) {
			vel.y = y;
		} else {
			vel.y += y;
		}

		return this._entity;
	},

	z: function (z, relative) {
		var vel = this._velocity;

		if (!relative) {
			vel.z = y;
		} else {
			vel.z += z;
		}

		return this._entity;
	},

	vector3: function (vector, relative) {
		if (typeof(vector.scale) !== 'number') {
			vector.scale = 1; // Default to 1
		}

		var vel = this._velocity,
			x = vector.x,
			y = vector.y,
			z = vector.z;

		if (!relative) {
			vel.x = x;
			vel.y = y;
			vel.z = z;
		} else {
			vel.x += x;
			vel.y += y;
			vel.z += z;
		}

		return this._entity;
	},

	friction: function (val) {
		var finalFriction = 1 - val;

		if (finalFriction < 0) {
			finalFriction = 0;
		}

		this._friction = new IgePoint3d(finalFriction, finalFriction, finalFriction);

		return this._entity;
	},

	linearForce: function (degrees, power) {
		power /= 1000;
		var radians = (degrees * Math.PI / 180),
			x = Math.cos(radians) * power,
			y = Math.sin(radians) * power,
			z = x * y;
		this._linearForce = new IgePoint3d(x, y, z);

		return this._entity;
	},

	linearForceXYZ: function (x, y, z) {
		this._linearForce = new IgePoint3d(x, y, z);
		return this._entity;
	},

	linearForceVector3: function (vector, power, relative) {
		var force = this._linearForce = this._linearForce || new IgePoint3d(0, 0, 0),
			x = vector.x / 1000,
			y = vector.y / 1000,
			z = vector.z / 1000;

		if (!relative) {
			force.x = x || 0;
			force.y = y || 0;
			force.z = z || 0;
		} else {
			force.x += x || 0;
			force.y += y || 0;
			force.z += z || 0;
		}

		return this._entity;
	},

	_applyLinearForce: function (delta) {
		if (this._linearForce) {
			var vel = this._velocity;

			vel.x += (this._linearForce.x * delta);
			vel.y += (this._linearForce.y * delta);
			vel.z += (this._linearForce.z * delta);
		}
	},

	_applyFriction: function () {
		var vel = this._velocity,
			fric = this._friction;

		vel.x *= fric.x;
		vel.y *= fric.y;
		vel.z *= fric.z;
	},

	tick: function (ctx) {
		var delta = ige._tickDelta,
			vel = this._velocity,
			x, y, z;

		if (delta) {
			this._applyLinearForce(delta);
			//this._applyFriction();

			x = vel.x * delta;
			y = vel.y * delta;
			z = vel.z * delta;

			if (x || y || z) {
				this._entity.translateBy(x, y, z);
			}
		}
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = IgeVelocityComponent; }
/**
 * This component is already included in the IgeEngine (ige)
 * instance and is not designed for use in any other way!
 * It handles global tween processing on all tweening values.
 */
var IgeTweenComponent = IgeClass.extend({
	classId: 'IgeTweenComponent',
	componentId: 'tween',

	init: function (entity, options) {
		this._entity = entity;
		this._transform = entity.transform;

		// Setup the array that will hold our active tweens
		this._tweens = [];

		// Add the tween behaviour to the entity 
		entity.addBehaviour('tween', this.update);
	},

	/**
	 * Start tweening particular properties for the object.
	 * @param {IgeTween} tween The tween to start.
	 * @return {Number} The index of the added tween or -1 on error.
	 */
	start: function (tween) {
		if (tween._startTime > ige._currentTime) {
			// The tween is scheduled for later
			// Push the tween into the IgeTweenComponent's _tweens array
			this._tweens.push(tween);
		} else {
			// The tween should start immediately
			tween._currentStep = 0;
			
			// Setup the tween's step
			if (this._setupStep(tween, false)) {
				// Push the tween into the IgeTweenComponent's _tweens array
				this._tweens.push(tween);
			}
		}

		// Enable tweening on the IgeTweenComponent
		this.enable();

		// Return the tween
		return tween;
	},

	_setupStep: function (tween, newTime) {
		var targetObj = tween._targetObj,
			step = tween._steps[tween._currentStep],
			propertyNameAndValue, // = tween._propertyObj
			durationMs,
			endTime,
			easing,
			propertyIndex,
			targetData = [];

		if (step) {
			propertyNameAndValue = step.props;
		}

		if (targetObj) {
			// Check / fill some option defaults
			if (tween._currentStep === 0 && !newTime) {
				// Because we are on step zero we can check for a start time
				if (tween._startTime === undefined) {
					tween._startTime = ige._currentTime;
				}
			} else {
				// We're not on step zero anymore so the new step start time
				// is NOW!
				tween._startTime = ige._currentTime;
			}

			durationMs = step.durationMs ? step.durationMs : tween._durationMs;
			tween._selectedEasing = step.easing ? step.easing : tween._easing;

			// Calculate the end time
			tween._endTime = tween._startTime + durationMs;

			for (propertyIndex in propertyNameAndValue) {
				if (propertyNameAndValue.hasOwnProperty(propertyIndex)) {
					targetData.push({
						targetObj: targetObj,
						propName: propertyIndex,
						deltaVal: propertyNameAndValue[propertyIndex] - (step.isDelta ? 0 : targetObj[propertyIndex]), // The diff between end and start values
						oldDelta: 0 // Var to save the old delta in order to get the actual difference data.
					});
				}
			}

			tween._targetData = targetData;
			tween._destTime = tween._endTime - tween._startTime;

			return tween; // Return the tween
		} else {
			this.log('Cannot start tweening properties of the specified object "' + obj + '" because it does not exist!', 'error');
		}
	},

	/**
	 * Removes the specified tween from the active tween list.
	 * @param {IgeTween} tween The tween to stop.
	 */
	stop: function (tween) {
		// Store the new tween details in the item
		this._tweens.pull(tween);

		if (!this._tweens.length) {
			// Disable tweening on this item as there are
			// no more tweens to process
			this.disable();
		}
		
		return this;
	},

	/**
	 * Stop all tweening for the object.
	 */
	stopAll: function () {
		// Disable tweening
		this.disable();

		// Remove all tween details
		delete this._tweens;
		this._tweens = [];

		return this;
	},

	/**
	 * Enable tweening for the object.
	 */
	enable: function () {
		// Check if the item is currently tweening
		if (!this._tweening) {
			// Set the item to tweening
			this._tweening = true;
		}

		return this;
	},

	/**
	 * Disable tweening for the object.
	 */
	disable: function () {
		// Check if the item is currently tweening
		if (this._tweening) {
			// Set the item to not tweening
			this._tweening = false;
		}

		return this;
	},

	/**
	 * Process tweening for the object.
	 */
	update: function (ctx) {
		var thisTween = this.tween;
		if (thisTween._tweens && thisTween._tweens.length) {
			var currentTime = ige._tickStart,
				tweens = thisTween._tweens,
				tweenCount = tweens.length,
				tween,
				deltaTime,
				destTime,
				easing,
				item,
				targetProp,
				targetPropVal,
				targets,
				targetIndex,
				stepIndex,
				stopped,
				currentDelta;

			// Loop the item's tweens
			while (tweenCount--) {
				tween = tweens[tweenCount];
				stopped = false;

				// Check if we should be starting this tween yet
				if (tween._started || currentTime >= tween._startTime) {
					if (!tween._started) {
						// Check if the tween's step is -1 indicating no step
						// data has been set up yet
						if (tween._currentStep === -1) {
							// Setup the tween step now
							tween._currentStep = 0;
							thisTween._setupStep(tween, false);
						}
						
						// Check if we have a beforeTween callback to fire
						if (typeof(tween._beforeTween) === 'function') {
							// Fire the beforeTween callback
							tween._beforeTween(tween);

							// Delete the callback so we don't store it any longer
							delete tween._beforeTween;
						}

						// Check if we have a beforeStep callback to fire
						if (typeof(tween._beforeStep) === 'function') {
							// Fire the beforeStep callback
							if (tween._stepDirection) {
								stepIndex = tween._steps.length - (tween._currentStep + 1);
							} else {
								stepIndex = tween._currentStep;
							}
							tween._beforeStep(tween, stepIndex);
						}

						tween._started = true;
					}

					deltaTime = currentTime - tween._startTime; // Delta from start time to current time
					destTime = tween._destTime;
					easing = tween._selectedEasing;

					// Check if the tween has reached it's destination based upon
					// the current time
					if (deltaTime >= destTime) {
						// The tween time indicates the tween has ended so set to
						// the ending value
						targets = tween._targetData;

						for (targetIndex in targets) {
							if (targets.hasOwnProperty(targetIndex)) {
								item = targets[targetIndex];
								targetProp = item.targetObj;
								targetPropVal = targetProp[item.propName];
								
								// Check if the destination time is not zero
								// because otherwise the easing method will provide
								// a divide by zero error resulting in a NaN value
								if (destTime !== 0) {
									// Add the delta amount to destination
									currentDelta = thisTween.easing[easing](
										destTime,
										item.deltaVal,
										destTime
									);
								} else {
									currentDelta = item.deltaVal;
								}
								
								targetPropVal += currentDelta - item.oldDelta;
								
								// Round the value to correct floating point operation imprecision
								var roundingPrecision = Math.pow(10, 15-(targetPropVal.toFixed(0).toString().length));
								targetProp[item.propName] = Math.round(targetPropVal * roundingPrecision)/roundingPrecision;
							}
						}

						// Check if we have a afterStep callback to fire
						if (typeof(tween._afterStep) === 'function') {
							// Fire the afterStep
							if (tween._stepDirection) {
								stepIndex = tween._steps.length - (tween._currentStep + 1);
							} else {
								stepIndex = tween._currentStep;
							}
							tween._afterStep(tween, stepIndex);
						}

						if (tween._steps.length === tween._currentStep + 1) {
							// The tween has ended, is the tween repeat mode enabled?
							if (tween._repeatMode) {
								// We have a repeat mode, lets check for a count
								if (tween._repeatCount !== -1) {
									// Check if the repeat count has reached the
									// number of repeats we wanted
									tween._repeatedCount++;
									if (tween._repeatCount === tween._repeatedCount) {
										// The tween has ended
										stopped = true;
									}
								}

								if (!stopped) {
									// Work out what mode we're running on
									if (tween._repeatMode === 1) {
										tween._currentStep = 0;
									}

									if (tween._repeatMode === 2) {
										// We are on "reverse loop" mode so now
										// reverse the tween's steps and then
										// start from step zero
										tween._stepDirection = !tween._stepDirection;
										tween._steps.reverse();

										tween._currentStep = 1;
									}

									// Check if we have a stepsComplete callback to fire
									if (typeof(tween._stepsComplete) === 'function') {
										// Fire the stepsComplete callback
										tween._stepsComplete(tween, tween._currentStep);
									}

									// Check if we have a beforeStep callback to fire
									if (typeof(tween._beforeStep) === 'function') {
										// Fire the beforeStep callback
										if (tween._stepDirection) {
											stepIndex = tween._steps.length - (tween._currentStep + 1);
										} else {
											stepIndex = tween._currentStep;
										}
										tween._beforeStep(tween, stepIndex);
									}

									thisTween._setupStep(tween, true);
								}
							} else {
								stopped = true;
							}

							if (stopped) {
								// Now stop tweening this tween
								tween.stop();

								// If there is a callback, call it
								if (typeof(tween._afterTween) === 'function') {
									// Fire the afterTween callback
									tween._afterTween(tween);

									// Delete the callback so we don't store it any longer
									delete tween._afterTween;
								}
							}
						} else {
							// Start the next step
							tween._currentStep++;

							// Check if we have a beforeStep callback to fire
							if (typeof(tween._beforeStep) === 'function') {
								// Fire the beforeStep callback
								if (tween._stepDirection) {
									stepIndex = tween._steps.length - (tween._currentStep + 1);
								} else {
									stepIndex = tween._currentStep;
								}
								tween._beforeStep(tween, stepIndex);
							}

							thisTween._setupStep(tween, true);
						}
						
						if (typeof(tween._afterChange) === 'function') {
							tween._afterChange(tween, stepIndex);
						}
					} else {
						// The tween is still active, process the tween by passing it's details
						// to the selected easing method
						targets = tween._targetData;

						for (targetIndex in targets) {
							if (targets.hasOwnProperty(targetIndex)) {
								item = targets[targetIndex];
								var currentDelta = thisTween.easing[easing](
									deltaTime,
									item.deltaVal,
									destTime
								);
								item.targetObj[item.propName] += currentDelta - item.oldDelta;
								item.oldDelta = currentDelta;
							}
						}
						
						if (typeof(tween._afterChange) === 'function') {
							tween._afterChange(tween, stepIndex);
						}
					}
				}
			}
		}
	},

	/** tweenEasing - Contains all the tween easing functions. {
		category:"property",
		type:"object",
	} **/
	easing: {
		// Easing equations converted from AS to JS from original source at
		// http://robertpenner.com/easing/
		none: function(t, c, d) {
			return c*t/d;
		},
		inQuad: function(t, c, d) {
			return c*(t/=d)*t;
		},
		outQuad: function(t, c, d) {
			return -c *(t/=d)*(t-2);
		},
		inOutQuad: function(t, c, d) {
			if((t/=d/2) < 1) { return c/2*t*t; }
			return -c/2 *((--t)*(t-2) - 1);
		},
		inCubic: function(t, c, d) {
			return c*(t/=d)*t*t;
		},
		outCubic: function(t, c, d) {
			return c*((t=t/d-1)*t*t + 1);
		},
		inOutCubic: function(t, c, d) {
			if((t/=d/2) < 1) { return c/2*t*t*t; }
			return c/2*((t-=2)*t*t + 2);
		},
		outInCubic: function(t, c, d) {
			if(t < d/2) { return this.outCubic(t*2, c/2, d); }
			return this.inCubic((t*2)-d, c/2, c/2, d);
		},
		inQuart: function(t, c, d) {
			return c*(t/=d)*t*t*t;
		},
		outQuart: function(t, c, d) {
			return -c *((t=t/d-1)*t*t*t - 1);
		},
		inOutQuart: function(t, c, d) {
			if((t/=d/2) < 1) { return c/2*t*t*t*t; }
			return -c/2 *((t-=2)*t*t*t - 2);
		},
		outInQuart: function(t, c, d) {
			if(t < d/2) { return this.outQuart(t*2, c/2, d); }
			return this.inQuart((t*2)-d, c/2, c/2, d);
		},
		inQuint: function(t, c, d) {
			return c*(t/=d)*t*t*t*t;
		},
		outQuint: function(t, c, d) {
			return c*((t=t/d-1)*t*t*t*t + 1);
		},
		inOutQuint: function(t, c, d) {
			if((t/=d/2) < 1) { return c/2*t*t*t*t*t; }
			return c/2*((t-=2)*t*t*t*t + 2);
		},
		outInQuint: function(t, c, d) {
			if(t < d/2) { return this.outQuint(t*2, c/2, d); }
			return this.inQuint((t*2)-d, c/2, c/2, d);
		},
		inSine: function(t, c, d) {
			return -c * Math.cos(t/d *(Math.PI/2)) + c;
		},
		outSine: function(t, c, d) {
			return c * Math.sin(t/d *(Math.PI/2));
		},
		inOutSine: function(t, c, d) {
			return -c/2 *(Math.cos(Math.PI*t/d) - 1);
		},
		outInSine: function(t, c, d) {
			if(t < d/2) { return this.outSine(t*2, c/2, d); }
			return this.inSine((t*2)-d, c/2, c/2, d);
		},
		inExpo: function(t, c, d) {
			return(t === 0) ? 0 : c * Math.pow(2, 10 *(t/d - 1)) - c * 0.001;
		},
		outExpo: function(t, c, d) {
			return(t === d) ? c : c * 1.001 *(-Math.pow(2, -10 * t/d) + 1);
		},
		inOutExpo: function(t, c, d) {
			if(t === 0) { return 0; }
			if(t === d) { return c; }
			if((t/=d/2) < 1) { return c/2 * Math.pow(2, 10 *(t - 1)) - c * 0.0005; }
			return c/2 * 1.0005 *(-Math.pow(2, -10 * --t) + 2);
		},
		outInExpo: function(t, c, d) {
			if(t < d/2) { return this.outExpo(t*2, c/2, d); }
			return this.inExpo((t*2)-d, c/2, c/2, d);
		},
		inCirc: function(t, c, d) {
			return -c *(Math.sqrt(1 -(t/=d)*t) - 1);
		},
		outCirc: function(t, c, d) {
			return c * Math.sqrt(1 -(t=t/d-1)*t);
		},
		inOutCirc: function(t, c, d) {
			if((t/=d/2) < 1) { return -c/2 *(Math.sqrt(1 - t*t) - 1); }
			return c/2 *(Math.sqrt(1 -(t-=2)*t) + 1);
		},
		outInCirc: function(t, c, d) {
			if(t < d/2) { return this.outCirc(t*2, c/2, d); }
			return this.inCirc((t*2)-d, c/2, c/2, d);
		},
		inElastic: function(t, c, d, a, p) {
			var s;
			if(t===0) {return 0;}
			if((t/=d)===1) { return c; }
			if(!p) { p=d*0.3; }
			if(!a || a < Math.abs(c)) { a=c; s=p/4; } else { s = p/(2*Math.PI) * Math.asin(c/a); }
			return -(a*Math.pow(2,10*(t-=1)) * Math.sin((t*d-s)*(2*Math.PI)/p ));
		},
		outElastic: function(t, c, d, a, p) {
			var s;
			if(t===0) { return 0; }
			if((t/=d)===1) { return c; }
			if(!p) { p=d*0.3; }
			if(!a || a < Math.abs(c)) { a=c; s=p/4; } else { s = p/(2*Math.PI) * Math.asin(c/a); }
			return(a*Math.pow(2,-10*t) * Math.sin((t*d-s)*(2*Math.PI)/p ) + c);
		},
		inOutElastic: function(t, c, d, a, p) {
			var s;
			if(t===0) { return 0; }
			if((t/=d/2)===2) { return c; }
			if(!p) { p=d*(0.3*1.5); }
			if(!a || a < Math.abs(c)) { a=c; s=p/4; } else { s = p/(2*Math.PI) * Math.asin(c/a); }
			if(t < 1) { return -0.5*(a*Math.pow(2,10*(t-=1)) * Math.sin((t*d-s)*(2*Math.PI)/p)); }
			return a*Math.pow(2,-10*(t-=1)) * Math.sin((t*d-s)*(2*Math.PI)/p )*0.5 + c;
		},
		outInElastic: function(t, c, d, a, p) {
			if(t < d/2) { return this.outElastic(t*2, c/2, d, a, p); }
			return this.inElastic((t*2)-d, c/2, c/2, d, a, p);
		},
		inBack: function(t, c, d, s) {
			if(s === undefined) { s = 1.70158; }
			return c*(t/=d)*t*((s+1)*t - s);
		},
		outBack: function(t, c, d, s) {
			if(s === undefined) { s = 1.70158; }
			return c*((t=t/d-1)*t*((s+1)*t + s) + 1);
		},
		inOutBack: function(t, c, d, s) {
			if(s === undefined) { s = 1.70158; }
			if((t/=d/2) < 1) { return c/2*(t*t*(((s*=(1.525))+1)*t - s)); }
			return c/2*((t-=2)*t*(((s*=(1.525))+1)*t + s) + 2);
		},
		outInBack: function(t, c, d, s) {
			if(t < d/2) { return this.outBack(t*2, c/2, d, s); }
			return this.inBack((t*2)-d, c/2, c/2, d, s);
		},
		inBounce: function(t, c, d) {
			return c - this.outBounce(d-t, 0, c, d);
		},
		outBounce: function(t, c, d) {
			if((t/=d) <(1/2.75)) {
				return c*(7.5625*t*t);
			} else if(t <(2/2.75)) {
				return c*(7.5625*(t-=(1.5/2.75))*t + 0.75);
			} else if(t <(2.5/2.75)) {
				return c*(7.5625*(t-=(2.25/2.75))*t + 0.9375);
			} else {
				return c*(7.5625*(t-=(2.625/2.75))*t + 0.984375);
			}
		},
		inOutBounce: function(t, c, d) {
			if(t < d/2) {
				return this.inBounce(t*2, 0, c, d) * 0.5;
			} else {
				return this.outBounce(t*2-d, 0, c, d) * 0.5 + c*0.5;
			}
		},
		outInBounce: function(t, c, d) {
			if(t < d/2) { return this.outBounce(t*2, c/2, d); }
			return this.inBounce((t*2)-d, c/2, c/2, d);
		}
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = IgeTweenComponent; }
/**
 * Handles entity path traversal.
 */
var IgePathComponent = IgeEventingClass.extend({
	classId: 'IgePathComponent',
	componentId: 'path',

	init: function (entity, options) {
		this._entity = entity;
		this._points = [];
		this._speed = 1 / 1000;
		
		this._previousPointFrom = 0;
		this._currentPointFrom = 0;
		this._previousPointTo = 0;
		this._currentPointTo = 0;
		
		// Add the path behaviour to the entity
		entity.addBehaviour('path', this._updateBehaviour, false);
	},

	/**
	 * Gets / sets the tile map that will be used when calculating paths.
	 * @param {IgeTileMap2d} val The tileMap to use for path calculations.
	 * @returns {*}
	 */
	tileMap: function (val) {
		if (val !== undefined) {
			this._tileMap = val;
			return this;
		}
		
		return this._tileMap;
	},
	
	/**
	 * Gets / sets the path finder class instance used to generate paths.
	 * @param {IgePathFinder} val The pathfinder class instance to use to generate paths.
	 * @returns {*}
	 */
	finder: function (val) {
		if (val !== undefined) {
			this._finder = val;
			return this;
		}
		
		return this._finder;
	},

	/**
	 * Gets / sets the dynamic mode enabled flag. If dynamic mode is enabled
	 * then at the end of every path point (reaching a tile along the path)
	 * the path finder will evaluate the path by looking ahead and seeing if
	 * the path has changed (the tiles along the path have now been marked as
	 * cannot path on). If any tile along the path up to the look-ahead value
	 * has been blocked, the path will auto re-calculate to avoid the new block.
	 * 
	 * For dynamic mode to work you need to supply a path-finder instance by
	 * calling .finder(), a tile checker method by calling .tileChecker() and
	 * the number of look-ahead steps by calling .lookAheadSteps(). See the
	 * doc for those methods for usage and required arguments.
	 * @param {Boolean} enable If set to true, enables dynamic mode.
	 * @returns {*}
	 */
	dynamic: function (enable) {
		if (enable !== undefined) {
			this._dynamic = enable;
			return this;
		}
		
		return this._dynamic;
	},

	/**
	 * Gets / sets the tile checker method used when calculating paths.
	 * @param {Function=} val The method to call when checking if a tile is valid
	 * to traverse when calculating paths.
	 * @returns {*}
	 */
	tileChecker: function (val) {
		if (val !== undefined) {
			var self = this;
			
			this._tileChecker = function () { return val.apply(self._entity, arguments); };
			return this;
		}
		
		return this._tileChecker;
	},
	
	lookAheadSteps: function (val) {
		if (val !== undefined) {
			this._lookAheadSteps = val;
			return this;
		}
		
		return this._lookAheadSteps;
	},

	/**
	 * Gets / sets the flag determining if a path can use N, S, E and W movement.
	 * @param {Boolean=} val Set to true to allow, false to disallow.
	 * @returns {*}
	 */
	allowSquare: function (val) {
		if (val !== undefined) {
			this._allowSquare = val;
			return this;
		}
		
		return this._allowSquare;
	},
	
	/**
	 * Gets / sets the flag determining if a path can use NW, SW, NE and SE movement.
	 * @param {Boolean=} val Set to true to allow, false to disallow.
	 * @returns {*}
	 */
	allowDiagonal: function (val) {
		if (val !== undefined) {
			this._allowDiagonal = val;
			return this;
		}
		
		return this._allowDiagonal;
	},

	/**
	 * Clears any existing path points and sets the path the entity will traverse
	 * from start to finish.
	 * @param {Number} fromX The x tile to path from.
	 * @param {Number} fromY The y tile to path from.
	 * @param {Number} fromZ The z tile to path from.
	 * @param {Number} toX The x tile to path to.
	 * @param {Number} toY The y tile to path to.
	 * @param {Number} toZ The z tile to path to.
	 * @param {Boolean=} findNearest If the destination is unreachable, when set to
	 * true this option will allow the pathfinder to return the closest path to the
	 * destination tile.
	 * @returns {*}
	 */
	set: function (fromX, fromY, fromZ, toX, toY, toZ, findNearest) {
		// Clear existing path
		this.clear();
		
		// Create a new path
		var path = this._finder.generate(
			this._tileMap,
			new IgePoint3d(fromX, fromY, fromZ),
			new IgePoint3d(toX, toY, toZ),
			this._tileChecker,
			this._allowSquare,
			this._allowDiagonal,
			findNearest
		);
		
		this.addPoints(path);
		
		return this;
	},
	
	add: function (x, y, z, findNearest) {
		// Get the endPoint of the current path
		var endPoint = this.getEndPoint(),
			shift = true;
		
		if (!endPoint) {
			// There is no existing path, detect current tile position
			endPoint = this._entity._parent.pointToTile(this._entity._translate);
			shift = false;
		}
		
		// Create a new path
		var path = this._finder.generate(
			this._tileMap,
			endPoint,
			new IgePoint3d(x, y, z),
			this._tileChecker,
			this._allowSquare,
			this._allowDiagonal,
			findNearest
		);
		
		if (shift) {
			// Remove the first tile, it's the last one on the list already
			path.shift();
		}
		
		this.addPoints(path);
		
		return this;
	},

	/**
	 * Adds a path array containing path points (IgePoint3d instances) to the points queue.
	 * @param {Array} path An array of path points.
	 * @return {*}
	 */
	addPoints: function (path) {
		if (path !== undefined) {
			// Check the path array has items in it!
			if (path.length) {
				this._points = this._points.concat(path);
				this._calculatePathData();
			} else {
				this.log('Cannot add an empty path to the path queue!', 'warning');
			}
		}

		return this;
	},

	/**
	 * Gets the path node point that the entity is travelling from.
	 * @return {IgePoint3d} A new point representing the travelled from node.
	 */
	getFromPoint: function () {
		return this._points[this._currentPointFrom];
	},

	/**
	 * Gets the path node point that the entity is travelling to.
	 * @return {IgePoint3d} A new point representing the travelling to node.
	 */
	getToPoint: function () {
		return this._points[this._currentPointTo];
	},

	/**
	 * Gets the current direction.
	 * @example #Get the direction of movement along the current path
	 *     // Create an entity and add the path component
	 *     var entity = new IgeEntity()
	 *         .addComponent(IgePathComponent);
	 *     
	 *     // Create a path and add it to the entity
	 *     // ...
	 *     // Now get the current direction
	 *     var direction = entity.path.currentDirection();
	 * @return {String} A string such as N, S, E, W, NW, NE, SW, SE.
	 * If there is currently no direction then the return value is a blank string.
	 */
	getDirection: function () {
		if (!this._finished) {
			var cell = this.getToPoint(),
				dir = '';
			
			if (cell) {
				dir = cell.direction;
				
				if (this._entity._mode === 1) {
					// Convert direction for isometric
					switch (dir) {
						case 'E':
							dir = 'SE';
							break;
						
						case 'S':
							dir = 'SW';
							break;
						
						case 'W':
							dir = 'NW';
							break;
						
						case 'N':
							dir = 'NE';
							break;
						
						case 'NE':
							dir = 'E';
							break;
						
						case 'SW':
							dir = 'W';
							break;
						
						case 'NW':
							dir = 'N';
							break;
						
						case 'SE':
							dir = 'S';
							break;
					}
				}
			}
		} else {
			dir = '';
		}

		return dir;
	},

	/**
	 * Gets / sets the time towards the end of the path when the path
	 * component will emit a "almostComplete" event.
	 * @param {Number=} ms The time in milliseconds to emit the event
	 * on before the end of the path.
	 * @return {*}
	 */
	warnTime: function (ms) {
		if (ms !== undefined) {
			this._warnTime = ms;
			return this;
		}

		return this._warnTime;
	},

	/**
	 * Gets / sets the flag determining if the entity moving along
	 * the path will stop automatically at the end of the path.
	 * @param {Boolean=} val If true, will stop at the end of the path.
	 * @return {*}
	 */
	autoStop: function (val) {
		if (val !== undefined) {
			this._autoStop = val;
			return this;
		}

		return this._autoStop;
	},

	/**
	 * Gets / sets the speed at which the entity will traverse the path in pixels
	 * per second (world space).
	 * @param {Number=} val
	 * @return {*}
	 */
	speed: function (val) {
		if (val !== undefined) {
			this._speed = val / 1000;
			
			if (this._active) {
				this.stop();
				this.start(this._startTime);
			}
			return this;
		}

		return this._speed;
	},

	/**
	 * Starts path traversal.
	 * @param {Number=} startTime The time to start path traversal. Defaults
	 * to new Date().getTime() if no
	 * value is presented.
	 * @return {*}
	 */
	start: function (startTime) {
		if (!this._active) {
			this._active = true;
			this._finished = false;
			this._startTime = startTime || ige._currentTime;
			
			this._calculatePathData();
		} else {
			this._finished = false;
		}
		
		return this;
	},

	/**
	 * Returns the last point of the last path in the path queue.
	 * @return {IgePoint3d}
	 */
	getEndPoint: function () {
		return this._points[this._points.length - 1];
	},

	/**
	 * Pauses path traversal but does not clear the path queue or any path data.
	 * @return {*}
	 */
	pause: function () {
		this._active = false;
		this._paused = true;
		this._pauseTime = ige._currentTime;
		
		this.emit('paused', this._entity);
		return this;
	},

	/**
	 * Clears all path queue and path data.
	 * @return {*}
	 */
	clear: function () {
		if (this._active) {
			this.stop();
		}
		
		this._previousPointFrom = 0;
		this._currentPointFrom = 0;
		this._previousPointTo = 0;
		this._currentPointTo = 0;
		this._points = [];
		
		this.emit('cleared', this._entity);
		return this;
	},
	
	/**
	 * Stops path traversal but does not clear the path
	 * queue or any path data.
	 * @return {*}
	 */
	stop: function () {
		//this.log('Setting pathing as inactive...');
		this._active = false;
		this._finished = true;
		this.emit('stopped', this._entity);
		
		return this;
	},

	/**
	 * Gets / sets the flag determining if the path component
	 * should draw the current path of the entity to the canvas
	 * on each tick. Useful for debugging paths.
	 * @param {Boolean=} val If true, will draw the path.
	 * @return {*}
	 */
	drawPath: function (val) {
		if (val !== undefined) {
			this._drawPath = val;
			
			if (val) {
				this._entity.addBehaviour('path', this._tickBehaviour, true);
			} else {
				this._entity.removeBehaviour('path', true);
			}
			
			return this;
		}

		return this._drawPath;
	},

	/**
	 * Gets / sets the flag that determines if the path that
	 * is drawn gets some added glow effects or not. Pure eye
	 * candy, completely pointless otherwise.
	 * @param {Boolean=} val If true will add glow effects to the path.
	 * @return {*}
	 */
	drawPathGlow: function (val) {
		if (val !== undefined) {
			this._drawPathGlow = val;
			return this;
		}

		return this._drawPathGlow;
	},

	/**
	 * Gets / sets the flag that determines if the path that
	 * is drawn gets some added labels or not.
	 * @param {Boolean=} val If true will draw labels on each path point.
	 * @return {*}
	 */
	drawPathText: function (val) {
		if (val !== undefined) {
			this._drawPathText = val;
			return this;
		}

		return this._drawPathText;
	},
	
	multiplyPoint: function (point) {
		return point.multiply(
			this._entity._parent._tileWidth,
			this._entity._parent._tileHeight,
			1
		);
	},

	dividePoint: function (point) {
		return point.divide(
			this._entity._parent._tileWidth,
			this._entity._parent._tileHeight,
			1
		);
	},
	
	transformPoint: function (point) {
		return new IgePoint3d(
			point.x + this._entity._parent._tileWidth / 2,
			point.y + this._entity._parent._tileHeight / 2,
			point.z
		);
	},

	unTransformPoint: function (point) {
		return new IgePoint3d(
			point.x - this._entity._parent._tileWidth / 2,
			point.y - this._entity._parent._tileHeight / 2,
			point.z
		);
	},

	/**
	 * The behaviour method executed each tick.
	 * @param {CanvasRenderingContext2d} ctx The canvas that is currently being
	 * rendered to.
	 * @private
	 */
	_updateBehaviour: function (ctx) {
		var path = this.path,
			currentTime = ige._currentTime,
			progressTime = currentTime - path._startTime;
		
		// Check if we should be processing paths
		if (path._active && path._totalDistance !== 0 && currentTime >= path._startTime && (progressTime <= path._totalTime || !path._finished)) {
			var distanceTravelled = (path._speed) * progressTime,
				totalDistance = 0,
				pointArr = path._points,
				pointCount = pointArr.length,
				pointIndex,
				pointFrom,
				pointTo,
				newPoint,
				dynamicResult;
			
			// Loop points along the path and determine which points we are traversing between
			for (pointIndex = 0; pointIndex < pointCount; pointIndex++) {
				totalDistance += pointArr[pointIndex]._distanceToNext;
				
				if (totalDistance > distanceTravelled) {
					// Found points we are traversing
					path._finished = false;
					path._currentPointFrom = pointIndex;
					path._currentPointTo = pointIndex + 1;
					pointFrom = pointArr[pointIndex];
					pointTo = pointArr[pointIndex + 1];
					break;
				}
			}
			
			// Check if we have points to traverse between
			if (pointFrom && pointTo) {
				if (path._currentPointFrom !== path._previousPointFrom) {
					// Emit point complete
					path.emit('pointComplete', [this, pointArr[path._previousPointFrom].x, pointArr[path._previousPointFrom].y, pointArr[path._currentPointFrom].x, pointArr[path._currentPointFrom].y]);
				}
				
				// Check if we are in dynamic mode and if so, ensure our path is still valid
				if (path._dynamic) {
					dynamicResult = path._processDynamic(pointFrom, pointTo, pointArr[pointCount - 1]);
					if (dynamicResult === true) {
						// Re-assign the points to the new ones that the dynamic path
						// spliced into our points array
						pointFrom = pointArr[path._currentPointFrom];
						pointTo = pointArr[path._currentPointTo];
						
						path.emit('pathRecalculated', [this, pointArr[path._previousPointFrom].x, pointArr[path._previousPointFrom].y, pointArr[path._currentPointFrom].x, pointArr[path._currentPointFrom].y]);
					}
					
					if (dynamicResult === -1) {
						// Failed to find a new dynamic path
						path._finished = true;
					}
				}
				
				// Calculate position along vector between the two points
				newPoint = path._positionAlongVector(
					pointFrom,
					pointTo,
					path._speed,
					pointFrom._deltaTimeToNext - (pointFrom._absoluteTimeToNext - progressTime)
				);
				
				newPoint = path.multiplyPoint(newPoint);
				newPoint = path.transformPoint(newPoint);
				
				// Translate the entity to the new path point
				this.translateToPoint(newPoint);
				
				path._previousPointFrom = path._currentPointFrom;
				path._previousPointTo = path._currentPointTo;
			} else {
				pointTo = pointArr[pointCount - 1];
				
				newPoint = path.multiplyPoint(pointTo);
				newPoint = path.transformPoint(newPoint);
				
				path._previousPointFrom = pointCount - 1;
				path._previousPointTo = pointCount - 1;
				path._currentPointFrom = pointCount - 1;
				path._currentPointTo = pointCount - 1;
				
				this.translateToPoint(newPoint);
				
				path._finished = true;
				path.emit('pathComplete', [this, pointArr[path._previousPointFrom].x, pointArr[path._previousPointFrom].y]);
			}
		} else if(path._active && path._totalDistance == 0 && !path._finished) {
			path._finished = true;
		}
	},
	
	_processDynamic: function (pointFrom, pointTo, destinationPoint) {
		var self = this,
			tileMapData,
			tileCheckData,
			newPathPoints;
		
		// We are in dynamic mode, check steps ahead to see if they
		// have been blocked or not
		tileMapData = self._tileMap.map._mapData;
		tileCheckData = tileMapData[pointTo.y] && tileMapData[pointTo.y][pointTo.x] ? tileMapData[pointTo.y][pointTo.x] : null;
		
		if (!self._tileChecker(tileCheckData, pointTo.x, pointTo.y, null, null, null, true)) {
			// The new destination tile is blocked, recalculate path
			newPathPoints = self._finder.generate(
				self._tileMap,
				new IgePoint3d(pointFrom.x, pointFrom.y, pointFrom.z),
				new IgePoint3d(destinationPoint.x, destinationPoint.y, destinationPoint.z),
				self._tileChecker,
				self._allowSquare,
				self._allowDiagonal,
				false
			);
			
			if (newPathPoints.length) {
				self.replacePoints(self._currentPointFrom, self._points.length - self._currentPointFrom, newPathPoints);
				return true;
			} else {
				// Cannot generate valid path, delete this path
				self.emit('dynamicFail', [this, new IgePoint3d(pointFrom.x, pointFrom.y, pointFrom.z), new IgePoint3d(destinationPoint.x, destinationPoint.y, destinationPoint.z)]);
				self.clear();
				
				return -1;
			}
		}
		
		return false;
	},
	
	_calculatePathData: function () {
		var totalDistance = 0,
			startPoint,
			pointFrom,
			pointTo,
			i;


		if(this._currentPointFrom === 0) {
			// always set the first point to be the current position
			startPoint = this._entity._translate.clone();
			startPoint = this.unTransformPoint(startPoint);
			startPoint = this.dividePoint(startPoint);
			this._points[0] = startPoint;
		}

		// Calculate total distance to travel
		for (i = 1; i < this._points.length; i++) {
			pointFrom = this._points[i - 1];
			pointTo = this._points[i];
			pointFrom._distanceToNext = Math.distance(pointFrom.x, pointFrom.y, pointTo.x, pointTo.y);
			
			totalDistance += Math.abs(pointFrom._distanceToNext);
			
			pointFrom._deltaTimeToNext = pointFrom._distanceToNext / this._speed;
			pointFrom._absoluteTimeToNext = totalDistance / this._speed;
		}
		
		this._totalDistance = totalDistance;
		this._totalTime = totalDistance / this._speed;
		
		return this;
	},

	/**
	 * Replaces a number of points in the current queue with the new points passed.
	 * @param {Number} fromIndex The from index.
	 * @param {Number} replaceLength The number of points to replace.
	 * @param {Array} newPoints The array of new points to insert.
	 */
	replacePoints: function (fromIndex, replaceLength, newPoints) {
		var args = [fromIndex, replaceLength].concat(newPoints);
		this._points.splice.apply(this._points, args);
		this._calculatePathData();
	},
	
	_tickBehaviour: function (ctx) {
		if (ige.isClient) {
			var self = this.path,
				entity = this,
				currentPath = self._points,
				oldTracePathPoint,
				tracePathPoint,
				pathPointIndex,
				tempPathText;
			
			if (currentPath.length) {
				if (currentPath && self._drawPath) {
					// Draw the current path
					ctx.save();
	
					oldTracePathPoint = undefined;
	
					for (pathPointIndex = 0; pathPointIndex < currentPath.length; pathPointIndex++) {
						ctx.strokeStyle = '#0096ff';
						ctx.fillStyle = '#0096ff';
						
						tracePathPoint = new IgePoint3d(
							currentPath[pathPointIndex].x,
							currentPath[pathPointIndex].y,
							currentPath[pathPointIndex].z
						);
						
						tracePathPoint = self.multiplyPoint(tracePathPoint);
						tracePathPoint = self.transformPoint(tracePathPoint);
						
						if (entity._parent._mountMode === 1) {
							tracePathPoint = tracePathPoint.toIso();
						}
	
						if (!oldTracePathPoint) {
							// The starting point of the path
							ctx.beginPath();
							ctx.arc(tracePathPoint.x, tracePathPoint.y, 5, 0, Math.PI*2, true);
							ctx.closePath();
							ctx.fill();
						} else {
							// Not the starting point
							if (self._drawPathGlow) {
								ctx.globalAlpha = 0.1;
								for (var k = 3; k >= 0 ; k--) {
									ctx.lineWidth = (k + 1) * 4 - 3.5;
									ctx.beginPath();
									ctx.moveTo(oldTracePathPoint.x, oldTracePathPoint.y);
									ctx.lineTo(tracePathPoint.x, tracePathPoint.y);
									
									if (pathPointIndex < self._currentPointTo) {
										ctx.strokeStyle = '#666666';
										ctx.fillStyle = '#333333';
									}
									if (k === 0) {
										ctx.globalAlpha = 1;
									}
	
									ctx.stroke();
								}
							} else {
								ctx.beginPath();
								ctx.moveTo(oldTracePathPoint.x, oldTracePathPoint.y);
								ctx.lineTo(tracePathPoint.x, tracePathPoint.y);
								
								if (pathPointIndex < self._currentPointTo) {
									ctx.strokeStyle = '#666666';
									ctx.fillStyle = '#333333';
								}
	
								ctx.stroke();
							}
	
							if (pathPointIndex === self._currentPointTo) {
								ctx.save();
								ctx.fillStyle = '#24b9ea';
								ctx.fillRect(tracePathPoint.x - 5, tracePathPoint.y - 5, 10, 10);
								
								if (self._drawPathText) {
									ctx.fillStyle = '#eade24';
				
									if (self._drawPathGlow) {
										// Apply shadow to the text
										ctx.shadowOffsetX = 1;
										ctx.shadowOffsetY = 2;
										ctx.shadowBlur    = 4;
										ctx.shadowColor   = 'rgba(0, 0, 0, 1)';
									}
				
									tempPathText = 'Entity: ' + entity.id();
									ctx.fillText(tempPathText, tracePathPoint.x - Math.floor(ctx.measureText(tempPathText).width / 2), tracePathPoint.y + 16);
				
									tempPathText = 'Point (' + currentPath[pathPointIndex].x + ', ' + currentPath[pathPointIndex].y + ')';
									ctx.fillText(tempPathText, tracePathPoint.x - Math.floor(ctx.measureText(tempPathText).width / 2), tracePathPoint.y + 28);
									
									tempPathText = 'Abs (' + Math.floor(entity._translate.x) + ', ' + Math.floor(entity._translate.y) + ')';
									ctx.fillText(tempPathText, tracePathPoint.x - Math.floor(ctx.measureText(tempPathText).width / 2), tracePathPoint.y + 40);
								}
								
								ctx.restore();
							} else {
								ctx.fillRect(tracePathPoint.x - 2.5, tracePathPoint.y - 2.5, 5, 5);
							}
						}
	
						oldTracePathPoint = tracePathPoint;
					}
					
					ctx.restore();
				}
			}
		}
	},

	getPreviousPoint: function (val) {
		return this._points[this._currentPointFrom - val];
	},
	
	getNextPoint: function (val) {
		return this._points[this._currentPointTo + val];
	},

	/**
	 * Calculates the position of the entity along a vector based on the speed
	 * of the entity and the delta time.
	 * @param {IgePoint3d} p1 Vector start point
	 * @param {IgePoint3d} p2 Vector end point
	 * @param {Number} speed Speed along the vector
	 * @param {Number} deltaTime The time between the last update and now.
	 * @return {IgePoint3d}
	 * @private
	 */
	_positionAlongVector: function (p1, p2, speed, deltaTime) {
		var newPoint,
			p1X = p1.x,
			p1Y = p1.y,
			p2X = p2.x,
			p2Y = p2.y,
			deltaX = (p2X - p1X),
			deltaY = (p2Y - p1Y),
			magnitude = Math.sqrt(deltaX * deltaX + deltaY * deltaY),
			normalisedX = deltaX / magnitude,
			normalisedY = deltaY / magnitude;
		
		if (deltaX !== 0 || deltaY !== 0) {
			newPoint = new IgePoint3d(
				p1X + (normalisedX * (speed * deltaTime)),
				p1Y + (normalisedY * (speed * deltaTime)),
				0
			);
		} else {
			newPoint = new IgePoint3d(0, 0, 0);
		}

		return newPoint;
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = IgePathComponent; }
var IgeInputComponent = IgeEventingClass.extend({
	classId: 'IgeInputComponent',
	componentId: 'input',

	init: function () {
		// Setup the input objects to hold the current input state
		this._eventQueue = [];
		this._eventControl = {
			_cancelled: false,
			stopPropagation: function () {
				this._cancelled = true;
			}
		};

		this.tick();

		this.mouse = {
			// Virtual codes
			dblClick: -302,
			down: -301,
			up: -300,
			move: -259,
			wheel: -258,
			wheelUp: -257,
			wheelDown: -256,
			x: -255,
			y: -254,
			button1: -253,
			button2: -252,
			button3: -251
		};

		this.pad1 = {
			// Virtual codes
			button1: -250,
			button2: -249,
			button3: -248,
			button4: -247,
			button5: -246,
			button6: -245,
			button7: -244,
			button8: -243,
			button9: -242,
			button10: -241,
			button11: -240,
			button12: -239,
			button13: -238,
			button14: -237,
			button15: -236,
			button16: -235,
			button17: -234,
			button18: -233,
			button19: -232,
			button20: -231,
			stick1: -230,
			stick2: -229,
			stick1Up: -228,
			stick1Down: -227,
			stick1Left: -226,
			stick1Right: -225,
			stick2Up: -224,
			stick2Down: -223,
			stick2Left: -222,
			stick2Right: -221
		};

		this.pad2 = {
			// Virtual codes
			button1: -220,
			button2: -219,
			button3: -218,
			button4: -217,
			button5: -216,
			button6: -215,
			button7: -214,
			button8: -213,
			button9: -212,
			button10: -211,
			button11: -210,
			button12: -209,
			button13: -208,
			button14: -207,
			button15: -206,
			button16: -205,
			button17: -204,
			button18: -203,
			button19: -202,
			button20: -201,
			stick1: -200,
			stick2: -199,
			stick1Up: -198,
			stick1Down: -197,
			stick1Left: -196,
			stick1Right: -195,
			stick2Up: -194,
			stick2Down: -193,
			stick2Left: -192,
			stick2Right: -191
		};

		// Keycodes from http://www.asciitable.com/
		// and general console.log efforts :)
		this.key = {
			// Virtual codes
			'shift': -3,
			'ctrl': -2,
			'alt': -1,
			// Read codes
			'backspace': 8,
			'tab': 9,
			'enter': 13,
			'escape': 27,
			'space': 32,
			'pageUp': 33,
			'pageDown': 34,
			'end': 35,
			'home': 36,
			'left': 37,
			'up': 38,
			'right': 39,
			'down': 40,
			'insert': 45,
			'del': 46,
			'0': 48,
			'1': 49,
			'2': 50,
			'3': 51,
			'4': 52,
			'5': 53,
			'6': 54,
			'7': 55,
			'8': 56,
			'9': 57,
			'a': 65,
			'b': 66,
			'c': 67,
			'd': 68,
			'e': 69,
			'f': 70,
			'g': 71,
			'h': 72,
			'i': 73,
			'j': 74,
			'k': 75,
			'l': 76,
			'm': 77,
			'n': 78,
			'o': 79,
			'p': 80,
			'q': 81,
			'r': 82,
			's': 83,
			't': 84,
			'u': 85,
			'v': 86,
			'w': 87,
			'x': 88,
			'y': 89,
			'z': 90
		};

		this._controlMap = [];
		this._state = [];

		// Set default values for the mouse position
		this._state[this.mouse.x] = 0;
		this._state[this.mouse.y] = 0;
	},

	debug: function (val) {
		if (val !== undefined) {
			this._debug = val;
			return this;
		}

		return this._debug;
	},

	/**
	 * Sets up the event listeners on the main window and front
	 * buffer DOM objects.
	 * @private
	 */
	setupListeners: function (canvas) {
		this.log('Setting up input event listeners...');

		this._canvas = canvas;

		// Setup the event listeners
		var self = this;

		// Define event functions and keep references for later removal
		this._evRef = {
			'mousedown': function (event) { event.igeType = 'mouse'; self._rationalise(event); self._mouseDown(event); },
			'mouseup': function (event) { event.igeType = 'mouse'; self._rationalise(event); self._mouseUp(event); },
			'mousemove': function (event) { event.igeType = 'mouse'; self._rationalise(event); self._mouseMove(event); },
			'mousewheel': function (event) { event.igeType = 'mouse'; self._rationalise(event); self._mouseWheel(event); },

			'touchmove': function (event) { event.igeType = 'touch'; self._rationalise(event, true); self._mouseMove(event); },
			'touchstart': function (event) { event.igeType = 'touch'; self._rationalise(event, true); self._mouseDown(event); },
			'touchend': function (event) { event.igeType = 'touch'; self._rationalise(event, true); self._mouseUp(event); },

			'contextmenu': function (event) { event.preventDefault(); event.igeType = 'mouse'; self._rationalise(event); self._contextMenu(event); },

			'keydown': function (event) { event.igeType = 'key'; self._rationalise(event); self._keyDown(event); },
			'keyup': function (event) { event.igeType = 'key'; self._rationalise(event); self._keyUp(event); }
		};

		// Listen for mouse events
		canvas.addEventListener('mousedown', this._evRef.mousedown, false);
		canvas.addEventListener('mouseup', this._evRef.mouseup, false);
		canvas.addEventListener('mousemove', this._evRef.mousemove, false);
		canvas.addEventListener('mousewheel', this._evRef.mousewheel, false);

		// Touch events
		canvas.addEventListener('touchmove', this._evRef.touchmove, false);
		canvas.addEventListener('touchstart', this._evRef.touchstart, false);
		canvas.addEventListener('touchend', this._evRef.touchend, false);

		// Kill the context menu on right-click, urgh!
		canvas.addEventListener('contextmenu', this._evRef.contextmenu, false);

		// Listen for keyboard events
		window.addEventListener('keydown', this._evRef.keydown, false);
		window.addEventListener('keyup', this._evRef.keyup, false);
	},

	destroyListeners: function () {
		this.log('Removing input event listeners...');

		// Remove the event listeners
		var canvas = this._canvas;

		// Listen for mouse events
		canvas.removeEventListener('mousedown', this._evRef.mousedown, false);
		canvas.removeEventListener('mouseup', this._evRef.mouseup, false);
		canvas.removeEventListener('mousemove', this._evRef.mousemove, false);
		canvas.removeEventListener('mousewheel', this._evRef.mousewheel, false);

		// Touch events
		canvas.removeEventListener('touchmove', this._evRef.touchmove, false);
		canvas.removeEventListener('touchstart', this._evRef.touchstart, false);
		canvas.removeEventListener('touchend', this._evRef.touchend, false);

		// Kill the context menu on right-click, urgh!
		canvas.removeEventListener('contextmenu', this._evRef.contextmenu, false);

		// Listen for keyboard events
		window.removeEventListener('keydown', this._evRef.keydown, false);
		window.removeEventListener('keyup', this._evRef.keyup, false);
	},

	/**
	 * Fires an input event that didn't occur on the main canvas, as if it had
	 * occurred on the main canvas, allowing you to pass through events like
	 * mousedown and mouseup that occurred elsewhere on the DOM but might be
	 * useful for the engine to be aware of, such as if you are dragging an entity
	 * and then the mouse goes off-canvas and the button is released.
	 * @param {String} eventName The lowercase name of the event to fire e.g. mousedown.
	 * @param {Object} eventObj The event object that was passed by the DOM.
	 */
	fireManualEvent: function (eventName, eventObj) {
		if (eventName && eventObj) {
			if (this._evRef[eventName]) {
				this._evRef[eventName](eventObj);
			} else {
				this.log('Cannot fire manual event "' + eventName + '" because no listener exists in the engine for this event type!', 'warning');
			}
		} else {
			this.log('Cannot fire manual event because both eventName and eventObj params are required.', 'warning');
		}
	},

	/**
	 * Sets igeX and igeY properties in the event object that
	 * can be relied on to provide the x, y co-ordinates of the
	 * mouse event including the canvas offset.
	 * @param {Event} event The event object.
	 * @param {Boolean} touch If the event was a touch event or
	 * not.
	 * @private
	 */
	_rationalise: function (event, touch) {
		// Check if we want to prevent default behaviour
		if (event.igeType === 'key') {
			if (event.keyCode === 8) { // Backspace
				// Check if the event occurred on the body
				var elem = event.srcElement || event.target;

				if (elem.tagName.toLowerCase() === 'body') {
					// The event occurred on our body element so prevent
					// default behaviour. This allows other elements on
					// the page to retain focus such as text boxes etc
					// and allows them to behave normally.
					event.preventDefault();
				}
			}
		}

		if (event.igeType === 'touch') {
			event.preventDefault();
		}

		if (touch) {
			event.button = 0; // Emulate left mouse button

			// Handle touch changed
			if (event.changedTouches && event.changedTouches.length) {
				event.igePageX = event.changedTouches[0].pageX;
				event.igePageY = event.changedTouches[0].pageY;
			}
		} else {
			event.igePageX = event.pageX;
			event.igePageY = event.pageY;
		}

		event.igeX = (event.igePageX - ige._canvasPosition().left);
		event.igeY = (event.igePageY - ige._canvasPosition().top);

		this.emit('inputEvent', event);
	},


	/**
	 * Emits the "mouseDown" event.
	 * @param event
	 * @private
	 */
	_mouseDown: function (event) {
		if (this._debug) {
			console.log('Mouse Down', event);
		}
		// Update the mouse position within the viewports
		this._updateMouseData(event);

		var mx = event.igeX - ige._bounds2d.x2,
			my = event.igeY - ige._bounds2d.y2,
			self = this;

		if (event.button === 0) {
			this._state[this.mouse.button1] = true;
		}

		if (event.button === 1) {
			this._state[this.mouse.button2] = true;
		}

		if (event.button === 2) {
			this._state[this.mouse.button3] = true;
		}

		this.mouseDown = event;

		if (!self.emit('preMouseDown', [event, mx, my, event.button + 1])) {
			this.queueEvent(this, function () {
				self.emit('mouseDown', [event, mx, my, event.button + 1]);
			});
		}
	},

	/**
	 * Emits the "mouseUp" event.
	 * @param event
	 * @private
	 */
	_mouseUp: function (event) {
		if (this._debug) {
			console.log('Mouse Up', event);
		}
		// Update the mouse position within the viewports
		this._updateMouseData(event);

		var mx = event.igeX - ige._bounds2d.x2,
			my = event.igeY - ige._bounds2d.y2,
			self = this;

		if (event.button === 0) {
			this._state[this.mouse.button1] = false;
		}

		if (event.button === 1) {
			this._state[this.mouse.button2] = false;
		}

		if (event.button === 2) {
			this._state[this.mouse.button3] = false;
		}

		this.mouseUp = event;
		
		if (!self.emit('preMouseUp', [event, mx, my, event.button + 1])) {
			this.queueEvent(this, function () {
				self.emit('mouseUp', [event, mx, my, event.button + 1]);
			});
		}
	},
	
	_contextMenu: function (event) {
		if (this._debug) {
			console.log('Context Menu', event);
		}
		// Update the mouse position within the viewports
		this._updateMouseData(event);

		var mx = event.igeX - ige._bounds2d.x2,
			my = event.igeY - ige._bounds2d.y2,
			self = this;

		if (event.button === 0) {
			this._state[this.mouse.button1] = false;
		}

		if (event.button === 1) {
			this._state[this.mouse.button2] = false;
		}

		if (event.button === 2) {
			this._state[this.mouse.button3] = false;
		}

		this.contextMenu = event;
		
		if (!self.emit('preContextMenu', [event, mx, my, event.button + 1])) {
			this.queueEvent(this, function () {
				self.emit('contextMenu', [event, mx, my, event.button + 1]);
			});
		}
	},

	/**
	 * Emits the "mouseMove" event.
	 * @param event
	 * @private
	 */
	_mouseMove: function (event) {
		// Update the mouse position within the viewports
		ige._mouseOverVp = this._updateMouseData(event);

		var mx = event.igeX - ige._bounds2d.x2,
			my = event.igeY - ige._bounds2d.y2,
			self = this;

		this._state[this.mouse.x] = mx;
		this._state[this.mouse.y] = my;

		this.mouseMove = event;

		if (!self.emit('preMouseMove', [event, mx, my, event.button + 1])) {
			this.queueEvent(this, function () {
				self.emit('mouseMove', [event, mx, my, event.button + 1]);
			});
		}
	},

	/**
	 * Emits the "mouseWheel" event.
	 * @param event
	 * @private
	 */
	_mouseWheel: function (event) {
		// Update the mouse position within the viewports
		this._updateMouseData(event);

		var mx = event.igeX - ige._bounds2d.x2,
			my = event.igeY - ige._bounds2d.y2,
			self = this;

		this._state[this.mouse.wheel] = event.wheelDelta;

		if (event.wheelDelta > 0) {
			this._state[this.mouse.wheelUp] = true;
		} else {
			this._state[this.mouse.wheelDown] = true;
		}

		this.mouseWheel = event;

		if (!self.emit('preMouseWheel', [event, mx, my, event.button + 1])) {
			this.queueEvent(this, function () {
				self.emit('mouseWheel', [event, mx, my, event.button + 1]);
			});
		}
	},

	/**
	 * Emits the "keyDown" event.
	 * @param event
	 * @private
	 */
	_keyDown: function (event) {
		var self = this;

		this._state[event.keyCode] = true;
		
		if (this._debug) {
			console.log('Key Down', event);
		}
		
		if (!self.emit('preKeyDown', [event, event.keyCode])) {
			this.queueEvent(this, function () {
				self.emit('keyDown', [event, event.keyCode]);
			});
		}
	},

	/**
	 * Emits the "keyUp" event.
	 * @param event
	 * @private
	 */
	_keyUp: function (event) {
		var self = this;

		this._state[event.keyCode] = false;
		
		if (this._debug) {
			console.log('Key Up', event);
		}
		
		if (!self.emit('preKeyUp', [event, event.keyCode])) {
			this.queueEvent(this, function () {
				self.emit('keyUp', [event, event.keyCode]);
			});
		}
	},

	/**
	 * Loops the mounted viewports and updates their respective mouse
	 * co-ordinates so that mouse events can work out where on a viewport
	 * they occurred.
	 *
	 * @param event
	 * @return {*}
	 * @private
	 */
	_updateMouseData: function (event) {
		// Loop the viewports and check if the mouse is inside
		var arr = ige._children,
			arrCount = arr.length,
			vp, vpUpdated,
			mx = (event.igeX - ige._bounds2d.x2) - ige._translate.x,
			my = (event.igeY - ige._bounds2d.y2) - ige._translate.y;

		ige._mousePos.x = mx;
		ige._mousePos.y = my;

		while (arrCount--) {
			vp = arr[arr.length - (arrCount + 1)];
			// Check if the mouse is inside this viewport's bounds
			// TODO: Update this code to take into account viewport rotation and camera rotation
			if (mx > vp._translate.x - vp._bounds2d.x / 2 && mx < vp._translate.x + vp._bounds2d.x / 2) {
				if (my > vp._translate.y - vp._bounds2d.y / 2 && my < vp._translate.y + vp._bounds2d.y / 2) {
					// Mouse is inside this viewport
					vp._mousePos = new IgePoint3d(
						Math.floor((mx - vp._translate.x) / vp.camera._scale.x + vp.camera._translate.x),
						Math.floor((my - vp._translate.y) / vp.camera._scale.y + vp.camera._translate.y),
						0
					);

					vpUpdated = vp;

					// Record the viewport that this event occurred on in the
					// event object
					event.igeViewport = vp;
					break;
				}
			}
		}

		return vpUpdated;
	},

	/**
	 * Defines an action that will be emitted when the specified event type
	 * occurs.
	 * @param actionName
	 * @param eventCode
	 */
	mapAction: function (actionName, eventCode) {
		this._controlMap[actionName] = eventCode;
	},

	/**
	 * Returns the passed action's input state value.
	 * @param actionName
	 */
	actionVal: function (actionName) {
		return this._state[this._controlMap[actionName]];
	},

	/**
	 * Returns true if the passed action's input is pressed or it's state
	 * is not zero.
	 * @param actionName
	 */
	actionState: function (actionName) {
		var val = this._state[this._controlMap[actionName]];
		return !!val; // "Not not" to convert to boolean true/false
	},

	/**
	 * Returns an input's current value.
	 * @param actionName
	 * @return {*}
	 */
	val: function (inputId) {
		return this._state[inputId];
	},

	/**
	 * Returns an input's current state as a boolean.
	 * @param stateId
	 * @return {Boolean}
	 */
	state: function (inputId) {
		return !!this._state[inputId];
	},

	/**
	 * Stops further event propagation for this tick.
	 * @return {*}
	 */
	stopPropagation: function () {
		this._eventControl._cancelled = true;
		return this;
	},

	/**
	 * Adds an event method to the eventQueue array. The array is
	 * processed during each tick after the scenegraph has been
	 * rendered.
	 * @param context
	 * @param ev
	 */
	queueEvent: function (context, ev, data) {
		if (ev !== undefined) {
			this._eventQueue.push([context, ev, data]);
		}

		return this;
	},

	/**
	 * Called by the engine after ALL other tick methods have processed.
	 * Call originates in IgeEngine.js. Allows us to reset any flags etc.
	 */
	tick: function () {
		// If we have an event queue, process it
		var arr = this._eventQueue,
			arrCount = arr.length,
			evc = this._eventControl;

		while (arrCount--) {
			arr[arrCount][1].apply(arr[arrCount][0], [evc, arr[arrCount][2]]);
			if (evc._cancelled) {
				// The last event queue method stopped propagation so cancel all further
				// event processing (the last event took control of the input)
				break;
			}
		}

		// Reset all the flags and variables for the next tick
		this._eventQueue = [];
		this._eventControl._cancelled = false;
		this.dblClick = false; // TODO: Add double-click event handling
		this.mouseMove = false;
		this.mouseDown = false;
		this.mouseUp = false;
		this.mouseWheel = false;
	},

	/**
	 * Emit an event by name. Overrides the IgeEventingClass emit method and
	 * checks for propagation stopped by calling ige.input.stopPropagation().
	 * @param {Object} eventName The name of the event to emit.
	 * @param {Object || Array} args The arguments to send to any listening methods.
	 * If you are sending multiple arguments, use an array containing each argument.
	 * @return {Number}
	 */
	emit: function (eventName, args) {
		if (this._eventListeners) {
			// Check if the event has any listeners
			if (this._eventListeners[eventName]) {

				// Fire the listeners for this event
				var eventCount = this._eventListeners[eventName].length,
					eventCount2 = this._eventListeners[eventName].length - 1,
					evc = this._eventControl,
					finalArgs, i, cancelFlag, eventIndex, tempEvt, retVal;

				// If there are some events, ensure that the args is ready to be used
				if (eventCount) {
					finalArgs = [];
					if (typeof(args) === 'object' && args !== null && args[0] !== null) {
						for (i in args) {
							if (args.hasOwnProperty(i)) {
								finalArgs[i] = args[i];
							}
						}
					} else {
						finalArgs = [args];
					}

					// Loop and emit!
					cancelFlag = false;

					this._eventListeners._processing = true;
					while (eventCount--) {
						if (evc._cancelled) {
							// The stopPropagation() method was called, cancel all other event calls
							break;
						}
						eventIndex = eventCount2 - eventCount;
						tempEvt = this._eventListeners[eventName][eventIndex];

						// If the sendEventName flag is set, overwrite the arguments with the event name
						if (tempEvt.sendEventName) { finalArgs = [eventName]; }

						// Call the callback
						retVal = tempEvt.call.apply(tempEvt.context || this, finalArgs);

						// If the retVal === true then store the cancel flag and return to the emitting method
						if (retVal === true || evc._cancelled === true) {
							// The receiver method asked us to send a cancel request back to the emitter
							cancelFlag = true;
						}

						// Check if we should now cancel the event
						if (tempEvt.oneShot) {
							// The event has a oneShot flag so since we have fired the event,
							// lets cancel the listener now
							this.off(eventName, tempEvt);
						}
					}
					this._eventListeners._processing = false;

					// Now process any event removal
					this._processRemovals();

					if (cancelFlag) {
						return 1;
					}

				}

			}
		}
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = IgeInputComponent; }
var IgeGamePadComponent = IgeEventingClass.extend({
	classId: 'IgeGamePadComponent',
	componentId: 'gamePad',
	
	init: function (entity, options) {
		var self = this;
		
		this._entity = entity;
		this._options = options;
		this.gamepadAvailable = null;
			
		// A number of typical buttons recognized by Gamepad API and mapped to
		// standard controls. Any extraneous buttons will have larger indexes.
		this.TYPICAL_BUTTON_COUNT = 16;

		// A number of typical axes recognized by Gamepad API and mapped to
		// standard controls. Any extraneous buttons will have larger indexes.
		this.TYPICAL_AXIS_COUNT = 4;

		// Whether we’re requestAnimationFrameing like it’s 1999.
		this.ticking = false;

		// The canonical list of attached gamepads, without “holes” (always
		// starting at [0]) and unified between Firefox and Chrome.
		this.gamepads = [];

		// Remembers the connected gamepads at the last check; used in Chrome
		// to figure out when gamepads get connected or disconnected, since no
		// events are fired.
		this.prevRawGamepadTypes = [];

		// Previous timestamps for gamepad state; used in Chrome to not bother with
		// analyzing the polled data if nothing changed (timestamp is the same
		// as last time).
		this.prevTimestamps = [];
		
		if (ige.isClient) {
			// As of writing, it seems impossible to detect Gamepad API support
			// in Firefox, hence we need to hardcode it in the third clause. 
			// (The preceding two clauses are for Chrome.)
			this.gamepadAvailable = !!navigator.webkitGetGamepads ||
				!!navigator.webkitGamepads ||
				(navigator.userAgent.indexOf('Firefox/') != -1);
	
			if (!this.gamepadAvailable) {
				// It doesn't seem Gamepad API is available – show a message telling
				// the visitor about it.
				this.emit('notSupported');
			} else {
				// Firefox supports the connect/disconnect event, so we attach event
				// handlers to those.
				window.addEventListener('MozGamepadConnected', function () { self.onGamepadConnect.apply(self, arguments); }, false);
				window.addEventListener('MozGamepadDisconnected', function () { self.onGamepadDisconnect.apply(self, arguments); }, false);
	
				// Since Chrome only supports polling, we initiate polling loop straight
				// away. For Firefox, we will only do it if we get a connect event.
				if (!!navigator.webkitGamepads || !!navigator.webkitGetGamepads) {
					this.startPolling();
				}
			}
			
			entity.addBehaviour('gamePadComponent', this._behaviour);
		}
	},

	onGamepadConnect: function(event) {
		// Add the new gamepad on the list of gamepads to look after.
		this.gamepads.push(event.gamepad);

		// Start the polling loop to monitor button changes.
		this.startPolling();

		// Ask the tester to update the screen to show more gamepads.
		this.emit('change');
	},

	/**
	 * React to the gamepad being disconnected.
	 */
	onGamepadDisconnect: function(event) {
		// Remove the gamepad from the list of gamepads to monitor.
		for (var i in this.gamepads) {
			if (this.gamepads[i].index == event.gamepad.index) {
				this.gamepads.splice(i, 1);
				break;
			}
		}

		// If no gamepads are left, stop the polling loop.
		if (this.gamepads.length == 0) {
			this.stopPolling();
		}

		// Ask the tester to update the screen to remove the gamepad.
		this.emit('change');
	},

	/**
	 * Starts a polling loop to check for gamepad state.
	 */
	startPolling: function() {
		this.ticking = true;
	},

	/**
	 * Stops a polling loop by setting a flag which will prevent the next
	 * requestAnimationFrame() from being scheduled.
	 */
	stopPolling: function() {
		this.ticking = false;
	},

	/**
	 * A function called with each requestAnimationFrame(). Polls the gamepad
	 * status and schedules another poll.
	 */
	_behaviour: function() {
		this.gamePad.pollStatus();
	},

	/**
	 * Checks for the gamepad status. Monitors the necessary data and notices
	 * the differences from previous state (buttons for Chrome/Firefox,
	 * new connects/disconnects for Chrome). If differences are noticed, asks
	 * to update the display accordingly. Should run as close to 60 frames per
	 * second as possible.
	 */
	pollStatus: function() {
		// Poll to see if gamepads are connected or disconnected. Necessary
		// only on Chrome.
		this.pollGamepads();

		for (var i in this.gamepads) {
			var gamepad = this.gamepads[i];

			// Don’t do anything if the current timestamp is the same as previous
			// one, which means that the state of the gamepad hasn’t changed.
			// This is only supported by Chrome right now, so the first check
			// makes sure we’re not doing anything if the timestamps are empty
			// or undefined.
			if (gamepad.timestamp && (gamepad.timestamp == this.prevTimestamps[i])) {
				continue;
			}
			this.prevTimestamps[i] = gamepad.timestamp;
		}
	},

	// This function is called only on Chrome, which does not yet support
	// connection/disconnection events, but requires you to monitor
	// an array for changes.
	pollGamepads: function() {
		// Get the array of gamepads – the first method (getGamepads)
		// is the most modern one and is supported by Firefox 28+ and
		// Chrome 35+. The second one (webkitGetGamepads) is a deprecated method
		// used by older Chrome builds.
		var rawGamepads =
			(navigator.getGamepads && navigator.getGamepads()) ||
				(navigator.webkitGetGamepads && navigator.webkitGetGamepads());

		if (rawGamepads) {
			// We don’t want to use rawGamepads coming straight from the browser,
			// since it can have “holes” (e.g. if you plug two gamepads, and then
			// unplug the first one, the remaining one will be at index [1]).
			this.gamepads = [];

			// We only refresh the display when we detect some gamepads are new
			// or removed; we do it by comparing raw gamepad table entries to
			// “undefined.”
			var gamepadsChanged = false;

			for (var i = 0; i < rawGamepads.length; i++) {
				if (typeof rawGamepads[i] != this.prevRawGamepadTypes[i]) {
					gamepadsChanged = true;
					this.prevRawGamepadTypes[i] = typeof rawGamepads[i];
				}

				if (rawGamepads[i]) {
					this.gamepads.push(rawGamepads[i]);
				}
			}

			// Ask the tester to refresh the visual representations of gamepads
			// on the screen.
			if (gamepadsChanged) {
				this.emit('change');
			}
		}
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = IgeGamePadComponent; }
/**
 * When added to a viewport, automatically adds mouse panning
 * capabilities to the viewport's camera.
 */
var IgeMousePanComponent = IgeEventingClass.extend({
	classId: 'IgeMousePanComponent',
	componentId: 'mousePan',

	/**
	 * @constructor
	 * @param {IgeObject} entity The object that the component is added to.
	 * @param {Object=} options The options object that was passed to the component during
	 * the call to addComponent.
	 */
	init: function (entity, options) {
		this._entity = entity;
		this._options = options;

		// Set the pan component to inactive to start with
		this._enabled = false;
		this._startThreshold = 5; // The number of pixels the mouse should move to activate a pan
	},

	/**
	 * Gets / sets the number of pixels after a mouse down that the mouse
	 * must move in order to activate a pan operation. Defaults to 5.
	 * @param val
	 * @return {*}
	 */
	startThreshold: function (val) {
		if (val !== undefined) {
			this._startThreshold = val;
			return this._entity;
		}

		return this._startThreshold;
	},

	/**
	 * Gets / sets the rectangle that the pan operation will be limited
	 * to using an IgeRect instance.
	 * @param {IgeRect=} rect
	 * @return {*}
	 */
	limit: function (rect) {
		if (rect !== undefined) {
			this._limit = rect;
			return this._entity;
		}

		return this._limit;
	},

	/**
	 * Gets / sets the enabled flag. If set to true, pan
	 * operations will be processed. If false, no panning will
	 * occur.
	 * @param {Boolean=} val
	 * @return {*}
	 */
	enabled: function (val) {
		var self = this;

		if (val !== undefined) {
			this._enabled = val;

			// Reset pan values.
			// This prevents problems if mouse pan is disabled mid-pan.
			this._panPreStart = false;
			this._panStarted  = false;

			if (this._enabled) {
				// Listen for the mouse events we need to operate a mouse pan
				this._entity.mouseDown(function (event) { self._mouseDown(event); });
				this._entity.mouseMove(function (event) { self._mouseMove(event); });
				this._entity.mouseUp(function (event) { self._mouseUp(event); });
			} else {
				// Remove the pan start data
				delete this._panStartMouse;
				delete this._panStartCamera;
			}

			return this._entity;
		}

		return this._enabled;
	},

	/**
	 * Handles the mouseDown event. Records the starting position of the
	 * camera pan and the current camera translation.
	 * @param event
	 * @private
	 */
	_mouseDown: function (event) {
		if (!this._panStarted && this._enabled && event.igeViewport.id() === this._entity.id()) {
			// Record the mouse down position - pan pre-start
			var curMousePos = ige._mousePos;
			this._panStartMouse = curMousePos.clone();

			this._panStartCamera = {
				x: this._entity.camera._translate.x,
				y: this._entity.camera._translate.y
			};

			this._panPreStart = true;
			this._panStarted = false;
		}
	},

	/**
	 * Handles the mouse move event. Translates the camera as the mouse
	 * moves across the screen.
	 * @param event
	 * @private
	 */
	_mouseMove: function (event) {
		if (this._enabled) {
			// Pan the camera if the mouse is down
			if (this._panStartMouse) {
				var curMousePos = ige._mousePos,
					panCords = {
						x: this._panStartMouse.x - curMousePos.x,
						y: this._panStartMouse.y - curMousePos.y
					}, distX = Math.abs(panCords.x), distY = Math.abs(panCords.y),
					panFinalX = (panCords.x / this._entity.camera._scale.x) + this._panStartCamera.x,
					panFinalY = (panCords.y / this._entity.camera._scale.y) + this._panStartCamera.y;

				// Check if we have a limiter on the rectangle area
				// that we should allow panning inside.
				if (this._limit) {
					// Check the pan co-ordinates against
					// the limiter rectangle
					if (panFinalX < this._limit.x) {
						panFinalX = this._limit.x;
					}

					if (panFinalX > this._limit.x + this._limit.width) {
						panFinalX = this._limit.x + this._limit.width;
					}

					if (panFinalY < this._limit.y) {
						panFinalY = this._limit.y;
					}

					if (panFinalY > this._limit.y + this._limit.height) {
						panFinalY = this._limit.y + this._limit.height;
					}
				}

				if (this._panPreStart) {
					// Check if we've reached the start threshold
					if (distX > this._startThreshold || distY > this._startThreshold) {
						this._entity.camera.translateTo(
							panFinalX,
							panFinalY,
							0
						);
						this.emit('panStart');
						this._panPreStart = false;
						this._panStarted = true;

						this.emit('panMove');
					}
				} else {
					// Pan has already started
					this._entity.camera.translateTo(
						panFinalX,
						panFinalY,
						0
					);

					this.emit('panMove');
				}
			}
		}
	},

	/**
	 * Handles the mouse up event. Finishes the camera translate and
	 * removes the starting pan data.
	 * @param event
	 * @private
	 */
	_mouseUp: function (event) {
		if (this._enabled) {
			// End the pan
			if (this._panStarted) {
				if (this._panStartMouse) {
					var curMousePos = ige._mousePos,
						panCords = {
							x: this._panStartMouse.x - curMousePos.x,
							y: this._panStartMouse.y - curMousePos.y
						},
						panFinalX = (panCords.x / this._entity.camera._scale.x) + this._panStartCamera.x,
						panFinalY = (panCords.y / this._entity.camera._scale.y) + this._panStartCamera.y;

					// Check if we have a limiter on the rectangle area
					// that we should allow panning inside.
					if (this._limit) {
						// Check the pan co-ordinates against
						// the limiter rectangle
						if (panFinalX < this._limit.x) {
							panFinalX = this._limit.x;
						}

						if (panFinalX > this._limit.x + this._limit.width) {
							panFinalX = this._limit.x + this._limit.width;
						}

						if (panFinalY < this._limit.y) {
							panFinalY = this._limit.y;
						}

						if (panFinalY > this._limit.y + this._limit.height) {
							panFinalY = this._limit.y + this._limit.height;
						}
					}

					this._entity.camera.translateTo(
						panFinalX,
						panFinalY,
						0
					);

					// Remove the pan start data to end the pan operation
					delete this._panStartMouse;
					delete this._panStartCamera;

					this.emit('panEnd');
					this._panStarted = false;
				}
			} else {
				delete this._panStartMouse;
				delete this._panStartCamera;
				this._panStarted = false;
			}
		}
	}
});

/**
 * When added to a viewport, automatically adds mouse zooming
 * capabilities to the viewport's camera.
 */
var IgeMouseZoomComponent = IgeEventingClass.extend({
	classId: 'IgeMouseZoomComponent',
	componentId: 'mouseZoom',

	/**
	 * @constructor
	 * @param {IgeObject} entity The object that the component is added to.
	 * @param {Object=} options The options object that was passed to the component during
	 * the call to addComponent.
	 */
	init: function (entity, options) {
		this._entity = entity;
		this._options = options;

		// Set the zoom component to inactive to start with
		this._enabled = false;
	},

	/**
	 * Sets / gets the enabled flag. If set to true, zoom
	 * operations will be processed. If false, no zooming will
	 * occur.
	 * @param {Boolean=} val
	 * @return {*}
	 */
	enabled: function (val) {
		var self = this;

		if (val !== undefined) {
			this._enabled = val;

			if (this._enabled) {
				// Listen for the mouse events we need to operate a mouse pan
				this._entity.mouseDown(function (event) { self._mouseDown(event); });
				this._entity.mouseMove(function (event) { self._mouseMove(event); });
				this._entity.mouseUp(function (event) { self._mouseUp(event); });
			} else {
				// Remove the zoom start data
				delete this._zoomStartMouse;
				delete this._zoomStartCamera;
			}

			return this._entity;
		}

		return this._enabled;
	},

	/**
	 * Handles the mouseDown event. Records the starting position of the
	 * camera zoom and the current camera translation.
	 * @param event
	 * @private
	 */
	_mouseDown: function (event) {
		if (this._enabled && event.igeViewport.id() === this._entity.id()) {
			// Record the mouse down position - zoom starting
			var curMousePos = ige._mousePos;
			this._zoomStartMouse = {
				x: curMousePos.x,
				y: curMousePos.y
			};

			this._zoomStartCamera = {
				x: this._entity.camera._scale.x,
				y: this._entity.camera._scale.y
			};
		}
	},

	/**
	 * Handles the mouse move event. Scales the camera as the mouse
	 * moves across the screen.
	 * @param event
	 * @private
	 */
	_mouseMove: function (event) {
		if (this._enabled) {
			// Zoom the camera if the mouse is down
			if (this._zoomStartMouse) {
				var curMousePos = ige._mousePos,
					zoomCords = {
						x: -(this._zoomStartMouse.x - curMousePos.x) / 100,
						y: -(this._zoomStartMouse.y - curMousePos.y) / 100
					};

				this._entity.camera.scaleTo(
					zoomCords.x + this._zoomStartCamera.x > 0.02 ? zoomCords.x + this._zoomStartCamera.x : 0.02,
					zoomCords.x + this._zoomStartCamera.x > 0.02 ? zoomCords.x + this._zoomStartCamera.x : 0.02,
					0
				);
			}
		}
	},

	/**
	 * Handles the mouse up event. Finishes the camera scale and
	 * removes the starting zoom data.
	 * @param event
	 * @private
	 */
	_mouseUp: function (event) {
		if (this._enabled) {
			// End the zoom
			if (this._zoomStartMouse) {
				var curMousePos = ige._mousePos,
					zoomCords = {
						x: -(this._zoomStartMouse.x - curMousePos.x) / 100,
						y: -(this._zoomStartMouse.y - curMousePos.y) / 100
					};

				this._entity.camera.scaleTo(
					zoomCords.x + this._zoomStartCamera.x > 0.02 ? zoomCords.x + this._zoomStartCamera.x : 0.02,
					zoomCords.x + this._zoomStartCamera.x > 0.02 ? zoomCords.x + this._zoomStartCamera.x : 0.02,
					0
				);

				// Remove the zoom start data to end the zoom operation
				delete this._zoomStartMouse;
				delete this._zoomStartCamera;
			}
		}
	}
});
/**
 * Loads slightly modified Tiled-format json map data into the Isogenic Engine.
 */
var IgeTiledComponent = IgeClass.extend({
	classId: 'IgeTiledComponent',
	componentId: 'tiled',

	/**
	 * @constructor
	 * @param entity
	 * @param options
	 */
	init: function (entity, options) {
		this._entity = entity;
		this._options = options;
	},

	/**
	 * Loads a .js Tiled json-format file and converts to IGE format,
	 * then calls the callback with the newly created scene and the
	 * various layers as IgeTextureMap instances.
	 * @param url
	 * @param callback
	 */
	loadJson: function (url, callback) {
		var self = this,
			scriptElem;

		if (typeof(url) === 'string') {
			if (ige.isClient) {
				scriptElem = document.createElement('script');
				scriptElem.src = url;
				scriptElem.onload = function () {
					self.log('Tiled data loaded, processing...');
					self._processData(tiled, callback);
				};
				document.getElementsByTagName('head')[0].appendChild(scriptElem);
			} else {
				this.log('URL-based Tiled data is only available client-side. If you want to load Tiled map data on the server please include the map file in your ServerConfig.js file and then specify the map\'s data object instead of the URL.', 'error');
			}
		} else {
			self._processData(url, callback);
		}
	},

	_processData: function (data, callback) {
		var mapClass = ige.isServer === true ? IgeTileMap2d : IgeTextureMap,
			mapWidth = data.width,
			mapHeight = data.height,
			layerArray = data.layers,
			layerCount = layerArray.length,
			layer,
			layerType,
			layerData,
			layerDataCount,
			maps = [],
			layersById = {},
			tileSetArray = data.tilesets,
			tileSetCount = tileSetArray.length,
			tileSetItem,
			tileSetsTotal = tileSetCount,
			tileSetsLoaded = 0,
			textureCellLookup = [],
			currentTexture,
			currentCell,
			onLoadFunc,
			image,
			textures = [],
			allTexturesLoadedFunc,
			i, k, x, y, z,
			ent;

		// Define the function to call when all textures have finished loading
		allTexturesLoadedFunc = function () {
			// Create a map for each layer
			for (i = 0; i < layerCount; i++) {
				layer = layerArray[i];
				layerType = layer.type;

				// Check if the layer is a tile layer or an object layer
				if (layerType === 'tilelayer') {
					layerData = layer.data;

					maps[i] = new mapClass()
						.id(layer.name)
						.tileWidth(data.tilewidth)
						.tileHeight(data.tilewidth)
						.depth(i);

					maps[i].type = layerType;

					// Check if the layer should be isometric mounts enabled
					if (data.orientation === 'isometric') {
						maps[i].isometricMounts(true);
					}

					layersById[layer.name] = maps[i];
					tileSetCount = tileSetArray.length;

					if (ige.isClient) {
						for (k = 0; k < tileSetCount; k++) {
							maps[i].addTexture(textures[k]);
						}
					}

					// Loop through the layer data and paint the tiles
					layerDataCount = layerData.length;

					for (y = 0; y < mapHeight; y++) {
						for (x = 0; x < mapWidth; x++) {
							z = x + (y * mapWidth);

							if (layerData[z] > 0 && layerData[z] !== 2147483712) {
								if (ige.isClient) {
									// Paint the tile
									currentTexture = textureCellLookup[layerData[z]];
									if (currentTexture) {
										currentCell = layerData[z] - (currentTexture._tiledStartingId - 1);
										maps[i].paintTile(x, y, maps[i]._textureList.indexOf(currentTexture), currentCell);
									}
								} else {
									// Server-side we don't paint tiles on a texture map
									// we just mark the map data so that it can be used
									// to do things like path-finding and auto-creating
									// static physics objects.
									maps[i].occupyTile(x, y, 1, 1, layerData[z]);
								}
							}
						}
					}
				}

				if (layerType === 'objectgroup') {
					maps[i] = layer;
					layersById[layer.name] = maps[i];
				}
			}

			callback(maps, layersById);
		};

		if (ige.isClient) {
			onLoadFunc = function (textures, tileSetCount, tileSetItem) {
				return function () {
					var i, cc,
						cs = new IgeCellSheet(tileSetItem.image, this.width / tileSetItem.tilewidth, this.height / tileSetItem.tileheight)
							.id(tileSetItem.name)
							.on('loaded', function () {
								cc = this.cellCount();

								this._tiledStartingId = tileSetItem.firstgid;
								// Fill the lookup array
								for (i = 0; i < cc; i++) {
									textureCellLookup[this._tiledStartingId + i] = this;
								}

								textures.push(this);

								tileSetsLoaded++;

								if (tileSetsLoaded === tileSetsTotal) {
									// All textures loaded, fire processing function
									allTexturesLoadedFunc();
								}
							});
				};
			};

			// Load the tile sets as textures
			while (tileSetCount--) {
				// Load the image into memory first so we can read the total width and height
				image = new Image();

				tileSetItem = tileSetArray[tileSetCount];
				image.onload = onLoadFunc(textures, tileSetCount, tileSetItem);
				image.src = tileSetItem.image;
			}
		} else {
			// We're on the server so no textures are actually loaded
			allTexturesLoadedFunc();
		}
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = IgeTiledComponent; }
var IgeUiManagerComponent = IgeClass.extend({
	classId: 'IgeUiManagerComponent',
	componentId: 'ui',
	
	init: function (entity, options) {
		var self = this;
		
		this._entity = entity;
		this._options = options;
		
		this._focus = null; // The element that currently has focus
		this._caret = null; // The caret position within the focused element
		this._register = [];
		this._styles = {};
		this._elementsByStyle = {};
		
		ige.input.on('keyDown', function (event) { self._keyDown(event); });
	},

	/**
	 * Get / set a style by name.
	 * @param {String} name The unique name of the style. 
	 * @param {Object=} data The style properties and values to assign to the
	 * style.
	 * @returns {*}
	 */
	style: function (name, data) {
		if (name !== undefined) {
			if (data !== undefined) {
				// Set the data against the name, update any elements using the style
				this._styles[name] = data;
				return this;
			}
			
			// Get the data and return
			return this._styles[name];
		}
		
		return this;
	},

	/**
	 * Registers a UI element with the UI manager.
	 * @param elem
	 */
	registerElement: function (elem) {
		this._register.push(elem);
	},

	/**
	 * Un-registers a UI element with the UI manager.
	 * @param elem
	 */
	unRegisterElement: function (elem) {
		this._register.pull(elem);
		
		// Kill any styles defined for this element id
		delete this._styles['#' + elem._id];
		
		delete this._styles['#' + elem._id + ':active'];
		delete this._styles['#' + elem._id + ':focus'];
		delete this._styles['#' + elem._id + ':hover'];
	},

	/**
	 * Registers a UI element against a style for quick lookup.
	 * @param elem
	 */
	registerElementStyle: function (elem) {
		if (elem && elem._styleClass) {
			this._elementsByStyle[elem._styleClass] = this._elementsByStyle[elem._styleClass] || [];
			this._elementsByStyle[elem._styleClass].push(elem);
		}
	},

	/**
	 * Un-registers a UI element from a style.
	 * @param elem
	 */
	unRegisterElementStyle: function (elem) {
		if (elem && elem._styleClass) {
			this._elementsByStyle[elem._styleClass] = this._elementsByStyle[elem._styleClass] || [];
			this._elementsByStyle[elem._styleClass].push(elem);
		}
	},
	
	canFocus: function (elem) {
		return elem._allowFocus;
	},
	
	focus: function (elem) {
		if (elem !== undefined) {
			if (elem !== this._focus) {
				// The element is not our current focus so focus to it
				var previousFocus = this._focus;
				
				// Tell the current focused element that it is about to loose focus
				if (!previousFocus || !previousFocus.emit('blur', elem)) {
					if (previousFocus) {
						previousFocus._focused = false;
						previousFocus.blur();
					}
					
					// The blur was not cancelled
					if (!elem.emit('focus', previousFocus)) {
						// The focus was not cancelled
						this._focus = elem;
						elem._focused = true;
						
						return true;
					}
				}
			} else {
				// We are already focused
				return true;
			}
		}
		
		return false;
	},
	
	blur: function (elem) {
		//console.log('blur', elem._id, elem);
		if (elem !== undefined) {
			if (elem === this._focus) {
				// The element is currently focused
				// Tell the current focused element that it is about to loose focus
				if (!elem.emit('blur')) {
					// The blur was not cancelled
					this._focus = null;
					elem._focused = false;
					elem._updateStyle();
					
					return true;
				}
			}
		}
		
		return false;
	},
	
	_keyUp: function (event) {
		// Direct the key event to the focused element
		if (this._focus) {
			this._focus.emit('keyUp', event);
			ige.input.stopPropagation();
		}
	},
	
	_keyDown: function (event) {
		// Direct the key event to the focused element
		if (this._focus) {
			this._focus.emit('keyDown', event);
			ige.input.stopPropagation();
		}
	}
});
var IgeEntityManager = IgeEventingClass.extend({
	classId: 'IgeEntityManager',
	componentId: 'entityManager',
	
	init: function (entity, options) {
		this._entity = entity;
		this._options = options;
		
		// Create queue arrays that will store entities waiting to
		// be mounted or unmounted
		this._mountQueue = [];
		this._unMountQueue = [];
		this._maxMountsPerOp = 0;
		this._maxUnMountsPerOp = 0;
			
		// Create the _orphans array on the entity
		entity._orphans = [];
		
		// Set a method (behaviour) that will be called on every update
		entity.addBehaviour('entManager', this._updateBehaviour, false);
	},

	/**
	 * Called each update frame from the component parent and calls various private
	 * methods to ensure that entities that should be mounted are mounted and those
	 * that are to be unmounted are unmounted.
	 * @private
	 */
	_updateBehaviour: function (ctx) {
		// Draw visible area rect
		var rect = ige._currentViewport.viewArea();
		
		/*new IgeEntity()
			.id('visArea')
			.texture(this.gameTexture.simpleBox)
			.opacity(0.5)
			.mount(ige.$('objectScene'));*/
		
		/*ige.$('visArea')
			.translateTo(rect.x + (rect.width / 2), rect.y + (rect.height / 2), 0)
			.height(rect.height)
			.width(rect.width);*/
		
		// Get our instance back
		var self = this.entityManager;
		
		self._updateOrphans();
		self._updateChildren();
		
		self._processMountQueue();
		self._processUnMountQueue();
	},

	/**
	 * Checks all the mounted entities of our component parent are still supposed
	 * to be in the scenegraph and if not, adds them to the un-mount queue. Also
	 * marks any entities that are non-managed but also off-screen as inView = false.
	 * @private
	 */
	_updateOrphans: function () {
		var arr = this._entity._children,
			arrCount = arr.length,
			viewportArr = ige._children,
			vpCount = viewportArr.length,
			item,
			itemAabb,
			vpIndex,
			inVisibleArea;
		
		while (arrCount--) {
			item = arr[arrCount];

			if (item._managed) {
				if (item.aabb) {
					if (item._mode === 1 || (item._parent && item._parent._mountMode === 1)) {
						itemAabb = item.bounds3dPolygon().aabb();
					} else {
						itemAabb = item.aabb();
					}
					
					inVisibleArea = false;
					
					// Check the entity to see if its bounds are "inside" any
					// viewport's visible area
					for (vpIndex = 0; vpIndex < vpCount; vpIndex++) {
						if (viewportArr[vpIndex].viewArea().intersects(itemAabb)) {
							inVisibleArea = true;
							break;
						}
					}
					
					if (!inVisibleArea) {
						// Check for managed mode 1 (static entities that can be unmounted)
						// or managed mode 2 (dynamic and should just be marked as inView = false)
						if (item._managed === 1) {
							// The entity is not inside the viewport visible area
							// and is managed mode 1 (static) so unmount it
							this._unMountQueue.push(item);
						} else if (item._managed === 2) {
							// The entity is dynamic so mark is as inView = false
							item._inView = false;
						}
					} else if (item._managed === 2) {
						// The entity is dynamic so mark is as inView = true
						item._inView = true;
					}
				} else {
					this._unMountQueue.push(item);
				}
			}
		}
	},
	
	/**
	 * Checks all the un-mounted entities of our component parent to see if they are
	 * now inside the visible area of a viewport and if so, queues them for re-mounting.
	 * @private
	 */
	_updateChildren: function () {
		var arr = this._entity._orphans,
			arrCount = arr.length,
			viewportArr = ige._children,
			vpCount = viewportArr.length,
			item,
			itemAabb,
			vpIndex,
			inVisibleArea;
		
		while (arrCount--) {
			item = arr[arrCount];

			if (item._managed) {
				if (item.aabb) {
					if (item._mode === 1 || (item._parent && item._parent._mountMode === 1)) {
						itemAabb = item.bounds3dPolygon().aabb();
					} else {
						itemAabb = item.aabb();
					}
					
					inVisibleArea = false;
					
					// Check the entity to see if its bounds are "inside" any
					// viewport's visible area
					for (vpIndex = 0; vpIndex < vpCount; vpIndex++) {
						if (viewportArr[vpIndex].viewArea().intersects(itemAabb)) {
							inVisibleArea = true;
							break;
						}
					}
					
					if (inVisibleArea) {
						// Check for managed mode 1 (static entities that can be mounted)
						// or managed mode 2 (dynamic and should just be marked as inView = true)
						if (item._managed === 1) {
							// The entity is inside the viewport visible area
							// and is managed mode 1 (static) so mount it
							this._mountQueue.push(item);
						} else if (item._managed === 2) {
							// The entity is dynamic so mark is as inView = true
							item._inView = true;
						}
					}
				} else {
					this._mountQueue.push(item);
				}
			}
		}
	},

	/**
	 * Loops any entities queued for mounting and mounts them.
	 * @private
	 */
	_processMountQueue: function () {
		var arr = this._mountQueue,
			arrCount = arr.length,
			item;
		
		while (arrCount--) {
			item = arr[arrCount];
			
			this._entity._orphans.pull(item);
			item.mount(this._entity);
		}
		
		this._mountQueue = [];
	},

	/**
	 * Loops any entities queued for un-mounting and un-mounts them.
	 * @private
	 */
	_processUnMountQueue: function () {
		var arr = this._unMountQueue,
			arrCount = arr.length,
			item;
		
		while (arrCount--) {
			item = arr[arrCount];
			item.unMount();
			
			this._entity._orphans.push(item);
		}
		
		this._unMountQueue = [];
	}
});
var IgeEntityManagerComponent = IgeClass.extend({
	classId: 'IgeEntityManagerComponent',
	componentId: 'entityManager',

	/**
	 * @constructor
	 * @param {Object} entity The parent object that this component is being added to.
	 * @param {Object=} options An optional object that is passed to the component when it is being initialised.
	 */
	init: function (entity, options) {
		this._entity = entity;
		this._options = options;

		// Check we are being added to a tile map
		if (!this._entity.pointToTile) {
			this.log('Warning, IgeEntityManagerComponent is only meant to be added to a tile map!', 'warning');
		}

		this._maps = [];
		this._overwatchMode = 0;
		this._removeMode = 0;
		this._createArr = [];
		this._removeArr = [];

		entity.addBehaviour('entityManager', this._behaviour);
	},

	/**
	 * Adds a map that will be used to read data and convert
	 * to entities as the visible map area is moved.
	 * @param {IgeTileMap2d=} map
	 * @return {*}
	 */
	addMap: function (map) {
		if (map !== undefined) {
			this._maps.push(map);
		}

		return this._entity;
	},

	/**
	 * Gets / sets the boolean flag determining if the entity
	 * manager is enabled or not.
	 * @param {Boolean=} val
	 * @return {*}
	 */
	active: function (val) {
		if (val !== undefined) {
			this._active = val;
			return this._entity;
		}

		return this._active;
	},

	/**
	 * Gets / sets the number of entities the entity manager can
	 * create per tick. If the number of entities that need to be
	 * created is greater than this number they will be queued
	 * and processed on the next tick.
	 * @param val
	 * @return {*}
	 */
	maxCreatePerTick: function (val) {
		if (val !== undefined) {
			this._maxCreatePerTick = val;
			return this._entity;
		}

		return this._maxCreatePerTick;
	},

	/**
	 * Gets / sets the number of entities the entity manager can
	 * remove per tick. If the number of entities that need to be
	 * removed is greater than this number they will be queued
	 * and processed on the next tick.
	 * @param val
	 * @return {*}
	 */
	maxRemovePerTick: function (val) {
		if (val !== undefined) {
			this._maxRemovePerTick = val;
			return this._entity;
		}

		return this._maxRemovePerTick;
	},

	/**
	 * Gets / sets the overwatch mode for the entity manager. This
	 * is the mode that the manager will use when monitoring the
	 * entities under it's control to determine if any should be
	 * removed or not.
	 * @param {Number=} val Overwatch mode, defaults to 0.
	 * @return {*}
	 */
	overwatchMode: function (val) {
		if (val !== undefined) {
			this._overwatchMode = val;
			return this._entity;
		}

		return this._overwatchMode;
	},

	/**
	 * Adds a callback method that is called before an entity is
	 * created and asks the callback to return true if the entity
	 * should be allowed to be created, or false if not.
	 * @param {Function=} val The callback method.
	 * @return {*}
	 */
	createCheck: function (val) {
		if (val !== undefined) {
			this._createCheck = val;
			return this._entity;
		}

		return this._createCheck;
	},

	/**
	 * Adds a callback method that is called to allow you to execute
	 * the required code to create the desired entity from the map
	 * data you are being passed.
	 * @param {Function=} val The callback method.
	 * @return {*}
	 */
	createEntityFromMapData: function (val) {
		if (val !== undefined) {
			this._createEntityFromMapData = val;
			return this._entity;
		}

		return this._createEntityFromMapData;
	},

	/**
	 * Adds a callback method that is called before an entity is removed
	 * and if the callback returns true then the entity will be removed
	 * or if false, will not.
	 * @param {Function=} val The callback method.
	 * @return {*}
	 */
	removeCheck: function (val) {
		if (val !== undefined) {
			this._removeCheck = val;
			return this._entity;
		}

		return this._removeCheck;
	},

	/**
	 * Get / sets the entity that will be used to determine the
	 * center point of the area to manage. This allows the
	 * area to become dynamic based on this entity's position.
	 * @param entity
	 * @return {*}
	 */
	trackTranslate: function (entity) {
		if (entity !== undefined) {
			this._trackTranslateTarget = entity;
			return this;
		}

		return this._trackTranslateTarget;
	},

	/**
	 * Stops tracking the current tracking target's translation.
	 */
	unTrackTranslate: function () {
		delete this._trackTranslateTarget;
	},

	/**
	 * Gets / sets the center position of the management area.
	 * @param {Number=} x
	 * @param {Number=} y
	 * @return {*}
	 */
	areaCenter: function (x, y) {
		if (x !== undefined && y !== undefined) {
			// Adjust the passed x, y to account for this
			// texture map's translation
			var ent = this._entity,
				offset;

			if (ent._mode === 0) {
				// 2d mode
				offset = ent._translate;
			}

			if (ent._mode === 1) {
				// Iso mode
				offset = ent._translate.toIso();
			}

			x -= offset.x;
			y -= offset.y;

			this._areaCenter = new IgePoint3d(x, y, 0);
			return this._entity;
		}

		return this._areaCenter;
	},

	/**
	 * Gets / sets the area rectangle of the management area where
	 * entities outside this area are considered for removal and map
	 * data that falls inside this area is considered for entity
	 * creation.
	 * @param {Number=} x
	 * @param {Number=} y
	 * @param {Number=} width
	 * @param {Number=} height
	 * @return {*}
	 */
	areaRect: function (x, y, width, height) {
		if (x !== undefined && y !== undefined && width !== undefined && height !== undefined) {
			this._areaRect = new IgeRect(x, y, width, height);
			return this._entity;
		}

		return this._areaRect;
	},

	areaRectAutoSize: function (val, options) {
		if (val !== undefined) {
			this._areaRectAutoSize = val;
			this._areaRectAutoSizeOptions = options;
			return this._entity;
		}

		return this._areaRectAutoSize;
	},

	/**
	 * Returns the current management area.
	 * @return {IgeRect}
	 */
	currentArea: function () {
		// Check if we are tracking an entity that is used to
		// set the center point of the area
		if (this._trackTranslateTarget) {
			// Calculate which tile our character is currently "over"
			if (this._trackTranslateTarget.isometric() === true) {
				entTranslate = this._trackTranslateTarget._translate.toIso();
			} else {
				entTranslate = this._trackTranslateTarget._translate;
			}

			this.areaCenter(entTranslate.x, entTranslate.y);
		}

		var areaRect = this._areaRect,
			areaCenter = this._areaCenter;

		if (areaRect && areaCenter) {
			return new IgeRect(Math.floor(areaRect.x + areaCenter.x), Math.floor(areaRect.y + areaCenter.y), Math.floor(areaRect.width), Math.floor(areaRect.height));
		} else {
			return new IgeRect(0, 0, 0, 0);
		}
	},

	/**
	 * Gets / sets the mode that entities will be removed with.
	 * If set to 0 (default) the entities will be removed via a
	 * call to their destroy() method. If set to 1, entities will
	 * be unmounted via a call to unMount(). This means that their
	 * associated box2d bodies will not be removed from the
	 * simulation if in mode 1.
	 * @param val
	 * @return {*}
	 */
	removeMode: function (val) {
		if (val !== undefined) {
			this._removeMode = val;
			return this._entity;
		}

		return this._removeMode;
	},

	/**
	 * The behaviour method executed each tick.
	 * @param ctx
	 * @private
	 */
	_behaviour: function (ctx) {
		var self = this.entityManager,
			currentArea,
			currentAreaTiles,
			arr = this._children,
			arrCount = arr.length,
			item,
			maps = self._maps,
			map,
			mapIndex,
			mapData,
			currentTile,
			renderX, renderY,
			renderWidth, renderHeight,
			x, y,
			tileData,
			renderSize,
			ratio;

		if ((!self._areaRect || ige._resized) && self._areaRectAutoSize) {
			self._resizeEvent();
		}

		currentArea = self.currentArea();

		if (self._areaCenter && self._areaRect && !currentArea.compare(self._lastArea)) {
			////////////////////////////////////
			// ENTITY REMOVAL CHECKS          //
			////////////////////////////////////

			/*// Check if the area metrics have changed
			if (this._overwatchMode === 0 && (!currentArea.compare(self._lastArea))) {
				// Overwatch mode is zero so only scan for entities to remove
				// if the area metrics have changed.
			}

			if (self._overwatchMode === 1) {
				// Actively scan every tick for entities to remove
				while (arrCount--) {
					item = arr[arrCount];

					// Check if the item has an aabb method
					if (item.aabb) {
						// Check the entity to see if its bounds are "inside" the
						// manager's visible area
						if (!currentArea.intersects(item.aabb())) {
							// The item is outside the manager's area so
							// ask the removeCheck callback if we should
							// remove the entity
							if (!self._removeCheck || self._removeCheck(item)) {
								// Queue the entity for removal
								self._removeArr.push(item);
							}
						}
					}
				}
			}*/

			currentTile = this.pointToTile(self._areaCenter);
			renderX = currentTile.x;
			renderY = currentTile.y;
			renderWidth = Math.ceil(currentArea.width / this._tileWidth);
			renderHeight = Math.ceil(currentArea.height / this._tileHeight);

			currentArea.x -= (this._tileWidth);
			currentArea.y -= (this._tileHeight / 2);
			currentArea.width += (this._tileWidth * 2);
			currentArea.height += (this._tileHeight);

			// Check if we are rendering in 2d or isometric mode
			if (this._mountMode === 0) {
				// 2d
				currentAreaTiles = new IgeRect(
					renderX - Math.floor(renderWidth / 2) - 1,
					renderY - Math.floor(renderHeight / 2) - 1,
					renderX + Math.floor(renderWidth / 2) + 1 - (renderX - Math.floor(renderWidth / 2) - 1),
					renderY + Math.floor(renderHeight / 2) + 1 - (renderY - Math.floor(renderHeight / 2) - 1)
				);
			}

			if (this._mountMode === 1) {
				// Isometric
				renderSize = Math.abs(renderWidth) > Math.abs(renderHeight) ? renderWidth : renderHeight;
				ratio = 0.6;
				currentAreaTiles = new IgeRect(
					renderX - Math.floor(renderSize * ratio),
					renderY - Math.floor(renderSize * ratio),
					renderX + Math.floor(renderSize * ratio) + 1 - (renderX - Math.floor(renderSize * ratio)),
					renderY + Math.floor(renderSize * ratio) + 1 - (renderY - Math.floor(renderSize * ratio))
				);
			}

			// Generate the bounds rectangle
			if (this._drawBounds) {
				ctx.strokeStyle = '#ff0000';
				ctx.strokeRect(currentArea.x, currentArea.y, currentArea.width, currentArea.height);

				this._highlightTileRect = currentAreaTiles;
			}

			////////////////////////////////////
			// ENTITY REMOVAL CHECKS          //
			////////////////////////////////////
			//this._highlightTileRect = currentAreaTiles;

			map = this.map;
			while (arrCount--) {
				item = arr[arrCount];

				if (!self._removeCheck || self._removeCheck(item)) {
					if (!currentAreaTiles.intersects(item._occupiedRect)) {
						// The item is outside the manager's area so
						// ask the removeCheck callback if we should
						// remove the entity

						// Queue the entity for removal
						self._removeArr.push(item);
					}
				}
			}

			////////////////////////////////////
			// ENTITY CREATION CHECKS         //
			////////////////////////////////////
			for (mapIndex in maps) {
				if (maps.hasOwnProperty(mapIndex)) {
					map = maps[mapIndex];
					mapData = map.map._mapData;
					// TODO: This can be optimised further by only checking the area that has changed

					for (y = currentAreaTiles.y; y < currentAreaTiles.y + currentAreaTiles.height; y++) {
						if (mapData[y]) {
							for (x = currentAreaTiles.x; x < currentAreaTiles.x + currentAreaTiles.width; x++) {
								// Grab the tile data to paint
								tileData = mapData[y][x];

								if (tileData) {
									if (!self._createCheck || self._createCheck(map, x, y, tileData)) {
										// Queue the entity for creation
										self._createArr.push([map, x, y, tileData]);
									}
								}
							}
						}
					}
				}
			}

			self._lastArea = currentArea;

			// Process the entity queues
			self.processQueues();
		}
	},

	processQueues: function () {
		var createArr = this._createArr,
			createCount = createArr.length,
			createLimit = this._maxCreatePerTick !== undefined ? this._maxCreatePerTick : 0,
			createEntityFunc = this._createEntityFromMapData,
			removeArr = this._removeArr,
			removeCount = removeArr.length,
			removeLimit = this._maxRemovePerTick !== undefined ? this._maxRemovePerTick : 0,
			i;

		if (createLimit && createCount > createLimit) { createCount = createLimit; }
		if (removeLimit && removeCount > removeLimit) { removeCount = removeLimit; }

		// Process remove queue
		for (i = 0; i < removeCount; i++) {
			if (this._removeMode === 0) {
				// Pop the first item off the array and destroy it
				removeArr.shift().destroy();
			}
		}

		// Process creation
		for (i = 0; i < createCount; i++) {
			// Pop the first item off the array and pass it as arguments
			// to the entity creation method assigned to this manager
			createEntityFunc.apply(this, createArr.shift());
		}
	},

	/**
	 * Handles screen resize events.
	 * @param event
	 * @private
	 */
	_resizeEvent: function (event) {
		// Set width / height of scene to match parent
		if (this._areaRectAutoSize) {
			var geom = this._entity._parent._bounds2d,
				additionX = 0, additionY = 0;

			if (this._areaRectAutoSizeOptions) {
				if (this._areaRectAutoSizeOptions.bufferMultiple) {
					additionX = (geom.x * this._areaRectAutoSizeOptions.bufferMultiple.x) - geom.x;
					additionY = (geom.y * this._areaRectAutoSizeOptions.bufferMultiple.y) - geom.y;
				}

				if (this._areaRectAutoSizeOptions.bufferPixels) {
					additionX = this._areaRectAutoSizeOptions.bufferPixels.x;
					additionY = this._areaRectAutoSizeOptions.bufferPixels.y;
				}
			}

			this.areaRect(-Math.floor((geom.x + additionX) / 2), -Math.floor((geom.y + additionY) / 2), geom.x + additionX, geom.y + additionY);

			// Check if caching is enabled
			if (this._caching > 0) {
				this._resizeCacheCanvas();
			}
		}
	}
});
/**
 * When added to a viewport, automatically adds entity rotate
 * capabilities to the selected entity in the scenegraph viewer.
 */
var IgeEditorComponent = IgeEventingClass.extend({
	classId: 'IgeEditorComponent',
	componentId: 'editor',

	/**
	 * @constructor
	 * @param {IgeObject} entity The object that the component is added to.
	 * @param {Object=} options The options object that was passed to the component during
	 * the call to addComponent.
	 */
	init: function (entity, options) {
		var self = this;
		
		this._entity = entity;
		this._options = options;
		this._showStats = 0;
		
		this._templateCache = {};
		this._cacheTemplates = true;
		
		this.ui = {};
		
		this._interceptMouse = false;
		
		// Hook the input component's keyUp and check for the = symbol... if there, toggle editor
		this._activateKeyHandle = ige.input.on('keyUp', function (event) {
			if (event.keyIdentifier === "U+00BB") {
				// = key pressed, toggle the editor
				self.toggle();
				
				// Return true to stop this event from being emitted by the engine to the scenegraph
				return true;
			}
		});
		
		// Hook the input component's keyUp and check for the - symbol... if there, toggle stats
		this._activateKeyHandle = ige.input.on('keyUp', function (event) {
			if (event.keyIdentifier === "U+00BD") {
				// Toggle the stats
				self.toggleStats();
				
				// Return true to stop this event from being emitted by the engine to the scenegraph
				return true;
			}
		});
		
		// Hook the engine's input system and take over mouse interaction
		this._mouseUpHandle = ige.input.on('preMouseUp', function (event) {
			if (self._enabled && self._interceptMouse) {
				self.emit('mouseUp', event);
				
				// Return true to stop this event from being emitted by the engine to the scenegraph
				return true;
			}
		});
		
		this._mouseDownHandle = ige.input.on('preMouseDown', function (event) {
			if (self._enabled && self._interceptMouse) {
				self.emit('mouseDown', event);
				
				// Return true to stop this event from being emitted by the engine to the scenegraph
				return true;
			}
		});
		
		this._mouseMoveHandle = ige.input.on('preMouseMove', function (event) {
			if (self._enabled && self._interceptMouse) {
				self.emit('mouseMove', event);
				
				// Return true to stop this event from being emitted by the engine to the scenegraph
				return true;
			}
		});
		
		this._contextMenuHandle = ige.input.on('preContextMenu', function (event) {
			if (self._enabled && self._interceptMouse) {
				self.emit('contextMenu', event);
				
				// Return true to stop this event from being emitted by the engine to the scenegraph
				return true;
			}
		});
		
		// Load jsRender for HTML template support
		ige.requireScript(igeRoot + 'components/editor/vendor/jsRender.js');
		
		// Load jQuery, the editor will use it for DOM manipulation simplicity
		ige.requireScript(igeRoot + 'components/editor/vendor/jquery.2.0.3.min.js');
		
		ige.on('allRequireScriptsLoaded', function () {
			// Stop drag-drop of files over the page from doing a redirect and leaving the page
			$(function () {
				$('body')
					.on('dragover', function (e) {
						e.preventDefault();
					})
					.on('drop', function (e) {
						e.preventDefault();
					});
			});
			
			// Load editor html into the DOM
			self.loadHtml(igeRoot + 'components/editor/root.html', function (html) {
				// Add the html
				$('body').append($(html));
				
				ige.requireScript(igeRoot + 'components/editor/vendor/jsrender-helpers.js');
				
				// Object mutation observer polyfill
				ige.requireScript(igeRoot + 'components/editor/vendor/observe.js');
				
				// Load plugin styles
				ige.requireStylesheet(igeRoot + 'components/editor/vendor/glyphicons/css/halflings.css');
				ige.requireStylesheet(igeRoot + 'components/editor/vendor/glyphicons/css/glyphicons.css');
				ige.requireStylesheet(igeRoot + 'components/editor/vendor/treeview_simple/css/style.css');
				
				// Load the editor stylesheet
				ige.requireStylesheet(igeRoot + 'components/editor/css/editor.css');
				
				// Listen for scenegraph tree selection updates
				ige.on('sgTreeSelectionChanged', function (objectId) {
					self._objectSelected(ige.$(objectId));
				});
				
				// Wait for all required files to finish loading
				ige.on('allRequireScriptsLoaded', function () {
					// Load UI scripts
					ige.sync(ige.requireScript, igeRoot + 'components/editor/ui/dialogs/dialogs.js');
					ige.sync(ige.requireScript, igeRoot + 'components/editor/ui/scenegraph/scenegraph.js');
					ige.sync(ige.requireScript, igeRoot + 'components/editor/ui/menu/menu.js');
					ige.sync(ige.requireScript, igeRoot + 'components/editor/ui/toolbox/toolbox.js');
					ige.sync(ige.requireScript, igeRoot + 'components/editor/ui/panels/panels.js');
					ige.sync(ige.requireScript, igeRoot + 'components/editor/ui/textures/textures.js');
					ige.sync(ige.requireScript, igeRoot + 'components/editor/ui/textureEditor/textureEditor.js');
					ige.sync(ige.requireScript, igeRoot + 'components/editor/ui/animationEditor/animationEditor.js');
					
					// Load jquery plugins
					ige.sync(ige.requireScript, igeRoot + 'components/editor/vendor/autoback.jquery.js');
					ige.sync(ige.requireScript, igeRoot + 'components/editor/vendor/tree/tree.jquery.js');
					ige.sync(ige.requireScript, igeRoot + 'components/editor/vendor/tabs/tabs.jquery.js');
					ige.sync(ige.requireScript, igeRoot + 'components/editor/vendor/treeview_simple/treeview_simple.jquery.js');
					
					ige.on('syncComplete', function () {
						// Observe changes to the engine to update our display
						setInterval(function () {
							// Update the stats counters
							$('#editorFps').html(ige._fps + ' fps');
							$('#editorDps').html(ige._dps + ' dps');
							$('#editorDpf').html(ige._dpf + ' dpf');
							$('#editorUd').html(ige._updateTime + ' ud/ms');
							$('#editorRd').html(ige._renderTime + ' rd/ms');
							$('#editorTd').html(ige._tickTime + ' td/ms');
						}, 1000);
						
						// Add auto-backing
						$('.backed').autoback();
						
						// Call finished on all ui instances
						for (var i in self.ui) {
							if (self.ui.hasOwnProperty(i)) {
								if (self.ui[i].ready) {
									self.ui[i].ready();
								}
							}
						}
						
						// Enable tabs
						$('.tabGroup').tabs();
						
						// Enable the stats toggle button
						$('#statsToggle').on('click', function () {
							ige.editor.toggleStats();
						});
						
						// Enable the editor toggle button
						$('#editorToggle').on('click', function () {
							ige.editor.toggle();
						});
					}, null, true);
				}, null, true);
			});
		}, null, true);
		
		// Set the component to inactive to start with
		this._enabled = false;
		this._show = false;
		
		// Set object create defaults
		this.objectDefault = {
			'IgeTextureMap': {
				drawGrid: 100
			}
		};
		
		this.log('Init complete');
	},
	
	interceptMouse: function (val) {
		this._interceptMouse = val;
	},
	
	/**
	 * Gets / sets the enabled flag. If set to true, 
	 * operations will be processed. If false, no operations will
	 * occur.
	 * @param {Boolean=} val
	 * @return {*}
	 */
	enabled: function (val) {
		var self = this;

		if (val !== undefined) {
			this._enabled = val;
			return this._entity;
		}

		return this._enabled;
	},
	
	toggle: function () {
		var elem = $('#editorToggle');
		
		if (elem.hasClass('active')) {
			ige.editor.hide();
		} else {
			ige.editor.show();
		}
	},
	
	show: function () {
		this.enabled(true);
		this._show = true;
		
		$('#editorToggle')
			.html('Editor On')
			.removeClass('active')
			.addClass('active');
		
		$('.editorElem.toggleHide').addClass('shown');
	},
	
	hide: function () {
		this.enabled(false);
		this._show = false;
		
		$('#editorToggle')
			.html('Editor Off')
			.removeClass('active');
		
		$('.editorElem.toggleHide').removeClass('shown');
	},
	
	toggleStats: function () {
		var elem = $('#statsToggle');
							
		if (elem.hasClass('active')) {
			ige.editor.hideStats();
		} else {
			ige.editor.showStats();
		}
	},
	
	showStats: function () {
		$('#statsToggle')
			.html('Stats On')
			.removeClass('active')
			.addClass('active');
		
		$('.counter').show();
	},
	
	hideStats: function () {
		$('#statsToggle')
			.html('Stats Off')
			.removeClass('active');
		
		$('.counter').hide();
	},
	
	loadHtml: function (url, callback) {
		$.ajax({
			url: url,
			success: callback,
			dataType: 'html'
		});
	},
	
	template: function (url, callback) {
		var self = this;
		
		if (!this._cacheTemplates || !this._templateCache[url]) {
			this.log('Loading template data from: ' + url);
			$.ajax(url, {
				async: true,
				dataType: 'text',
				complete: function (xhr, status) {
					if (status === 'success') {
						// Convert the text into a jsRender template object
						var template = jsviews.templates(xhr.responseText);
						
						if (self._cacheTemplates) {
							self._templateCache[url] = template;
						}
						
						if (callback) { callback(false, template); }
					} else {
						if (callback) { callback(true, status); }
					}
				}
			});
		} else {
			if (callback) { callback(false, this._templateCache[url]); }
		}
	},
	
	renderTemplate: function (url, data, callback) {
		this.template(url, function (err, template) {
			if (!err) {
				callback(err, $($.parseHTML(template.render(data))));
			} else {
				callback(err);
			}
		});
	},
	
	selectObject: function (id) {
		if (id !== undefined) {
			if (id) {
				this._selectedObject = ige.$(id);
				this._objectSelected(this._selectedObject);
			} else {
				delete this._selectedObject;
			}
		}
	},
	
	_objectSelected: function (obj) {
		if (obj) {
			ige.editor.ui.panels.showPanelByInstance(obj);
			this._selectedObjectClassList = ige.getClassDerivedList(obj);
			
			// Update active-for selectors
			$('[data-active-for]')
				.removeClass('disabled')
				.addClass('disabled');
			
			var classArr = this._selectedObjectClassList,
				i;
			
			for (i = 0; i < classArr.length; i++) {
				$('[data-active-for~="' + classArr[i] + '"]')
					.removeClass('disabled');
			}
			
			this.emit('selectedObject', obj.id());
		}
	},
	
	destroySelected: function () {
		if (this._selectedObject) {
			this._selectedObject.destroy();
			this.selectObject(null);
		}
	},
	
	createObject: function (classId, select) {
		if (this._selectedObject) {
			var newObj = ige.newClassInstance(classId);
			newObj.mount(this._selectedObject);
			this.ui.scenegraph.updateSceneGraph();
			
			if (select) {
				this.selectObject(newObj.id());
				this.ui.toolbox.select('toolSelect');
			}
			
			// Set some object defaults if there are any
			if (this.objectDefault[classId]) {
				for (var i in this.objectDefault[classId]) {
					if (this.objectDefault[classId].hasOwnProperty(i)) {
						if (this.objectDefault[classId][i] instanceof Array) {
							newObj[i].apply(newObj, this.objectDefault[classId][i]);
						} else {
							newObj[i].call(newObj, this.objectDefault[classId][i]);
						}
					}
				}
			}
		}
	},
	
	/**
	 * Updates the stats HTML overlay with the latest data.
	 * @private
	 */
	_statsTick: function () {
		var self = ige.editor,
			i,
			watchCount,
			watchItem,
			itemName,
			res,
			html = '';

		// Check if the stats output is enabled
		if (self._showStats && !self._statsPauseUpdate) {
			switch (self._showStats) {
				case 1:
					/*if (self._watch && self._watch.length) {
						watchCount = self._watch.length;

						for (i = 0; i < watchCount; i++) {
							watchItem = self._watch[i];

							if (typeof(watchItem) === 'string') {
								itemName = watchItem;
								try {
									eval('res = ' + watchItem);
								} catch (err) {
									res = '<span style="color:#ff0000;">' + err + '</span>';
								}
							} else {
								itemName = watchItem.name;
								res = watchItem.value;
							}
							html += i + ' (<a href="javascript:ige.watchStop(' + i + '); ige._statsPauseUpdate = false;" style="color:#cccccc;" onmouseover="ige._statsPauseUpdate = true;" onmouseout="ige._statsPauseUpdate = false;">Remove</a>): <span style="color:#7aff80">' + itemName + '</span>: <span style="color:#00c6ff">' + res + '</span><br />';
						}
						html += '<br />';
					}*/
					/*html += '<div class="sgButton" title="Show / Hide SceneGraph Tree" onmouseup="ige.toggleShowEditor();">Scene</div> <span class="met" title="Frames Per Second">' + self._fps + ' fps</span> <span class="met" title="Draws Per Second">' + self._dps + ' dps</span> <span class="met" title="Draws Per Frame">' + self._dpf + ' dpt</span> <span class="met" title="Update Delta (How Long the Last Update Took)">' + self._updateTime + ' ms\/ud</span> <span class="met" title="Render Delta (How Long the Last Render Took)">' + self._renderTime + ' ms\/rd</span> <span class="met" title="Tick Delta (How Long the Last Tick Took)">' + self._tickTime + ' ms\/pt</span>';

					if (self.network) {
						// Add the network latency too
						html += ' <span class="met" title="Network Latency (Time From Server to This Client)">' + self.network._latency + ' ms\/net</span>';
					}

					self._statsDiv.innerHTML = html;*/
					
					
					break;
			}
		}
	},
	
	addToSgTree: function (item) {
		var elem = document.createElement('li'),
			arr,
			arrCount,
			i,
			mouseUp,
			dblClick,
			timingString;

		mouseUp = function (event) {
			event.stopPropagation();

			var elems = document.getElementsByClassName('sgItem selected');
			for (i = 0; i < elems.length; i++) {
				elems[i].className = 'sgItem';
			}

			this.className += ' selected';
			ige._sgTreeSelected = this.id;

			ige._currentViewport.drawBounds(true);
			if (this.id !== 'ige') {
				ige._currentViewport.drawBoundsLimitId(this.id);
			} else {
				ige._currentViewport.drawBoundsLimitId('');
			}
			
			ige.emit('sgTreeSelectionChanged', ige._sgTreeSelected);
		};

		dblClick = function (event) {
			event.stopPropagation();
		};

		//elem.addEventListener('mouseover', mouseOver, false);
		//elem.addEventListener('mouseout', mouseOut, false);
		elem.addEventListener('mouseup', mouseUp, false);
		elem.addEventListener('dblclick', dblClick, false);

		elem.id = item.id;
		elem.innerHTML = item.text;
		elem.className = 'sgItem';

		if (ige._sgTreeSelected === item.id) {
			elem.className += ' selected';
		}

		if (igeConfig.debug._timing) {
			if (ige._timeSpentInTick[item.id]) {
				timingString = '<span>' + ige._timeSpentInTick[item.id] + 'ms</span>';
				/*if (ige._timeSpentLastTick[item.id]) {
					if (typeof(ige._timeSpentLastTick[item.id].ms) === 'number') {
						timingString += ' | LastTick: ' + ige._timeSpentLastTick[item.id].ms;
					}
				}*/

				elem.innerHTML += ' ' + timingString;
			}
		}

		document.getElementById(item.parentId + '_items').appendChild(elem);

		if (item.items) {
			// Create a ul inside the li
			elem = document.createElement('ul');
			elem.id = item.id + '_items';
			document.getElementById(item.id).appendChild(elem);

			arr = item.items;
			arrCount = arr.length;

			for (i = 0; i < arrCount; i++) {
				ige.addToSgTree(arr[i]);
			}
		}
	},
	
	toggleShowEditor: function () {
		this._showSgTree = !this._showSgTree;

		if (this._showSgTree) {
			// Create the scenegraph tree
			var self = this,
				elem1 = document.createElement('div'),
				elem2,
				canvasBoundingRect;
			
			canvasBoundingRect = ige._canvasPosition();

			elem1.id = 'igeSgTree';
			elem1.style.top = (parseInt(canvasBoundingRect.top) + 5) + 'px';
			elem1.style.left = (parseInt(canvasBoundingRect.left) + 5) + 'px';
			elem1.style.height = (ige._bounds2d.y - 30) + 'px';
			elem1.style.overflow = 'auto';
			elem1.addEventListener('mousemove', function (event) {
				event.stopPropagation();
			});
			elem1.addEventListener('mouseup', function (event) {
				event.stopPropagation();
			});
			elem1.addEventListener('mousedown', function (event) {
				event.stopPropagation();
			});

			elem2 = document.createElement('ul');
			elem2.id = 'sceneGraph_items';
			elem1.appendChild(elem2);

			document.body.appendChild(elem1);
			
			// Create the IGE console
			var consoleHolderElem = document.createElement('div'),
				consoleElem = document.createElement('input'),
				classChainElem = document.createElement('div'),
				dociFrame = document.createElement('iframe');

			consoleHolderElem.id = 'igeSgConsoleHolder';
			consoleHolderElem.innerHTML = '<div><b>Console</b>: Double-Click a SceneGraph Object to Script it Here</div>';
			
			consoleElem.type = 'text';
			consoleElem.id = 'igeSgConsole';
			
			classChainElem.id = 'igeSgItemClassChain';

			dociFrame.id = 'igeSgDocPage';
			dociFrame.name = 'igeSgDocPage';

			consoleHolderElem.appendChild(consoleElem);
			consoleHolderElem.appendChild(classChainElem);
			consoleHolderElem.appendChild(dociFrame);
			
			document.body.appendChild(consoleHolderElem);

			this.sgTreeUpdate();
			
			// Now add a refresh button to the scene button
			var button = document.createElement('input');
			button.type = 'button';
			button.id = 'igeSgRefreshTree'
			button.style.position = 'absolute';
			button.style.top = '0px';
			button.style.right = '0px'
			button.value = 'Refresh';
			
			button.addEventListener('click', function () {
				self.sgTreeUpdate();
			}, false);
			
			document.getElementById('igeSgTree').appendChild(button);
			
			// Add basic editor controls
			var editorRoot = document.createElement('div'),
				editorModeTranslate = document.createElement('input'),
				editorModeRotate = document.createElement('input'),
				editorModeScale = document.createElement('input'),
				editorStatus = document.createElement('span');
			
			editorRoot.id = 'igeSgEditorRoot';
			editorStatus.id = 'igeSgEditorStatus';
			
			editorModeTranslate.type = 'button';
			editorModeTranslate.id = 'igeSgEditorTranslate';
			editorModeTranslate.value = 'Translate';
			editorModeTranslate.addEventListener('click', function () {
				// Disable other modes
				ige.editorRotate.enabled(false);
				
				if (ige.editorTranslate.enabled()) {
					ige.editorTranslate.enabled(false);
					self.log('Editor: Translate mode disabled');
				} else {
					ige.editorTranslate.enabled(true);
					self.log('Editor: Translate mode enabled');
				}
			});
			
			editorModeRotate.type = 'button';
			editorModeRotate.id = 'igeSgEditorRotate';
			editorModeRotate.value = 'Rotate';
			editorModeRotate.addEventListener('click', function () {
				// Disable other modes
				ige.editorTranslate.enabled(false);
				
				if (ige.editorRotate.enabled()) {
					ige.editorRotate.enabled(false);
					self.log('Editor: Rotate mode disabled');
				} else {
					ige.editorRotate.enabled(true);
					self.log('Editor: Rotate mode enabled');
				}
			});
			
			editorModeScale.type = 'button';
			editorModeScale.id = 'igeSgEditorScale';
			editorModeScale.value = 'Scale';
			
			editorRoot.appendChild(editorModeTranslate);
			editorRoot.appendChild(editorModeRotate);
			editorRoot.appendChild(editorModeScale);
			editorRoot.appendChild(editorStatus);
			
			document.body.appendChild(editorRoot);
			
			// Add the translate component to the ige instance
			ige.addComponent(IgeEditorTranslateComponent);
			ige.addComponent(IgeEditorRotateComponent);
			
			// Schedule tree updates every second
			ige._sgTreeUpdateInterval = setInterval(function () { self.sgTreeUpdate(); }, 1000);
		} else {
			// Kill interval
			clearInterval(ige._sgTreeUpdateInterval);
			
			var child = document.getElementById('igeSgTree');
			child.parentNode.removeChild(child);

			child = document.getElementById('igeSgConsoleHolder');
			child.parentNode.removeChild(child);
			
			child = document.getElementById('igeSgEditorRoot');
			child.parentNode.removeChild(child);
			
			ige.removeComponent('editorTranslate');
			ige.removeComponent('editorRotate');
		}
	},
	
	sgTreeUpdate: function () {
		// Update the scenegraph tree
		document.getElementById('sceneGraph_items').innerHTML = '';

		// Get the scenegraph data
		this.addToSgTree(this.getSceneGraphData(this, true));
	},
});

/*
* Copyright (c) 2006-2007 Erin Catto http://www.gphysics.com
*
* This software is provided 'as-is', without any express or implied
* warranty.  In no event will the authors be held liable for any damages
* arising from the use of this software.
* Permission is granted to anyone to use this software for any purpose,
* including commercial applications, and to alter it and redistribute it
* freely, subject to the following restrictions:
* 1. The origin of this software must not be misrepresented; you must not
* claim that you wrote the original software. If you use this software
* in a product, an acknowledgment in the product documentation would be
* appreciated but is not required.
* 2. Altered source versions must be plainly marked as such, and must not be
* misrepresented as being the original software.
* 3. This notice may not be removed or altered from any source distribution.
*/
var Box2D = {};

(function (a2j, undefined) {
   if(!(Object.defineProperty instanceof Function)
      && Object.__defineGetter__ instanceof Function
      && Object.__defineSetter__ instanceof Function)
   {
      Object.defineProperty = function(obj, p, cfg) {
         if(cfg.get instanceof Function)
            obj.__defineGetter__(p, cfg.get);
         if(cfg.set instanceof Function)
            obj.__defineSetter__(p, cfg.set);
      }
   }
   
   function emptyFn() {};
   a2j.inherit = function(cls, base) {
      var tmpCtr = cls;
      emptyFn.prototype = base.prototype;
      cls.prototype = new emptyFn;
      cls.prototype.constructor = tmpCtr;
   };
   
   a2j.generateCallback = function generateCallback(context, cb) {
      return function () {
         cb.apply(context, arguments);
      };
   };
   
   a2j.NVector = function NVector(length) {
      if (length === undefined) length = 0;
      var tmp = new Array(length || 0);
      for (var i = 0; i < length; ++i)
      tmp[i] = 0;
      return tmp;
   };
   
   a2j.is = function is(o1, o2) {
      if (o1 === null) return false;
      if ((o2 instanceof Function) && (o1 instanceof o2)) return true;
      if ((o1.constructor.__implements != undefined) && (o1.constructor.__implements[o2])) return true;
      return false;
   };
   
   a2j.parseUInt = function(v) {
      return Math.abs(parseInt(v));
   }
   
})(Box2D);

//#TODO remove assignments from global namespace
var Vector = Array;
var Vector_a2j_Number = Box2D.NVector;
//package structure
if (typeof(Box2D) === "undefined") Box2D = {};
if (typeof(Box2D.Collision) === "undefined") Box2D.Collision = {};
if (typeof(Box2D.Collision.Shapes) === "undefined") Box2D.Collision.Shapes = {};
if (typeof(Box2D.Common) === "undefined") Box2D.Common = {};
if (typeof(Box2D.Common.Math) === "undefined") Box2D.Common.Math = {};
if (typeof(Box2D.Dynamics) === "undefined") Box2D.Dynamics = {};
if (typeof(Box2D.Dynamics.Contacts) === "undefined") Box2D.Dynamics.Contacts = {};
if (typeof(Box2D.Dynamics.Controllers) === "undefined") Box2D.Dynamics.Controllers = {};
if (typeof(Box2D.Dynamics.Joints) === "undefined") Box2D.Dynamics.Joints = {};
//pre-definitions
(function () {
   Box2D.Collision.IBroadPhase = 'Box2D.Collision.IBroadPhase';

   function b2AABB() {
      b2AABB.b2AABB.apply(this, arguments);
   };
   Box2D.Collision.b2AABB = b2AABB;

   function b2Bound() {
      b2Bound.b2Bound.apply(this, arguments);
   };
   Box2D.Collision.b2Bound = b2Bound;

   function b2BoundValues() {
      b2BoundValues.b2BoundValues.apply(this, arguments);
      if (this.constructor === b2BoundValues) this.b2BoundValues.apply(this, arguments);
   };
   Box2D.Collision.b2BoundValues = b2BoundValues;

   function b2Collision() {
      b2Collision.b2Collision.apply(this, arguments);
   };
   Box2D.Collision.b2Collision = b2Collision;

   function b2ContactID() {
      b2ContactID.b2ContactID.apply(this, arguments);
      if (this.constructor === b2ContactID) this.b2ContactID.apply(this, arguments);
   };
   Box2D.Collision.b2ContactID = b2ContactID;

   function b2ContactPoint() {
      b2ContactPoint.b2ContactPoint.apply(this, arguments);
   };
   Box2D.Collision.b2ContactPoint = b2ContactPoint;

   function b2Distance() {
      b2Distance.b2Distance.apply(this, arguments);
   };
   Box2D.Collision.b2Distance = b2Distance;

   function b2DistanceInput() {
      b2DistanceInput.b2DistanceInput.apply(this, arguments);
   };
   Box2D.Collision.b2DistanceInput = b2DistanceInput;

   function b2DistanceOutput() {
      b2DistanceOutput.b2DistanceOutput.apply(this, arguments);
   };
   Box2D.Collision.b2DistanceOutput = b2DistanceOutput;

   function b2DistanceProxy() {
      b2DistanceProxy.b2DistanceProxy.apply(this, arguments);
   };
   Box2D.Collision.b2DistanceProxy = b2DistanceProxy;

   function b2DynamicTree() {
      b2DynamicTree.b2DynamicTree.apply(this, arguments);
      if (this.constructor === b2DynamicTree) this.b2DynamicTree.apply(this, arguments);
   };
   Box2D.Collision.b2DynamicTree = b2DynamicTree;

   function b2DynamicTreeBroadPhase() {
      b2DynamicTreeBroadPhase.b2DynamicTreeBroadPhase.apply(this, arguments);
   };
   Box2D.Collision.b2DynamicTreeBroadPhase = b2DynamicTreeBroadPhase;

   function b2DynamicTreeNode() {
      b2DynamicTreeNode.b2DynamicTreeNode.apply(this, arguments);
   };
   Box2D.Collision.b2DynamicTreeNode = b2DynamicTreeNode;

   function b2DynamicTreePair() {
      b2DynamicTreePair.b2DynamicTreePair.apply(this, arguments);
   };
   Box2D.Collision.b2DynamicTreePair = b2DynamicTreePair;

   function b2Manifold() {
      b2Manifold.b2Manifold.apply(this, arguments);
      if (this.constructor === b2Manifold) this.b2Manifold.apply(this, arguments);
   };
   Box2D.Collision.b2Manifold = b2Manifold;

   function b2ManifoldPoint() {
      b2ManifoldPoint.b2ManifoldPoint.apply(this, arguments);
      if (this.constructor === b2ManifoldPoint) this.b2ManifoldPoint.apply(this, arguments);
   };
   Box2D.Collision.b2ManifoldPoint = b2ManifoldPoint;

   function b2Point() {
      b2Point.b2Point.apply(this, arguments);
   };
   Box2D.Collision.b2Point = b2Point;

   function b2RayCastInput() {
      b2RayCastInput.b2RayCastInput.apply(this, arguments);
      if (this.constructor === b2RayCastInput) this.b2RayCastInput.apply(this, arguments);
   };
   Box2D.Collision.b2RayCastInput = b2RayCastInput;

   function b2RayCastOutput() {
      b2RayCastOutput.b2RayCastOutput.apply(this, arguments);
   };
   Box2D.Collision.b2RayCastOutput = b2RayCastOutput;

   function b2Segment() {
      b2Segment.b2Segment.apply(this, arguments);
   };
   Box2D.Collision.b2Segment = b2Segment;

   function b2SeparationFunction() {
      b2SeparationFunction.b2SeparationFunction.apply(this, arguments);
   };
   Box2D.Collision.b2SeparationFunction = b2SeparationFunction;

   function b2Simplex() {
      b2Simplex.b2Simplex.apply(this, arguments);
      if (this.constructor === b2Simplex) this.b2Simplex.apply(this, arguments);
   };
   Box2D.Collision.b2Simplex = b2Simplex;

   function b2SimplexCache() {
      b2SimplexCache.b2SimplexCache.apply(this, arguments);
   };
   Box2D.Collision.b2SimplexCache = b2SimplexCache;

   function b2SimplexVertex() {
      b2SimplexVertex.b2SimplexVertex.apply(this, arguments);
   };
   Box2D.Collision.b2SimplexVertex = b2SimplexVertex;

   function b2TimeOfImpact() {
      b2TimeOfImpact.b2TimeOfImpact.apply(this, arguments);
   };
   Box2D.Collision.b2TimeOfImpact = b2TimeOfImpact;

   function b2TOIInput() {
      b2TOIInput.b2TOIInput.apply(this, arguments);
   };
   Box2D.Collision.b2TOIInput = b2TOIInput;

   function b2WorldManifold() {
      b2WorldManifold.b2WorldManifold.apply(this, arguments);
      if (this.constructor === b2WorldManifold) this.b2WorldManifold.apply(this, arguments);
   };
   Box2D.Collision.b2WorldManifold = b2WorldManifold;

   function ClipVertex() {
      ClipVertex.ClipVertex.apply(this, arguments);
   };
   Box2D.Collision.ClipVertex = ClipVertex;

   function Features() {
      Features.Features.apply(this, arguments);
   };
   Box2D.Collision.Features = Features;

   function b2CircleShape() {
      b2CircleShape.b2CircleShape.apply(this, arguments);
      if (this.constructor === b2CircleShape) this.b2CircleShape.apply(this, arguments);
   };
   Box2D.Collision.Shapes.b2CircleShape = b2CircleShape;

   function b2EdgeChainDef() {
      b2EdgeChainDef.b2EdgeChainDef.apply(this, arguments);
      if (this.constructor === b2EdgeChainDef) this.b2EdgeChainDef.apply(this, arguments);
   };
   Box2D.Collision.Shapes.b2EdgeChainDef = b2EdgeChainDef;

   function b2EdgeShape() {
      b2EdgeShape.b2EdgeShape.apply(this, arguments);
      if (this.constructor === b2EdgeShape) this.b2EdgeShape.apply(this, arguments);
   };
   Box2D.Collision.Shapes.b2EdgeShape = b2EdgeShape;

   function b2MassData() {
      b2MassData.b2MassData.apply(this, arguments);
   };
   Box2D.Collision.Shapes.b2MassData = b2MassData;

   function b2PolygonShape() {
      b2PolygonShape.b2PolygonShape.apply(this, arguments);
      if (this.constructor === b2PolygonShape) this.b2PolygonShape.apply(this, arguments);
   };
   Box2D.Collision.Shapes.b2PolygonShape = b2PolygonShape;

   function b2Shape() {
      b2Shape.b2Shape.apply(this, arguments);
      if (this.constructor === b2Shape) this.b2Shape.apply(this, arguments);
   };
   Box2D.Collision.Shapes.b2Shape = b2Shape;
   Box2D.Common.b2internal = 'Box2D.Common.b2internal';

   function b2Color() {
      b2Color.b2Color.apply(this, arguments);
      if (this.constructor === b2Color) this.b2Color.apply(this, arguments);
   };
   Box2D.Common.b2Color = b2Color;

   function b2Settings() {
      b2Settings.b2Settings.apply(this, arguments);
   };
   Box2D.Common.b2Settings = b2Settings;

   function b2Mat22() {
      b2Mat22.b2Mat22.apply(this, arguments);
      if (this.constructor === b2Mat22) this.b2Mat22.apply(this, arguments);
   };
   Box2D.Common.Math.b2Mat22 = b2Mat22;

   function b2Mat33() {
      b2Mat33.b2Mat33.apply(this, arguments);
      if (this.constructor === b2Mat33) this.b2Mat33.apply(this, arguments);
   };
   Box2D.Common.Math.b2Mat33 = b2Mat33;

   function b2Math() {
      b2Math.b2Math.apply(this, arguments);
   };
   Box2D.Common.Math.b2Math = b2Math;

   function b2Sweep() {
      b2Sweep.b2Sweep.apply(this, arguments);
   };
   Box2D.Common.Math.b2Sweep = b2Sweep;

   function b2Transform() {
      b2Transform.b2Transform.apply(this, arguments);
      if (this.constructor === b2Transform) this.b2Transform.apply(this, arguments);
   };
   Box2D.Common.Math.b2Transform = b2Transform;

   function b2Vec2() {
      b2Vec2.b2Vec2.apply(this, arguments);
      if (this.constructor === b2Vec2) this.b2Vec2.apply(this, arguments);
   };
   Box2D.Common.Math.b2Vec2 = b2Vec2;

   function b2Vec3() {
      b2Vec3.b2Vec3.apply(this, arguments);
      if (this.constructor === b2Vec3) this.b2Vec3.apply(this, arguments);
   };
   Box2D.Common.Math.b2Vec3 = b2Vec3;

   function b2Body() {
      b2Body.b2Body.apply(this, arguments);
      if (this.constructor === b2Body) this.b2Body.apply(this, arguments);
   };
   Box2D.Dynamics.b2Body = b2Body;

   function b2BodyDef() {
      b2BodyDef.b2BodyDef.apply(this, arguments);
      if (this.constructor === b2BodyDef) this.b2BodyDef.apply(this, arguments);
   };
   Box2D.Dynamics.b2BodyDef = b2BodyDef;

   function b2ContactFilter() {
      b2ContactFilter.b2ContactFilter.apply(this, arguments);
   };
   Box2D.Dynamics.b2ContactFilter = b2ContactFilter;

   function b2ContactImpulse() {
      b2ContactImpulse.b2ContactImpulse.apply(this, arguments);
   };
   Box2D.Dynamics.b2ContactImpulse = b2ContactImpulse;

   function b2ContactListener() {
      b2ContactListener.b2ContactListener.apply(this, arguments);
   };
   Box2D.Dynamics.b2ContactListener = b2ContactListener;

   function b2ContactManager() {
      b2ContactManager.b2ContactManager.apply(this, arguments);
      if (this.constructor === b2ContactManager) this.b2ContactManager.apply(this, arguments);
   };
   Box2D.Dynamics.b2ContactManager = b2ContactManager;

   function b2DebugDraw() {
      b2DebugDraw.b2DebugDraw.apply(this, arguments);
      if (this.constructor === b2DebugDraw) this.b2DebugDraw.apply(this, arguments);
   };
   Box2D.Dynamics.b2DebugDraw = b2DebugDraw;

   function b2DestructionListener() {
      b2DestructionListener.b2DestructionListener.apply(this, arguments);
   };
   Box2D.Dynamics.b2DestructionListener = b2DestructionListener;

   function b2FilterData() {
      b2FilterData.b2FilterData.apply(this, arguments);
   };
   Box2D.Dynamics.b2FilterData = b2FilterData;

   function b2Fixture() {
      b2Fixture.b2Fixture.apply(this, arguments);
      if (this.constructor === b2Fixture) this.b2Fixture.apply(this, arguments);
   };
   Box2D.Dynamics.b2Fixture = b2Fixture;

   function b2FixtureDef() {
      b2FixtureDef.b2FixtureDef.apply(this, arguments);
      if (this.constructor === b2FixtureDef) this.b2FixtureDef.apply(this, arguments);
   };
   Box2D.Dynamics.b2FixtureDef = b2FixtureDef;

   function b2Island() {
      b2Island.b2Island.apply(this, arguments);
      if (this.constructor === b2Island) this.b2Island.apply(this, arguments);
   };
   Box2D.Dynamics.b2Island = b2Island;

   function b2TimeStep() {
      b2TimeStep.b2TimeStep.apply(this, arguments);
   };
   Box2D.Dynamics.b2TimeStep = b2TimeStep;

   function b2World() {
      b2World.b2World.apply(this, arguments);
      if (this.constructor === b2World) this.b2World.apply(this, arguments);
   };
   Box2D.Dynamics.b2World = b2World;

   function b2CircleContact() {
      b2CircleContact.b2CircleContact.apply(this, arguments);
   };
   Box2D.Dynamics.Contacts.b2CircleContact = b2CircleContact;

   function b2Contact() {
      b2Contact.b2Contact.apply(this, arguments);
      if (this.constructor === b2Contact) this.b2Contact.apply(this, arguments);
   };
   Box2D.Dynamics.Contacts.b2Contact = b2Contact;

   function b2ContactConstraint() {
      b2ContactConstraint.b2ContactConstraint.apply(this, arguments);
      if (this.constructor === b2ContactConstraint) this.b2ContactConstraint.apply(this, arguments);
   };
   Box2D.Dynamics.Contacts.b2ContactConstraint = b2ContactConstraint;

   function b2ContactConstraintPoint() {
      b2ContactConstraintPoint.b2ContactConstraintPoint.apply(this, arguments);
   };
   Box2D.Dynamics.Contacts.b2ContactConstraintPoint = b2ContactConstraintPoint;

   function b2ContactEdge() {
      b2ContactEdge.b2ContactEdge.apply(this, arguments);
   };
   Box2D.Dynamics.Contacts.b2ContactEdge = b2ContactEdge;

   function b2ContactFactory() {
      b2ContactFactory.b2ContactFactory.apply(this, arguments);
      if (this.constructor === b2ContactFactory) this.b2ContactFactory.apply(this, arguments);
   };
   Box2D.Dynamics.Contacts.b2ContactFactory = b2ContactFactory;

   function b2ContactRegister() {
      b2ContactRegister.b2ContactRegister.apply(this, arguments);
   };
   Box2D.Dynamics.Contacts.b2ContactRegister = b2ContactRegister;

   function b2ContactResult() {
      b2ContactResult.b2ContactResult.apply(this, arguments);
   };
   Box2D.Dynamics.Contacts.b2ContactResult = b2ContactResult;

   function b2ContactSolver() {
      b2ContactSolver.b2ContactSolver.apply(this, arguments);
      if (this.constructor === b2ContactSolver) this.b2ContactSolver.apply(this, arguments);
   };
   Box2D.Dynamics.Contacts.b2ContactSolver = b2ContactSolver;

   function b2EdgeAndCircleContact() {
      b2EdgeAndCircleContact.b2EdgeAndCircleContact.apply(this, arguments);
   };
   Box2D.Dynamics.Contacts.b2EdgeAndCircleContact = b2EdgeAndCircleContact;

   function b2NullContact() {
      b2NullContact.b2NullContact.apply(this, arguments);
      if (this.constructor === b2NullContact) this.b2NullContact.apply(this, arguments);
   };
   Box2D.Dynamics.Contacts.b2NullContact = b2NullContact;

   function b2PolyAndCircleContact() {
      b2PolyAndCircleContact.b2PolyAndCircleContact.apply(this, arguments);
   };
   Box2D.Dynamics.Contacts.b2PolyAndCircleContact = b2PolyAndCircleContact;

   function b2PolyAndEdgeContact() {
      b2PolyAndEdgeContact.b2PolyAndEdgeContact.apply(this, arguments);
   };
   Box2D.Dynamics.Contacts.b2PolyAndEdgeContact = b2PolyAndEdgeContact;

   function b2PolygonContact() {
      b2PolygonContact.b2PolygonContact.apply(this, arguments);
   };
   Box2D.Dynamics.Contacts.b2PolygonContact = b2PolygonContact;

   function b2PositionSolverManifold() {
      b2PositionSolverManifold.b2PositionSolverManifold.apply(this, arguments);
      if (this.constructor === b2PositionSolverManifold) this.b2PositionSolverManifold.apply(this, arguments);
   };
   Box2D.Dynamics.Contacts.b2PositionSolverManifold = b2PositionSolverManifold;

   function b2BuoyancyController() {
      b2BuoyancyController.b2BuoyancyController.apply(this, arguments);
   };
   Box2D.Dynamics.Controllers.b2BuoyancyController = b2BuoyancyController;

   function b2ConstantAccelController() {
      b2ConstantAccelController.b2ConstantAccelController.apply(this, arguments);
   };
   Box2D.Dynamics.Controllers.b2ConstantAccelController = b2ConstantAccelController;

   function b2ConstantForceController() {
      b2ConstantForceController.b2ConstantForceController.apply(this, arguments);
   };
   Box2D.Dynamics.Controllers.b2ConstantForceController = b2ConstantForceController;

   function b2Controller() {
      b2Controller.b2Controller.apply(this, arguments);
   };
   Box2D.Dynamics.Controllers.b2Controller = b2Controller;

   function b2ControllerEdge() {
      b2ControllerEdge.b2ControllerEdge.apply(this, arguments);
   };
   Box2D.Dynamics.Controllers.b2ControllerEdge = b2ControllerEdge;

   function b2GravityController() {
      b2GravityController.b2GravityController.apply(this, arguments);
   };
   Box2D.Dynamics.Controllers.b2GravityController = b2GravityController;

   function b2TensorDampingController() {
      b2TensorDampingController.b2TensorDampingController.apply(this, arguments);
   };
   Box2D.Dynamics.Controllers.b2TensorDampingController = b2TensorDampingController;

   function b2DistanceJoint() {
      b2DistanceJoint.b2DistanceJoint.apply(this, arguments);
      if (this.constructor === b2DistanceJoint) this.b2DistanceJoint.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2DistanceJoint = b2DistanceJoint;

   function b2DistanceJointDef() {
      b2DistanceJointDef.b2DistanceJointDef.apply(this, arguments);
      if (this.constructor === b2DistanceJointDef) this.b2DistanceJointDef.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2DistanceJointDef = b2DistanceJointDef;

   function b2FrictionJoint() {
      b2FrictionJoint.b2FrictionJoint.apply(this, arguments);
      if (this.constructor === b2FrictionJoint) this.b2FrictionJoint.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2FrictionJoint = b2FrictionJoint;

   function b2FrictionJointDef() {
      b2FrictionJointDef.b2FrictionJointDef.apply(this, arguments);
      if (this.constructor === b2FrictionJointDef) this.b2FrictionJointDef.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2FrictionJointDef = b2FrictionJointDef;

   function b2GearJoint() {
      b2GearJoint.b2GearJoint.apply(this, arguments);
      if (this.constructor === b2GearJoint) this.b2GearJoint.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2GearJoint = b2GearJoint;

   function b2GearJointDef() {
      b2GearJointDef.b2GearJointDef.apply(this, arguments);
      if (this.constructor === b2GearJointDef) this.b2GearJointDef.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2GearJointDef = b2GearJointDef;

   function b2Jacobian() {
      b2Jacobian.b2Jacobian.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2Jacobian = b2Jacobian;

   function b2Joint() {
      b2Joint.b2Joint.apply(this, arguments);
      if (this.constructor === b2Joint) this.b2Joint.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2Joint = b2Joint;

   function b2JointDef() {
      b2JointDef.b2JointDef.apply(this, arguments);
      if (this.constructor === b2JointDef) this.b2JointDef.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2JointDef = b2JointDef;

   function b2JointEdge() {
      b2JointEdge.b2JointEdge.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2JointEdge = b2JointEdge;

   function b2LineJoint() {
      b2LineJoint.b2LineJoint.apply(this, arguments);
      if (this.constructor === b2LineJoint) this.b2LineJoint.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2LineJoint = b2LineJoint;

   function b2LineJointDef() {
      b2LineJointDef.b2LineJointDef.apply(this, arguments);
      if (this.constructor === b2LineJointDef) this.b2LineJointDef.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2LineJointDef = b2LineJointDef;

   function b2MouseJoint() {
      b2MouseJoint.b2MouseJoint.apply(this, arguments);
      if (this.constructor === b2MouseJoint) this.b2MouseJoint.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2MouseJoint = b2MouseJoint;

   function b2MouseJointDef() {
      b2MouseJointDef.b2MouseJointDef.apply(this, arguments);
      if (this.constructor === b2MouseJointDef) this.b2MouseJointDef.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2MouseJointDef = b2MouseJointDef;

   function b2PrismaticJoint() {
      b2PrismaticJoint.b2PrismaticJoint.apply(this, arguments);
      if (this.constructor === b2PrismaticJoint) this.b2PrismaticJoint.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2PrismaticJoint = b2PrismaticJoint;

   function b2PrismaticJointDef() {
      b2PrismaticJointDef.b2PrismaticJointDef.apply(this, arguments);
      if (this.constructor === b2PrismaticJointDef) this.b2PrismaticJointDef.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2PrismaticJointDef = b2PrismaticJointDef;

   function b2PulleyJoint() {
      b2PulleyJoint.b2PulleyJoint.apply(this, arguments);
      if (this.constructor === b2PulleyJoint) this.b2PulleyJoint.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2PulleyJoint = b2PulleyJoint;

   function b2PulleyJointDef() {
      b2PulleyJointDef.b2PulleyJointDef.apply(this, arguments);
      if (this.constructor === b2PulleyJointDef) this.b2PulleyJointDef.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2PulleyJointDef = b2PulleyJointDef;

   function b2RevoluteJoint() {
      b2RevoluteJoint.b2RevoluteJoint.apply(this, arguments);
      if (this.constructor === b2RevoluteJoint) this.b2RevoluteJoint.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2RevoluteJoint = b2RevoluteJoint;

   function b2RevoluteJointDef() {
      b2RevoluteJointDef.b2RevoluteJointDef.apply(this, arguments);
      if (this.constructor === b2RevoluteJointDef) this.b2RevoluteJointDef.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2RevoluteJointDef = b2RevoluteJointDef;

   function b2WeldJoint() {
      b2WeldJoint.b2WeldJoint.apply(this, arguments);
      if (this.constructor === b2WeldJoint) this.b2WeldJoint.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2WeldJoint = b2WeldJoint;

   function b2WeldJointDef() {
      b2WeldJointDef.b2WeldJointDef.apply(this, arguments);
      if (this.constructor === b2WeldJointDef) this.b2WeldJointDef.apply(this, arguments);
   };
   Box2D.Dynamics.Joints.b2WeldJointDef = b2WeldJointDef;
})(); //definitions
Box2D.postDefs = [];
(function () {
   var b2CircleShape = Box2D.Collision.Shapes.b2CircleShape,
      b2EdgeChainDef = Box2D.Collision.Shapes.b2EdgeChainDef,
      b2EdgeShape = Box2D.Collision.Shapes.b2EdgeShape,
      b2MassData = Box2D.Collision.Shapes.b2MassData,
      b2PolygonShape = Box2D.Collision.Shapes.b2PolygonShape,
      b2Shape = Box2D.Collision.Shapes.b2Shape,
      b2Color = Box2D.Common.b2Color,
      b2internal = Box2D.Common.b2internal,
      b2Settings = Box2D.Common.b2Settings,
      b2Mat22 = Box2D.Common.Math.b2Mat22,
      b2Mat33 = Box2D.Common.Math.b2Mat33,
      b2Math = Box2D.Common.Math.b2Math,
      b2Sweep = Box2D.Common.Math.b2Sweep,
      b2Transform = Box2D.Common.Math.b2Transform,
      b2Vec2 = Box2D.Common.Math.b2Vec2,
      b2Vec3 = Box2D.Common.Math.b2Vec3,
      b2AABB = Box2D.Collision.b2AABB,
      b2Bound = Box2D.Collision.b2Bound,
      b2BoundValues = Box2D.Collision.b2BoundValues,
      b2Collision = Box2D.Collision.b2Collision,
      b2ContactID = Box2D.Collision.b2ContactID,
      b2ContactPoint = Box2D.Collision.b2ContactPoint,
      b2Distance = Box2D.Collision.b2Distance,
      b2DistanceInput = Box2D.Collision.b2DistanceInput,
      b2DistanceOutput = Box2D.Collision.b2DistanceOutput,
      b2DistanceProxy = Box2D.Collision.b2DistanceProxy,
      b2DynamicTree = Box2D.Collision.b2DynamicTree,
      b2DynamicTreeBroadPhase = Box2D.Collision.b2DynamicTreeBroadPhase,
      b2DynamicTreeNode = Box2D.Collision.b2DynamicTreeNode,
      b2DynamicTreePair = Box2D.Collision.b2DynamicTreePair,
      b2Manifold = Box2D.Collision.b2Manifold,
      b2ManifoldPoint = Box2D.Collision.b2ManifoldPoint,
      b2Point = Box2D.Collision.b2Point,
      b2RayCastInput = Box2D.Collision.b2RayCastInput,
      b2RayCastOutput = Box2D.Collision.b2RayCastOutput,
      b2Segment = Box2D.Collision.b2Segment,
      b2SeparationFunction = Box2D.Collision.b2SeparationFunction,
      b2Simplex = Box2D.Collision.b2Simplex,
      b2SimplexCache = Box2D.Collision.b2SimplexCache,
      b2SimplexVertex = Box2D.Collision.b2SimplexVertex,
      b2TimeOfImpact = Box2D.Collision.b2TimeOfImpact,
      b2TOIInput = Box2D.Collision.b2TOIInput,
      b2WorldManifold = Box2D.Collision.b2WorldManifold,
      ClipVertex = Box2D.Collision.ClipVertex,
      Features = Box2D.Collision.Features,
      IBroadPhase = Box2D.Collision.IBroadPhase;

   b2AABB.b2AABB = function () {
      this.lowerBound = new b2Vec2();
      this.upperBound = new b2Vec2();
   };
   b2AABB.prototype.IsValid = function () {
      var dX = this.upperBound.x - this.lowerBound.x;
      var dY = this.upperBound.y - this.lowerBound.y;
      var valid = dX >= 0.0 && dY >= 0.0;
      valid = valid && this.lowerBound.IsValid() && this.upperBound.IsValid();
      return valid;
   }
   b2AABB.prototype.GetCenter = function () {
      return new b2Vec2((this.lowerBound.x + this.upperBound.x) / 2, (this.lowerBound.y + this.upperBound.y) / 2);
   }
   b2AABB.prototype.GetExtents = function () {
      return new b2Vec2((this.upperBound.x - this.lowerBound.x) / 2, (this.upperBound.y - this.lowerBound.y) / 2);
   }
   b2AABB.prototype.Contains = function (aabb) {
      var result = true;
      result = result && this.lowerBound.x <= aabb.lowerBound.x;
      result = result && this.lowerBound.y <= aabb.lowerBound.y;
      result = result && aabb.upperBound.x <= this.upperBound.x;
      result = result && aabb.upperBound.y <= this.upperBound.y;
      return result;
   }
   b2AABB.prototype.RayCast = function (output, input) {
      var tmin = (-Number.MAX_VALUE);
      var tmax = Number.MAX_VALUE;
      var pX = input.p1.x;
      var pY = input.p1.y;
      var dX = input.p2.x - input.p1.x;
      var dY = input.p2.y - input.p1.y;
      var absDX = Math.abs(dX);
      var absDY = Math.abs(dY);
      var normal = output.normal;
      var inv_d = 0;
      var t1 = 0;
      var t2 = 0;
      var t3 = 0;
      var s = 0; {
         if (absDX < Number.MIN_VALUE) {
            if (pX < this.lowerBound.x || this.upperBound.x < pX) return false;
         }
         else {
            inv_d = 1.0 / dX;
            t1 = (this.lowerBound.x - pX) * inv_d;
            t2 = (this.upperBound.x - pX) * inv_d;
            s = (-1.0);
            if (t1 > t2) {
               t3 = t1;
               t1 = t2;
               t2 = t3;
               s = 1.0;
            }
            if (t1 > tmin) {
               normal.x = s;
               normal.y = 0;
               tmin = t1;
            }
            tmax = Math.min(tmax, t2);
            if (tmin > tmax) return false;
         }
      } {
         if (absDY < Number.MIN_VALUE) {
            if (pY < this.lowerBound.y || this.upperBound.y < pY) return false;
         }
         else {
            inv_d = 1.0 / dY;
            t1 = (this.lowerBound.y - pY) * inv_d;
            t2 = (this.upperBound.y - pY) * inv_d;
            s = (-1.0);
            if (t1 > t2) {
               t3 = t1;
               t1 = t2;
               t2 = t3;
               s = 1.0;
            }
            if (t1 > tmin) {
               normal.y = s;
               normal.x = 0;
               tmin = t1;
            }
            tmax = Math.min(tmax, t2);
            if (tmin > tmax) return false;
         }
      }
      output.fraction = tmin;
      return true;
   }
   b2AABB.prototype.TestOverlap = function (other) {
      var d1X = other.lowerBound.x - this.upperBound.x;
      var d1Y = other.lowerBound.y - this.upperBound.y;
      var d2X = this.lowerBound.x - other.upperBound.x;
      var d2Y = this.lowerBound.y - other.upperBound.y;
      if (d1X > 0.0 || d1Y > 0.0) return false;
      if (d2X > 0.0 || d2Y > 0.0) return false;
      return true;
   }
   b2AABB.Combine = function (aabb1, aabb2) {
      var aabb = new b2AABB();
      aabb.Combine(aabb1, aabb2);
      return aabb;
   }
   b2AABB.prototype.Combine = function (aabb1, aabb2) {
      this.lowerBound.x = Math.min(aabb1.lowerBound.x, aabb2.lowerBound.x);
      this.lowerBound.y = Math.min(aabb1.lowerBound.y, aabb2.lowerBound.y);
      this.upperBound.x = Math.max(aabb1.upperBound.x, aabb2.upperBound.x);
      this.upperBound.y = Math.max(aabb1.upperBound.y, aabb2.upperBound.y);
   }
   b2Bound.b2Bound = function () {};
   b2Bound.prototype.IsLower = function () {
      return (this.value & 1) == 0;
   }
   b2Bound.prototype.IsUpper = function () {
      return (this.value & 1) == 1;
   }
   b2Bound.prototype.Swap = function (b) {
      var tempValue = this.value;
      var tempProxy = this.proxy;
      var tempStabbingCount = this.stabbingCount;
      this.value = b.value;
      this.proxy = b.proxy;
      this.stabbingCount = b.stabbingCount;
      b.value = tempValue;
      b.proxy = tempProxy;
      b.stabbingCount = tempStabbingCount;
   }
   b2BoundValues.b2BoundValues = function () {};
   b2BoundValues.prototype.b2BoundValues = function () {
      this.lowerValues = new Vector_a2j_Number();
      this.lowerValues[0] = 0.0;
      this.lowerValues[1] = 0.0;
      this.upperValues = new Vector_a2j_Number();
      this.upperValues[0] = 0.0;
      this.upperValues[1] = 0.0;
   }
   b2Collision.b2Collision = function () {};
   b2Collision.ClipSegmentToLine = function (vOut, vIn, normal, offset) {
      if (offset === undefined) offset = 0;
      var cv;
      var numOut = 0;
      cv = vIn[0];
      var vIn0 = cv.v;
      cv = vIn[1];
      var vIn1 = cv.v;
      var distance0 = normal.x * vIn0.x + normal.y * vIn0.y - offset;
      var distance1 = normal.x * vIn1.x + normal.y * vIn1.y - offset;
      if (distance0 <= 0.0) vOut[numOut++].Set(vIn[0]);
      if (distance1 <= 0.0) vOut[numOut++].Set(vIn[1]);
      if (distance0 * distance1 < 0.0) {
         var interp = distance0 / (distance0 - distance1);
         cv = vOut[numOut];
         var tVec = cv.v;
         tVec.x = vIn0.x + interp * (vIn1.x - vIn0.x);
         tVec.y = vIn0.y + interp * (vIn1.y - vIn0.y);
         cv = vOut[numOut];
         var cv2;
         if (distance0 > 0.0) {
            cv2 = vIn[0];
            cv.id = cv2.id;
         }
         else {
            cv2 = vIn[1];
            cv.id = cv2.id;
         }++numOut;
      }
      return numOut;
   }
   b2Collision.EdgeSeparation = function (poly1, xf1, edge1, poly2, xf2) {
      if (edge1 === undefined) edge1 = 0;
      var count1 = parseInt(poly1.m_vertexCount);
      var vertices1 = poly1.m_vertices;
      var normals1 = poly1.m_normals;
      var count2 = parseInt(poly2.m_vertexCount);
      var vertices2 = poly2.m_vertices;
      var tMat;
      var tVec;
      tMat = xf1.R;
      tVec = normals1[edge1];
      var normal1WorldX = (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      var normal1WorldY = (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      tMat = xf2.R;
      var normal1X = (tMat.col1.x * normal1WorldX + tMat.col1.y * normal1WorldY);
      var normal1Y = (tMat.col2.x * normal1WorldX + tMat.col2.y * normal1WorldY);
      var index = 0;
      var minDot = Number.MAX_VALUE;
      for (var i = 0; i < count2; ++i) {
         tVec = vertices2[i];
         var dot = tVec.x * normal1X + tVec.y * normal1Y;
         if (dot < minDot) {
            minDot = dot;
            index = i;
         }
      }
      tVec = vertices1[edge1];
      tMat = xf1.R;
      var v1X = xf1.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      var v1Y = xf1.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      tVec = vertices2[index];
      tMat = xf2.R;
      var v2X = xf2.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      var v2Y = xf2.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      v2X -= v1X;
      v2Y -= v1Y;
      var separation = v2X * normal1WorldX + v2Y * normal1WorldY;
      return separation;
   }
   b2Collision.FindMaxSeparation = function (edgeIndex, poly1, xf1, poly2, xf2) {
      var count1 = parseInt(poly1.m_vertexCount);
      var normals1 = poly1.m_normals;
      var tVec;
      var tMat;
      tMat = xf2.R;
      tVec = poly2.m_centroid;
      var dX = xf2.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      var dY = xf2.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      tMat = xf1.R;
      tVec = poly1.m_centroid;
      dX -= xf1.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      dY -= xf1.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      var dLocal1X = (dX * xf1.R.col1.x + dY * xf1.R.col1.y);
      var dLocal1Y = (dX * xf1.R.col2.x + dY * xf1.R.col2.y);
      var edge = 0;
      var maxDot = (-Number.MAX_VALUE);
      for (var i = 0; i < count1; ++i) {
         tVec = normals1[i];
         var dot = (tVec.x * dLocal1X + tVec.y * dLocal1Y);
         if (dot > maxDot) {
            maxDot = dot;
            edge = i;
         }
      }
      var s = b2Collision.EdgeSeparation(poly1, xf1, edge, poly2, xf2);
      var prevEdge = parseInt(edge - 1 >= 0 ? edge - 1 : count1 - 1);
      var sPrev = b2Collision.EdgeSeparation(poly1, xf1, prevEdge, poly2, xf2);
      var nextEdge = parseInt(edge + 1 < count1 ? edge + 1 : 0);
      var sNext = b2Collision.EdgeSeparation(poly1, xf1, nextEdge, poly2, xf2);
      var bestEdge = 0;
      var bestSeparation = 0;
      var increment = 0;
      if (sPrev > s && sPrev > sNext) {
         increment = (-1);
         bestEdge = prevEdge;
         bestSeparation = sPrev;
      }
      else if (sNext > s) {
         increment = 1;
         bestEdge = nextEdge;
         bestSeparation = sNext;
      }
      else {
         edgeIndex[0] = edge;
         return s;
      }
      while (true) {
         if (increment == (-1)) edge = bestEdge - 1 >= 0 ? bestEdge - 1 : count1 - 1;
         else edge = bestEdge + 1 < count1 ? bestEdge + 1 : 0;s = b2Collision.EdgeSeparation(poly1, xf1, edge, poly2, xf2);
         if (s > bestSeparation) {
            bestEdge = edge;
            bestSeparation = s;
         }
         else {
            break;
         }
      }
      edgeIndex[0] = bestEdge;
      return bestSeparation;
   }
   b2Collision.FindIncidentEdge = function (c, poly1, xf1, edge1, poly2, xf2) {
      if (edge1 === undefined) edge1 = 0;
      var count1 = parseInt(poly1.m_vertexCount);
      var normals1 = poly1.m_normals;
      var count2 = parseInt(poly2.m_vertexCount);
      var vertices2 = poly2.m_vertices;
      var normals2 = poly2.m_normals;
      var tMat;
      var tVec;
      tMat = xf1.R;
      tVec = normals1[edge1];
      var normal1X = (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      var normal1Y = (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      tMat = xf2.R;
      var tX = (tMat.col1.x * normal1X + tMat.col1.y * normal1Y);
      normal1Y = (tMat.col2.x * normal1X + tMat.col2.y * normal1Y);
      normal1X = tX;
      var index = 0;
      var minDot = Number.MAX_VALUE;
      for (var i = 0; i < count2; ++i) {
         tVec = normals2[i];
         var dot = (normal1X * tVec.x + normal1Y * tVec.y);
         if (dot < minDot) {
            minDot = dot;
            index = i;
         }
      }
      var tClip;
      var i1 = parseInt(index);
      var i2 = parseInt(i1 + 1 < count2 ? i1 + 1 : 0);
      tClip = c[0];
      tVec = vertices2[i1];
      tMat = xf2.R;
      tClip.v.x = xf2.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      tClip.v.y = xf2.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      tClip.id.features.referenceEdge = edge1;
      tClip.id.features.incidentEdge = i1;
      tClip.id.features.incidentVertex = 0;
      tClip = c[1];
      tVec = vertices2[i2];
      tMat = xf2.R;
      tClip.v.x = xf2.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      tClip.v.y = xf2.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      tClip.id.features.referenceEdge = edge1;
      tClip.id.features.incidentEdge = i2;
      tClip.id.features.incidentVertex = 1;
   }
   b2Collision.MakeClipPointVector = function () {
      var r = new Vector(2);
      r[0] = new ClipVertex();
      r[1] = new ClipVertex();
      return r;
   }
   b2Collision.CollidePolygons = function (manifold, polyA, xfA, polyB, xfB) {
      var cv;
      manifold.m_pointCount = 0;
      var totalRadius = polyA.m_radius + polyB.m_radius;
      var edgeA = 0;
      b2Collision.s_edgeAO[0] = edgeA;
      var separationA = b2Collision.FindMaxSeparation(b2Collision.s_edgeAO, polyA, xfA, polyB, xfB);
      edgeA = b2Collision.s_edgeAO[0];
      if (separationA > totalRadius) return;
      var edgeB = 0;
      b2Collision.s_edgeBO[0] = edgeB;
      var separationB = b2Collision.FindMaxSeparation(b2Collision.s_edgeBO, polyB, xfB, polyA, xfA);
      edgeB = b2Collision.s_edgeBO[0];
      if (separationB > totalRadius) return;
      var poly1;
      var poly2;
      var xf1;
      var xf2;
      var edge1 = 0;
      var flip = 0;
      var k_relativeTol = 0.98;
      var k_absoluteTol = 0.001;
      var tMat;
      if (separationB > k_relativeTol * separationA + k_absoluteTol) {
         poly1 = polyB;
         poly2 = polyA;
         xf1 = xfB;
         xf2 = xfA;
         edge1 = edgeB;
         manifold.m_type = b2Manifold.e_faceB;
         flip = 1;
      }
      else {
         poly1 = polyA;
         poly2 = polyB;
         xf1 = xfA;
         xf2 = xfB;
         edge1 = edgeA;
         manifold.m_type = b2Manifold.e_faceA;
         flip = 0;
      }
      var incidentEdge = b2Collision.s_incidentEdge;
      b2Collision.FindIncidentEdge(incidentEdge, poly1, xf1, edge1, poly2, xf2);
      var count1 = parseInt(poly1.m_vertexCount);
      var vertices1 = poly1.m_vertices;
      var local_v11 = vertices1[edge1];
      var local_v12;
      if (edge1 + 1 < count1) {
         local_v12 = vertices1[parseInt(edge1 + 1)];
      }
      else {
         local_v12 = vertices1[0];
      }
      var localTangent = b2Collision.s_localTangent;
      localTangent.Set(local_v12.x - local_v11.x, local_v12.y - local_v11.y);
      localTangent.Normalize();
      var localNormal = b2Collision.s_localNormal;
      localNormal.x = localTangent.y;
      localNormal.y = (-localTangent.x);
      var planePoint = b2Collision.s_planePoint;
      planePoint.Set(0.5 * (local_v11.x + local_v12.x), 0.5 * (local_v11.y + local_v12.y));
      var tangent = b2Collision.s_tangent;
      tMat = xf1.R;
      tangent.x = (tMat.col1.x * localTangent.x + tMat.col2.x * localTangent.y);
      tangent.y = (tMat.col1.y * localTangent.x + tMat.col2.y * localTangent.y);
      var tangent2 = b2Collision.s_tangent2;
      tangent2.x = (-tangent.x);
      tangent2.y = (-tangent.y);
      var normal = b2Collision.s_normal;
      normal.x = tangent.y;
      normal.y = (-tangent.x);
      var v11 = b2Collision.s_v11;
      var v12 = b2Collision.s_v12;
      v11.x = xf1.position.x + (tMat.col1.x * local_v11.x + tMat.col2.x * local_v11.y);
      v11.y = xf1.position.y + (tMat.col1.y * local_v11.x + tMat.col2.y * local_v11.y);
      v12.x = xf1.position.x + (tMat.col1.x * local_v12.x + tMat.col2.x * local_v12.y);
      v12.y = xf1.position.y + (tMat.col1.y * local_v12.x + tMat.col2.y * local_v12.y);
      var frontOffset = normal.x * v11.x + normal.y * v11.y;
      var sideOffset1 = (-tangent.x * v11.x) - tangent.y * v11.y + totalRadius;
      var sideOffset2 = tangent.x * v12.x + tangent.y * v12.y + totalRadius;
      var clipPoints1 = b2Collision.s_clipPoints1;
      var clipPoints2 = b2Collision.s_clipPoints2;
      var np = 0;
      np = b2Collision.ClipSegmentToLine(clipPoints1, incidentEdge, tangent2, sideOffset1);
      if (np < 2) return;
      np = b2Collision.ClipSegmentToLine(clipPoints2, clipPoints1, tangent, sideOffset2);
      if (np < 2) return;
      manifold.m_localPlaneNormal.SetV(localNormal);
      manifold.m_localPoint.SetV(planePoint);
      var pointCount = 0;
      for (var i = 0; i < b2Settings.b2_maxManifoldPoints; ++i) {
         cv = clipPoints2[i];
         var separation = normal.x * cv.v.x + normal.y * cv.v.y - frontOffset;
         if (separation <= totalRadius) {
            var cp = manifold.m_points[pointCount];
            tMat = xf2.R;
            var tX = cv.v.x - xf2.position.x;
            var tY = cv.v.y - xf2.position.y;
            cp.m_localPoint.x = (tX * tMat.col1.x + tY * tMat.col1.y);
            cp.m_localPoint.y = (tX * tMat.col2.x + tY * tMat.col2.y);
            cp.m_id.Set(cv.id);
            cp.m_id.features.flip = flip;
            ++pointCount;
         }
      }
      manifold.m_pointCount = pointCount;
   }
   b2Collision.CollideCircles = function (manifold, circle1, xf1, circle2, xf2) {
      manifold.m_pointCount = 0;
      var tMat;
      var tVec;
      tMat = xf1.R;
      tVec = circle1.m_p;
      var p1X = xf1.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      var p1Y = xf1.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      tMat = xf2.R;
      tVec = circle2.m_p;
      var p2X = xf2.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      var p2Y = xf2.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      var dX = p2X - p1X;
      var dY = p2Y - p1Y;
      var distSqr = dX * dX + dY * dY;
      var radius = circle1.m_radius + circle2.m_radius;
      if (distSqr > radius * radius) {
         return;
      }
      manifold.m_type = b2Manifold.e_circles;
      manifold.m_localPoint.SetV(circle1.m_p);
      manifold.m_localPlaneNormal.SetZero();
      manifold.m_pointCount = 1;
      manifold.m_points[0].m_localPoint.SetV(circle2.m_p);
      manifold.m_points[0].m_id.key = 0;
   }
   b2Collision.CollidePolygonAndCircle = function (manifold, polygon, xf1, circle, xf2) {
      manifold.m_pointCount = 0;
      var tPoint;
      var dX = 0;
      var dY = 0;
      var positionX = 0;
      var positionY = 0;
      var tVec;
      var tMat;
      tMat = xf2.R;
      tVec = circle.m_p;
      var cX = xf2.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      var cY = xf2.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      dX = cX - xf1.position.x;
      dY = cY - xf1.position.y;
      tMat = xf1.R;
      var cLocalX = (dX * tMat.col1.x + dY * tMat.col1.y);
      var cLocalY = (dX * tMat.col2.x + dY * tMat.col2.y);
      var dist = 0;
      var normalIndex = 0;
      var separation = (-Number.MAX_VALUE);
      var radius = polygon.m_radius + circle.m_radius;
      var vertexCount = parseInt(polygon.m_vertexCount);
      var vertices = polygon.m_vertices;
      var normals = polygon.m_normals;
      for (var i = 0; i < vertexCount; ++i) {
         tVec = vertices[i];
         dX = cLocalX - tVec.x;
         dY = cLocalY - tVec.y;
         tVec = normals[i];
         var s = tVec.x * dX + tVec.y * dY;
         if (s > radius) {
            return;
         }
         if (s > separation) {
            separation = s;
            normalIndex = i;
         }
      }
      var vertIndex1 = parseInt(normalIndex);
      var vertIndex2 = parseInt(vertIndex1 + 1 < vertexCount ? vertIndex1 + 1 : 0);
      var v1 = vertices[vertIndex1];
      var v2 = vertices[vertIndex2];
      if (separation < Number.MIN_VALUE) {
         manifold.m_pointCount = 1;
         manifold.m_type = b2Manifold.e_faceA;
         manifold.m_localPlaneNormal.SetV(normals[normalIndex]);
         manifold.m_localPoint.x = 0.5 * (v1.x + v2.x);
         manifold.m_localPoint.y = 0.5 * (v1.y + v2.y);
         manifold.m_points[0].m_localPoint.SetV(circle.m_p);
         manifold.m_points[0].m_id.key = 0;
         return;
      }
      var u1 = (cLocalX - v1.x) * (v2.x - v1.x) + (cLocalY - v1.y) * (v2.y - v1.y);
      var u2 = (cLocalX - v2.x) * (v1.x - v2.x) + (cLocalY - v2.y) * (v1.y - v2.y);
      if (u1 <= 0.0) {
         if ((cLocalX - v1.x) * (cLocalX - v1.x) + (cLocalY - v1.y) * (cLocalY - v1.y) > radius * radius) return;
         manifold.m_pointCount = 1;
         manifold.m_type = b2Manifold.e_faceA;
         manifold.m_localPlaneNormal.x = cLocalX - v1.x;
         manifold.m_localPlaneNormal.y = cLocalY - v1.y;
         manifold.m_localPlaneNormal.Normalize();
         manifold.m_localPoint.SetV(v1);
         manifold.m_points[0].m_localPoint.SetV(circle.m_p);
         manifold.m_points[0].m_id.key = 0;
      }
      else if (u2 <= 0) {
         if ((cLocalX - v2.x) * (cLocalX - v2.x) + (cLocalY - v2.y) * (cLocalY - v2.y) > radius * radius) return;
         manifold.m_pointCount = 1;
         manifold.m_type = b2Manifold.e_faceA;
         manifold.m_localPlaneNormal.x = cLocalX - v2.x;
         manifold.m_localPlaneNormal.y = cLocalY - v2.y;
         manifold.m_localPlaneNormal.Normalize();
         manifold.m_localPoint.SetV(v2);
         manifold.m_points[0].m_localPoint.SetV(circle.m_p);
         manifold.m_points[0].m_id.key = 0;
      }
      else {
         var faceCenterX = 0.5 * (v1.x + v2.x);
         var faceCenterY = 0.5 * (v1.y + v2.y);
         separation = (cLocalX - faceCenterX) * normals[vertIndex1].x + (cLocalY - faceCenterY) * normals[vertIndex1].y;
         if (separation > radius) return;
         manifold.m_pointCount = 1;
         manifold.m_type = b2Manifold.e_faceA;
         manifold.m_localPlaneNormal.x = normals[vertIndex1].x;
         manifold.m_localPlaneNormal.y = normals[vertIndex1].y;
         manifold.m_localPlaneNormal.Normalize();
         manifold.m_localPoint.Set(faceCenterX, faceCenterY);
         manifold.m_points[0].m_localPoint.SetV(circle.m_p);
         manifold.m_points[0].m_id.key = 0;
      }
   }
   b2Collision.TestOverlap = function (a, b) {
      var t1 = b.lowerBound;
      var t2 = a.upperBound;
      var d1X = t1.x - t2.x;
      var d1Y = t1.y - t2.y;
      t1 = a.lowerBound;
      t2 = b.upperBound;
      var d2X = t1.x - t2.x;
      var d2Y = t1.y - t2.y;
      if (d1X > 0.0 || d1Y > 0.0) return false;
      if (d2X > 0.0 || d2Y > 0.0) return false;
      return true;
   }
   Box2D.postDefs.push(function () {
      Box2D.Collision.b2Collision.s_incidentEdge = b2Collision.MakeClipPointVector();
      Box2D.Collision.b2Collision.s_clipPoints1 = b2Collision.MakeClipPointVector();
      Box2D.Collision.b2Collision.s_clipPoints2 = b2Collision.MakeClipPointVector();
      Box2D.Collision.b2Collision.s_edgeAO = new Vector_a2j_Number(1);
      Box2D.Collision.b2Collision.s_edgeBO = new Vector_a2j_Number(1);
      Box2D.Collision.b2Collision.s_localTangent = new b2Vec2();
      Box2D.Collision.b2Collision.s_localNormal = new b2Vec2();
      Box2D.Collision.b2Collision.s_planePoint = new b2Vec2();
      Box2D.Collision.b2Collision.s_normal = new b2Vec2();
      Box2D.Collision.b2Collision.s_tangent = new b2Vec2();
      Box2D.Collision.b2Collision.s_tangent2 = new b2Vec2();
      Box2D.Collision.b2Collision.s_v11 = new b2Vec2();
      Box2D.Collision.b2Collision.s_v12 = new b2Vec2();
      Box2D.Collision.b2Collision.b2CollidePolyTempVec = new b2Vec2();
      Box2D.Collision.b2Collision.b2_nullFeature = 0x000000ff;
   });
   b2ContactID.b2ContactID = function () {
      this.features = new Features();
   };
   b2ContactID.prototype.b2ContactID = function () {
      this.features._m_id = this;
   }
   b2ContactID.prototype.Set = function (id) {
      this.key = id._key;
   }
   b2ContactID.prototype.Copy = function () {
      var id = new b2ContactID();
      id.key = this.key;
      return id;
   }
   Object.defineProperty(b2ContactID.prototype, 'key', {
      enumerable: false,
      configurable: true,
      get: function () {
         return this._key;
      }
   });
   Object.defineProperty(b2ContactID.prototype, 'key', {
      enumerable: false,
      configurable: true,
      set: function (value) {
         if (value === undefined) value = 0;
         this._key = value;
         this.features._referenceEdge = this._key & 0x000000ff;
         this.features._incidentEdge = ((this._key & 0x0000ff00) >> 8) & 0x000000ff;
         this.features._incidentVertex = ((this._key & 0x00ff0000) >> 16) & 0x000000ff;
         this.features._flip = ((this._key & 0xff000000) >> 24) & 0x000000ff;
      }
   });
   b2ContactPoint.b2ContactPoint = function () {
      this.position = new b2Vec2();
      this.velocity = new b2Vec2();
      this.normal = new b2Vec2();
      this.id = new b2ContactID();
   };
   b2Distance.b2Distance = function () {};
   b2Distance.Distance = function (output, cache, input) {
      ++b2Distance.b2_gjkCalls;
      var proxyA = input.proxyA;
      var proxyB = input.proxyB;
      var transformA = input.transformA;
      var transformB = input.transformB;
      var simplex = b2Distance.s_simplex;
      simplex.ReadCache(cache, proxyA, transformA, proxyB, transformB);
      var vertices = simplex.m_vertices;
      var k_maxIters = 20;
      var saveA = b2Distance.s_saveA;
      var saveB = b2Distance.s_saveB;
      var saveCount = 0;
      var closestPoint = simplex.GetClosestPoint();
      var distanceSqr1 = closestPoint.LengthSquared();
      var distanceSqr2 = distanceSqr1;
      var i = 0;
      var p;
      var iter = 0;
      while (iter < k_maxIters) {
         saveCount = simplex.m_count;
         for (i = 0;
         i < saveCount; i++) {
            saveA[i] = vertices[i].indexA;
            saveB[i] = vertices[i].indexB;
         }
         switch (simplex.m_count) {
         case 1:
            break;
         case 2:
            simplex.Solve2();
            break;
         case 3:
            simplex.Solve3();
            break;
         default:
            b2Settings.b2Assert(false);
         }
         if (simplex.m_count == 3) {
            break;
         }
         p = simplex.GetClosestPoint();
         distanceSqr2 = p.LengthSquared();
         if (distanceSqr2 > distanceSqr1) {}
         distanceSqr1 = distanceSqr2;
         var d = simplex.GetSearchDirection();
         if (d.LengthSquared() < Number.MIN_VALUE * Number.MIN_VALUE) {
            break;
         }
         var vertex = vertices[simplex.m_count];
         vertex.indexA = proxyA.GetSupport(b2Math.MulTMV(transformA.R, d.GetNegative()));
         vertex.wA = b2Math.MulX(transformA, proxyA.GetVertex(vertex.indexA));
         vertex.indexB = proxyB.GetSupport(b2Math.MulTMV(transformB.R, d));
         vertex.wB = b2Math.MulX(transformB, proxyB.GetVertex(vertex.indexB));
         vertex.w = b2Math.SubtractVV(vertex.wB, vertex.wA);
         ++iter;
         ++b2Distance.b2_gjkIters;
         var duplicate = false;
         for (i = 0;
         i < saveCount; i++) {
            if (vertex.indexA == saveA[i] && vertex.indexB == saveB[i]) {
               duplicate = true;
               break;
            }
         }
         if (duplicate) {
            break;
         }++simplex.m_count;
      }
      b2Distance.b2_gjkMaxIters = b2Math.Max(b2Distance.b2_gjkMaxIters, iter);
      simplex.GetWitnessPoints(output.pointA, output.pointB);
      output.distance = b2Math.SubtractVV(output.pointA, output.pointB).Length();
      output.iterations = iter;
      simplex.WriteCache(cache);
      if (input.useRadii) {
         var rA = proxyA.m_radius;
         var rB = proxyB.m_radius;
         if (output.distance > rA + rB && output.distance > Number.MIN_VALUE) {
            output.distance -= rA + rB;
            var normal = b2Math.SubtractVV(output.pointB, output.pointA);
            normal.Normalize();
            output.pointA.x += rA * normal.x;
            output.pointA.y += rA * normal.y;
            output.pointB.x -= rB * normal.x;
            output.pointB.y -= rB * normal.y;
         }
         else {
            p = new b2Vec2();
            p.x = .5 * (output.pointA.x + output.pointB.x);
            p.y = .5 * (output.pointA.y + output.pointB.y);
            output.pointA.x = output.pointB.x = p.x;
            output.pointA.y = output.pointB.y = p.y;
            output.distance = 0.0;
         }
      }
   }
   Box2D.postDefs.push(function () {
      Box2D.Collision.b2Distance.s_simplex = new b2Simplex();
      Box2D.Collision.b2Distance.s_saveA = new Vector_a2j_Number(3);
      Box2D.Collision.b2Distance.s_saveB = new Vector_a2j_Number(3);
   });
   b2DistanceInput.b2DistanceInput = function () {};
   b2DistanceOutput.b2DistanceOutput = function () {
      this.pointA = new b2Vec2();
      this.pointB = new b2Vec2();
   };
   b2DistanceProxy.b2DistanceProxy = function () {};
   b2DistanceProxy.prototype.Set = function (shape) {
      switch (shape.GetType()) {
      case b2Shape.e_circleShape:
         {
            var circle = (shape instanceof b2CircleShape ? shape : null);
            this.m_vertices = new Vector(1, true);
            this.m_vertices[0] = circle.m_p;
            this.m_count = 1;
            this.m_radius = circle.m_radius;
         }
         break;
      case b2Shape.e_polygonShape:
         {
            var polygon = (shape instanceof b2PolygonShape ? shape : null);
            this.m_vertices = polygon.m_vertices;
            this.m_count = polygon.m_vertexCount;
            this.m_radius = polygon.m_radius;
         }
         break;
      default:
         b2Settings.b2Assert(false);
      }
   }
   b2DistanceProxy.prototype.GetSupport = function (d) {
      var bestIndex = 0;
      var bestValue = this.m_vertices[0].x * d.x + this.m_vertices[0].y * d.y;
      for (var i = 1; i < this.m_count; ++i) {
         var value = this.m_vertices[i].x * d.x + this.m_vertices[i].y * d.y;
         if (value > bestValue) {
            bestIndex = i;
            bestValue = value;
         }
      }
      return bestIndex;
   }
   b2DistanceProxy.prototype.GetSupportVertex = function (d) {
      var bestIndex = 0;
      var bestValue = this.m_vertices[0].x * d.x + this.m_vertices[0].y * d.y;
      for (var i = 1; i < this.m_count; ++i) {
         var value = this.m_vertices[i].x * d.x + this.m_vertices[i].y * d.y;
         if (value > bestValue) {
            bestIndex = i;
            bestValue = value;
         }
      }
      return this.m_vertices[bestIndex];
   }
   b2DistanceProxy.prototype.GetVertexCount = function () {
      return this.m_count;
   }
   b2DistanceProxy.prototype.GetVertex = function (index) {
      if (index === undefined) index = 0;
      b2Settings.b2Assert(0 <= index && index < this.m_count);
      return this.m_vertices[index];
   }
   b2DynamicTree.b2DynamicTree = function () {};
   b2DynamicTree.prototype.b2DynamicTree = function () {
      this.m_root = null;
      this.m_freeList = null;
      this.m_path = 0;
      this.m_insertionCount = 0;
   }
   b2DynamicTree.prototype.CreateProxy = function (aabb, userData) {
      var node = this.AllocateNode();
      var extendX = b2Settings.b2_aabbExtension;
      var extendY = b2Settings.b2_aabbExtension;
      node.aabb.lowerBound.x = aabb.lowerBound.x - extendX;
      node.aabb.lowerBound.y = aabb.lowerBound.y - extendY;
      node.aabb.upperBound.x = aabb.upperBound.x + extendX;
      node.aabb.upperBound.y = aabb.upperBound.y + extendY;
      node.userData = userData;
      this.InsertLeaf(node);
      return node;
   }
   b2DynamicTree.prototype.DestroyProxy = function (proxy) {
      this.RemoveLeaf(proxy);
      this.FreeNode(proxy);
   }
   b2DynamicTree.prototype.MoveProxy = function (proxy, aabb, displacement) {
      b2Settings.b2Assert(proxy.IsLeaf());
      if (proxy.aabb.Contains(aabb)) {
         return false;
      }
      this.RemoveLeaf(proxy);
      var extendX = b2Settings.b2_aabbExtension + b2Settings.b2_aabbMultiplier * (displacement.x > 0 ? displacement.x : (-displacement.x));
      var extendY = b2Settings.b2_aabbExtension + b2Settings.b2_aabbMultiplier * (displacement.y > 0 ? displacement.y : (-displacement.y));
      proxy.aabb.lowerBound.x = aabb.lowerBound.x - extendX;
      proxy.aabb.lowerBound.y = aabb.lowerBound.y - extendY;
      proxy.aabb.upperBound.x = aabb.upperBound.x + extendX;
      proxy.aabb.upperBound.y = aabb.upperBound.y + extendY;
      this.InsertLeaf(proxy);
      return true;
   }
   b2DynamicTree.prototype.Rebalance = function (iterations) {
      if (iterations === undefined) iterations = 0;
      if (this.m_root == null) return;
      for (var i = 0; i < iterations; i++) {
         var node = this.m_root;
         var bit = 0;
         while (node.IsLeaf() == false) {
            node = (this.m_path >> bit) & 1 ? node.child2 : node.child1;
            bit = (bit + 1) & 31;
         }++this.m_path;
         this.RemoveLeaf(node);
         this.InsertLeaf(node);
      }
   }
   b2DynamicTree.prototype.GetFatAABB = function (proxy) {
      return proxy.aabb;
   }
   b2DynamicTree.prototype.GetUserData = function (proxy) {
      return proxy.userData;
   }
   b2DynamicTree.prototype.Query = function (callback, aabb) {
      if (this.m_root == null) return;
      var stack = new Vector();
      var count = 0;
      stack[count++] = this.m_root;
      while (count > 0) {
         var node = stack[--count];
         if (node.aabb.TestOverlap(aabb)) {
            if (node.IsLeaf()) {
               var proceed = callback(node);
               if (!proceed) return;
            }
            else {
               stack[count++] = node.child1;
               stack[count++] = node.child2;
            }
         }
      }
   }
   b2DynamicTree.prototype.RayCast = function (callback, input) {
      if (this.m_root == null) return;
      var p1 = input.p1;
      var p2 = input.p2;
      var r = b2Math.SubtractVV(p1, p2);
      r.Normalize();
      var v = b2Math.CrossFV(1.0, r);
      var abs_v = b2Math.AbsV(v);
      var maxFraction = input.maxFraction;
      var segmentAABB = new b2AABB();
      var tX = 0;
      var tY = 0; {
         tX = p1.x + maxFraction * (p2.x - p1.x);
         tY = p1.y + maxFraction * (p2.y - p1.y);
         segmentAABB.lowerBound.x = Math.min(p1.x, tX);
         segmentAABB.lowerBound.y = Math.min(p1.y, tY);
         segmentAABB.upperBound.x = Math.max(p1.x, tX);
         segmentAABB.upperBound.y = Math.max(p1.y, tY);
      }
      var stack = new Vector();
      var count = 0;
      stack[count++] = this.m_root;
      while (count > 0) {
         var node = stack[--count];
         if (node.aabb.TestOverlap(segmentAABB) == false) {
            continue;
         }
         var c = node.aabb.GetCenter();
         var h = node.aabb.GetExtents();
         var separation = Math.abs(v.x * (p1.x - c.x) + v.y * (p1.y - c.y)) - abs_v.x * h.x - abs_v.y * h.y;
         if (separation > 0.0) continue;
         if (node.IsLeaf()) {
            var subInput = new b2RayCastInput();
            subInput.p1 = input.p1;
            subInput.p2 = input.p2;
            subInput.maxFraction = input.maxFraction;
            maxFraction = callback(subInput, node);
            if (maxFraction == 0.0) return;
            if (maxFraction > 0.0) {
               tX = p1.x + maxFraction * (p2.x - p1.x);
               tY = p1.y + maxFraction * (p2.y - p1.y);
               segmentAABB.lowerBound.x = Math.min(p1.x, tX);
               segmentAABB.lowerBound.y = Math.min(p1.y, tY);
               segmentAABB.upperBound.x = Math.max(p1.x, tX);
               segmentAABB.upperBound.y = Math.max(p1.y, tY);
            }
         }
         else {
            stack[count++] = node.child1;
            stack[count++] = node.child2;
         }
      }
   }
   b2DynamicTree.prototype.AllocateNode = function () {
      if (this.m_freeList) {
         var node = this.m_freeList;
         this.m_freeList = node.parent;
         node.parent = null;
         node.child1 = null;
         node.child2 = null;
         return node;
      }
      return new b2DynamicTreeNode();
   }
   b2DynamicTree.prototype.FreeNode = function (node) {
      node.parent = this.m_freeList;
      this.m_freeList = node;
   }
   b2DynamicTree.prototype.InsertLeaf = function (leaf) {
      ++this.m_insertionCount;
      if (this.m_root == null) {
         this.m_root = leaf;
         this.m_root.parent = null;
         return;
      }
      var center = leaf.aabb.GetCenter();
      var sibling = this.m_root;
      if (sibling.IsLeaf() == false) {
         do {
            var child1 = sibling.child1;
            var child2 = sibling.child2;
            var norm1 = Math.abs((child1.aabb.lowerBound.x + child1.aabb.upperBound.x) / 2 - center.x) + Math.abs((child1.aabb.lowerBound.y + child1.aabb.upperBound.y) / 2 - center.y);
            var norm2 = Math.abs((child2.aabb.lowerBound.x + child2.aabb.upperBound.x) / 2 - center.x) + Math.abs((child2.aabb.lowerBound.y + child2.aabb.upperBound.y) / 2 - center.y);
            if (norm1 < norm2) {
               sibling = child1;
            }
            else {
               sibling = child2;
            }
         }
         while (sibling.IsLeaf() == false)
      }
      var node1 = sibling.parent;
      var node2 = this.AllocateNode();
      node2.parent = node1;
      node2.userData = null;
      node2.aabb.Combine(leaf.aabb, sibling.aabb);
      if (node1) {
         if (sibling.parent.child1 == sibling) {
            node1.child1 = node2;
         }
         else {
            node1.child2 = node2;
         }
         node2.child1 = sibling;
         node2.child2 = leaf;
         sibling.parent = node2;
         leaf.parent = node2;
         do {
            if (node1.aabb.Contains(node2.aabb)) break;
            node1.aabb.Combine(node1.child1.aabb, node1.child2.aabb);
            node2 = node1;
            node1 = node1.parent;
         }
         while (node1)
      }
      else {
         node2.child1 = sibling;
         node2.child2 = leaf;
         sibling.parent = node2;
         leaf.parent = node2;
         this.m_root = node2;
      }
   }
   b2DynamicTree.prototype.RemoveLeaf = function (leaf) {
      if (leaf == this.m_root) {
         this.m_root = null;
         return;
      }
      var node2 = leaf.parent;
      var node1 = node2.parent;
      var sibling;
      if (node2.child1 == leaf) {
         sibling = node2.child2;
      }
      else {
         sibling = node2.child1;
      }
      if (node1) {
         if (node1.child1 == node2) {
            node1.child1 = sibling;
         }
         else {
            node1.child2 = sibling;
         }
         sibling.parent = node1;
         this.FreeNode(node2);
         while (node1) {
            var oldAABB = node1.aabb;
            node1.aabb = b2AABB.Combine(node1.child1.aabb, node1.child2.aabb);
            if (oldAABB.Contains(node1.aabb)) break;
            node1 = node1.parent;
         }
      }
      else {
         this.m_root = sibling;
         sibling.parent = null;
         this.FreeNode(node2);
      }
   }
   b2DynamicTreeBroadPhase.b2DynamicTreeBroadPhase = function () {
      this.m_tree = new b2DynamicTree();
      this.m_moveBuffer = new Vector();
      this.m_pairBuffer = new Vector();
      this.m_pairCount = 0;
   };
   b2DynamicTreeBroadPhase.prototype.CreateProxy = function (aabb, userData) {
      var proxy = this.m_tree.CreateProxy(aabb, userData);
      ++this.m_proxyCount;
      this.BufferMove(proxy);
      return proxy;
   }
   b2DynamicTreeBroadPhase.prototype.DestroyProxy = function (proxy) {
      this.UnBufferMove(proxy);
      --this.m_proxyCount;
      this.m_tree.DestroyProxy(proxy);
   }
   b2DynamicTreeBroadPhase.prototype.MoveProxy = function (proxy, aabb, displacement) {
      var buffer = this.m_tree.MoveProxy(proxy, aabb, displacement);
      if (buffer) {
         this.BufferMove(proxy);
      }
   }
   b2DynamicTreeBroadPhase.prototype.TestOverlap = function (proxyA, proxyB) {
      var aabbA = this.m_tree.GetFatAABB(proxyA);
      var aabbB = this.m_tree.GetFatAABB(proxyB);
      return aabbA.TestOverlap(aabbB);
   }
   b2DynamicTreeBroadPhase.prototype.GetUserData = function (proxy) {
      return this.m_tree.GetUserData(proxy);
   }
   b2DynamicTreeBroadPhase.prototype.GetFatAABB = function (proxy) {
      return this.m_tree.GetFatAABB(proxy);
   }
   b2DynamicTreeBroadPhase.prototype.GetProxyCount = function () {
      return this.m_proxyCount;
   }
   b2DynamicTreeBroadPhase.prototype.UpdatePairs = function (callback) {
      var __this = this;
      __this.m_pairCount = 0;
      var i = 0,
         queryProxy;
      for (i = 0;
      i < __this.m_moveBuffer.length; ++i) {
         queryProxy = __this.m_moveBuffer[i];

         function QueryCallback(proxy) {
            if (proxy == queryProxy) return true;
            if (__this.m_pairCount == __this.m_pairBuffer.length) {
               __this.m_pairBuffer[__this.m_pairCount] = new b2DynamicTreePair();
            }
            var pair = __this.m_pairBuffer[__this.m_pairCount];
            pair.proxyA = proxy < queryProxy ? proxy : queryProxy;
            pair.proxyB = proxy >= queryProxy ? proxy : queryProxy;++__this.m_pairCount;
            return true;
         };
         var fatAABB = __this.m_tree.GetFatAABB(queryProxy);
         __this.m_tree.Query(QueryCallback, fatAABB);
      }
      __this.m_moveBuffer.length = 0;
      for (var i = 0; i < __this.m_pairCount;) {
         var primaryPair = __this.m_pairBuffer[i];
         var userDataA = __this.m_tree.GetUserData(primaryPair.proxyA);
         var userDataB = __this.m_tree.GetUserData(primaryPair.proxyB);
         callback(userDataA, userDataB);
         ++i;
         while (i < __this.m_pairCount) {
            var pair = __this.m_pairBuffer[i];
            if (pair.proxyA != primaryPair.proxyA || pair.proxyB != primaryPair.proxyB) {
               break;
            }++i;
         }
      }
   }
   b2DynamicTreeBroadPhase.prototype.Query = function (callback, aabb) {
      this.m_tree.Query(callback, aabb);
   }
   b2DynamicTreeBroadPhase.prototype.RayCast = function (callback, input) {
      this.m_tree.RayCast(callback, input);
   }
   b2DynamicTreeBroadPhase.prototype.Validate = function () {}
   b2DynamicTreeBroadPhase.prototype.Rebalance = function (iterations) {
      if (iterations === undefined) iterations = 0;
      this.m_tree.Rebalance(iterations);
   }
   b2DynamicTreeBroadPhase.prototype.BufferMove = function (proxy) {
      this.m_moveBuffer[this.m_moveBuffer.length] = proxy;
   }
   b2DynamicTreeBroadPhase.prototype.UnBufferMove = function (proxy) {
      var i = parseInt(this.m_moveBuffer.indexOf(proxy));
      this.m_moveBuffer.splice(i, 1);
   }
   b2DynamicTreeBroadPhase.prototype.ComparePairs = function (pair1, pair2) {
      return 0;
   }
   b2DynamicTreeBroadPhase.__implements = {};
   b2DynamicTreeBroadPhase.__implements[IBroadPhase] = true;
   b2DynamicTreeNode.b2DynamicTreeNode = function () {
      this.aabb = new b2AABB();
   };
   b2DynamicTreeNode.prototype.IsLeaf = function () {
      return this.child1 == null;
   }
   b2DynamicTreePair.b2DynamicTreePair = function () {};
   b2Manifold.b2Manifold = function () {
      this.m_pointCount = 0;
   };
   b2Manifold.prototype.b2Manifold = function () {
      this.m_points = new Vector(b2Settings.b2_maxManifoldPoints);
      for (var i = 0; i < b2Settings.b2_maxManifoldPoints; i++) {
         this.m_points[i] = new b2ManifoldPoint();
      }
      this.m_localPlaneNormal = new b2Vec2();
      this.m_localPoint = new b2Vec2();
   }
   b2Manifold.prototype.Reset = function () {
      for (var i = 0; i < b2Settings.b2_maxManifoldPoints; i++) {
         ((this.m_points[i] instanceof b2ManifoldPoint ? this.m_points[i] : null)).Reset();
      }
      this.m_localPlaneNormal.SetZero();
      this.m_localPoint.SetZero();
      this.m_type = 0;
      this.m_pointCount = 0;
   }
   b2Manifold.prototype.Set = function (m) {
      this.m_pointCount = m.m_pointCount;
      for (var i = 0; i < b2Settings.b2_maxManifoldPoints; i++) {
         ((this.m_points[i] instanceof b2ManifoldPoint ? this.m_points[i] : null)).Set(m.m_points[i]);
      }
      this.m_localPlaneNormal.SetV(m.m_localPlaneNormal);
      this.m_localPoint.SetV(m.m_localPoint);
      this.m_type = m.m_type;
   }
   b2Manifold.prototype.Copy = function () {
      var copy = new b2Manifold();
      copy.Set(this);
      return copy;
   }
   Box2D.postDefs.push(function () {
      Box2D.Collision.b2Manifold.e_circles = 0x0001;
      Box2D.Collision.b2Manifold.e_faceA = 0x0002;
      Box2D.Collision.b2Manifold.e_faceB = 0x0004;
   });
   b2ManifoldPoint.b2ManifoldPoint = function () {
      this.m_localPoint = new b2Vec2();
      this.m_id = new b2ContactID();
   };
   b2ManifoldPoint.prototype.b2ManifoldPoint = function () {
      this.Reset();
   }
   b2ManifoldPoint.prototype.Reset = function () {
      this.m_localPoint.SetZero();
      this.m_normalImpulse = 0.0;
      this.m_tangentImpulse = 0.0;
      this.m_id.key = 0;
   }
   b2ManifoldPoint.prototype.Set = function (m) {
      this.m_localPoint.SetV(m.m_localPoint);
      this.m_normalImpulse = m.m_normalImpulse;
      this.m_tangentImpulse = m.m_tangentImpulse;
      this.m_id.Set(m.m_id);
   }
   b2Point.b2Point = function () {
      this.p = new b2Vec2();
   };
   b2Point.prototype.Support = function (xf, vX, vY) {
      if (vX === undefined) vX = 0;
      if (vY === undefined) vY = 0;
      return this.p;
   }
   b2Point.prototype.GetFirstVertex = function (xf) {
      return this.p;
   }
   b2RayCastInput.b2RayCastInput = function () {
      this.p1 = new b2Vec2();
      this.p2 = new b2Vec2();
   };
   b2RayCastInput.prototype.b2RayCastInput = function (p1, p2, maxFraction) {
      if (p1 === undefined) p1 = null;
      if (p2 === undefined) p2 = null;
      if (maxFraction === undefined) maxFraction = 1;
      if (p1) this.p1.SetV(p1);
      if (p2) this.p2.SetV(p2);
      this.maxFraction = maxFraction;
   }
   b2RayCastOutput.b2RayCastOutput = function () {
      this.normal = new b2Vec2();
   };
   b2Segment.b2Segment = function () {
      this.p1 = new b2Vec2();
      this.p2 = new b2Vec2();
   };
   b2Segment.prototype.TestSegment = function (lambda, normal, segment, maxLambda) {
      if (maxLambda === undefined) maxLambda = 0;
      var s = segment.p1;
      var rX = segment.p2.x - s.x;
      var rY = segment.p2.y - s.y;
      var dX = this.p2.x - this.p1.x;
      var dY = this.p2.y - this.p1.y;
      var nX = dY;
      var nY = (-dX);
      var k_slop = 100.0 * Number.MIN_VALUE;
      var denom = (-(rX * nX + rY * nY));
      if (denom > k_slop) {
         var bX = s.x - this.p1.x;
         var bY = s.y - this.p1.y;
         var a = (bX * nX + bY * nY);
         if (0.0 <= a && a <= maxLambda * denom) {
            var mu2 = (-rX * bY) + rY * bX;
            if ((-k_slop * denom) <= mu2 && mu2 <= denom * (1.0 + k_slop)) {
               a /= denom;
               var nLen = Math.sqrt(nX * nX + nY * nY);
               nX /= nLen;
               nY /= nLen;
               lambda[0] = a;
               normal.Set(nX, nY);
               return true;
            }
         }
      }
      return false;
   }
   b2Segment.prototype.Extend = function (aabb) {
      this.ExtendForward(aabb);
      this.ExtendBackward(aabb);
   }
   b2Segment.prototype.ExtendForward = function (aabb) {
      var dX = this.p2.x - this.p1.x;
      var dY = this.p2.y - this.p1.y;
      var lambda = Math.min(dX > 0 ? (aabb.upperBound.x - this.p1.x) / dX : dX < 0 ? (aabb.lowerBound.x - this.p1.x) / dX : Number.POSITIVE_INFINITY,
      dY > 0 ? (aabb.upperBound.y - this.p1.y) / dY : dY < 0 ? (aabb.lowerBound.y - this.p1.y) / dY : Number.POSITIVE_INFINITY);
      this.p2.x = this.p1.x + dX * lambda;
      this.p2.y = this.p1.y + dY * lambda;
   }
   b2Segment.prototype.ExtendBackward = function (aabb) {
      var dX = (-this.p2.x) + this.p1.x;
      var dY = (-this.p2.y) + this.p1.y;
      var lambda = Math.min(dX > 0 ? (aabb.upperBound.x - this.p2.x) / dX : dX < 0 ? (aabb.lowerBound.x - this.p2.x) / dX : Number.POSITIVE_INFINITY,
      dY > 0 ? (aabb.upperBound.y - this.p2.y) / dY : dY < 0 ? (aabb.lowerBound.y - this.p2.y) / dY : Number.POSITIVE_INFINITY);
      this.p1.x = this.p2.x + dX * lambda;
      this.p1.y = this.p2.y + dY * lambda;
   }
   b2SeparationFunction.b2SeparationFunction = function () {
      this.m_localPoint = new b2Vec2();
      this.m_axis = new b2Vec2();
   };
   b2SeparationFunction.prototype.Initialize = function (cache, proxyA, transformA, proxyB, transformB) {
      this.m_proxyA = proxyA;
      this.m_proxyB = proxyB;
      var count = parseInt(cache.count);
      b2Settings.b2Assert(0 < count && count < 3);
      var localPointA;
      var localPointA1;
      var localPointA2;
      var localPointB;
      var localPointB1;
      var localPointB2;
      var pointAX = 0;
      var pointAY = 0;
      var pointBX = 0;
      var pointBY = 0;
      var normalX = 0;
      var normalY = 0;
      var tMat;
      var tVec;
      var s = 0;
      var sgn = 0;
      if (count == 1) {
         this.m_type = b2SeparationFunction.e_points;
         localPointA = this.m_proxyA.GetVertex(cache.indexA[0]);
         localPointB = this.m_proxyB.GetVertex(cache.indexB[0]);
         tVec = localPointA;
         tMat = transformA.R;
         pointAX = transformA.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
         pointAY = transformA.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
         tVec = localPointB;
         tMat = transformB.R;
         pointBX = transformB.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
         pointBY = transformB.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
         this.m_axis.x = pointBX - pointAX;
         this.m_axis.y = pointBY - pointAY;
         this.m_axis.Normalize();
      }
      else if (cache.indexB[0] == cache.indexB[1]) {
         this.m_type = b2SeparationFunction.e_faceA;
         localPointA1 = this.m_proxyA.GetVertex(cache.indexA[0]);
         localPointA2 = this.m_proxyA.GetVertex(cache.indexA[1]);
         localPointB = this.m_proxyB.GetVertex(cache.indexB[0]);
         this.m_localPoint.x = 0.5 * (localPointA1.x + localPointA2.x);
         this.m_localPoint.y = 0.5 * (localPointA1.y + localPointA2.y);
         this.m_axis = b2Math.CrossVF(b2Math.SubtractVV(localPointA2, localPointA1), 1.0);
         this.m_axis.Normalize();
         tVec = this.m_axis;
         tMat = transformA.R;
         normalX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
         normalY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
         tVec = this.m_localPoint;
         tMat = transformA.R;
         pointAX = transformA.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
         pointAY = transformA.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
         tVec = localPointB;
         tMat = transformB.R;
         pointBX = transformB.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
         pointBY = transformB.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
         s = (pointBX - pointAX) * normalX + (pointBY - pointAY) * normalY;
         if (s < 0.0) {
            this.m_axis.NegativeSelf();
         }
      }
      else if (cache.indexA[0] == cache.indexA[0]) {
         this.m_type = b2SeparationFunction.e_faceB;
         localPointB1 = this.m_proxyB.GetVertex(cache.indexB[0]);
         localPointB2 = this.m_proxyB.GetVertex(cache.indexB[1]);
         localPointA = this.m_proxyA.GetVertex(cache.indexA[0]);
         this.m_localPoint.x = 0.5 * (localPointB1.x + localPointB2.x);
         this.m_localPoint.y = 0.5 * (localPointB1.y + localPointB2.y);
         this.m_axis = b2Math.CrossVF(b2Math.SubtractVV(localPointB2, localPointB1), 1.0);
         this.m_axis.Normalize();
         tVec = this.m_axis;
         tMat = transformB.R;
         normalX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
         normalY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
         tVec = this.m_localPoint;
         tMat = transformB.R;
         pointBX = transformB.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
         pointBY = transformB.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
         tVec = localPointA;
         tMat = transformA.R;
         pointAX = transformA.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
         pointAY = transformA.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
         s = (pointAX - pointBX) * normalX + (pointAY - pointBY) * normalY;
         if (s < 0.0) {
            this.m_axis.NegativeSelf();
         }
      }
      else {
         localPointA1 = this.m_proxyA.GetVertex(cache.indexA[0]);
         localPointA2 = this.m_proxyA.GetVertex(cache.indexA[1]);
         localPointB1 = this.m_proxyB.GetVertex(cache.indexB[0]);
         localPointB2 = this.m_proxyB.GetVertex(cache.indexB[1]);
         var pA = b2Math.MulX(transformA, localPointA);
         var dA = b2Math.MulMV(transformA.R, b2Math.SubtractVV(localPointA2, localPointA1));
         var pB = b2Math.MulX(transformB, localPointB);
         var dB = b2Math.MulMV(transformB.R, b2Math.SubtractVV(localPointB2, localPointB1));
         var a = dA.x * dA.x + dA.y * dA.y;
         var e = dB.x * dB.x + dB.y * dB.y;
         var r = b2Math.SubtractVV(dB, dA);
         var c = dA.x * r.x + dA.y * r.y;
         var f = dB.x * r.x + dB.y * r.y;
         var b = dA.x * dB.x + dA.y * dB.y;
         var denom = a * e - b * b;
         s = 0.0;
         if (denom != 0.0) {
            s = b2Math.Clamp((b * f - c * e) / denom, 0.0, 1.0);
         }
         var t = (b * s + f) / e;
         if (t < 0.0) {
            t = 0.0;
            s = b2Math.Clamp((b - c) / a, 0.0, 1.0);
         }
         localPointA = new b2Vec2();
         localPointA.x = localPointA1.x + s * (localPointA2.x - localPointA1.x);
         localPointA.y = localPointA1.y + s * (localPointA2.y - localPointA1.y);
         localPointB = new b2Vec2();
         localPointB.x = localPointB1.x + s * (localPointB2.x - localPointB1.x);
         localPointB.y = localPointB1.y + s * (localPointB2.y - localPointB1.y);
         if (s == 0.0 || s == 1.0) {
            this.m_type = b2SeparationFunction.e_faceB;
            this.m_axis = b2Math.CrossVF(b2Math.SubtractVV(localPointB2, localPointB1), 1.0);
            this.m_axis.Normalize();
            this.m_localPoint = localPointB;
            tVec = this.m_axis;
            tMat = transformB.R;
            normalX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
            normalY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
            tVec = this.m_localPoint;
            tMat = transformB.R;
            pointBX = transformB.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
            pointBY = transformB.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
            tVec = localPointA;
            tMat = transformA.R;
            pointAX = transformA.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
            pointAY = transformA.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
            sgn = (pointAX - pointBX) * normalX + (pointAY - pointBY) * normalY;
            if (s < 0.0) {
               this.m_axis.NegativeSelf();
            }
         }
         else {
            this.m_type = b2SeparationFunction.e_faceA;
            this.m_axis = b2Math.CrossVF(b2Math.SubtractVV(localPointA2, localPointA1), 1.0);
            this.m_localPoint = localPointA;
            tVec = this.m_axis;
            tMat = transformA.R;
            normalX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
            normalY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
            tVec = this.m_localPoint;
            tMat = transformA.R;
            pointAX = transformA.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
            pointAY = transformA.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
            tVec = localPointB;
            tMat = transformB.R;
            pointBX = transformB.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
            pointBY = transformB.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
            sgn = (pointBX - pointAX) * normalX + (pointBY - pointAY) * normalY;
            if (s < 0.0) {
               this.m_axis.NegativeSelf();
            }
         }
      }
   }
   b2SeparationFunction.prototype.Evaluate = function (transformA, transformB) {
      var axisA;
      var axisB;
      var localPointA;
      var localPointB;
      var pointA;
      var pointB;
      var seperation = 0;
      var normal;
      switch (this.m_type) {
      case b2SeparationFunction.e_points:
         {
            axisA = b2Math.MulTMV(transformA.R, this.m_axis);
            axisB = b2Math.MulTMV(transformB.R, this.m_axis.GetNegative());
            localPointA = this.m_proxyA.GetSupportVertex(axisA);
            localPointB = this.m_proxyB.GetSupportVertex(axisB);
            pointA = b2Math.MulX(transformA, localPointA);
            pointB = b2Math.MulX(transformB, localPointB);
            seperation = (pointB.x - pointA.x) * this.m_axis.x + (pointB.y - pointA.y) * this.m_axis.y;
            return seperation;
         }
      case b2SeparationFunction.e_faceA:
         {
            normal = b2Math.MulMV(transformA.R, this.m_axis);
            pointA = b2Math.MulX(transformA, this.m_localPoint);
            axisB = b2Math.MulTMV(transformB.R, normal.GetNegative());
            localPointB = this.m_proxyB.GetSupportVertex(axisB);
            pointB = b2Math.MulX(transformB, localPointB);
            seperation = (pointB.x - pointA.x) * normal.x + (pointB.y - pointA.y) * normal.y;
            return seperation;
         }
      case b2SeparationFunction.e_faceB:
         {
            normal = b2Math.MulMV(transformB.R, this.m_axis);
            pointB = b2Math.MulX(transformB, this.m_localPoint);
            axisA = b2Math.MulTMV(transformA.R, normal.GetNegative());
            localPointA = this.m_proxyA.GetSupportVertex(axisA);
            pointA = b2Math.MulX(transformA, localPointA);
            seperation = (pointA.x - pointB.x) * normal.x + (pointA.y - pointB.y) * normal.y;
            return seperation;
         }
      default:
         b2Settings.b2Assert(false);
         return 0.0;
      }
   }
   Box2D.postDefs.push(function () {
      Box2D.Collision.b2SeparationFunction.e_points = 0x01;
      Box2D.Collision.b2SeparationFunction.e_faceA = 0x02;
      Box2D.Collision.b2SeparationFunction.e_faceB = 0x04;
   });
   b2Simplex.b2Simplex = function () {
      this.m_v1 = new b2SimplexVertex();
      this.m_v2 = new b2SimplexVertex();
      this.m_v3 = new b2SimplexVertex();
      this.m_vertices = new Vector(3);
   };
   b2Simplex.prototype.b2Simplex = function () {
      this.m_vertices[0] = this.m_v1;
      this.m_vertices[1] = this.m_v2;
      this.m_vertices[2] = this.m_v3;
   }
   b2Simplex.prototype.ReadCache = function (cache, proxyA, transformA, proxyB, transformB) {
      b2Settings.b2Assert(0 <= cache.count && cache.count <= 3);
      var wALocal;
      var wBLocal;
      this.m_count = cache.count;
      var vertices = this.m_vertices;
      for (var i = 0; i < this.m_count; i++) {
         var v = vertices[i];
         v.indexA = cache.indexA[i];
         v.indexB = cache.indexB[i];
         wALocal = proxyA.GetVertex(v.indexA);
         wBLocal = proxyB.GetVertex(v.indexB);
         v.wA = b2Math.MulX(transformA, wALocal);
         v.wB = b2Math.MulX(transformB, wBLocal);
         v.w = b2Math.SubtractVV(v.wB, v.wA);
         v.a = 0;
      }
      if (this.m_count > 1) {
         var metric1 = cache.metric;
         var metric2 = this.GetMetric();
         if (metric2 < .5 * metric1 || 2.0 * metric1 < metric2 || metric2 < Number.MIN_VALUE) {
            this.m_count = 0;
         }
      }
      if (this.m_count == 0) {
         v = vertices[0];
         v.indexA = 0;
         v.indexB = 0;
         wALocal = proxyA.GetVertex(0);
         wBLocal = proxyB.GetVertex(0);
         v.wA = b2Math.MulX(transformA, wALocal);
         v.wB = b2Math.MulX(transformB, wBLocal);
         v.w = b2Math.SubtractVV(v.wB, v.wA);
         this.m_count = 1;
      }
   }
   b2Simplex.prototype.WriteCache = function (cache) {
      cache.metric = this.GetMetric();
      cache.count = Box2D.parseUInt(this.m_count);
      var vertices = this.m_vertices;
      for (var i = 0; i < this.m_count; i++) {
         cache.indexA[i] = Box2D.parseUInt(vertices[i].indexA);
         cache.indexB[i] = Box2D.parseUInt(vertices[i].indexB);
      }
   }
   b2Simplex.prototype.GetSearchDirection = function () {
      switch (this.m_count) {
      case 1:
         return this.m_v1.w.GetNegative();
      case 2:
         {
            var e12 = b2Math.SubtractVV(this.m_v2.w, this.m_v1.w);
            var sgn = b2Math.CrossVV(e12, this.m_v1.w.GetNegative());
            if (sgn > 0.0) {
               return b2Math.CrossFV(1.0, e12);
            }
            else {
               return b2Math.CrossVF(e12, 1.0);
            }
         }
      default:
         b2Settings.b2Assert(false);
         return new b2Vec2();
      }
   }
   b2Simplex.prototype.GetClosestPoint = function () {
      switch (this.m_count) {
      case 0:
         b2Settings.b2Assert(false);
         return new b2Vec2();
      case 1:
         return this.m_v1.w;
      case 2:
         return new b2Vec2(this.m_v1.a * this.m_v1.w.x + this.m_v2.a * this.m_v2.w.x, this.m_v1.a * this.m_v1.w.y + this.m_v2.a * this.m_v2.w.y);
      default:
         b2Settings.b2Assert(false);
         return new b2Vec2();
      }
   }
   b2Simplex.prototype.GetWitnessPoints = function (pA, pB) {
      switch (this.m_count) {
      case 0:
         b2Settings.b2Assert(false);
         break;
      case 1:
         pA.SetV(this.m_v1.wA);
         pB.SetV(this.m_v1.wB);
         break;
      case 2:
         pA.x = this.m_v1.a * this.m_v1.wA.x + this.m_v2.a * this.m_v2.wA.x;
         pA.y = this.m_v1.a * this.m_v1.wA.y + this.m_v2.a * this.m_v2.wA.y;
         pB.x = this.m_v1.a * this.m_v1.wB.x + this.m_v2.a * this.m_v2.wB.x;
         pB.y = this.m_v1.a * this.m_v1.wB.y + this.m_v2.a * this.m_v2.wB.y;
         break;
      case 3:
         pB.x = pA.x = this.m_v1.a * this.m_v1.wA.x + this.m_v2.a * this.m_v2.wA.x + this.m_v3.a * this.m_v3.wA.x;
         pB.y = pA.y = this.m_v1.a * this.m_v1.wA.y + this.m_v2.a * this.m_v2.wA.y + this.m_v3.a * this.m_v3.wA.y;
         break;
      default:
         b2Settings.b2Assert(false);
         break;
      }
   }
   b2Simplex.prototype.GetMetric = function () {
      switch (this.m_count) {
      case 0:
         b2Settings.b2Assert(false);
         return 0.0;
      case 1:
         return 0.0;
      case 2:
         return b2Math.SubtractVV(this.m_v1.w, this.m_v2.w).Length();
      case 3:
         return b2Math.CrossVV(b2Math.SubtractVV(this.m_v2.w, this.m_v1.w), b2Math.SubtractVV(this.m_v3.w, this.m_v1.w));
      default:
         b2Settings.b2Assert(false);
         return 0.0;
      }
   }
   b2Simplex.prototype.Solve2 = function () {
      var w1 = this.m_v1.w;
      var w2 = this.m_v2.w;
      var e12 = b2Math.SubtractVV(w2, w1);
      var d12_2 = (-(w1.x * e12.x + w1.y * e12.y));
      if (d12_2 <= 0.0) {
         this.m_v1.a = 1.0;
         this.m_count = 1;
         return;
      }
      var d12_1 = (w2.x * e12.x + w2.y * e12.y);
      if (d12_1 <= 0.0) {
         this.m_v2.a = 1.0;
         this.m_count = 1;
         this.m_v1.Set(this.m_v2);
         return;
      }
      var inv_d12 = 1.0 / (d12_1 + d12_2);
      this.m_v1.a = d12_1 * inv_d12;
      this.m_v2.a = d12_2 * inv_d12;
      this.m_count = 2;
   }
   b2Simplex.prototype.Solve3 = function () {
      var w1 = this.m_v1.w;
      var w2 = this.m_v2.w;
      var w3 = this.m_v3.w;
      var e12 = b2Math.SubtractVV(w2, w1);
      var w1e12 = b2Math.Dot(w1, e12);
      var w2e12 = b2Math.Dot(w2, e12);
      var d12_1 = w2e12;
      var d12_2 = (-w1e12);
      var e13 = b2Math.SubtractVV(w3, w1);
      var w1e13 = b2Math.Dot(w1, e13);
      var w3e13 = b2Math.Dot(w3, e13);
      var d13_1 = w3e13;
      var d13_2 = (-w1e13);
      var e23 = b2Math.SubtractVV(w3, w2);
      var w2e23 = b2Math.Dot(w2, e23);
      var w3e23 = b2Math.Dot(w3, e23);
      var d23_1 = w3e23;
      var d23_2 = (-w2e23);
      var n123 = b2Math.CrossVV(e12, e13);
      var d123_1 = n123 * b2Math.CrossVV(w2, w3);
      var d123_2 = n123 * b2Math.CrossVV(w3, w1);
      var d123_3 = n123 * b2Math.CrossVV(w1, w2);
      if (d12_2 <= 0.0 && d13_2 <= 0.0) {
         this.m_v1.a = 1.0;
         this.m_count = 1;
         return;
      }
      if (d12_1 > 0.0 && d12_2 > 0.0 && d123_3 <= 0.0) {
         var inv_d12 = 1.0 / (d12_1 + d12_2);
         this.m_v1.a = d12_1 * inv_d12;
         this.m_v2.a = d12_2 * inv_d12;
         this.m_count = 2;
         return;
      }
      if (d13_1 > 0.0 && d13_2 > 0.0 && d123_2 <= 0.0) {
         var inv_d13 = 1.0 / (d13_1 + d13_2);
         this.m_v1.a = d13_1 * inv_d13;
         this.m_v3.a = d13_2 * inv_d13;
         this.m_count = 2;
         this.m_v2.Set(this.m_v3);
         return;
      }
      if (d12_1 <= 0.0 && d23_2 <= 0.0) {
         this.m_v2.a = 1.0;
         this.m_count = 1;
         this.m_v1.Set(this.m_v2);
         return;
      }
      if (d13_1 <= 0.0 && d23_1 <= 0.0) {
         this.m_v3.a = 1.0;
         this.m_count = 1;
         this.m_v1.Set(this.m_v3);
         return;
      }
      if (d23_1 > 0.0 && d23_2 > 0.0 && d123_1 <= 0.0) {
         var inv_d23 = 1.0 / (d23_1 + d23_2);
         this.m_v2.a = d23_1 * inv_d23;
         this.m_v3.a = d23_2 * inv_d23;
         this.m_count = 2;
         this.m_v1.Set(this.m_v3);
         return;
      }
      var inv_d123 = 1.0 / (d123_1 + d123_2 + d123_3);
      this.m_v1.a = d123_1 * inv_d123;
      this.m_v2.a = d123_2 * inv_d123;
      this.m_v3.a = d123_3 * inv_d123;
      this.m_count = 3;
   }
   b2SimplexCache.b2SimplexCache = function () {
      this.indexA = new Vector_a2j_Number(3);
      this.indexB = new Vector_a2j_Number(3);
   };
   b2SimplexVertex.b2SimplexVertex = function () {};
   b2SimplexVertex.prototype.Set = function (other) {
      this.wA.SetV(other.wA);
      this.wB.SetV(other.wB);
      this.w.SetV(other.w);
      this.a = other.a;
      this.indexA = other.indexA;
      this.indexB = other.indexB;
   }
   b2TimeOfImpact.b2TimeOfImpact = function () {};
   b2TimeOfImpact.TimeOfImpact = function (input) {
      ++b2TimeOfImpact.b2_toiCalls;
      var proxyA = input.proxyA;
      var proxyB = input.proxyB;
      var sweepA = input.sweepA;
      var sweepB = input.sweepB;
      b2Settings.b2Assert(sweepA.t0 == sweepB.t0);
      b2Settings.b2Assert(1.0 - sweepA.t0 > Number.MIN_VALUE);
      var radius = proxyA.m_radius + proxyB.m_radius;
      var tolerance = input.tolerance;
      var alpha = 0.0;
      var k_maxIterations = 1000;
      var iter = 0;
      var target = 0.0;
      b2TimeOfImpact.s_cache.count = 0;
      b2TimeOfImpact.s_distanceInput.useRadii = false;
      for (;;) {
         sweepA.GetTransform(b2TimeOfImpact.s_xfA, alpha);
         sweepB.GetTransform(b2TimeOfImpact.s_xfB, alpha);
         b2TimeOfImpact.s_distanceInput.proxyA = proxyA;
         b2TimeOfImpact.s_distanceInput.proxyB = proxyB;
         b2TimeOfImpact.s_distanceInput.transformA = b2TimeOfImpact.s_xfA;
         b2TimeOfImpact.s_distanceInput.transformB = b2TimeOfImpact.s_xfB;
         b2Distance.Distance(b2TimeOfImpact.s_distanceOutput, b2TimeOfImpact.s_cache, b2TimeOfImpact.s_distanceInput);
         if (b2TimeOfImpact.s_distanceOutput.distance <= 0.0) {
            alpha = 1.0;
            break;
         }
         b2TimeOfImpact.s_fcn.Initialize(b2TimeOfImpact.s_cache, proxyA, b2TimeOfImpact.s_xfA, proxyB, b2TimeOfImpact.s_xfB);
         var separation = b2TimeOfImpact.s_fcn.Evaluate(b2TimeOfImpact.s_xfA, b2TimeOfImpact.s_xfB);
         if (separation <= 0.0) {
            alpha = 1.0;
            break;
         }
         if (iter == 0) {
            if (separation > radius) {
               target = b2Math.Max(radius - tolerance, 0.75 * radius);
            }
            else {
               target = b2Math.Max(separation - tolerance, 0.02 * radius);
            }
         }
         if (separation - target < 0.5 * tolerance) {
            if (iter == 0) {
               alpha = 1.0;
               break;
            }
            break;
         }
         var newAlpha = alpha; {
            var x1 = alpha;
            var x2 = 1.0;
            var f1 = separation;
            sweepA.GetTransform(b2TimeOfImpact.s_xfA, x2);
            sweepB.GetTransform(b2TimeOfImpact.s_xfB, x2);
            var f2 = b2TimeOfImpact.s_fcn.Evaluate(b2TimeOfImpact.s_xfA, b2TimeOfImpact.s_xfB);
            if (f2 >= target) {
               alpha = 1.0;
               break;
            }
            var rootIterCount = 0;
            for (;;) {
               var x = 0;
               if (rootIterCount & 1) {
                  x = x1 + (target - f1) * (x2 - x1) / (f2 - f1);
               }
               else {
                  x = 0.5 * (x1 + x2);
               }
               sweepA.GetTransform(b2TimeOfImpact.s_xfA, x);
               sweepB.GetTransform(b2TimeOfImpact.s_xfB, x);
               var f = b2TimeOfImpact.s_fcn.Evaluate(b2TimeOfImpact.s_xfA, b2TimeOfImpact.s_xfB);
               if (b2Math.Abs(f - target) < 0.025 * tolerance) {
                  newAlpha = x;
                  break;
               }
               if (f > target) {
                  x1 = x;
                  f1 = f;
               }
               else {
                  x2 = x;
                  f2 = f;
               }++rootIterCount;
               ++b2TimeOfImpact.b2_toiRootIters;
               if (rootIterCount == 50) {
                  break;
               }
            }
            b2TimeOfImpact.b2_toiMaxRootIters = b2Math.Max(b2TimeOfImpact.b2_toiMaxRootIters, rootIterCount);
         }
         if (newAlpha < (1.0 + 100.0 * Number.MIN_VALUE) * alpha) {
            break;
         }
         alpha = newAlpha;
         iter++;
         ++b2TimeOfImpact.b2_toiIters;
         if (iter == k_maxIterations) {
            break;
         }
      }
      b2TimeOfImpact.b2_toiMaxIters = b2Math.Max(b2TimeOfImpact.b2_toiMaxIters, iter);
      return alpha;
   }
   Box2D.postDefs.push(function () {
      Box2D.Collision.b2TimeOfImpact.b2_toiCalls = 0;
      Box2D.Collision.b2TimeOfImpact.b2_toiIters = 0;
      Box2D.Collision.b2TimeOfImpact.b2_toiMaxIters = 0;
      Box2D.Collision.b2TimeOfImpact.b2_toiRootIters = 0;
      Box2D.Collision.b2TimeOfImpact.b2_toiMaxRootIters = 0;
      Box2D.Collision.b2TimeOfImpact.s_cache = new b2SimplexCache();
      Box2D.Collision.b2TimeOfImpact.s_distanceInput = new b2DistanceInput();
      Box2D.Collision.b2TimeOfImpact.s_xfA = new b2Transform();
      Box2D.Collision.b2TimeOfImpact.s_xfB = new b2Transform();
      Box2D.Collision.b2TimeOfImpact.s_fcn = new b2SeparationFunction();
      Box2D.Collision.b2TimeOfImpact.s_distanceOutput = new b2DistanceOutput();
   });
   b2TOIInput.b2TOIInput = function () {
      this.proxyA = new b2DistanceProxy();
      this.proxyB = new b2DistanceProxy();
      this.sweepA = new b2Sweep();
      this.sweepB = new b2Sweep();
   };
   b2WorldManifold.b2WorldManifold = function () {
      this.m_normal = new b2Vec2();
   };
   b2WorldManifold.prototype.b2WorldManifold = function () {
      this.m_points = new Vector(b2Settings.b2_maxManifoldPoints);
      for (var i = 0; i < b2Settings.b2_maxManifoldPoints; i++) {
         this.m_points[i] = new b2Vec2();
      }
   }
   b2WorldManifold.prototype.Initialize = function (manifold, xfA, radiusA, xfB, radiusB) {
      if (radiusA === undefined) radiusA = 0;
      if (radiusB === undefined) radiusB = 0;
      if (manifold.m_pointCount == 0) {
         return;
      }
      var i = 0;
      var tVec;
      var tMat;
      var normalX = 0;
      var normalY = 0;
      var planePointX = 0;
      var planePointY = 0;
      var clipPointX = 0;
      var clipPointY = 0;
      switch (manifold.m_type) {
      case b2Manifold.e_circles:
         {
            tMat = xfA.R;
            tVec = manifold.m_localPoint;
            var pointAX = xfA.position.x + tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
            var pointAY = xfA.position.y + tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
            tMat = xfB.R;
            tVec = manifold.m_points[0].m_localPoint;
            var pointBX = xfB.position.x + tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
            var pointBY = xfB.position.y + tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
            var dX = pointBX - pointAX;
            var dY = pointBY - pointAY;
            var d2 = dX * dX + dY * dY;
            if (d2 > Number.MIN_VALUE * Number.MIN_VALUE) {
               var d = Math.sqrt(d2);
               this.m_normal.x = dX / d;
               this.m_normal.y = dY / d;
            }
            else {
               this.m_normal.x = 1;
               this.m_normal.y = 0;
            }
            var cAX = pointAX + radiusA * this.m_normal.x;
            var cAY = pointAY + radiusA * this.m_normal.y;
            var cBX = pointBX - radiusB * this.m_normal.x;
            var cBY = pointBY - radiusB * this.m_normal.y;
            this.m_points[0].x = 0.5 * (cAX + cBX);
            this.m_points[0].y = 0.5 * (cAY + cBY);
         }
         break;
      case b2Manifold.e_faceA:
         {
            tMat = xfA.R;
            tVec = manifold.m_localPlaneNormal;
            normalX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
            normalY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
            tMat = xfA.R;
            tVec = manifold.m_localPoint;
            planePointX = xfA.position.x + tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
            planePointY = xfA.position.y + tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
            this.m_normal.x = normalX;
            this.m_normal.y = normalY;
            for (i = 0;
            i < manifold.m_pointCount; i++) {
               tMat = xfB.R;
               tVec = manifold.m_points[i].m_localPoint;
               clipPointX = xfB.position.x + tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
               clipPointY = xfB.position.y + tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
               this.m_points[i].x = clipPointX + 0.5 * (radiusA - (clipPointX - planePointX) * normalX - (clipPointY - planePointY) * normalY - radiusB) * normalX;
               this.m_points[i].y = clipPointY + 0.5 * (radiusA - (clipPointX - planePointX) * normalX - (clipPointY - planePointY) * normalY - radiusB) * normalY;
            }
         }
         break;
      case b2Manifold.e_faceB:
         {
            tMat = xfB.R;
            tVec = manifold.m_localPlaneNormal;
            normalX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
            normalY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
            tMat = xfB.R;
            tVec = manifold.m_localPoint;
            planePointX = xfB.position.x + tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
            planePointY = xfB.position.y + tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
            this.m_normal.x = (-normalX);
            this.m_normal.y = (-normalY);
            for (i = 0;
            i < manifold.m_pointCount; i++) {
               tMat = xfA.R;
               tVec = manifold.m_points[i].m_localPoint;
               clipPointX = xfA.position.x + tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
               clipPointY = xfA.position.y + tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
               this.m_points[i].x = clipPointX + 0.5 * (radiusB - (clipPointX - planePointX) * normalX - (clipPointY - planePointY) * normalY - radiusA) * normalX;
               this.m_points[i].y = clipPointY + 0.5 * (radiusB - (clipPointX - planePointX) * normalX - (clipPointY - planePointY) * normalY - radiusA) * normalY;
            }
         }
         break;
      }
   }
   ClipVertex.ClipVertex = function () {
      this.v = new b2Vec2();
      this.id = new b2ContactID();
   };
   ClipVertex.prototype.Set = function (other) {
      this.v.SetV(other.v);
      this.id.Set(other.id);
   }
   Features.Features = function () {};
   Object.defineProperty(Features.prototype, 'referenceEdge', {
      enumerable: false,
      configurable: true,
      get: function () {
         return this._referenceEdge;
      }
   });
   Object.defineProperty(Features.prototype, 'referenceEdge', {
      enumerable: false,
      configurable: true,
      set: function (value) {
         if (value === undefined) value = 0;
         this._referenceEdge = value;
         this._m_id._key = (this._m_id._key & 0xffffff00) | (this._referenceEdge & 0x000000ff);
      }
   });
   Object.defineProperty(Features.prototype, 'incidentEdge', {
      enumerable: false,
      configurable: true,
      get: function () {
         return this._incidentEdge;
      }
   });
   Object.defineProperty(Features.prototype, 'incidentEdge', {
      enumerable: false,
      configurable: true,
      set: function (value) {
         if (value === undefined) value = 0;
         this._incidentEdge = value;
         this._m_id._key = (this._m_id._key & 0xffff00ff) | ((this._incidentEdge << 8) & 0x0000ff00);
      }
   });
   Object.defineProperty(Features.prototype, 'incidentVertex', {
      enumerable: false,
      configurable: true,
      get: function () {
         return this._incidentVertex;
      }
   });
   Object.defineProperty(Features.prototype, 'incidentVertex', {
      enumerable: false,
      configurable: true,
      set: function (value) {
         if (value === undefined) value = 0;
         this._incidentVertex = value;
         this._m_id._key = (this._m_id._key & 0xff00ffff) | ((this._incidentVertex << 16) & 0x00ff0000);
      }
   });
   Object.defineProperty(Features.prototype, 'flip', {
      enumerable: false,
      configurable: true,
      get: function () {
         return this._flip;
      }
   });
   Object.defineProperty(Features.prototype, 'flip', {
      enumerable: false,
      configurable: true,
      set: function (value) {
         if (value === undefined) value = 0;
         this._flip = value;
         this._m_id._key = (this._m_id._key & 0x00ffffff) | ((this._flip << 24) & 0xff000000);
      }
   });
})();
(function () {
   var b2Color = Box2D.Common.b2Color,
      b2internal = Box2D.Common.b2internal,
      b2Settings = Box2D.Common.b2Settings,
      b2CircleShape = Box2D.Collision.Shapes.b2CircleShape,
      b2EdgeChainDef = Box2D.Collision.Shapes.b2EdgeChainDef,
      b2EdgeShape = Box2D.Collision.Shapes.b2EdgeShape,
      b2MassData = Box2D.Collision.Shapes.b2MassData,
      b2PolygonShape = Box2D.Collision.Shapes.b2PolygonShape,
      b2Shape = Box2D.Collision.Shapes.b2Shape,
      b2Mat22 = Box2D.Common.Math.b2Mat22,
      b2Mat33 = Box2D.Common.Math.b2Mat33,
      b2Math = Box2D.Common.Math.b2Math,
      b2Sweep = Box2D.Common.Math.b2Sweep,
      b2Transform = Box2D.Common.Math.b2Transform,
      b2Vec2 = Box2D.Common.Math.b2Vec2,
      b2Vec3 = Box2D.Common.Math.b2Vec3,
      b2Body = Box2D.Dynamics.b2Body,
      b2BodyDef = Box2D.Dynamics.b2BodyDef,
      b2ContactFilter = Box2D.Dynamics.b2ContactFilter,
      b2ContactImpulse = Box2D.Dynamics.b2ContactImpulse,
      b2ContactListener = Box2D.Dynamics.b2ContactListener,
      b2ContactManager = Box2D.Dynamics.b2ContactManager,
      b2DebugDraw = Box2D.Dynamics.b2DebugDraw,
      b2DestructionListener = Box2D.Dynamics.b2DestructionListener,
      b2FilterData = Box2D.Dynamics.b2FilterData,
      b2Fixture = Box2D.Dynamics.b2Fixture,
      b2FixtureDef = Box2D.Dynamics.b2FixtureDef,
      b2Island = Box2D.Dynamics.b2Island,
      b2TimeStep = Box2D.Dynamics.b2TimeStep,
      b2World = Box2D.Dynamics.b2World,
      b2AABB = Box2D.Collision.b2AABB,
      b2Bound = Box2D.Collision.b2Bound,
      b2BoundValues = Box2D.Collision.b2BoundValues,
      b2Collision = Box2D.Collision.b2Collision,
      b2ContactID = Box2D.Collision.b2ContactID,
      b2ContactPoint = Box2D.Collision.b2ContactPoint,
      b2Distance = Box2D.Collision.b2Distance,
      b2DistanceInput = Box2D.Collision.b2DistanceInput,
      b2DistanceOutput = Box2D.Collision.b2DistanceOutput,
      b2DistanceProxy = Box2D.Collision.b2DistanceProxy,
      b2DynamicTree = Box2D.Collision.b2DynamicTree,
      b2DynamicTreeBroadPhase = Box2D.Collision.b2DynamicTreeBroadPhase,
      b2DynamicTreeNode = Box2D.Collision.b2DynamicTreeNode,
      b2DynamicTreePair = Box2D.Collision.b2DynamicTreePair,
      b2Manifold = Box2D.Collision.b2Manifold,
      b2ManifoldPoint = Box2D.Collision.b2ManifoldPoint,
      b2Point = Box2D.Collision.b2Point,
      b2RayCastInput = Box2D.Collision.b2RayCastInput,
      b2RayCastOutput = Box2D.Collision.b2RayCastOutput,
      b2Segment = Box2D.Collision.b2Segment,
      b2SeparationFunction = Box2D.Collision.b2SeparationFunction,
      b2Simplex = Box2D.Collision.b2Simplex,
      b2SimplexCache = Box2D.Collision.b2SimplexCache,
      b2SimplexVertex = Box2D.Collision.b2SimplexVertex,
      b2TimeOfImpact = Box2D.Collision.b2TimeOfImpact,
      b2TOIInput = Box2D.Collision.b2TOIInput,
      b2WorldManifold = Box2D.Collision.b2WorldManifold,
      ClipVertex = Box2D.Collision.ClipVertex,
      Features = Box2D.Collision.Features,
      IBroadPhase = Box2D.Collision.IBroadPhase;

   Box2D.inherit(b2CircleShape, Box2D.Collision.Shapes.b2Shape);
   b2CircleShape.prototype.__super = Box2D.Collision.Shapes.b2Shape.prototype;
   b2CircleShape.b2CircleShape = function () {
      Box2D.Collision.Shapes.b2Shape.b2Shape.apply(this, arguments);
      this.m_p = new b2Vec2();
   };
   b2CircleShape.prototype.Copy = function () {
      var s = new b2CircleShape();
      s.Set(this);
      return s;
   }
   b2CircleShape.prototype.Set = function (other) {
      this.__super.Set.call(this, other);
      if (Box2D.is(other, b2CircleShape)) {
         var other2 = (other instanceof b2CircleShape ? other : null);
         this.m_p.SetV(other2.m_p);
      }
   }
   b2CircleShape.prototype.TestPoint = function (transform, p) {
      var tMat = transform.R;
      var dX = transform.position.x + (tMat.col1.x * this.m_p.x + tMat.col2.x * this.m_p.y);
      var dY = transform.position.y + (tMat.col1.y * this.m_p.x + tMat.col2.y * this.m_p.y);
      dX = p.x - dX;
      dY = p.y - dY;
      return (dX * dX + dY * dY) <= this.m_radius * this.m_radius;
   }
   b2CircleShape.prototype.RayCast = function (output, input, transform) {
      var tMat = transform.R;
      var positionX = transform.position.x + (tMat.col1.x * this.m_p.x + tMat.col2.x * this.m_p.y);
      var positionY = transform.position.y + (tMat.col1.y * this.m_p.x + tMat.col2.y * this.m_p.y);
      var sX = input.p1.x - positionX;
      var sY = input.p1.y - positionY;
      var b = (sX * sX + sY * sY) - this.m_radius * this.m_radius;
      var rX = input.p2.x - input.p1.x;
      var rY = input.p2.y - input.p1.y;
      var c = (sX * rX + sY * rY);
      var rr = (rX * rX + rY * rY);
      var sigma = c * c - rr * b;
      if (sigma < 0.0 || rr < Number.MIN_VALUE) {
         return false;
      }
      var a = (-(c + Math.sqrt(sigma)));
      if (0.0 <= a && a <= input.maxFraction * rr) {
         a /= rr;
         output.fraction = a;
         output.normal.x = sX + a * rX;
         output.normal.y = sY + a * rY;
         output.normal.Normalize();
         return true;
      }
      return false;
   }
   b2CircleShape.prototype.ComputeAABB = function (aabb, transform) {
      var tMat = transform.R;
      var pX = transform.position.x + (tMat.col1.x * this.m_p.x + tMat.col2.x * this.m_p.y);
      var pY = transform.position.y + (tMat.col1.y * this.m_p.x + tMat.col2.y * this.m_p.y);
      aabb.lowerBound.Set(pX - this.m_radius, pY - this.m_radius);
      aabb.upperBound.Set(pX + this.m_radius, pY + this.m_radius);
   }
   b2CircleShape.prototype.ComputeMass = function (massData, density) {
      if (density === undefined) density = 0;
      massData.mass = density * b2Settings.b2_pi * this.m_radius * this.m_radius;
      massData.center.SetV(this.m_p);
      massData.I = massData.mass * (0.5 * this.m_radius * this.m_radius + (this.m_p.x * this.m_p.x + this.m_p.y * this.m_p.y));
   }
   b2CircleShape.prototype.ComputeSubmergedArea = function (normal, offset, xf, c) {
      if (offset === undefined) offset = 0;
      var p = b2Math.MulX(xf, this.m_p);
      var l = (-(b2Math.Dot(normal, p) - offset));
      if (l < (-this.m_radius) + Number.MIN_VALUE) {
         return 0;
      }
      if (l > this.m_radius) {
         c.SetV(p);
         return Math.PI * this.m_radius * this.m_radius;
      }
      var r2 = this.m_radius * this.m_radius;
      var l2 = l * l;
      var area = r2 * (Math.asin(l / this.m_radius) + Math.PI / 2) + l * Math.sqrt(r2 - l2);
      var com = (-2 / 3 * Math.pow(r2 - l2, 1.5) / area);
      c.x = p.x + normal.x * com;
      c.y = p.y + normal.y * com;
      return area;
   }
   b2CircleShape.prototype.GetLocalPosition = function () {
      return this.m_p;
   }
   b2CircleShape.prototype.SetLocalPosition = function (position) {
      this.m_p.SetV(position);
   }
   b2CircleShape.prototype.GetRadius = function () {
      return this.m_radius;
   }
   b2CircleShape.prototype.SetRadius = function (radius) {
      if (radius === undefined) radius = 0;
      this.m_radius = radius;
   }
   b2CircleShape.prototype.b2CircleShape = function (radius) {
      if (radius === undefined) radius = 0;
      this.__super.b2Shape.call(this);
      this.m_type = b2Shape.e_circleShape;
      this.m_radius = radius;
   }
   b2EdgeChainDef.b2EdgeChainDef = function () {};
   b2EdgeChainDef.prototype.b2EdgeChainDef = function () {
      this.vertexCount = 0;
      this.isALoop = true;
      this.vertices = [];
   }
   Box2D.inherit(b2EdgeShape, Box2D.Collision.Shapes.b2Shape);
   b2EdgeShape.prototype.__super = Box2D.Collision.Shapes.b2Shape.prototype;
   b2EdgeShape.b2EdgeShape = function () {
      Box2D.Collision.Shapes.b2Shape.b2Shape.apply(this, arguments);
      this.s_supportVec = new b2Vec2();
      this.m_v1 = new b2Vec2();
      this.m_v2 = new b2Vec2();
      this.m_coreV1 = new b2Vec2();
      this.m_coreV2 = new b2Vec2();
      this.m_normal = new b2Vec2();
      this.m_direction = new b2Vec2();
      this.m_cornerDir1 = new b2Vec2();
      this.m_cornerDir2 = new b2Vec2();
   };
   b2EdgeShape.prototype.TestPoint = function (transform, p) {
      return false;
   }
   b2EdgeShape.prototype.RayCast = function (output, input, transform) {
      var tMat;
      var rX = input.p2.x - input.p1.x;
      var rY = input.p2.y - input.p1.y;
      tMat = transform.R;
      var v1X = transform.position.x + (tMat.col1.x * this.m_v1.x + tMat.col2.x * this.m_v1.y);
      var v1Y = transform.position.y + (tMat.col1.y * this.m_v1.x + tMat.col2.y * this.m_v1.y);
      var nX = transform.position.y + (tMat.col1.y * this.m_v2.x + tMat.col2.y * this.m_v2.y) - v1Y;
      var nY = (-(transform.position.x + (tMat.col1.x * this.m_v2.x + tMat.col2.x * this.m_v2.y) - v1X));
      var k_slop = 100.0 * Number.MIN_VALUE;
      var denom = (-(rX * nX + rY * nY));
      if (denom > k_slop) {
         var bX = input.p1.x - v1X;
         var bY = input.p1.y - v1Y;
         var a = (bX * nX + bY * nY);
         if (0.0 <= a && a <= input.maxFraction * denom) {
            var mu2 = (-rX * bY) + rY * bX;
            if ((-k_slop * denom) <= mu2 && mu2 <= denom * (1.0 + k_slop)) {
               a /= denom;
               output.fraction = a;
               var nLen = Math.sqrt(nX * nX + nY * nY);
               output.normal.x = nX / nLen;
               output.normal.y = nY / nLen;
               return true;
            }
         }
      }
      return false;
   }
   b2EdgeShape.prototype.ComputeAABB = function (aabb, transform) {
      var tMat = transform.R;
      var v1X = transform.position.x + (tMat.col1.x * this.m_v1.x + tMat.col2.x * this.m_v1.y);
      var v1Y = transform.position.y + (tMat.col1.y * this.m_v1.x + tMat.col2.y * this.m_v1.y);
      var v2X = transform.position.x + (tMat.col1.x * this.m_v2.x + tMat.col2.x * this.m_v2.y);
      var v2Y = transform.position.y + (tMat.col1.y * this.m_v2.x + tMat.col2.y * this.m_v2.y);
      if (v1X < v2X) {
         aabb.lowerBound.x = v1X;
         aabb.upperBound.x = v2X;
      }
      else {
         aabb.lowerBound.x = v2X;
         aabb.upperBound.x = v1X;
      }
      if (v1Y < v2Y) {
         aabb.lowerBound.y = v1Y;
         aabb.upperBound.y = v2Y;
      }
      else {
         aabb.lowerBound.y = v2Y;
         aabb.upperBound.y = v1Y;
      }
   }
   b2EdgeShape.prototype.ComputeMass = function (massData, density) {
      if (density === undefined) density = 0;
      massData.mass = 0;
      massData.center.SetV(this.m_v1);
      massData.I = 0;
   }
   b2EdgeShape.prototype.ComputeSubmergedArea = function (normal, offset, xf, c) {
      if (offset === undefined) offset = 0;
      var v0 = new b2Vec2(normal.x * offset, normal.y * offset);
      var v1 = b2Math.MulX(xf, this.m_v1);
      var v2 = b2Math.MulX(xf, this.m_v2);
      var d1 = b2Math.Dot(normal, v1) - offset;
      var d2 = b2Math.Dot(normal, v2) - offset;
      if (d1 > 0) {
         if (d2 > 0) {
            return 0;
         }
         else {
            v1.x = (-d2 / (d1 - d2) * v1.x) + d1 / (d1 - d2) * v2.x;
            v1.y = (-d2 / (d1 - d2) * v1.y) + d1 / (d1 - d2) * v2.y;
         }
      }
      else {
         if (d2 > 0) {
            v2.x = (-d2 / (d1 - d2) * v1.x) + d1 / (d1 - d2) * v2.x;
            v2.y = (-d2 / (d1 - d2) * v1.y) + d1 / (d1 - d2) * v2.y;
         }
         else {}
      }
      c.x = (v0.x + v1.x + v2.x) / 3;
      c.y = (v0.y + v1.y + v2.y) / 3;
      return 0.5 * ((v1.x - v0.x) * (v2.y - v0.y) - (v1.y - v0.y) * (v2.x - v0.x));
   }
   b2EdgeShape.prototype.GetLength = function () {
      return this.m_length;
   }
   b2EdgeShape.prototype.GetVertex1 = function () {
      return this.m_v1;
   }
   b2EdgeShape.prototype.GetVertex2 = function () {
      return this.m_v2;
   }
   b2EdgeShape.prototype.GetCoreVertex1 = function () {
      return this.m_coreV1;
   }
   b2EdgeShape.prototype.GetCoreVertex2 = function () {
      return this.m_coreV2;
   }
   b2EdgeShape.prototype.GetNormalVector = function () {
      return this.m_normal;
   }
   b2EdgeShape.prototype.GetDirectionVector = function () {
      return this.m_direction;
   }
   b2EdgeShape.prototype.GetCorner1Vector = function () {
      return this.m_cornerDir1;
   }
   b2EdgeShape.prototype.GetCorner2Vector = function () {
      return this.m_cornerDir2;
   }
   b2EdgeShape.prototype.Corner1IsConvex = function () {
      return this.m_cornerConvex1;
   }
   b2EdgeShape.prototype.Corner2IsConvex = function () {
      return this.m_cornerConvex2;
   }
   b2EdgeShape.prototype.GetFirstVertex = function (xf) {
      var tMat = xf.R;
      return new b2Vec2(xf.position.x + (tMat.col1.x * this.m_coreV1.x + tMat.col2.x * this.m_coreV1.y), xf.position.y + (tMat.col1.y * this.m_coreV1.x + tMat.col2.y * this.m_coreV1.y));
   }
   b2EdgeShape.prototype.GetNextEdge = function () {
      return this.m_nextEdge;
   }
   b2EdgeShape.prototype.GetPrevEdge = function () {
      return this.m_prevEdge;
   }
   b2EdgeShape.prototype.Support = function (xf, dX, dY) {
      if (dX === undefined) dX = 0;
      if (dY === undefined) dY = 0;
      var tMat = xf.R;
      var v1X = xf.position.x + (tMat.col1.x * this.m_coreV1.x + tMat.col2.x * this.m_coreV1.y);
      var v1Y = xf.position.y + (tMat.col1.y * this.m_coreV1.x + tMat.col2.y * this.m_coreV1.y);
      var v2X = xf.position.x + (tMat.col1.x * this.m_coreV2.x + tMat.col2.x * this.m_coreV2.y);
      var v2Y = xf.position.y + (tMat.col1.y * this.m_coreV2.x + tMat.col2.y * this.m_coreV2.y);
      if ((v1X * dX + v1Y * dY) > (v2X * dX + v2Y * dY)) {
         this.s_supportVec.x = v1X;
         this.s_supportVec.y = v1Y;
      }
      else {
         this.s_supportVec.x = v2X;
         this.s_supportVec.y = v2Y;
      }
      return this.s_supportVec;
   }
   b2EdgeShape.prototype.b2EdgeShape = function (v1, v2) {
      this.__super.b2Shape.call(this);
      this.m_type = b2Shape.e_edgeShape;
      this.m_prevEdge = null;
      this.m_nextEdge = null;
      this.m_v1 = v1;
      this.m_v2 = v2;
      this.m_direction.Set(this.m_v2.x - this.m_v1.x, this.m_v2.y - this.m_v1.y);
      this.m_length = this.m_direction.Normalize();
      this.m_normal.Set(this.m_direction.y, (-this.m_direction.x));
      this.m_coreV1.Set((-b2Settings.b2_toiSlop * (this.m_normal.x - this.m_direction.x)) + this.m_v1.x, (-b2Settings.b2_toiSlop * (this.m_normal.y - this.m_direction.y)) + this.m_v1.y);
      this.m_coreV2.Set((-b2Settings.b2_toiSlop * (this.m_normal.x + this.m_direction.x)) + this.m_v2.x, (-b2Settings.b2_toiSlop * (this.m_normal.y + this.m_direction.y)) + this.m_v2.y);
      this.m_cornerDir1 = this.m_normal;
      this.m_cornerDir2.Set((-this.m_normal.x), (-this.m_normal.y));
   }
   b2EdgeShape.prototype.SetPrevEdge = function (edge, core, cornerDir, convex) {
      this.m_prevEdge = edge;
      this.m_coreV1 = core;
      this.m_cornerDir1 = cornerDir;
      this.m_cornerConvex1 = convex;
   }
   b2EdgeShape.prototype.SetNextEdge = function (edge, core, cornerDir, convex) {
      this.m_nextEdge = edge;
      this.m_coreV2 = core;
      this.m_cornerDir2 = cornerDir;
      this.m_cornerConvex2 = convex;
   }
   b2MassData.b2MassData = function () {
      this.mass = 0.0;
      this.center = new b2Vec2(0, 0);
      this.I = 0.0;
   };
   Box2D.inherit(b2PolygonShape, Box2D.Collision.Shapes.b2Shape);
   b2PolygonShape.prototype.__super = Box2D.Collision.Shapes.b2Shape.prototype;
   b2PolygonShape.b2PolygonShape = function () {
      Box2D.Collision.Shapes.b2Shape.b2Shape.apply(this, arguments);
   };
   b2PolygonShape.prototype.Copy = function () {
      var s = new b2PolygonShape();
      s.Set(this);
      return s;
   }
   b2PolygonShape.prototype.Set = function (other) {
      this.__super.Set.call(this, other);
      if (Box2D.is(other, b2PolygonShape)) {
         var other2 = (other instanceof b2PolygonShape ? other : null);
         this.m_centroid.SetV(other2.m_centroid);
         this.m_vertexCount = other2.m_vertexCount;
         this.Reserve(this.m_vertexCount);
         for (var i = 0; i < this.m_vertexCount; i++) {
            this.m_vertices[i].SetV(other2.m_vertices[i]);
            this.m_normals[i].SetV(other2.m_normals[i]);
         }
      }
   }
   b2PolygonShape.prototype.SetAsArray = function (vertices, vertexCount) {
      if (vertexCount === undefined) vertexCount = 0;
      var v = new Vector();
      var i = 0,
         tVec;
      for (i = 0;
      i < vertices.length; ++i) {
         tVec = vertices[i];
         v.push(tVec);
      }
      this.SetAsVector(v, vertexCount);
   }
   b2PolygonShape.AsArray = function (vertices, vertexCount) {
      if (vertexCount === undefined) vertexCount = 0;
      var polygonShape = new b2PolygonShape();
      polygonShape.SetAsArray(vertices, vertexCount);
      return polygonShape;
   }
   b2PolygonShape.prototype.SetAsVector = function (vertices, vertexCount) {
      if (vertexCount === undefined) vertexCount = 0;
      if (vertexCount == 0) vertexCount = vertices.length;
      b2Settings.b2Assert(2 <= vertexCount);
      this.m_vertexCount = vertexCount;
      this.Reserve(vertexCount);
      var i = 0;
      for (i = 0;
      i < this.m_vertexCount; i++) {
         this.m_vertices[i].SetV(vertices[i]);
      }
      for (i = 0;
      i < this.m_vertexCount; ++i) {
         var i1 = parseInt(i);
         var i2 = parseInt(i + 1 < this.m_vertexCount ? i + 1 : 0);
         var edge = b2Math.SubtractVV(this.m_vertices[i2], this.m_vertices[i1]);
         b2Settings.b2Assert(edge.LengthSquared() > Number.MIN_VALUE);
         this.m_normals[i].SetV(b2Math.CrossVF(edge, 1.0));
         this.m_normals[i].Normalize();
      }
      this.m_centroid = b2PolygonShape.ComputeCentroid(this.m_vertices, this.m_vertexCount);
   }
   b2PolygonShape.AsVector = function (vertices, vertexCount) {
      if (vertexCount === undefined) vertexCount = 0;
      var polygonShape = new b2PolygonShape();
      polygonShape.SetAsVector(vertices, vertexCount);
      return polygonShape;
   }
   b2PolygonShape.prototype.SetAsBox = function (hx, hy) {
	  if (hx === undefined) hx = 0;
      if (hy === undefined) hy = 0;
      this.m_vertexCount = 4;
      this.Reserve(4);
      this.m_vertices[0].Set((-hx), (-hy));
      this.m_vertices[1].Set(hx, (-hy));
      this.m_vertices[2].Set(hx, hy);
      this.m_vertices[3].Set((-hx), hy);
      this.m_normals[0].Set(0.0, (-1.0));
      this.m_normals[1].Set(1.0, 0.0);
      this.m_normals[2].Set(0.0, 1.0);
      this.m_normals[3].Set((-1.0), 0.0);
	  this.m_centroid.SetZero();
   }
   b2PolygonShape.AsBox = function (hx, hy) {
      if (hx === undefined) hx = 0;
      if (hy === undefined) hy = 0;
      var polygonShape = new b2PolygonShape();
      polygonShape.SetAsBox(hx, hy);
      return polygonShape;
   }
   b2PolygonShape.prototype.SetAsOrientedBox = function (hx, hy, center, angle) {
      if (hx === undefined) hx = 0;
      if (hy === undefined) hy = 0;
      if (center === undefined) center = null;
      if (angle === undefined) angle = 0.0;
      this.m_vertexCount = 4;
      this.Reserve(4);
      this.m_vertices[0].Set((-hx), (-hy));
      this.m_vertices[1].Set(hx, (-hy));
      this.m_vertices[2].Set(hx, hy);
      this.m_vertices[3].Set((-hx), hy);
      this.m_normals[0].Set(0.0, (-1.0));
      this.m_normals[1].Set(1.0, 0.0);
      this.m_normals[2].Set(0.0, 1.0);
      this.m_normals[3].Set((-1.0), 0.0);
      this.m_centroid = center;
      var xf = new b2Transform();
      xf.position = center;
      xf.R.Set(angle);
      for (var i = 0; i < this.m_vertexCount; ++i) {
         this.m_vertices[i] = b2Math.MulX(xf, this.m_vertices[i]);
         this.m_normals[i] = b2Math.MulMV(xf.R, this.m_normals[i]);
      }
   }
   b2PolygonShape.AsOrientedBox = function (hx, hy, center, angle) {
      if (hx === undefined) hx = 0;
      if (hy === undefined) hy = 0;
      if (center === undefined) center = null;
      if (angle === undefined) angle = 0.0;
      var polygonShape = new b2PolygonShape();
      polygonShape.SetAsOrientedBox(hx, hy, center, angle);
      return polygonShape;
   }
   b2PolygonShape.prototype.SetAsEdge = function (v1, v2) {
      this.m_vertexCount = 2;
      this.Reserve(2);
      this.m_vertices[0].SetV(v1);
      this.m_vertices[1].SetV(v2);
      this.m_centroid.x = 0.5 * (v1.x + v2.x);
      this.m_centroid.y = 0.5 * (v1.y + v2.y);
      this.m_normals[0] = b2Math.CrossVF(b2Math.SubtractVV(v2, v1), 1.0);
      this.m_normals[0].Normalize();
      this.m_normals[1].x = (-this.m_normals[0].x);
      this.m_normals[1].y = (-this.m_normals[0].y);
   }
   b2PolygonShape.AsEdge = function (v1, v2) {
      var polygonShape = new b2PolygonShape();
      polygonShape.SetAsEdge(v1, v2);
      return polygonShape;
   }
   b2PolygonShape.prototype.TestPoint = function (xf, p) {
      var tVec;
      var tMat = xf.R;
      var tX = p.x - xf.position.x;
      var tY = p.y - xf.position.y;
      var pLocalX = (tX * tMat.col1.x + tY * tMat.col1.y);
      var pLocalY = (tX * tMat.col2.x + tY * tMat.col2.y);
      for (var i = 0; i < this.m_vertexCount; ++i) {
         tVec = this.m_vertices[i];
         tX = pLocalX - tVec.x;
         tY = pLocalY - tVec.y;
         tVec = this.m_normals[i];
         var dot = (tVec.x * tX + tVec.y * tY);
         if (dot > 0.0) {
            return false;
         }
      }
      return true;
   }
   b2PolygonShape.prototype.RayCast = function (output, input, transform) {
      var lower = 0.0;
      var upper = input.maxFraction;
      var tX = 0;
      var tY = 0;
      var tMat;
      var tVec;
      tX = input.p1.x - transform.position.x;
      tY = input.p1.y - transform.position.y;
      tMat = transform.R;
      var p1X = (tX * tMat.col1.x + tY * tMat.col1.y);
      var p1Y = (tX * tMat.col2.x + tY * tMat.col2.y);
      tX = input.p2.x - transform.position.x;
      tY = input.p2.y - transform.position.y;
      tMat = transform.R;
      var p2X = (tX * tMat.col1.x + tY * tMat.col1.y);
      var p2Y = (tX * tMat.col2.x + tY * tMat.col2.y);
      var dX = p2X - p1X;
      var dY = p2Y - p1Y;
      var index = parseInt((-1));
      for (var i = 0; i < this.m_vertexCount; ++i) {
         tVec = this.m_vertices[i];
         tX = tVec.x - p1X;
         tY = tVec.y - p1Y;
         tVec = this.m_normals[i];
         var numerator = (tVec.x * tX + tVec.y * tY);
         var denominator = (tVec.x * dX + tVec.y * dY);
         if (denominator == 0.0) {
            if (numerator < 0.0) {
               return false;
            }
         }
         else {
            if (denominator < 0.0 && numerator < lower * denominator) {
               lower = numerator / denominator;
               index = i;
            }
            else if (denominator > 0.0 && numerator < upper * denominator) {
               upper = numerator / denominator;
            }
         }
         if (upper < lower - Number.MIN_VALUE) {
            return false;
         }
      }
      if (index >= 0) {
         output.fraction = lower;
         tMat = transform.R;
         tVec = this.m_normals[index];
         output.normal.x = (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
         output.normal.y = (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
         return true;
      }
      return false;
   }
   b2PolygonShape.prototype.ComputeAABB = function (aabb, xf) {
      var tMat = xf.R;
      var tVec = this.m_vertices[0];
      var lowerX = xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      var lowerY = xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      var upperX = lowerX;
      var upperY = lowerY;
      for (var i = 1; i < this.m_vertexCount; ++i) {
         tVec = this.m_vertices[i];
         var vX = xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
         var vY = xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
         lowerX = lowerX < vX ? lowerX : vX;
         lowerY = lowerY < vY ? lowerY : vY;
         upperX = upperX > vX ? upperX : vX;
         upperY = upperY > vY ? upperY : vY;
      }
      aabb.lowerBound.x = lowerX - this.m_radius;
      aabb.lowerBound.y = lowerY - this.m_radius;
      aabb.upperBound.x = upperX + this.m_radius;
      aabb.upperBound.y = upperY + this.m_radius;
   }
   b2PolygonShape.prototype.ComputeMass = function (massData, density) {
      if (density === undefined) density = 0;
      if (this.m_vertexCount == 2) {
         massData.center.x = 0.5 * (this.m_vertices[0].x + this.m_vertices[1].x);
         massData.center.y = 0.5 * (this.m_vertices[0].y + this.m_vertices[1].y);
         massData.mass = 0.0;
         massData.I = 0.0;
         return;
      }
      var centerX = 0.0;
      var centerY = 0.0;
      var area = 0.0;
      var I = 0.0;
      var p1X = 0.0;
      var p1Y = 0.0;
      var k_inv3 = 1.0 / 3.0;
      for (var i = 0; i < this.m_vertexCount; ++i) {
         var p2 = this.m_vertices[i];
         var p3 = i + 1 < this.m_vertexCount ? this.m_vertices[parseInt(i + 1)] : this.m_vertices[0];
         var e1X = p2.x - p1X;
         var e1Y = p2.y - p1Y;
         var e2X = p3.x - p1X;
         var e2Y = p3.y - p1Y;
         var D = e1X * e2Y - e1Y * e2X;
         var triangleArea = 0.5 * D;area += triangleArea;
         centerX += triangleArea * k_inv3 * (p1X + p2.x + p3.x);
         centerY += triangleArea * k_inv3 * (p1Y + p2.y + p3.y);
         var px = p1X;
         var py = p1Y;
         var ex1 = e1X;
         var ey1 = e1Y;
         var ex2 = e2X;
         var ey2 = e2Y;
         var intx2 = k_inv3 * (0.25 * (ex1 * ex1 + ex2 * ex1 + ex2 * ex2) + (px * ex1 + px * ex2)) + 0.5 * px * px;
         var inty2 = k_inv3 * (0.25 * (ey1 * ey1 + ey2 * ey1 + ey2 * ey2) + (py * ey1 + py * ey2)) + 0.5 * py * py;I += D * (intx2 + inty2);
      }
      massData.mass = density * area;
      centerX *= 1.0 / area;
      centerY *= 1.0 / area;
      massData.center.Set(centerX, centerY);
      massData.I = density * I;
   }
   b2PolygonShape.prototype.ComputeSubmergedArea = function (normal, offset, xf, c) {
      if (offset === undefined) offset = 0;
      var normalL = b2Math.MulTMV(xf.R, normal);
      var offsetL = offset - b2Math.Dot(normal, xf.position);
      var depths = new Vector_a2j_Number();
      var diveCount = 0;
      var intoIndex = parseInt((-1));
      var outoIndex = parseInt((-1));
      var lastSubmerged = false;
      var i = 0;
      for (i = 0;
      i < this.m_vertexCount; ++i) {
         depths[i] = b2Math.Dot(normalL, this.m_vertices[i]) - offsetL;
         var isSubmerged = depths[i] < (-Number.MIN_VALUE);
         if (i > 0) {
            if (isSubmerged) {
               if (!lastSubmerged) {
                  intoIndex = i - 1;
                  diveCount++;
               }
            }
            else {
               if (lastSubmerged) {
                  outoIndex = i - 1;
                  diveCount++;
               }
            }
         }
         lastSubmerged = isSubmerged;
      }
      switch (diveCount) {
      case 0:
         if (lastSubmerged) {
            var md = new b2MassData();
            this.ComputeMass(md, 1);
            c.SetV(b2Math.MulX(xf, md.center));
            return md.mass;
         }
         else {
            return 0;
         }
         break;
      case 1:
         if (intoIndex == (-1)) {
            intoIndex = this.m_vertexCount - 1;
         }
         else {
            outoIndex = this.m_vertexCount - 1;
         }
         break;
      }
      var intoIndex2 = parseInt((intoIndex + 1) % this.m_vertexCount);
      var outoIndex2 = parseInt((outoIndex + 1) % this.m_vertexCount);
      var intoLamdda = (0 - depths[intoIndex]) / (depths[intoIndex2] - depths[intoIndex]);
      var outoLamdda = (0 - depths[outoIndex]) / (depths[outoIndex2] - depths[outoIndex]);
      var intoVec = new b2Vec2(this.m_vertices[intoIndex].x * (1 - intoLamdda) + this.m_vertices[intoIndex2].x * intoLamdda, this.m_vertices[intoIndex].y * (1 - intoLamdda) + this.m_vertices[intoIndex2].y * intoLamdda);
      var outoVec = new b2Vec2(this.m_vertices[outoIndex].x * (1 - outoLamdda) + this.m_vertices[outoIndex2].x * outoLamdda, this.m_vertices[outoIndex].y * (1 - outoLamdda) + this.m_vertices[outoIndex2].y * outoLamdda);
      var area = 0;
      var center = new b2Vec2();
      var p2 = this.m_vertices[intoIndex2];
      var p3;
      i = intoIndex2;
      while (i != outoIndex2) {
         i = (i + 1) % this.m_vertexCount;
         if (i == outoIndex2) p3 = outoVec;
         else p3 = this.m_vertices[i];
         var triangleArea = 0.5 * ((p2.x - intoVec.x) * (p3.y - intoVec.y) - (p2.y - intoVec.y) * (p3.x - intoVec.x));
         area += triangleArea;
         center.x += triangleArea * (intoVec.x + p2.x + p3.x) / 3;
         center.y += triangleArea * (intoVec.y + p2.y + p3.y) / 3;
         p2 = p3;
      }
      center.Multiply(1 / area);
      c.SetV(b2Math.MulX(xf, center));
      return area;
   }
   b2PolygonShape.prototype.GetVertexCount = function () {
      return this.m_vertexCount;
   }
   b2PolygonShape.prototype.GetVertices = function () {
      return this.m_vertices;
   }
   b2PolygonShape.prototype.GetNormals = function () {
      return this.m_normals;
   }
   b2PolygonShape.prototype.GetSupport = function (d) {
      var bestIndex = 0;
      var bestValue = this.m_vertices[0].x * d.x + this.m_vertices[0].y * d.y;
      for (var i = 1; i < this.m_vertexCount; ++i) {
         var value = this.m_vertices[i].x * d.x + this.m_vertices[i].y * d.y;
         if (value > bestValue) {
            bestIndex = i;
            bestValue = value;
         }
      }
      return bestIndex;
   }
   b2PolygonShape.prototype.GetSupportVertex = function (d) {
      var bestIndex = 0;
      var bestValue = this.m_vertices[0].x * d.x + this.m_vertices[0].y * d.y;
      for (var i = 1; i < this.m_vertexCount; ++i) {
         var value = this.m_vertices[i].x * d.x + this.m_vertices[i].y * d.y;
         if (value > bestValue) {
            bestIndex = i;
            bestValue = value;
         }
      }
      return this.m_vertices[bestIndex];
   }
   b2PolygonShape.prototype.Validate = function () {
      return false;
   }
   b2PolygonShape.prototype.b2PolygonShape = function () {
      this.__super.b2Shape.call(this);
      this.m_type = b2Shape.e_polygonShape;
      this.m_centroid = new b2Vec2();
      this.m_vertices = new Vector();
      this.m_normals = new Vector();
   }
   b2PolygonShape.prototype.Reserve = function (count) {
      if (count === undefined) count = 0;
      for (var i = parseInt(this.m_vertices.length); i < count; i++) {
         this.m_vertices[i] = new b2Vec2();
         this.m_normals[i] = new b2Vec2();
      }
   }
   b2PolygonShape.ComputeCentroid = function (vs, count) {
      if (count === undefined) count = 0;
      var c = new b2Vec2();
      var area = 0.0;
      var p1X = 0.0;
      var p1Y = 0.0;
      var inv3 = 1.0 / 3.0;
      for (var i = 0; i < count; ++i) {
         var p2 = vs[i];
         var p3 = i + 1 < count ? vs[parseInt(i + 1)] : vs[0];
         var e1X = p2.x - p1X;
         var e1Y = p2.y - p1Y;
         var e2X = p3.x - p1X;
         var e2Y = p3.y - p1Y;
         var D = (e1X * e2Y - e1Y * e2X);
         var triangleArea = 0.5 * D;area += triangleArea;
         c.x += triangleArea * inv3 * (p1X + p2.x + p3.x);
         c.y += triangleArea * inv3 * (p1Y + p2.y + p3.y);
      }
      c.x *= 1.0 / area;
      c.y *= 1.0 / area;
      return c;
   }
   b2PolygonShape.ComputeOBB = function (obb, vs, count) {
      if (count === undefined) count = 0;
      var i = 0;
      var p = new Vector(count + 1);
      for (i = 0;
      i < count; ++i) {
         p[i] = vs[i];
      }
      p[count] = p[0];
      var minArea = Number.MAX_VALUE;
      for (i = 1;
      i <= count; ++i) {
         var root = p[parseInt(i - 1)];
         var uxX = p[i].x - root.x;
         var uxY = p[i].y - root.y;
         var length = Math.sqrt(uxX * uxX + uxY * uxY);
         uxX /= length;
         uxY /= length;
         var uyX = (-uxY);
         var uyY = uxX;
         var lowerX = Number.MAX_VALUE;
         var lowerY = Number.MAX_VALUE;
         var upperX = (-Number.MAX_VALUE);
         var upperY = (-Number.MAX_VALUE);
         for (var j = 0; j < count; ++j) {
            var dX = p[j].x - root.x;
            var dY = p[j].y - root.y;
            var rX = (uxX * dX + uxY * dY);
            var rY = (uyX * dX + uyY * dY);
            if (rX < lowerX) lowerX = rX;
            if (rY < lowerY) lowerY = rY;
            if (rX > upperX) upperX = rX;
            if (rY > upperY) upperY = rY;
         }
         var area = (upperX - lowerX) * (upperY - lowerY);
         if (area < 0.95 * minArea) {
            minArea = area;
            obb.R.col1.x = uxX;
            obb.R.col1.y = uxY;
            obb.R.col2.x = uyX;
            obb.R.col2.y = uyY;
            var centerX = 0.5 * (lowerX + upperX);
            var centerY = 0.5 * (lowerY + upperY);
            var tMat = obb.R;
            obb.center.x = root.x + (tMat.col1.x * centerX + tMat.col2.x * centerY);
            obb.center.y = root.y + (tMat.col1.y * centerX + tMat.col2.y * centerY);
            obb.extents.x = 0.5 * (upperX - lowerX);
            obb.extents.y = 0.5 * (upperY - lowerY);
         }
      }
   }
   Box2D.postDefs.push(function () {
      Box2D.Collision.Shapes.b2PolygonShape.s_mat = new b2Mat22();
   });
   b2Shape.b2Shape = function () {};
   b2Shape.prototype.Copy = function () {
      return null;
   }
   b2Shape.prototype.Set = function (other) {
      this.m_radius = other.m_radius;
   }
   b2Shape.prototype.GetType = function () {
      return this.m_type;
   }
   b2Shape.prototype.TestPoint = function (xf, p) {
      return false;
   }
   b2Shape.prototype.RayCast = function (output, input, transform) {
      return false;
   }
   b2Shape.prototype.ComputeAABB = function (aabb, xf) {}
   b2Shape.prototype.ComputeMass = function (massData, density) {
      if (density === undefined) density = 0;
   }
   b2Shape.prototype.ComputeSubmergedArea = function (normal, offset, xf, c) {
      if (offset === undefined) offset = 0;
      return 0;
   }
   b2Shape.TestOverlap = function (shape1, transform1, shape2, transform2) {
      var input = new b2DistanceInput();
      input.proxyA = new b2DistanceProxy();
      input.proxyA.Set(shape1);
      input.proxyB = new b2DistanceProxy();
      input.proxyB.Set(shape2);
      input.transformA = transform1;
      input.transformB = transform2;
      input.useRadii = true;
      var simplexCache = new b2SimplexCache();
      simplexCache.count = 0;
      var output = new b2DistanceOutput();
      b2Distance.Distance(output, simplexCache, input);
      return output.distance < 10.0 * Number.MIN_VALUE;
   }
   b2Shape.prototype.b2Shape = function () {
      this.m_type = b2Shape.e_unknownShape;
      this.m_radius = b2Settings.b2_linearSlop;
   }
   Box2D.postDefs.push(function () {
      Box2D.Collision.Shapes.b2Shape.e_unknownShape = parseInt((-1));
      Box2D.Collision.Shapes.b2Shape.e_circleShape = 0;
      Box2D.Collision.Shapes.b2Shape.e_polygonShape = 1;
      Box2D.Collision.Shapes.b2Shape.e_edgeShape = 2;
      Box2D.Collision.Shapes.b2Shape.e_shapeTypeCount = 3;
      Box2D.Collision.Shapes.b2Shape.e_hitCollide = 1;
      Box2D.Collision.Shapes.b2Shape.e_missCollide = 0;
      Box2D.Collision.Shapes.b2Shape.e_startsInsideCollide = parseInt((-1));
   });
})();
(function () {
   var b2Color = Box2D.Common.b2Color,
      b2internal = Box2D.Common.b2internal,
      b2Settings = Box2D.Common.b2Settings,
      b2Mat22 = Box2D.Common.Math.b2Mat22,
      b2Mat33 = Box2D.Common.Math.b2Mat33,
      b2Math = Box2D.Common.Math.b2Math,
      b2Sweep = Box2D.Common.Math.b2Sweep,
      b2Transform = Box2D.Common.Math.b2Transform,
      b2Vec2 = Box2D.Common.Math.b2Vec2,
      b2Vec3 = Box2D.Common.Math.b2Vec3;

   b2Color.b2Color = function () {
      this._r = 0;
      this._g = 0;
      this._b = 0;
   };
   b2Color.prototype.b2Color = function (rr, gg, bb) {
      if (rr === undefined) rr = 0;
      if (gg === undefined) gg = 0;
      if (bb === undefined) bb = 0;
      this._r = Box2D.parseUInt(255 * b2Math.Clamp(rr, 0.0, 1.0));
      this._g = Box2D.parseUInt(255 * b2Math.Clamp(gg, 0.0, 1.0));
      this._b = Box2D.parseUInt(255 * b2Math.Clamp(bb, 0.0, 1.0));
   }
   b2Color.prototype.Set = function (rr, gg, bb) {
      if (rr === undefined) rr = 0;
      if (gg === undefined) gg = 0;
      if (bb === undefined) bb = 0;
      this._r = Box2D.parseUInt(255 * b2Math.Clamp(rr, 0.0, 1.0));
      this._g = Box2D.parseUInt(255 * b2Math.Clamp(gg, 0.0, 1.0));
      this._b = Box2D.parseUInt(255 * b2Math.Clamp(bb, 0.0, 1.0));
   }
   Object.defineProperty(b2Color.prototype, 'r', {
      enumerable: false,
      configurable: true,
      set: function (rr) {
         if (rr === undefined) rr = 0;
         this._r = Box2D.parseUInt(255 * b2Math.Clamp(rr, 0.0, 1.0));
      }
   });
   Object.defineProperty(b2Color.prototype, 'g', {
      enumerable: false,
      configurable: true,
      set: function (gg) {
         if (gg === undefined) gg = 0;
         this._g = Box2D.parseUInt(255 * b2Math.Clamp(gg, 0.0, 1.0));
      }
   });
   Object.defineProperty(b2Color.prototype, 'b', {
      enumerable: false,
      configurable: true,
      set: function (bb) {
         if (bb === undefined) bb = 0;
         this._b = Box2D.parseUInt(255 * b2Math.Clamp(bb, 0.0, 1.0));
      }
   });
   Object.defineProperty(b2Color.prototype, 'color', {
      enumerable: false,
      configurable: true,
      get: function () {
         return (this._r << 16) | (this._g << 8) | (this._b);
      }
   });
   b2Settings.b2Settings = function () {};
   b2Settings.b2MixFriction = function (friction1, friction2) {
      if (friction1 === undefined) friction1 = 0;
      if (friction2 === undefined) friction2 = 0;
      return Math.sqrt(friction1 * friction2);
   }
   b2Settings.b2MixRestitution = function (restitution1, restitution2) {
      if (restitution1 === undefined) restitution1 = 0;
      if (restitution2 === undefined) restitution2 = 0;
      return restitution1 > restitution2 ? restitution1 : restitution2;
   }
   b2Settings.b2Assert = function (a) {
      if (!a) {
         throw "Assertion Failed";
      }
   }
   Box2D.postDefs.push(function () {
      Box2D.Common.b2Settings.VERSION = "2.1alpha";
      Box2D.Common.b2Settings.USHRT_MAX = 0x0000ffff;
      Box2D.Common.b2Settings.b2_pi = Math.PI;
      Box2D.Common.b2Settings.b2_maxManifoldPoints = 2;
      Box2D.Common.b2Settings.b2_aabbExtension = 0.1;
      Box2D.Common.b2Settings.b2_aabbMultiplier = 2.0;
      Box2D.Common.b2Settings.b2_polygonRadius = 2.0 * b2Settings.b2_linearSlop;
      Box2D.Common.b2Settings.b2_linearSlop = 0.005;
      Box2D.Common.b2Settings.b2_angularSlop = 2.0 / 180.0 * b2Settings.b2_pi;
      Box2D.Common.b2Settings.b2_toiSlop = 8.0 * b2Settings.b2_linearSlop;
      Box2D.Common.b2Settings.b2_maxTOIContactsPerIsland = 32;
      Box2D.Common.b2Settings.b2_maxTOIJointsPerIsland = 32;
      Box2D.Common.b2Settings.b2_velocityThreshold = 1.0;
      Box2D.Common.b2Settings.b2_maxLinearCorrection = 0.2;
      Box2D.Common.b2Settings.b2_maxAngularCorrection = 8.0 / 180.0 * b2Settings.b2_pi;
      Box2D.Common.b2Settings.b2_maxTranslation = 2.0;
      Box2D.Common.b2Settings.b2_maxTranslationSquared = b2Settings.b2_maxTranslation * b2Settings.b2_maxTranslation;
      Box2D.Common.b2Settings.b2_maxRotation = 0.5 * b2Settings.b2_pi;
      Box2D.Common.b2Settings.b2_maxRotationSquared = b2Settings.b2_maxRotation * b2Settings.b2_maxRotation;
      Box2D.Common.b2Settings.b2_contactBaumgarte = 0.2;
      Box2D.Common.b2Settings.b2_timeToSleep = 0.5;
      Box2D.Common.b2Settings.b2_linearSleepTolerance = 0.01;
      Box2D.Common.b2Settings.b2_angularSleepTolerance = 2.0 / 180.0 * b2Settings.b2_pi;
   });
})();
(function () {
   var b2AABB = Box2D.Collision.b2AABB,
      b2Color = Box2D.Common.b2Color,
      b2internal = Box2D.Common.b2internal,
      b2Settings = Box2D.Common.b2Settings,
      b2Mat22 = Box2D.Common.Math.b2Mat22,
      b2Mat33 = Box2D.Common.Math.b2Mat33,
      b2Math = Box2D.Common.Math.b2Math,
      b2Sweep = Box2D.Common.Math.b2Sweep,
      b2Transform = Box2D.Common.Math.b2Transform,
      b2Vec2 = Box2D.Common.Math.b2Vec2,
      b2Vec3 = Box2D.Common.Math.b2Vec3;

   b2Mat22.b2Mat22 = function () {
      this.col1 = new b2Vec2();
      this.col2 = new b2Vec2();
   };
   b2Mat22.prototype.b2Mat22 = function () {
      this.SetIdentity();
   }
   b2Mat22.FromAngle = function (angle) {
      if (angle === undefined) angle = 0;
      var mat = new b2Mat22();
      mat.Set(angle);
      return mat;
   }
   b2Mat22.FromVV = function (c1, c2) {
      var mat = new b2Mat22();
      mat.SetVV(c1, c2);
      return mat;
   }
   b2Mat22.prototype.Set = function (angle) {
      if (angle === undefined) angle = 0;
      var c = Math.cos(angle);
      var s = Math.sin(angle);
      this.col1.x = c;
      this.col2.x = (-s);
      this.col1.y = s;
      this.col2.y = c;
   }
   b2Mat22.prototype.SetVV = function (c1, c2) {
      this.col1.SetV(c1);
      this.col2.SetV(c2);
   }
   b2Mat22.prototype.Copy = function () {
      var mat = new b2Mat22();
      mat.SetM(this);
      return mat;
   }
   b2Mat22.prototype.SetM = function (m) {
      this.col1.SetV(m.col1);
      this.col2.SetV(m.col2);
   }
   b2Mat22.prototype.AddM = function (m) {
      this.col1.x += m.col1.x;
      this.col1.y += m.col1.y;
      this.col2.x += m.col2.x;
      this.col2.y += m.col2.y;
   }
   b2Mat22.prototype.SetIdentity = function () {
      this.col1.x = 1.0;
      this.col2.x = 0.0;
      this.col1.y = 0.0;
      this.col2.y = 1.0;
   }
   b2Mat22.prototype.SetZero = function () {
      this.col1.x = 0.0;
      this.col2.x = 0.0;
      this.col1.y = 0.0;
      this.col2.y = 0.0;
   }
   b2Mat22.prototype.GetAngle = function () {
      return Math.atan2(this.col1.y, this.col1.x);
   }
   b2Mat22.prototype.GetInverse = function (out) {
      var a = this.col1.x;
      var b = this.col2.x;
      var c = this.col1.y;
      var d = this.col2.y;
      var det = a * d - b * c;
      if (det != 0.0) {
         det = 1.0 / det;
      }
      out.col1.x = det * d;
      out.col2.x = (-det * b);
      out.col1.y = (-det * c);
      out.col2.y = det * a;
      return out;
   }
   b2Mat22.prototype.Solve = function (out, bX, bY) {
      if (bX === undefined) bX = 0;
      if (bY === undefined) bY = 0;
      var a11 = this.col1.x;
      var a12 = this.col2.x;
      var a21 = this.col1.y;
      var a22 = this.col2.y;
      var det = a11 * a22 - a12 * a21;
      if (det != 0.0) {
         det = 1.0 / det;
      }
      out.x = det * (a22 * bX - a12 * bY);
      out.y = det * (a11 * bY - a21 * bX);
      return out;
   }
   b2Mat22.prototype.Abs = function () {
      this.col1.Abs();
      this.col2.Abs();
   }
   b2Mat33.b2Mat33 = function () {
      this.col1 = new b2Vec3();
      this.col2 = new b2Vec3();
      this.col3 = new b2Vec3();
   };
   b2Mat33.prototype.b2Mat33 = function (c1, c2, c3) {
      if (c1 === undefined) c1 = null;
      if (c2 === undefined) c2 = null;
      if (c3 === undefined) c3 = null;
      if (!c1 && !c2 && !c3) {
         this.col1.SetZero();
         this.col2.SetZero();
         this.col3.SetZero();
      }
      else {
         this.col1.SetV(c1);
         this.col2.SetV(c2);
         this.col3.SetV(c3);
      }
   }
   b2Mat33.prototype.SetVVV = function (c1, c2, c3) {
      this.col1.SetV(c1);
      this.col2.SetV(c2);
      this.col3.SetV(c3);
   }
   b2Mat33.prototype.Copy = function () {
      return new b2Mat33(this.col1, this.col2, this.col3);
   }
   b2Mat33.prototype.SetM = function (m) {
      this.col1.SetV(m.col1);
      this.col2.SetV(m.col2);
      this.col3.SetV(m.col3);
   }
   b2Mat33.prototype.AddM = function (m) {
      this.col1.x += m.col1.x;
      this.col1.y += m.col1.y;
      this.col1.z += m.col1.z;
      this.col2.x += m.col2.x;
      this.col2.y += m.col2.y;
      this.col2.z += m.col2.z;
      this.col3.x += m.col3.x;
      this.col3.y += m.col3.y;
      this.col3.z += m.col3.z;
   }
   b2Mat33.prototype.SetIdentity = function () {
      this.col1.x = 1.0;
      this.col2.x = 0.0;
      this.col3.x = 0.0;
      this.col1.y = 0.0;
      this.col2.y = 1.0;
      this.col3.y = 0.0;
      this.col1.z = 0.0;
      this.col2.z = 0.0;
      this.col3.z = 1.0;
   }
   b2Mat33.prototype.SetZero = function () {
      this.col1.x = 0.0;
      this.col2.x = 0.0;
      this.col3.x = 0.0;
      this.col1.y = 0.0;
      this.col2.y = 0.0;
      this.col3.y = 0.0;
      this.col1.z = 0.0;
      this.col2.z = 0.0;
      this.col3.z = 0.0;
   }
   b2Mat33.prototype.Solve22 = function (out, bX, bY) {
      if (bX === undefined) bX = 0;
      if (bY === undefined) bY = 0;
      var a11 = this.col1.x;
      var a12 = this.col2.x;
      var a21 = this.col1.y;
      var a22 = this.col2.y;
      var det = a11 * a22 - a12 * a21;
      if (det != 0.0) {
         det = 1.0 / det;
      }
      out.x = det * (a22 * bX - a12 * bY);
      out.y = det * (a11 * bY - a21 * bX);
      return out;
   }
   b2Mat33.prototype.Solve33 = function (out, bX, bY, bZ) {
      if (bX === undefined) bX = 0;
      if (bY === undefined) bY = 0;
      if (bZ === undefined) bZ = 0;
      var a11 = this.col1.x;
      var a21 = this.col1.y;
      var a31 = this.col1.z;
      var a12 = this.col2.x;
      var a22 = this.col2.y;
      var a32 = this.col2.z;
      var a13 = this.col3.x;
      var a23 = this.col3.y;
      var a33 = this.col3.z;
      var det = a11 * (a22 * a33 - a32 * a23) + a21 * (a32 * a13 - a12 * a33) + a31 * (a12 * a23 - a22 * a13);
      if (det != 0.0) {
         det = 1.0 / det;
      }
      out.x = det * (bX * (a22 * a33 - a32 * a23) + bY * (a32 * a13 - a12 * a33) + bZ * (a12 * a23 - a22 * a13));
      out.y = det * (a11 * (bY * a33 - bZ * a23) + a21 * (bZ * a13 - bX * a33) + a31 * (bX * a23 - bY * a13));
      out.z = det * (a11 * (a22 * bZ - a32 * bY) + a21 * (a32 * bX - a12 * bZ) + a31 * (a12 * bY - a22 * bX));
      return out;
   }
   b2Math.b2Math = function () {};
   b2Math.IsValid = function (x) {
      if (x === undefined) x = 0;
      return isFinite(x);
   }
   b2Math.Dot = function (a, b) {
      return a.x * b.x + a.y * b.y;
   }
   b2Math.CrossVV = function (a, b) {
      return a.x * b.y - a.y * b.x;
   }
   b2Math.CrossVF = function (a, s) {
      if (s === undefined) s = 0;
      var v = new b2Vec2(s * a.y, (-s * a.x));
      return v;
   }
   b2Math.CrossFV = function (s, a) {
      if (s === undefined) s = 0;
      var v = new b2Vec2((-s * a.y), s * a.x);
      return v;
   }
   b2Math.MulMV = function (A, v) {
      var u = new b2Vec2(A.col1.x * v.x + A.col2.x * v.y, A.col1.y * v.x + A.col2.y * v.y);
      return u;
   }
   b2Math.MulTMV = function (A, v) {
      var u = new b2Vec2(b2Math.Dot(v, A.col1), b2Math.Dot(v, A.col2));
      return u;
   }
   b2Math.MulX = function (T, v) {
      var a = b2Math.MulMV(T.R, v);
      a.x += T.position.x;
      a.y += T.position.y;
      return a;
   }
   b2Math.MulXT = function (T, v) {
      var a = b2Math.SubtractVV(v, T.position);
      var tX = (a.x * T.R.col1.x + a.y * T.R.col1.y);
      a.y = (a.x * T.R.col2.x + a.y * T.R.col2.y);
      a.x = tX;
      return a;
   }
   b2Math.AddVV = function (a, b) {
      var v = new b2Vec2(a.x + b.x, a.y + b.y);
      return v;
   }
   b2Math.SubtractVV = function (a, b) {
      var v = new b2Vec2(a.x - b.x, a.y - b.y);
      return v;
   }
   b2Math.Distance = function (a, b) {
      var cX = a.x - b.x;
      var cY = a.y - b.y;
      return Math.sqrt(cX * cX + cY * cY);
   }
   b2Math.DistanceSquared = function (a, b) {
      var cX = a.x - b.x;
      var cY = a.y - b.y;
      return (cX * cX + cY * cY);
   }
   b2Math.MulFV = function (s, a) {
      if (s === undefined) s = 0;
      var v = new b2Vec2(s * a.x, s * a.y);
      return v;
   }
   b2Math.AddMM = function (A, B) {
      var C = b2Mat22.FromVV(b2Math.AddVV(A.col1, B.col1), b2Math.AddVV(A.col2, B.col2));
      return C;
   }
   b2Math.MulMM = function (A, B) {
      var C = b2Mat22.FromVV(b2Math.MulMV(A, B.col1), b2Math.MulMV(A, B.col2));
      return C;
   }
   b2Math.MulTMM = function (A, B) {
      var c1 = new b2Vec2(b2Math.Dot(A.col1, B.col1), b2Math.Dot(A.col2, B.col1));
      var c2 = new b2Vec2(b2Math.Dot(A.col1, B.col2), b2Math.Dot(A.col2, B.col2));
      var C = b2Mat22.FromVV(c1, c2);
      return C;
   }
   b2Math.Abs = function (a) {
      if (a === undefined) a = 0;
      return a > 0.0 ? a : (-a);
   }
   b2Math.AbsV = function (a) {
      var b = new b2Vec2(b2Math.Abs(a.x), b2Math.Abs(a.y));
      return b;
   }
   b2Math.AbsM = function (A) {
      var B = b2Mat22.FromVV(b2Math.AbsV(A.col1), b2Math.AbsV(A.col2));
      return B;
   }
   b2Math.Min = function (a, b) {
      if (a === undefined) a = 0;
      if (b === undefined) b = 0;
      return a < b ? a : b;
   }
   b2Math.MinV = function (a, b) {
      var c = new b2Vec2(b2Math.Min(a.x, b.x), b2Math.Min(a.y, b.y));
      return c;
   }
   b2Math.Max = function (a, b) {
      if (a === undefined) a = 0;
      if (b === undefined) b = 0;
      return a > b ? a : b;
   }
   b2Math.MaxV = function (a, b) {
      var c = new b2Vec2(b2Math.Max(a.x, b.x), b2Math.Max(a.y, b.y));
      return c;
   }
   b2Math.Clamp = function (a, low, high) {
      if (a === undefined) a = 0;
      if (low === undefined) low = 0;
      if (high === undefined) high = 0;
      return a < low ? low : a > high ? high : a;
   }
   b2Math.ClampV = function (a, low, high) {
      return b2Math.MaxV(low, b2Math.MinV(a, high));
   }
   b2Math.Swap = function (a, b) {
      var tmp = a[0];
      a[0] = b[0];
      b[0] = tmp;
   }
   b2Math.Random = function () {
      return Math.random() * 2 - 1;
   }
   b2Math.RandomRange = function (lo, hi) {
      if (lo === undefined) lo = 0;
      if (hi === undefined) hi = 0;
      var r = Math.random();
      r = (hi - lo) * r + lo;
      return r;
   }
   b2Math.NextPowerOfTwo = function (x) {
      if (x === undefined) x = 0;
      x |= (x >> 1) & 0x7FFFFFFF;
      x |= (x >> 2) & 0x3FFFFFFF;
      x |= (x >> 4) & 0x0FFFFFFF;
      x |= (x >> 8) & 0x00FFFFFF;
      x |= (x >> 16) & 0x0000FFFF;
      return x + 1;
   }
   b2Math.IsPowerOfTwo = function (x) {
      if (x === undefined) x = 0;
      var result = x > 0 && (x & (x - 1)) == 0;
      return result;
   }
   Box2D.postDefs.push(function () {
      Box2D.Common.Math.b2Math.b2Vec2_zero = new b2Vec2(0.0, 0.0);
      Box2D.Common.Math.b2Math.b2Mat22_identity = b2Mat22.FromVV(new b2Vec2(1.0, 0.0), new b2Vec2(0.0, 1.0));
      Box2D.Common.Math.b2Math.b2Transform_identity = new b2Transform(b2Math.b2Vec2_zero, b2Math.b2Mat22_identity);
   });
   b2Sweep.b2Sweep = function () {
      this.localCenter = new b2Vec2();
      this.c0 = new b2Vec2;
      this.c = new b2Vec2();
   };
   b2Sweep.prototype.Set = function (other) {
      this.localCenter.SetV(other.localCenter);
      this.c0.SetV(other.c0);
      this.c.SetV(other.c);
      this.a0 = other.a0;
      this.a = other.a;
      this.t0 = other.t0;
   }
   b2Sweep.prototype.Copy = function () {
      var copy = new b2Sweep();
      copy.localCenter.SetV(this.localCenter);
      copy.c0.SetV(this.c0);
      copy.c.SetV(this.c);
      copy.a0 = this.a0;
      copy.a = this.a;
      copy.t0 = this.t0;
      return copy;
   }
   b2Sweep.prototype.GetTransform = function (xf, alpha) {
      if (alpha === undefined) alpha = 0;
      xf.position.x = (1.0 - alpha) * this.c0.x + alpha * this.c.x;
      xf.position.y = (1.0 - alpha) * this.c0.y + alpha * this.c.y;
      var angle = (1.0 - alpha) * this.a0 + alpha * this.a;
      xf.R.Set(angle);
      var tMat = xf.R;
      xf.position.x -= (tMat.col1.x * this.localCenter.x + tMat.col2.x * this.localCenter.y);
      xf.position.y -= (tMat.col1.y * this.localCenter.x + tMat.col2.y * this.localCenter.y);
   }
   b2Sweep.prototype.Advance = function (t) {
      if (t === undefined) t = 0;
      if (this.t0 < t && 1.0 - this.t0 > Number.MIN_VALUE) {
         var alpha = (t - this.t0) / (1.0 - this.t0);
         this.c0.x = (1.0 - alpha) * this.c0.x + alpha * this.c.x;
         this.c0.y = (1.0 - alpha) * this.c0.y + alpha * this.c.y;
         this.a0 = (1.0 - alpha) * this.a0 + alpha * this.a;
         this.t0 = t;
      }
   }
   b2Transform.b2Transform = function () {
      this.position = new b2Vec2;
      this.R = new b2Mat22();
   };
   b2Transform.prototype.b2Transform = function (pos, r) {
      if (pos === undefined) pos = null;
      if (r === undefined) r = null;
      if (pos) {
         this.position.SetV(pos);
         this.R.SetM(r);
      }
   }
   b2Transform.prototype.Initialize = function (pos, r) {
      this.position.SetV(pos);
      this.R.SetM(r);
   }
   b2Transform.prototype.SetIdentity = function () {
      this.position.SetZero();
      this.R.SetIdentity();
   }
   b2Transform.prototype.Set = function (x) {
      this.position.SetV(x.position);
      this.R.SetM(x.R);
   }
   b2Transform.prototype.GetAngle = function () {
      return Math.atan2(this.R.col1.y, this.R.col1.x);
   }
   b2Vec2.b2Vec2 = function () {};
   b2Vec2.prototype.b2Vec2 = function (x_, y_) {
      if (x_ === undefined) x_ = 0;
      if (y_ === undefined) y_ = 0;
      this.x = x_;
      this.y = y_;
   }
   b2Vec2.prototype.SetZero = function () {
      this.x = 0.0;
      this.y = 0.0;
   }
   b2Vec2.prototype.Set = function (x_, y_) {
      if (x_ === undefined) x_ = 0;
      if (y_ === undefined) y_ = 0;
      this.x = x_;
      this.y = y_;
   }
   b2Vec2.prototype.SetV = function (v) {
      this.x = v.x;
      this.y = v.y;
   }
   b2Vec2.prototype.GetNegative = function () {
      return new b2Vec2((-this.x), (-this.y));
   }
   b2Vec2.prototype.NegativeSelf = function () {
      this.x = (-this.x);
      this.y = (-this.y);
   }
   b2Vec2.Make = function (x_, y_) {
      if (x_ === undefined) x_ = 0;
      if (y_ === undefined) y_ = 0;
      return new b2Vec2(x_, y_);
   }
   b2Vec2.prototype.Copy = function () {
      return new b2Vec2(this.x, this.y);
   }
   b2Vec2.prototype.Add = function (v) {
      this.x += v.x;
      this.y += v.y;
   }
   b2Vec2.prototype.Subtract = function (v) {
      this.x -= v.x;
      this.y -= v.y;
   }
   b2Vec2.prototype.Multiply = function (a) {
      if (a === undefined) a = 0;
      this.x *= a;
      this.y *= a;
   }
   b2Vec2.prototype.MulM = function (A) {
      var tX = this.x;
      this.x = A.col1.x * tX + A.col2.x * this.y;
      this.y = A.col1.y * tX + A.col2.y * this.y;
   }
   b2Vec2.prototype.MulTM = function (A) {
      var tX = b2Math.Dot(this, A.col1);
      this.y = b2Math.Dot(this, A.col2);
      this.x = tX;
   }
   b2Vec2.prototype.CrossVF = function (s) {
      if (s === undefined) s = 0;
      var tX = this.x;
      this.x = s * this.y;
      this.y = (-s * tX);
   }
   b2Vec2.prototype.CrossFV = function (s) {
      if (s === undefined) s = 0;
      var tX = this.x;
      this.x = (-s * this.y);
      this.y = s * tX;
   }
   b2Vec2.prototype.MinV = function (b) {
      this.x = this.x < b.x ? this.x : b.x;
      this.y = this.y < b.y ? this.y : b.y;
   }
   b2Vec2.prototype.MaxV = function (b) {
      this.x = this.x > b.x ? this.x : b.x;
      this.y = this.y > b.y ? this.y : b.y;
   }
   b2Vec2.prototype.Abs = function () {
      if (this.x < 0) this.x = (-this.x);
      if (this.y < 0) this.y = (-this.y);
   }
   b2Vec2.prototype.Length = function () {
      return Math.sqrt(this.x * this.x + this.y * this.y);
   }
   b2Vec2.prototype.LengthSquared = function () {
      return (this.x * this.x + this.y * this.y);
   }
   b2Vec2.prototype.Normalize = function () {
      var length = Math.sqrt(this.x * this.x + this.y * this.y);
      if (length < Number.MIN_VALUE) {
         return 0.0;
      }
      var invLength = 1.0 / length;
      this.x *= invLength;
      this.y *= invLength;
      return length;
   }
   b2Vec2.prototype.IsValid = function () {
      return b2Math.IsValid(this.x) && b2Math.IsValid(this.y);
   }
   b2Vec3.b2Vec3 = function () {};
   b2Vec3.prototype.b2Vec3 = function (x, y, z) {
      if (x === undefined) x = 0;
      if (y === undefined) y = 0;
      if (z === undefined) z = 0;
      this.x = x;
      this.y = y;
      this.z = z;
   }
   b2Vec3.prototype.SetZero = function () {
      this.x = this.y = this.z = 0.0;
   }
   b2Vec3.prototype.Set = function (x, y, z) {
      if (x === undefined) x = 0;
      if (y === undefined) y = 0;
      if (z === undefined) z = 0;
      this.x = x;
      this.y = y;
      this.z = z;
   }
   b2Vec3.prototype.SetV = function (v) {
      this.x = v.x;
      this.y = v.y;
      this.z = v.z;
   }
   b2Vec3.prototype.GetNegative = function () {
      return new b2Vec3((-this.x), (-this.y), (-this.z));
   }
   b2Vec3.prototype.NegativeSelf = function () {
      this.x = (-this.x);
      this.y = (-this.y);
      this.z = (-this.z);
   }
   b2Vec3.prototype.Copy = function () {
      return new b2Vec3(this.x, this.y, this.z);
   }
   b2Vec3.prototype.Add = function (v) {
      this.x += v.x;
      this.y += v.y;
      this.z += v.z;
   }
   b2Vec3.prototype.Subtract = function (v) {
      this.x -= v.x;
      this.y -= v.y;
      this.z -= v.z;
   }
   b2Vec3.prototype.Multiply = function (a) {
      if (a === undefined) a = 0;
      this.x *= a;
      this.y *= a;
      this.z *= a;
   }
})();
(function () {
   var b2ControllerEdge = Box2D.Dynamics.Controllers.b2ControllerEdge,
      b2Mat22 = Box2D.Common.Math.b2Mat22,
      b2Mat33 = Box2D.Common.Math.b2Mat33,
      b2Math = Box2D.Common.Math.b2Math,
      b2Sweep = Box2D.Common.Math.b2Sweep,
      b2Transform = Box2D.Common.Math.b2Transform,
      b2Vec2 = Box2D.Common.Math.b2Vec2,
      b2Vec3 = Box2D.Common.Math.b2Vec3,
      b2Color = Box2D.Common.b2Color,
      b2internal = Box2D.Common.b2internal,
      b2Settings = Box2D.Common.b2Settings,
      b2AABB = Box2D.Collision.b2AABB,
      b2Bound = Box2D.Collision.b2Bound,
      b2BoundValues = Box2D.Collision.b2BoundValues,
      b2Collision = Box2D.Collision.b2Collision,
      b2ContactID = Box2D.Collision.b2ContactID,
      b2ContactPoint = Box2D.Collision.b2ContactPoint,
      b2Distance = Box2D.Collision.b2Distance,
      b2DistanceInput = Box2D.Collision.b2DistanceInput,
      b2DistanceOutput = Box2D.Collision.b2DistanceOutput,
      b2DistanceProxy = Box2D.Collision.b2DistanceProxy,
      b2DynamicTree = Box2D.Collision.b2DynamicTree,
      b2DynamicTreeBroadPhase = Box2D.Collision.b2DynamicTreeBroadPhase,
      b2DynamicTreeNode = Box2D.Collision.b2DynamicTreeNode,
      b2DynamicTreePair = Box2D.Collision.b2DynamicTreePair,
      b2Manifold = Box2D.Collision.b2Manifold,
      b2ManifoldPoint = Box2D.Collision.b2ManifoldPoint,
      b2Point = Box2D.Collision.b2Point,
      b2RayCastInput = Box2D.Collision.b2RayCastInput,
      b2RayCastOutput = Box2D.Collision.b2RayCastOutput,
      b2Segment = Box2D.Collision.b2Segment,
      b2SeparationFunction = Box2D.Collision.b2SeparationFunction,
      b2Simplex = Box2D.Collision.b2Simplex,
      b2SimplexCache = Box2D.Collision.b2SimplexCache,
      b2SimplexVertex = Box2D.Collision.b2SimplexVertex,
      b2TimeOfImpact = Box2D.Collision.b2TimeOfImpact,
      b2TOIInput = Box2D.Collision.b2TOIInput,
      b2WorldManifold = Box2D.Collision.b2WorldManifold,
      ClipVertex = Box2D.Collision.ClipVertex,
      Features = Box2D.Collision.Features,
      IBroadPhase = Box2D.Collision.IBroadPhase,
      b2CircleShape = Box2D.Collision.Shapes.b2CircleShape,
      b2EdgeChainDef = Box2D.Collision.Shapes.b2EdgeChainDef,
      b2EdgeShape = Box2D.Collision.Shapes.b2EdgeShape,
      b2MassData = Box2D.Collision.Shapes.b2MassData,
      b2PolygonShape = Box2D.Collision.Shapes.b2PolygonShape,
      b2Shape = Box2D.Collision.Shapes.b2Shape,
      b2Body = Box2D.Dynamics.b2Body,
      b2BodyDef = Box2D.Dynamics.b2BodyDef,
      b2ContactFilter = Box2D.Dynamics.b2ContactFilter,
      b2ContactImpulse = Box2D.Dynamics.b2ContactImpulse,
      b2ContactListener = Box2D.Dynamics.b2ContactListener,
      b2ContactManager = Box2D.Dynamics.b2ContactManager,
      b2DebugDraw = Box2D.Dynamics.b2DebugDraw,
      b2DestructionListener = Box2D.Dynamics.b2DestructionListener,
      b2FilterData = Box2D.Dynamics.b2FilterData,
      b2Fixture = Box2D.Dynamics.b2Fixture,
      b2FixtureDef = Box2D.Dynamics.b2FixtureDef,
      b2Island = Box2D.Dynamics.b2Island,
      b2TimeStep = Box2D.Dynamics.b2TimeStep,
      b2World = Box2D.Dynamics.b2World,
      b2CircleContact = Box2D.Dynamics.Contacts.b2CircleContact,
      b2Contact = Box2D.Dynamics.Contacts.b2Contact,
      b2ContactConstraint = Box2D.Dynamics.Contacts.b2ContactConstraint,
      b2ContactConstraintPoint = Box2D.Dynamics.Contacts.b2ContactConstraintPoint,
      b2ContactEdge = Box2D.Dynamics.Contacts.b2ContactEdge,
      b2ContactFactory = Box2D.Dynamics.Contacts.b2ContactFactory,
      b2ContactRegister = Box2D.Dynamics.Contacts.b2ContactRegister,
      b2ContactResult = Box2D.Dynamics.Contacts.b2ContactResult,
      b2ContactSolver = Box2D.Dynamics.Contacts.b2ContactSolver,
      b2EdgeAndCircleContact = Box2D.Dynamics.Contacts.b2EdgeAndCircleContact,
      b2NullContact = Box2D.Dynamics.Contacts.b2NullContact,
      b2PolyAndCircleContact = Box2D.Dynamics.Contacts.b2PolyAndCircleContact,
      b2PolyAndEdgeContact = Box2D.Dynamics.Contacts.b2PolyAndEdgeContact,
      b2PolygonContact = Box2D.Dynamics.Contacts.b2PolygonContact,
      b2PositionSolverManifold = Box2D.Dynamics.Contacts.b2PositionSolverManifold,
      b2Controller = Box2D.Dynamics.Controllers.b2Controller,
      b2DistanceJoint = Box2D.Dynamics.Joints.b2DistanceJoint,
      b2DistanceJointDef = Box2D.Dynamics.Joints.b2DistanceJointDef,
      b2FrictionJoint = Box2D.Dynamics.Joints.b2FrictionJoint,
      b2FrictionJointDef = Box2D.Dynamics.Joints.b2FrictionJointDef,
      b2GearJoint = Box2D.Dynamics.Joints.b2GearJoint,
      b2GearJointDef = Box2D.Dynamics.Joints.b2GearJointDef,
      b2Jacobian = Box2D.Dynamics.Joints.b2Jacobian,
      b2Joint = Box2D.Dynamics.Joints.b2Joint,
      b2JointDef = Box2D.Dynamics.Joints.b2JointDef,
      b2JointEdge = Box2D.Dynamics.Joints.b2JointEdge,
      b2LineJoint = Box2D.Dynamics.Joints.b2LineJoint,
      b2LineJointDef = Box2D.Dynamics.Joints.b2LineJointDef,
      b2MouseJoint = Box2D.Dynamics.Joints.b2MouseJoint,
      b2MouseJointDef = Box2D.Dynamics.Joints.b2MouseJointDef,
      b2PrismaticJoint = Box2D.Dynamics.Joints.b2PrismaticJoint,
      b2PrismaticJointDef = Box2D.Dynamics.Joints.b2PrismaticJointDef,
      b2PulleyJoint = Box2D.Dynamics.Joints.b2PulleyJoint,
      b2PulleyJointDef = Box2D.Dynamics.Joints.b2PulleyJointDef,
      b2RevoluteJoint = Box2D.Dynamics.Joints.b2RevoluteJoint,
      b2RevoluteJointDef = Box2D.Dynamics.Joints.b2RevoluteJointDef,
      b2WeldJoint = Box2D.Dynamics.Joints.b2WeldJoint,
      b2WeldJointDef = Box2D.Dynamics.Joints.b2WeldJointDef;

   b2Body.b2Body = function () {
      this.m_xf = new b2Transform();
      this.m_sweep = new b2Sweep();
      this.m_linearVelocity = new b2Vec2();
      this.m_force = new b2Vec2();
   };
   b2Body.prototype.connectEdges = function (s1, s2, angle1) {
      if (angle1 === undefined) angle1 = 0;
      var angle2 = Math.atan2(s2.GetDirectionVector().y, s2.GetDirectionVector().x);
      var coreOffset = Math.tan((angle2 - angle1) * 0.5);
      var core = b2Math.MulFV(coreOffset, s2.GetDirectionVector());
      core = b2Math.SubtractVV(core, s2.GetNormalVector());
      core = b2Math.MulFV(b2Settings.b2_toiSlop, core);
      core = b2Math.AddVV(core, s2.GetVertex1());
      var cornerDir = b2Math.AddVV(s1.GetDirectionVector(), s2.GetDirectionVector());
      cornerDir.Normalize();
      var convex = b2Math.Dot(s1.GetDirectionVector(), s2.GetNormalVector()) > 0.0;
      s1.SetNextEdge(s2, core, cornerDir, convex);
      s2.SetPrevEdge(s1, core, cornerDir, convex);
      return angle2;
   }
   b2Body.prototype.CreateFixture = function (def) {
      if (this.m_world.IsLocked() == true) {
         return null;
      }
      var fixture = new b2Fixture();
      fixture.Create(this, this.m_xf, def);
      if (this.m_flags & b2Body.e_activeFlag) {
         var broadPhase = this.m_world.m_contactManager.m_broadPhase;
         fixture.CreateProxy(broadPhase, this.m_xf);
      }
      fixture.m_next = this.m_fixtureList;
      this.m_fixtureList = fixture;
      ++this.m_fixtureCount;
      fixture.m_body = this;
      if (fixture.m_density > 0.0) {
         this.ResetMassData();
      }
      this.m_world.m_flags |= b2World.e_newFixture;
      return fixture;
   }
   b2Body.prototype.CreateFixture2 = function (shape, density) {
      if (density === undefined) density = 0.0;
      var def = new b2FixtureDef();
      def.shape = shape;
      def.density = density;
      return this.CreateFixture(def);
   }
   b2Body.prototype.DestroyFixture = function (fixture) {
      if (this.m_world.IsLocked() == true) {
         return;
      }
      var node = this.m_fixtureList;
      var ppF = null;
      var found = false;
      while (node != null) {
         if (node == fixture) {
            if (ppF) ppF.m_next = fixture.m_next;
            else this.m_fixtureList = fixture.m_next;
            found = true;
            break;
         }
         ppF = node;
         node = node.m_next;
      }
      var edge = this.m_contactList;
      while (edge) {
         var c = edge.contact;
         edge = edge.next;
         var fixtureA = c.GetFixtureA();
         var fixtureB = c.GetFixtureB();
         if (fixture == fixtureA || fixture == fixtureB) {
            this.m_world.m_contactManager.Destroy(c);
         }
      }
      if (this.m_flags & b2Body.e_activeFlag) {
         var broadPhase = this.m_world.m_contactManager.m_broadPhase;
         fixture.DestroyProxy(broadPhase);
      }
      else {}
      fixture.Destroy();
      fixture.m_body = null;
      fixture.m_next = null;
      --this.m_fixtureCount;
      this.ResetMassData();
   }
   b2Body.prototype.SetPositionAndAngle = function (position, angle) {
      if (angle === undefined) angle = 0;
      var f;
      if (this.m_world.IsLocked() == true) {
         return;
      }
      this.m_xf.R.Set(angle);
      this.m_xf.position.SetV(position);
      var tMat = this.m_xf.R;
      var tVec = this.m_sweep.localCenter;
      this.m_sweep.c.x = (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      this.m_sweep.c.y = (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      this.m_sweep.c.x += this.m_xf.position.x;
      this.m_sweep.c.y += this.m_xf.position.y;
      this.m_sweep.c0.SetV(this.m_sweep.c);
      this.m_sweep.a0 = this.m_sweep.a = angle;
      var broadPhase = this.m_world.m_contactManager.m_broadPhase;
      for (f = this.m_fixtureList;
      f; f = f.m_next) {
         f.Synchronize(broadPhase, this.m_xf, this.m_xf);
      }
      this.m_world.m_contactManager.FindNewContacts();
   }
   b2Body.prototype.SetTransform = function (xf) {
      this.SetPositionAndAngle(xf.position, xf.GetAngle());
   }
   b2Body.prototype.GetTransform = function () {
      return this.m_xf;
   }
   b2Body.prototype.GetPosition = function () {
      return this.m_xf.position;
   }
   b2Body.prototype.SetPosition = function (position) {
      this.SetPositionAndAngle(position, this.GetAngle());
   }
   b2Body.prototype.GetAngle = function () {
      return this.m_sweep.a;
   }
   b2Body.prototype.SetAngle = function (angle) {
      if (angle === undefined) angle = 0;
      this.SetPositionAndAngle(this.GetPosition(), angle);
   }
   b2Body.prototype.GetWorldCenter = function () {
      return this.m_sweep.c;
   }
   b2Body.prototype.GetLocalCenter = function () {
      return this.m_sweep.localCenter;
   }
   b2Body.prototype.SetLinearVelocity = function (v) {
      if (this.m_type == b2Body.b2_staticBody) {
         return;
      }
      this.m_linearVelocity.SetV(v);
   }
   b2Body.prototype.GetLinearVelocity = function () {
      return this.m_linearVelocity;
   }
   b2Body.prototype.SetAngularVelocity = function (omega) {
      if (omega === undefined) omega = 0;
      if (this.m_type == b2Body.b2_staticBody) {
         return;
      }
      this.m_angularVelocity = omega;
   }
   b2Body.prototype.GetAngularVelocity = function () {
      return this.m_angularVelocity;
   }
   b2Body.prototype.GetDefinition = function () {
      var bd = new b2BodyDef();
      bd.type = this.GetType();
      bd.allowSleep = (this.m_flags & b2Body.e_allowSleepFlag) == b2Body.e_allowSleepFlag;
      bd.angle = this.GetAngle();
      bd.angularDamping = this.m_angularDamping;
      bd.angularVelocity = this.m_angularVelocity;
      bd.fixedRotation = (this.m_flags & b2Body.e_fixedRotationFlag) == b2Body.e_fixedRotationFlag;
      bd.bullet = (this.m_flags & b2Body.e_bulletFlag) == b2Body.e_bulletFlag;
      bd.awake = (this.m_flags & b2Body.e_awakeFlag) == b2Body.e_awakeFlag;
      bd.linearDamping = this.m_linearDamping;
      bd.linearVelocity.SetV(this.GetLinearVelocity());
      bd.position = this.GetPosition();
      bd.userData = this.GetUserData();
      return bd;
   }
   b2Body.prototype.ApplyForce = function (force, point) {
      if (this.m_type != b2Body.b2_dynamicBody) {
         return;
      }
      if (this.IsAwake() == false) {
         this.SetAwake(true);
      }
      this.m_force.x += force.x;
      this.m_force.y += force.y;
      this.m_torque += ((point.x - this.m_sweep.c.x) * force.y - (point.y - this.m_sweep.c.y) * force.x);
   }
   b2Body.prototype.ApplyTorque = function (torque) {
      if (torque === undefined) torque = 0;
      if (this.m_type != b2Body.b2_dynamicBody) {
         return;
      }
      if (this.IsAwake() == false) {
         this.SetAwake(true);
      }
      this.m_torque += torque;
   }
   b2Body.prototype.ApplyImpulse = function (impulse, point) {
      if (this.m_type != b2Body.b2_dynamicBody) {
         return;
      }
      if (this.IsAwake() == false) {
         this.SetAwake(true);
      }
      this.m_linearVelocity.x += this.m_invMass * impulse.x;
      this.m_linearVelocity.y += this.m_invMass * impulse.y;
      this.m_angularVelocity += this.m_invI * ((point.x - this.m_sweep.c.x) * impulse.y - (point.y - this.m_sweep.c.y) * impulse.x);
   }
   b2Body.prototype.Split = function (callback) {
      var linearVelocity = this.GetLinearVelocity().Copy();
      var angularVelocity = this.GetAngularVelocity();
      var center = this.GetWorldCenter();
      var body1 = this;
      var body2 = this.m_world.CreateBody(this.GetDefinition());
      var prev;
      for (var f = body1.m_fixtureList; f;) {
         if (callback(f)) {
            var next = f.m_next;
            if (prev) {
               prev.m_next = next;
            }
            else {
               body1.m_fixtureList = next;
            }
            body1.m_fixtureCount--;
            f.m_next = body2.m_fixtureList;
            body2.m_fixtureList = f;
            body2.m_fixtureCount++;
            f.m_body = body2;
            f = next;
         }
         else {
            prev = f;
            f = f.m_next;
         }
      }
      body1.ResetMassData();
      body2.ResetMassData();
      var center1 = body1.GetWorldCenter();
      var center2 = body2.GetWorldCenter();
      var velocity1 = b2Math.AddVV(linearVelocity, b2Math.CrossFV(angularVelocity, b2Math.SubtractVV(center1, center)));
      var velocity2 = b2Math.AddVV(linearVelocity, b2Math.CrossFV(angularVelocity, b2Math.SubtractVV(center2, center)));
      body1.SetLinearVelocity(velocity1);
      body2.SetLinearVelocity(velocity2);
      body1.SetAngularVelocity(angularVelocity);
      body2.SetAngularVelocity(angularVelocity);
      body1.SynchronizeFixtures();
      body2.SynchronizeFixtures();
      return body2;
   }
   b2Body.prototype.Merge = function (other) {
      var f;
      for (f = other.m_fixtureList;
      f;) {
         var next = f.m_next;
         other.m_fixtureCount--;
         f.m_next = this.m_fixtureList;
         this.m_fixtureList = f;
         this.m_fixtureCount++;
         f.m_body = body2;
         f = next;
      }
      body1.m_fixtureCount = 0;
      var body1 = this;
      var body2 = other;
      var center1 = body1.GetWorldCenter();
      var center2 = body2.GetWorldCenter();
      var velocity1 = body1.GetLinearVelocity().Copy();
      var velocity2 = body2.GetLinearVelocity().Copy();
      var angular1 = body1.GetAngularVelocity();
      var angular = body2.GetAngularVelocity();
      body1.ResetMassData();
      this.SynchronizeFixtures();
   }
   b2Body.prototype.GetMass = function () {
      return this.m_mass;
   }
   b2Body.prototype.GetInertia = function () {
      return this.m_I;
   }
   b2Body.prototype.GetMassData = function (data) {
      data.mass = this.m_mass;
      data.I = this.m_I;
      data.center.SetV(this.m_sweep.localCenter);
   }
   b2Body.prototype.SetMassData = function (massData) {
      b2Settings.b2Assert(this.m_world.IsLocked() == false);
      if (this.m_world.IsLocked() == true) {
         return;
      }
      if (this.m_type != b2Body.b2_dynamicBody) {
         return;
      }
      this.m_invMass = 0.0;
      this.m_I = 0.0;
      this.m_invI = 0.0;
      this.m_mass = massData.mass;
      if (this.m_mass <= 0.0) {
         this.m_mass = 1.0;
      }
      this.m_invMass = 1.0 / this.m_mass;
      if (massData.I > 0.0 && (this.m_flags & b2Body.e_fixedRotationFlag) == 0) {
         this.m_I = massData.I - this.m_mass * (massData.center.x * massData.center.x + massData.center.y * massData.center.y);
         this.m_invI = 1.0 / this.m_I;
      }
      var oldCenter = this.m_sweep.c.Copy();
      this.m_sweep.localCenter.SetV(massData.center);
      this.m_sweep.c0.SetV(b2Math.MulX(this.m_xf, this.m_sweep.localCenter));
      this.m_sweep.c.SetV(this.m_sweep.c0);
      this.m_linearVelocity.x += this.m_angularVelocity * (-(this.m_sweep.c.y - oldCenter.y));
      this.m_linearVelocity.y += this.m_angularVelocity * (+(this.m_sweep.c.x - oldCenter.x));
   }
   b2Body.prototype.ResetMassData = function () {
      this.m_mass = 0.0;
      this.m_invMass = 0.0;
      this.m_I = 0.0;
      this.m_invI = 0.0;
      this.m_sweep.localCenter.SetZero();
      if (this.m_type == b2Body.b2_staticBody || this.m_type == b2Body.b2_kinematicBody) {
         return;
      }
      var center = b2Vec2.Make(0, 0);
      for (var f = this.m_fixtureList; f; f = f.m_next) {
         if (f.m_density == 0.0) {
            continue;
         }
         var massData = f.GetMassData();
         this.m_mass += massData.mass;
         center.x += massData.center.x * massData.mass;
         center.y += massData.center.y * massData.mass;
         this.m_I += massData.I;
      }
      if (this.m_mass > 0.0) {
         this.m_invMass = 1.0 / this.m_mass;
         center.x *= this.m_invMass;
         center.y *= this.m_invMass;
      }
      else {
         this.m_mass = 1.0;
         this.m_invMass = 1.0;
      }
      if (this.m_I > 0.0 && (this.m_flags & b2Body.e_fixedRotationFlag) == 0) {
         this.m_I -= this.m_mass * (center.x * center.x + center.y * center.y);
         this.m_I *= this.m_inertiaScale;
         b2Settings.b2Assert(this.m_I > 0);
         this.m_invI = 1.0 / this.m_I;
      }
      else {
         this.m_I = 0.0;
         this.m_invI = 0.0;
      }
      var oldCenter = this.m_sweep.c.Copy();
      this.m_sweep.localCenter.SetV(center);
      this.m_sweep.c0.SetV(b2Math.MulX(this.m_xf, this.m_sweep.localCenter));
      this.m_sweep.c.SetV(this.m_sweep.c0);
      this.m_linearVelocity.x += this.m_angularVelocity * (-(this.m_sweep.c.y - oldCenter.y));
      this.m_linearVelocity.y += this.m_angularVelocity * (+(this.m_sweep.c.x - oldCenter.x));
   }
   b2Body.prototype.GetWorldPoint = function (localPoint) {
      var A = this.m_xf.R;
      var u = new b2Vec2(A.col1.x * localPoint.x + A.col2.x * localPoint.y, A.col1.y * localPoint.x + A.col2.y * localPoint.y);
      u.x += this.m_xf.position.x;
      u.y += this.m_xf.position.y;
      return u;
   }
   b2Body.prototype.GetWorldVector = function (localVector) {
      return b2Math.MulMV(this.m_xf.R, localVector);
   }
   b2Body.prototype.GetLocalPoint = function (worldPoint) {
      return b2Math.MulXT(this.m_xf, worldPoint);
   }
   b2Body.prototype.GetLocalVector = function (worldVector) {
      return b2Math.MulTMV(this.m_xf.R, worldVector);
   }
   b2Body.prototype.GetLinearVelocityFromWorldPoint = function (worldPoint) {
      return new b2Vec2(this.m_linearVelocity.x - this.m_angularVelocity * (worldPoint.y - this.m_sweep.c.y), this.m_linearVelocity.y + this.m_angularVelocity * (worldPoint.x - this.m_sweep.c.x));
   }
   b2Body.prototype.GetLinearVelocityFromLocalPoint = function (localPoint) {
      var A = this.m_xf.R;
      var worldPoint = new b2Vec2(A.col1.x * localPoint.x + A.col2.x * localPoint.y, A.col1.y * localPoint.x + A.col2.y * localPoint.y);
      worldPoint.x += this.m_xf.position.x;
      worldPoint.y += this.m_xf.position.y;
      return new b2Vec2(this.m_linearVelocity.x - this.m_angularVelocity * (worldPoint.y - this.m_sweep.c.y), this.m_linearVelocity.y + this.m_angularVelocity * (worldPoint.x - this.m_sweep.c.x));
   }
   b2Body.prototype.GetLinearDamping = function () {
      return this.m_linearDamping;
   }
   b2Body.prototype.SetLinearDamping = function (linearDamping) {
      if (linearDamping === undefined) linearDamping = 0;
      this.m_linearDamping = linearDamping;
   }
   b2Body.prototype.GetAngularDamping = function () {
      return this.m_angularDamping;
   }
   b2Body.prototype.SetAngularDamping = function (angularDamping) {
      if (angularDamping === undefined) angularDamping = 0;
      this.m_angularDamping = angularDamping;
   }
   b2Body.prototype.SetType = function (type) {
      if (type === undefined) type = 0;
      if (this.m_type == type) {
         return;
      }
      this.m_type = type;
      this.ResetMassData();
      if (this.m_type == b2Body.b2_staticBody) {
         this.m_linearVelocity.SetZero();
         this.m_angularVelocity = 0.0;
      }
      this.SetAwake(true);
      this.m_force.SetZero();
      this.m_torque = 0.0;
      for (var ce = this.m_contactList; ce; ce = ce.next) {
         ce.contact.FlagForFiltering();
      }
   }
   b2Body.prototype.GetType = function () {
      return this.m_type;
   }
   b2Body.prototype.SetBullet = function (flag) {
      if (flag) {
         this.m_flags |= b2Body.e_bulletFlag;
      }
      else {
         this.m_flags &= ~b2Body.e_bulletFlag;
      }
   }
   b2Body.prototype.IsBullet = function () {
      return (this.m_flags & b2Body.e_bulletFlag) == b2Body.e_bulletFlag;
   }
   b2Body.prototype.SetSleepingAllowed = function (flag) {
      if (flag) {
         this.m_flags |= b2Body.e_allowSleepFlag;
      }
      else {
         this.m_flags &= ~b2Body.e_allowSleepFlag;
         this.SetAwake(true);
      }
   }
   b2Body.prototype.SetAwake = function (flag) {
      if (flag) {
         this.m_flags |= b2Body.e_awakeFlag;
         this.m_sleepTime = 0.0;
      }
      else {
         this.m_flags &= ~b2Body.e_awakeFlag;
         this.m_sleepTime = 0.0;
         this.m_linearVelocity.SetZero();
         this.m_angularVelocity = 0.0;
         this.m_force.SetZero();
         this.m_torque = 0.0;
      }
   }
   b2Body.prototype.IsAwake = function () {
      return (this.m_flags & b2Body.e_awakeFlag) == b2Body.e_awakeFlag;
   }
   b2Body.prototype.SetFixedRotation = function (fixed) {
      if (fixed) {
         this.m_flags |= b2Body.e_fixedRotationFlag;
      }
      else {
         this.m_flags &= ~b2Body.e_fixedRotationFlag;
      }
      this.ResetMassData();
   }
   b2Body.prototype.IsFixedRotation = function () {
      return (this.m_flags & b2Body.e_fixedRotationFlag) == b2Body.e_fixedRotationFlag;
   }
   b2Body.prototype.SetActive = function (flag) {
      if (flag == this.IsActive()) {
         return;
      }
      var broadPhase;
      var f;
      if (flag) {
         this.m_flags |= b2Body.e_activeFlag;
         broadPhase = this.m_world.m_contactManager.m_broadPhase;
         for (f = this.m_fixtureList;
         f; f = f.m_next) {
            f.CreateProxy(broadPhase, this.m_xf);
         }
      }
      else {
         this.m_flags &= ~b2Body.e_activeFlag;
         broadPhase = this.m_world.m_contactManager.m_broadPhase;
         for (f = this.m_fixtureList;
         f; f = f.m_next) {
            f.DestroyProxy(broadPhase);
         }
         var ce = this.m_contactList;
         while (ce) {
            var ce0 = ce;
            ce = ce.next;
            this.m_world.m_contactManager.Destroy(ce0.contact);
         }
         this.m_contactList = null;
      }
   }
   b2Body.prototype.IsActive = function () {
      return (this.m_flags & b2Body.e_activeFlag) == b2Body.e_activeFlag;
   }
   b2Body.prototype.IsSleepingAllowed = function () {
      return (this.m_flags & b2Body.e_allowSleepFlag) == b2Body.e_allowSleepFlag;
   }
   b2Body.prototype.GetFixtureList = function () {
      return this.m_fixtureList;
   }
   b2Body.prototype.GetJointList = function () {
      return this.m_jointList;
   }
   b2Body.prototype.GetControllerList = function () {
      return this.m_controllerList;
   }
   b2Body.prototype.GetContactList = function () {
      return this.m_contactList;
   }
   b2Body.prototype.GetNext = function () {
      return this.m_next;
   }
   b2Body.prototype.GetUserData = function () {
      return this.m_userData;
   }
   b2Body.prototype.SetUserData = function (data) {
      this.m_userData = data;
   }
   b2Body.prototype.GetWorld = function () {
      return this.m_world;
   }
   b2Body.prototype.b2Body = function (bd, world) {
      this.m_flags = 0;
      if (bd.bullet) {
         this.m_flags |= b2Body.e_bulletFlag;
      }
      if (bd.fixedRotation) {
         this.m_flags |= b2Body.e_fixedRotationFlag;
      }
      if (bd.allowSleep) {
         this.m_flags |= b2Body.e_allowSleepFlag;
      }
      if (bd.awake) {
         this.m_flags |= b2Body.e_awakeFlag;
      }
      if (bd.active) {
         this.m_flags |= b2Body.e_activeFlag;
      }
      this.m_world = world;
      this.m_xf.position.SetV(bd.position);
      this.m_xf.R.Set(bd.angle);
      this.m_sweep.localCenter.SetZero();
      this.m_sweep.t0 = 1.0;
      this.m_sweep.a0 = this.m_sweep.a = bd.angle;
      var tMat = this.m_xf.R;
      var tVec = this.m_sweep.localCenter;
      this.m_sweep.c.x = (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      this.m_sweep.c.y = (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      this.m_sweep.c.x += this.m_xf.position.x;
      this.m_sweep.c.y += this.m_xf.position.y;
      this.m_sweep.c0.SetV(this.m_sweep.c);
      this.m_jointList = null;
      this.m_controllerList = null;
      this.m_contactList = null;
      this.m_controllerCount = 0;
      this.m_prev = null;
      this.m_next = null;
      this.m_linearVelocity.SetV(bd.linearVelocity);
      this.m_angularVelocity = bd.angularVelocity;
      this.m_linearDamping = bd.linearDamping;
      this.m_angularDamping = bd.angularDamping;
      this.m_force.Set(0.0, 0.0);
      this.m_torque = 0.0;
      this.m_sleepTime = 0.0;
      this.m_type = bd.type;
      if (this.m_type == b2Body.b2_dynamicBody) {
         this.m_mass = 1.0;
         this.m_invMass = 1.0;
      }
      else {
         this.m_mass = 0.0;
         this.m_invMass = 0.0;
      }
      this.m_I = 0.0;
      this.m_invI = 0.0;
      this.m_inertiaScale = bd.inertiaScale;
      this.m_userData = bd.userData;
      this.m_fixtureList = null;
      this.m_fixtureCount = 0;
   }
   b2Body.prototype.SynchronizeFixtures = function () {
      var xf1 = b2Body.s_xf1;
      xf1.R.Set(this.m_sweep.a0);
      var tMat = xf1.R;
      var tVec = this.m_sweep.localCenter;
      xf1.position.x = this.m_sweep.c0.x - (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      xf1.position.y = this.m_sweep.c0.y - (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      var f;
      var broadPhase = this.m_world.m_contactManager.m_broadPhase;
      for (f = this.m_fixtureList;
      f; f = f.m_next) {
         f.Synchronize(broadPhase, xf1, this.m_xf);
      }
   }
   b2Body.prototype.SynchronizeTransform = function () {
      this.m_xf.R.Set(this.m_sweep.a);
      var tMat = this.m_xf.R;
      var tVec = this.m_sweep.localCenter;
      this.m_xf.position.x = this.m_sweep.c.x - (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      this.m_xf.position.y = this.m_sweep.c.y - (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
   }
   b2Body.prototype.ShouldCollide = function (other) {
      if (this.m_type != b2Body.b2_dynamicBody && other.m_type != b2Body.b2_dynamicBody) {
         return false;
      }
      for (var jn = this.m_jointList; jn; jn = jn.next) {
         if (jn.other == other) if (jn.joint.m_collideConnected == false) {
            return false;
         }
      }
      return true;
   }
   b2Body.prototype.Advance = function (t) {
      if (t === undefined) t = 0;
      this.m_sweep.Advance(t);
      this.m_sweep.c.SetV(this.m_sweep.c0);
      this.m_sweep.a = this.m_sweep.a0;
      this.SynchronizeTransform();
   }
   Box2D.postDefs.push(function () {
      Box2D.Dynamics.b2Body.s_xf1 = new b2Transform();
      Box2D.Dynamics.b2Body.e_islandFlag = 0x0001;
      Box2D.Dynamics.b2Body.e_awakeFlag = 0x0002;
      Box2D.Dynamics.b2Body.e_allowSleepFlag = 0x0004;
      Box2D.Dynamics.b2Body.e_bulletFlag = 0x0008;
      Box2D.Dynamics.b2Body.e_fixedRotationFlag = 0x0010;
      Box2D.Dynamics.b2Body.e_activeFlag = 0x0020;
      Box2D.Dynamics.b2Body.b2_staticBody = 0;
      Box2D.Dynamics.b2Body.b2_kinematicBody = 1;
      Box2D.Dynamics.b2Body.b2_dynamicBody = 2;
   });
   b2BodyDef.b2BodyDef = function () {
      this.position = new b2Vec2();
      this.linearVelocity = new b2Vec2();
   };
   b2BodyDef.prototype.b2BodyDef = function () {
      this.userData = null;
      this.position.Set(0.0, 0.0);
      this.angle = 0.0;
      this.linearVelocity.Set(0, 0);
      this.angularVelocity = 0.0;
      this.linearDamping = 0.0;
      this.angularDamping = 0.0;
      this.allowSleep = true;
      this.awake = true;
      this.fixedRotation = false;
      this.bullet = false;
      this.type = b2Body.b2_staticBody;
      this.active = true;
      this.inertiaScale = 1.0;
   }
   b2ContactFilter.b2ContactFilter = function () {};
   b2ContactFilter.prototype.ShouldCollide = function (fixtureA, fixtureB) {
      var filter1 = fixtureA.GetFilterData();
      var filter2 = fixtureB.GetFilterData();
      if (filter1.groupIndex == filter2.groupIndex && filter1.groupIndex != 0) {
         return filter1.groupIndex > 0;
      }
      var collide = (filter1.maskBits & filter2.categoryBits) != 0 && (filter1.categoryBits & filter2.maskBits) != 0;
      return collide;
   }
   b2ContactFilter.prototype.RayCollide = function (userData, fixture) {
      if (!userData) return true;
      return this.ShouldCollide((userData instanceof b2Fixture ? userData : null), fixture);
   }
   Box2D.postDefs.push(function () {
      Box2D.Dynamics.b2ContactFilter.b2_defaultFilter = new b2ContactFilter();
   });
   b2ContactImpulse.b2ContactImpulse = function () {
      this.normalImpulses = new Vector_a2j_Number(b2Settings.b2_maxManifoldPoints);
      this.tangentImpulses = new Vector_a2j_Number(b2Settings.b2_maxManifoldPoints);
   };
   b2ContactListener.b2ContactListener = function () {};
   b2ContactListener.prototype.BeginContact = function (contact) {}
   b2ContactListener.prototype.EndContact = function (contact) {}
   b2ContactListener.prototype.PreSolve = function (contact, oldManifold) {}
   b2ContactListener.prototype.PostSolve = function (contact, impulse) {}
   Box2D.postDefs.push(function () {
      Box2D.Dynamics.b2ContactListener.b2_defaultListener = new b2ContactListener();
   });
   b2ContactManager.b2ContactManager = function () {};
   b2ContactManager.prototype.b2ContactManager = function () {
      this.m_world = null;
      this.m_contactCount = 0;
      this.m_contactFilter = b2ContactFilter.b2_defaultFilter;
      this.m_contactListener = b2ContactListener.b2_defaultListener;
      this.m_contactFactory = new b2ContactFactory(this.m_allocator);
      this.m_broadPhase = new b2DynamicTreeBroadPhase();
   }
   b2ContactManager.prototype.AddPair = function (proxyUserDataA, proxyUserDataB) {
      var fixtureA = (proxyUserDataA instanceof b2Fixture ? proxyUserDataA : null);
      var fixtureB = (proxyUserDataB instanceof b2Fixture ? proxyUserDataB : null);
      var bodyA = fixtureA.GetBody();
      var bodyB = fixtureB.GetBody();
      if (bodyA == bodyB) return;
      var edge = bodyB.GetContactList();
      while (edge) {
         if (edge.other == bodyA) {
            var fA = edge.contact.GetFixtureA();
            var fB = edge.contact.GetFixtureB();
            if (fA == fixtureA && fB == fixtureB) return;
            if (fA == fixtureB && fB == fixtureA) return;
         }
         edge = edge.next;
      }
      if (bodyB.ShouldCollide(bodyA) == false) {
         return;
      }
      if (this.m_contactFilter.ShouldCollide(fixtureA, fixtureB) == false) {
         return;
      }
      var c = this.m_contactFactory.Create(fixtureA, fixtureB);
      fixtureA = c.GetFixtureA();
      fixtureB = c.GetFixtureB();
      bodyA = fixtureA.m_body;
      bodyB = fixtureB.m_body;
      c.m_prev = null;
      c.m_next = this.m_world.m_contactList;
      if (this.m_world.m_contactList != null) {
         this.m_world.m_contactList.m_prev = c;
      }
      this.m_world.m_contactList = c;
      c.m_nodeA.contact = c;
      c.m_nodeA.other = bodyB;
      c.m_nodeA.prev = null;
      c.m_nodeA.next = bodyA.m_contactList;
      if (bodyA.m_contactList != null) {
         bodyA.m_contactList.prev = c.m_nodeA;
      }
      bodyA.m_contactList = c.m_nodeA;
      c.m_nodeB.contact = c;
      c.m_nodeB.other = bodyA;
      c.m_nodeB.prev = null;
      c.m_nodeB.next = bodyB.m_contactList;
      if (bodyB.m_contactList != null) {
         bodyB.m_contactList.prev = c.m_nodeB;
      }
      bodyB.m_contactList = c.m_nodeB;
      ++this.m_world.m_contactCount;
      return;
   }
   b2ContactManager.prototype.FindNewContacts = function () {
      this.m_broadPhase.UpdatePairs(Box2D.generateCallback(this, this.AddPair));
   }
   b2ContactManager.prototype.Destroy = function (c) {
      var fixtureA = c.GetFixtureA();
      var fixtureB = c.GetFixtureB();
      var bodyA = fixtureA.GetBody();
      var bodyB = fixtureB.GetBody();
      if (c.IsTouching()) {
         this.m_contactListener.EndContact(c);
      }
      if (c.m_prev) {
         c.m_prev.m_next = c.m_next;
      }
      if (c.m_next) {
         c.m_next.m_prev = c.m_prev;
      }
      if (c == this.m_world.m_contactList) {
         this.m_world.m_contactList = c.m_next;
      }
      if (c.m_nodeA.prev) {
         c.m_nodeA.prev.next = c.m_nodeA.next;
      }
      if (c.m_nodeA.next) {
         c.m_nodeA.next.prev = c.m_nodeA.prev;
      }
      if (c.m_nodeA == bodyA.m_contactList) {
         bodyA.m_contactList = c.m_nodeA.next;
      }
      if (c.m_nodeB.prev) {
         c.m_nodeB.prev.next = c.m_nodeB.next;
      }
      if (c.m_nodeB.next) {
         c.m_nodeB.next.prev = c.m_nodeB.prev;
      }
      if (c.m_nodeB == bodyB.m_contactList) {
         bodyB.m_contactList = c.m_nodeB.next;
      }
      this.m_contactFactory.Destroy(c);
      --this.m_contactCount;
   }
   b2ContactManager.prototype.Collide = function () {
      var c = this.m_world.m_contactList;
      while (c) {
         var fixtureA = c.GetFixtureA();
         var fixtureB = c.GetFixtureB();
         var bodyA = fixtureA.GetBody();
         var bodyB = fixtureB.GetBody();
         if (bodyA.IsAwake() == false && bodyB.IsAwake() == false) {
            c = c.GetNext();
            continue;
         }
         if (c.m_flags & b2Contact.e_filterFlag) {
            if (bodyB.ShouldCollide(bodyA) == false) {
               var cNuke = c;
               c = cNuke.GetNext();
               this.Destroy(cNuke);
               continue;
            }
            if (this.m_contactFilter.ShouldCollide(fixtureA, fixtureB) == false) {
               cNuke = c;
               c = cNuke.GetNext();
               this.Destroy(cNuke);
               continue;
            }
            c.m_flags &= ~b2Contact.e_filterFlag;
         }
         var proxyA = fixtureA.m_proxy;
         var proxyB = fixtureB.m_proxy;
		 if (proxyA && proxyB) {
			 var overlap = this.m_broadPhase.TestOverlap(proxyA, proxyB);
			 if (overlap == false) {
				cNuke = c;
				c = cNuke.GetNext();
				this.Destroy(cNuke);
				continue;
			 }
	  	 }
         c.Update(this.m_contactListener);
         c = c.GetNext();
      }
   }
   Box2D.postDefs.push(function () {
      Box2D.Dynamics.b2ContactManager.s_evalCP = new b2ContactPoint();
   });
   b2DebugDraw.b2DebugDraw = function () {};
   b2DebugDraw.prototype.b2DebugDraw = function () {}
   b2DebugDraw.prototype.SetFlags = function (flags) {
      if (flags === undefined) flags = 0;
   }
   b2DebugDraw.prototype.GetFlags = function () {}
   b2DebugDraw.prototype.AppendFlags = function (flags) {
      if (flags === undefined) flags = 0;
   }
   b2DebugDraw.prototype.ClearFlags = function (flags) {
      if (flags === undefined) flags = 0;
   }
   b2DebugDraw.prototype.SetSprite = function (sprite) {}
   b2DebugDraw.prototype.GetSprite = function () {}
   b2DebugDraw.prototype.SetDrawScale = function (drawScale) {
      if (drawScale === undefined) drawScale = 0;
   }
   b2DebugDraw.prototype.GetDrawScale = function () {}
   b2DebugDraw.prototype.SetLineThickness = function (lineThickness) {
      if (lineThickness === undefined) lineThickness = 0;
   }
   b2DebugDraw.prototype.GetLineThickness = function () {}
   b2DebugDraw.prototype.SetAlpha = function (alpha) {
      if (alpha === undefined) alpha = 0;
   }
   b2DebugDraw.prototype.GetAlpha = function () {}
   b2DebugDraw.prototype.SetFillAlpha = function (alpha) {
      if (alpha === undefined) alpha = 0;
   }
   b2DebugDraw.prototype.GetFillAlpha = function () {}
   b2DebugDraw.prototype.SetXFormScale = function (xformScale) {
      if (xformScale === undefined) xformScale = 0;
   }
   b2DebugDraw.prototype.GetXFormScale = function () {}
   b2DebugDraw.prototype.DrawPolygon = function (vertices, vertexCount, color) {
      if (vertexCount === undefined) vertexCount = 0;
   }
   b2DebugDraw.prototype.DrawSolidPolygon = function (vertices, vertexCount, color) {
      if (vertexCount === undefined) vertexCount = 0;
   }
   b2DebugDraw.prototype.DrawCircle = function (center, radius, color) {
      if (radius === undefined) radius = 0;
   }
   b2DebugDraw.prototype.DrawSolidCircle = function (center, radius, axis, color) {
      if (radius === undefined) radius = 0;
   }
   b2DebugDraw.prototype.DrawSegment = function (p1, p2, color) {}
   b2DebugDraw.prototype.DrawTransform = function (xf) {}
   Box2D.postDefs.push(function () {
      Box2D.Dynamics.b2DebugDraw.e_shapeBit = 0x0001;
      Box2D.Dynamics.b2DebugDraw.e_jointBit = 0x0002;
      Box2D.Dynamics.b2DebugDraw.e_aabbBit = 0x0004;
      Box2D.Dynamics.b2DebugDraw.e_pairBit = 0x0008;
      Box2D.Dynamics.b2DebugDraw.e_centerOfMassBit = 0x0010;
      Box2D.Dynamics.b2DebugDraw.e_controllerBit = 0x0020;
   });
   b2DestructionListener.b2DestructionListener = function () {};
   b2DestructionListener.prototype.SayGoodbyeJoint = function (joint) {}
   b2DestructionListener.prototype.SayGoodbyeFixture = function (fixture) {}
   b2FilterData.b2FilterData = function () {
      this.categoryBits = 0x0001;
      this.maskBits = 0xFFFF;
      this.groupIndex = 0;
   };
   b2FilterData.prototype.Copy = function () {
      var copy = new b2FilterData();
      copy.categoryBits = this.categoryBits;
      copy.maskBits = this.maskBits;
      copy.groupIndex = this.groupIndex;
      return copy;
   }
   b2Fixture.b2Fixture = function () {
      this.m_filter = new b2FilterData();
   };
   b2Fixture.prototype.GetType = function () {
      return this.m_shape.GetType();
   }
   b2Fixture.prototype.GetShape = function () {
      return this.m_shape;
   }
   b2Fixture.prototype.SetSensor = function (sensor) {
      if (this.m_isSensor == sensor) return;
      this.m_isSensor = sensor;
      if (this.m_body == null) return;
      var edge = this.m_body.GetContactList();
      while (edge) {
         var contact = edge.contact;
         var fixtureA = contact.GetFixtureA();
         var fixtureB = contact.GetFixtureB();
         if (fixtureA == this || fixtureB == this) contact.SetSensor(fixtureA.IsSensor() || fixtureB.IsSensor());
         edge = edge.next;
      }
   }
   b2Fixture.prototype.IsSensor = function () {
      return this.m_isSensor;
   }
   b2Fixture.prototype.SetFilterData = function (filter) {
      this.m_filter = filter.Copy();
      if (this.m_body) return;
      var edge = this.m_body.GetContactList();
      while (edge) {
         var contact = edge.contact;
         var fixtureA = contact.GetFixtureA();
         var fixtureB = contact.GetFixtureB();
         if (fixtureA == this || fixtureB == this) contact.FlagForFiltering();
         edge = edge.next;
      }
   }
   b2Fixture.prototype.GetFilterData = function () {
      return this.m_filter.Copy();
   }
   b2Fixture.prototype.GetBody = function () {
      return this.m_body;
   }
   b2Fixture.prototype.GetNext = function () {
      return this.m_next;
   }
   b2Fixture.prototype.GetUserData = function () {
      return this.m_userData;
   }
   b2Fixture.prototype.SetUserData = function (data) {
      this.m_userData = data;
   }
   b2Fixture.prototype.TestPoint = function (p) {
      return this.m_shape.TestPoint(this.m_body.GetTransform(), p);
   }
   b2Fixture.prototype.RayCast = function (output, input) {
      return this.m_shape.RayCast(output, input, this.m_body.GetTransform());
   }
   b2Fixture.prototype.GetMassData = function (massData) {
      if (massData === undefined) massData = null;
      if (massData == null) {
         massData = new b2MassData();
      }
      this.m_shape.ComputeMass(massData, this.m_density);
      return massData;
   }
   b2Fixture.prototype.SetDensity = function (density) {
      if (density === undefined) density = 0;
      this.m_density = density;
   }
   b2Fixture.prototype.GetDensity = function () {
      return this.m_density;
   }
   b2Fixture.prototype.GetFriction = function () {
      return this.m_friction;
   }
   b2Fixture.prototype.SetFriction = function (friction) {
      if (friction === undefined) friction = 0;
      this.m_friction = friction;
   }
   b2Fixture.prototype.GetRestitution = function () {
      return this.m_restitution;
   }
   b2Fixture.prototype.SetRestitution = function (restitution) {
      if (restitution === undefined) restitution = 0;
      this.m_restitution = restitution;
   }
   b2Fixture.prototype.GetAABB = function () {
      return this.m_aabb;
   }
   b2Fixture.prototype.b2Fixture = function () {
      this.m_aabb = new b2AABB();
      this.m_userData = null;
      this.m_body = null;
      this.m_next = null;
      this.m_shape = null;
      this.m_density = 0.0;
      this.m_friction = 0.0;
      this.m_restitution = 0.0;
   }
   b2Fixture.prototype.Create = function (body, xf, def) {
      this.m_userData = def.userData;
      this.m_friction = def.friction;
      this.m_restitution = def.restitution;
      this.m_body = body;
      this.m_next = null;
      this.m_filter = def.filter.Copy();
      this.m_isSensor = def.isSensor;
      this.m_shape = def.shape.Copy();
      this.m_density = def.density;
   }
   b2Fixture.prototype.Destroy = function () {
      this.m_shape = null;
   }
   b2Fixture.prototype.CreateProxy = function (broadPhase, xf) {
      this.m_shape.ComputeAABB(this.m_aabb, xf);
      this.m_proxy = broadPhase.CreateProxy(this.m_aabb, this);
   }
   b2Fixture.prototype.DestroyProxy = function (broadPhase) {
      if (this.m_proxy == null) {
         return;
      }
      broadPhase.DestroyProxy(this.m_proxy);
      this.m_proxy = null;
   }
   b2Fixture.prototype.Synchronize = function (broadPhase, transform1, transform2) {
      if (!this.m_proxy) return;
      var aabb1 = new b2AABB();
      var aabb2 = new b2AABB();
      this.m_shape.ComputeAABB(aabb1, transform1);
      this.m_shape.ComputeAABB(aabb2, transform2);
      this.m_aabb.Combine(aabb1, aabb2);
      var displacement = b2Math.SubtractVV(transform2.position, transform1.position);
      broadPhase.MoveProxy(this.m_proxy, this.m_aabb, displacement);
   }
   b2FixtureDef.b2FixtureDef = function () {
      this.filter = new b2FilterData();
   };
   b2FixtureDef.prototype.b2FixtureDef = function () {
      this.shape = null;
      this.userData = null;
      this.friction = 0.2;
      this.restitution = 0.0;
      this.density = 0.0;
      this.filter.categoryBits = 0x0001;
      this.filter.maskBits = 0xFFFF;
      this.filter.groupIndex = 0;
      this.isSensor = false;
   }
   b2Island.b2Island = function () {};
   b2Island.prototype.b2Island = function () {
      this.m_bodies = new Vector();
      this.m_contacts = new Vector();
      this.m_joints = new Vector();
   }
   b2Island.prototype.Initialize = function (bodyCapacity, contactCapacity, jointCapacity, allocator, listener, contactSolver) {
      if (bodyCapacity === undefined) bodyCapacity = 0;
      if (contactCapacity === undefined) contactCapacity = 0;
      if (jointCapacity === undefined) jointCapacity = 0;
      var i = 0;
      this.m_bodyCapacity = bodyCapacity;
      this.m_contactCapacity = contactCapacity;
      this.m_jointCapacity = jointCapacity;
      this.m_bodyCount = 0;
      this.m_contactCount = 0;
      this.m_jointCount = 0;
      this.m_allocator = allocator;
      this.m_listener = listener;
      this.m_contactSolver = contactSolver;
      for (i = this.m_bodies.length;
      i < bodyCapacity; i++)
      this.m_bodies[i] = null;
      for (i = this.m_contacts.length;
      i < contactCapacity; i++)
      this.m_contacts[i] = null;
      for (i = this.m_joints.length;
      i < jointCapacity; i++)
      this.m_joints[i] = null;
   }
   b2Island.prototype.Clear = function () {
      this.m_bodyCount = 0;
      this.m_contactCount = 0;
      this.m_jointCount = 0;
   }
   b2Island.prototype.Solve = function (step, gravity, allowSleep) {
      var i = 0;
      var j = 0;
      var b;
      var joint;
	  var gravityX = gravity.x;
	  var gravityY = gravity.y;
	  
      for (i = 0;
      i < this.m_bodyCount; ++i) {
         b = this.m_bodies[i];
         if (b.GetType() != b2Body.b2_dynamicBody) continue;
		 if (b.m_nonGravitic) {
			 // Don't apply gravity to this body
			 b.m_linearVelocity.x += step.dt * (b.m_invMass * b.m_force.x);
			 b.m_linearVelocity.y += step.dt * (b.m_invMass * b.m_force.y);
		 } else {
			 // Apply gravity to this body
			 b.m_linearVelocity.x += step.dt * (gravityX + b.m_invMass * b.m_force.x);
			 b.m_linearVelocity.y += step.dt * (gravityY + b.m_invMass * b.m_force.y);
		 }
         b.m_angularVelocity += step.dt * b.m_invI * b.m_torque;
         b.m_linearVelocity.Multiply(b2Math.Clamp(1.0 - step.dt * b.m_linearDamping, 0.0, 1.0));
         b.m_angularVelocity *= b2Math.Clamp(1.0 - step.dt * b.m_angularDamping, 0.0, 1.0);
      }
      this.m_contactSolver.Initialize(step, this.m_contacts, this.m_contactCount, this.m_allocator);
      var contactSolver = this.m_contactSolver;
      contactSolver.InitVelocityConstraints(step);
      for (i = 0;
      i < this.m_jointCount; ++i) {
         joint = this.m_joints[i];
         joint.InitVelocityConstraints(step);
      }
      for (i = 0;
      i < step.velocityIterations; ++i) {
         for (j = 0;
         j < this.m_jointCount; ++j) {
            joint = this.m_joints[j];
            joint.SolveVelocityConstraints(step);
         }
         contactSolver.SolveVelocityConstraints();
      }
      for (i = 0;
      i < this.m_jointCount; ++i) {
         joint = this.m_joints[i];
         joint.FinalizeVelocityConstraints();
      }
      contactSolver.FinalizeVelocityConstraints();
      for (i = 0;
      i < this.m_bodyCount; ++i) {
         b = this.m_bodies[i];
         if (b.GetType() == b2Body.b2_staticBody) continue;
         var translationX = step.dt * b.m_linearVelocity.x;
         var translationY = step.dt * b.m_linearVelocity.y;
         if ((translationX * translationX + translationY * translationY) > b2Settings.b2_maxTranslationSquared) {
            b.m_linearVelocity.Normalize();
            b.m_linearVelocity.x *= b2Settings.b2_maxTranslation * step.inv_dt;
            b.m_linearVelocity.y *= b2Settings.b2_maxTranslation * step.inv_dt;
         }
         var rotation = step.dt * b.m_angularVelocity;
         if (rotation * rotation > b2Settings.b2_maxRotationSquared) {
            if (b.m_angularVelocity < 0.0) {
               b.m_angularVelocity = (-b2Settings.b2_maxRotation * step.inv_dt);
            }
            else {
               b.m_angularVelocity = b2Settings.b2_maxRotation * step.inv_dt;
            }
         }
         b.m_sweep.c0.SetV(b.m_sweep.c);
         b.m_sweep.a0 = b.m_sweep.a;
         b.m_sweep.c.x += step.dt * b.m_linearVelocity.x;
         b.m_sweep.c.y += step.dt * b.m_linearVelocity.y;
         b.m_sweep.a += step.dt * b.m_angularVelocity;
         b.SynchronizeTransform();
      }
      for (i = 0;
      i < step.positionIterations; ++i) {
         var contactsOkay = contactSolver.SolvePositionConstraints(b2Settings.b2_contactBaumgarte);
         var jointsOkay = true;
         for (j = 0;
         j < this.m_jointCount; ++j) {
            joint = this.m_joints[j];
            var jointOkay = joint.SolvePositionConstraints(b2Settings.b2_contactBaumgarte);
            jointsOkay = jointsOkay && jointOkay;
         }
         if (contactsOkay && jointsOkay) {
            break;
         }
      }
      this.Report(contactSolver.m_constraints);
      if (allowSleep) {
         var minSleepTime = Number.MAX_VALUE;
         var linTolSqr = b2Settings.b2_linearSleepTolerance * b2Settings.b2_linearSleepTolerance;
         var angTolSqr = b2Settings.b2_angularSleepTolerance * b2Settings.b2_angularSleepTolerance;
         for (i = 0;
         i < this.m_bodyCount; ++i) {
            b = this.m_bodies[i];
            if (b.GetType() == b2Body.b2_staticBody) {
               continue;
            }
            if ((b.m_flags & b2Body.e_allowSleepFlag) == 0) {
               b.m_sleepTime = 0.0;
               minSleepTime = 0.0;
            }
            if ((b.m_flags & b2Body.e_allowSleepFlag) == 0 || b.m_angularVelocity * b.m_angularVelocity > angTolSqr || b2Math.Dot(b.m_linearVelocity, b.m_linearVelocity) > linTolSqr) {
               b.m_sleepTime = 0.0;
               minSleepTime = 0.0;
            }
            else {
               b.m_sleepTime += step.dt;
               minSleepTime = b2Math.Min(minSleepTime, b.m_sleepTime);
            }
         }
         if (minSleepTime >= b2Settings.b2_timeToSleep) {
            for (i = 0;
            i < this.m_bodyCount; ++i) {
               b = this.m_bodies[i];
               b.SetAwake(false);
            }
         }
      }
   }
   b2Island.prototype.SolveTOI = function (subStep) {
      var i = 0;
      var j = 0;
      this.m_contactSolver.Initialize(subStep, this.m_contacts, this.m_contactCount, this.m_allocator);
      var contactSolver = this.m_contactSolver;
      for (i = 0;
      i < this.m_jointCount; ++i) {
         this.m_joints[i].InitVelocityConstraints(subStep);
      }
      for (i = 0;
      i < subStep.velocityIterations; ++i) {
         contactSolver.SolveVelocityConstraints();
         for (j = 0;
         j < this.m_jointCount; ++j) {
            this.m_joints[j].SolveVelocityConstraints(subStep);
         }
      }
      for (i = 0;
      i < this.m_bodyCount; ++i) {
         var b = this.m_bodies[i];
         if (b.GetType() == b2Body.b2_staticBody) continue;
         var translationX = subStep.dt * b.m_linearVelocity.x;
         var translationY = subStep.dt * b.m_linearVelocity.y;
         if ((translationX * translationX + translationY * translationY) > b2Settings.b2_maxTranslationSquared) {
            b.m_linearVelocity.Normalize();
            b.m_linearVelocity.x *= b2Settings.b2_maxTranslation * subStep.inv_dt;
            b.m_linearVelocity.y *= b2Settings.b2_maxTranslation * subStep.inv_dt;
         }
         var rotation = subStep.dt * b.m_angularVelocity;
         if (rotation * rotation > b2Settings.b2_maxRotationSquared) {
            if (b.m_angularVelocity < 0.0) {
               b.m_angularVelocity = (-b2Settings.b2_maxRotation * subStep.inv_dt);
            }
            else {
               b.m_angularVelocity = b2Settings.b2_maxRotation * subStep.inv_dt;
            }
         }
         b.m_sweep.c0.SetV(b.m_sweep.c);
         b.m_sweep.a0 = b.m_sweep.a;
         b.m_sweep.c.x += subStep.dt * b.m_linearVelocity.x;
         b.m_sweep.c.y += subStep.dt * b.m_linearVelocity.y;
         b.m_sweep.a += subStep.dt * b.m_angularVelocity;
         b.SynchronizeTransform();
      }
      var k_toiBaumgarte = 0.75;
      for (i = 0;
      i < subStep.positionIterations; ++i) {
         var contactsOkay = contactSolver.SolvePositionConstraints(k_toiBaumgarte);
         var jointsOkay = true;
         for (j = 0;
         j < this.m_jointCount; ++j) {
            var jointOkay = this.m_joints[j].SolvePositionConstraints(b2Settings.b2_contactBaumgarte);
            jointsOkay = jointsOkay && jointOkay;
         }
         if (contactsOkay && jointsOkay) {
            break;
         }
      }
      this.Report(contactSolver.m_constraints);
   }
   b2Island.prototype.Report = function (constraints) {
      if (this.m_listener == null) {
         return;
      }
      for (var i = 0; i < this.m_contactCount; ++i) {
         var c = this.m_contacts[i];
         var cc = constraints[i];
         for (var j = 0; j < cc.pointCount; ++j) {
            b2Island.s_impulse.normalImpulses[j] = cc.points[j].normalImpulse;
            b2Island.s_impulse.tangentImpulses[j] = cc.points[j].tangentImpulse;
         }
         this.m_listener.PostSolve(c, b2Island.s_impulse);
      }
   }
   b2Island.prototype.AddBody = function (body) {
      body.m_islandIndex = this.m_bodyCount;
      this.m_bodies[this.m_bodyCount++] = body;
   }
   b2Island.prototype.AddContact = function (contact) {
      this.m_contacts[this.m_contactCount++] = contact;
   }
   b2Island.prototype.AddJoint = function (joint) {
      this.m_joints[this.m_jointCount++] = joint;
   }
   Box2D.postDefs.push(function () {
      Box2D.Dynamics.b2Island.s_impulse = new b2ContactImpulse();
   });
   b2TimeStep.b2TimeStep = function () {};
   b2TimeStep.prototype.Set = function (step) {
      this.dt = step.dt;
      this.inv_dt = step.inv_dt;
      this.positionIterations = step.positionIterations;
      this.velocityIterations = step.velocityIterations;
      this.warmStarting = step.warmStarting;
   }
   b2World.b2World = function () {
      this.s_stack = new Vector();
      this.m_contactManager = new b2ContactManager();
      this.m_contactSolver = new b2ContactSolver();
      this.m_island = new b2Island();
   };
   b2World.prototype.b2World = function (gravity, doSleep) {
      this.m_destructionListener = null;
      this.m_debugDraw = null;
      this.m_bodyList = null;
      this.m_contactList = null;
      this.m_jointList = null;
      this.m_controllerList = null;
      this.m_bodyCount = 0;
      this.m_contactCount = 0;
      this.m_jointCount = 0;
      this.m_controllerCount = 0;
      b2World.m_warmStarting = true;
      b2World.m_continuousPhysics = true;
      this.m_allowSleep = doSleep;
      this.m_gravity = gravity;
      this.m_inv_dt0 = 0.0;
      this.m_contactManager.m_world = this;
      var bd = new b2BodyDef();
      this.m_groundBody = this.CreateBody(bd);
   }
   b2World.prototype.SetDestructionListener = function (listener) {
      this.m_destructionListener = listener;
   }
   b2World.prototype.SetContactFilter = function (filter) {
      this.m_contactManager.m_contactFilter = filter;
   }
   b2World.prototype.SetContactListener = function (listener) {
      this.m_contactManager.m_contactListener = listener;
   }
   b2World.prototype.SetDebugDraw = function (debugDraw) {
      this.m_debugDraw = debugDraw;
   }
   b2World.prototype.SetBroadPhase = function (broadPhase) {
      var oldBroadPhase = this.m_contactManager.m_broadPhase;
      this.m_contactManager.m_broadPhase = broadPhase;
      for (var b = this.m_bodyList; b; b = b.m_next) {
         for (var f = b.m_fixtureList; f; f = f.m_next) {
            f.m_proxy = broadPhase.CreateProxy(oldBroadPhase.GetFatAABB(f.m_proxy), f);
         }
      }
   }
   b2World.prototype.Validate = function () {
      this.m_contactManager.m_broadPhase.Validate();
   }
   b2World.prototype.GetProxyCount = function () {
      return this.m_contactManager.m_broadPhase.GetProxyCount();
   }
   b2World.prototype.CreateBody = function (def) {
      if (this.IsLocked() == true) {
         return null;
      }
      var b = new b2Body(def, this);
      b.m_prev = null;
      b.m_next = this.m_bodyList;
      if (this.m_bodyList) {
         this.m_bodyList.m_prev = b;
      }
      this.m_bodyList = b;
      ++this.m_bodyCount;
      return b;
   }
   b2World.prototype.DestroyBody = function (b) {
      if (this.IsLocked() == true) {
         return;
      }
      var jn = b.m_jointList;
      while (jn) {
         var jn0 = jn;
         jn = jn.next;
         if (this.m_destructionListener) {
            this.m_destructionListener.SayGoodbyeJoint(jn0.joint);
         }
         this.DestroyJoint(jn0.joint);
      }
      var coe = b.m_controllerList;
      while (coe) {
         var coe0 = coe;
         coe = coe.nextController;
         coe0.controller.RemoveBody(b);
      }
      var ce = b.m_contactList;
      while (ce) {
         var ce0 = ce;
         ce = ce.next;
         this.m_contactManager.Destroy(ce0.contact);
      }
      b.m_contactList = null;
      var f = b.m_fixtureList;
      while (f) {
         var f0 = f;
         f = f.m_next;
         if (this.m_destructionListener) {
            this.m_destructionListener.SayGoodbyeFixture(f0);
         }
         f0.DestroyProxy(this.m_contactManager.m_broadPhase);
         f0.Destroy();
      }
      b.m_fixtureList = null;
      b.m_fixtureCount = 0;
      if (b.m_prev) {
         b.m_prev.m_next = b.m_next;
      }
      if (b.m_next) {
         b.m_next.m_prev = b.m_prev;
      }
      if (b == this.m_bodyList) {
         this.m_bodyList = b.m_next;
      }--this.m_bodyCount;
   }
   b2World.prototype.CreateJoint = function (def) {
      var j = b2Joint.Create(def, null);
      j.m_prev = null;
      j.m_next = this.m_jointList;
      if (this.m_jointList) {
         this.m_jointList.m_prev = j;
      }
      this.m_jointList = j;
      ++this.m_jointCount;
      j.m_edgeA.joint = j;
      j.m_edgeA.other = j.m_bodyB;
      j.m_edgeA.prev = null;
      j.m_edgeA.next = j.m_bodyA.m_jointList;
      if (j.m_bodyA.m_jointList) j.m_bodyA.m_jointList.prev = j.m_edgeA;
      j.m_bodyA.m_jointList = j.m_edgeA;
      j.m_edgeB.joint = j;
      j.m_edgeB.other = j.m_bodyA;
      j.m_edgeB.prev = null;
      j.m_edgeB.next = j.m_bodyB.m_jointList;
      if (j.m_bodyB.m_jointList) j.m_bodyB.m_jointList.prev = j.m_edgeB;
      j.m_bodyB.m_jointList = j.m_edgeB;
      var bodyA = def.bodyA;
      var bodyB = def.bodyB;
      if (def.collideConnected == false) {
         var edge = bodyB.GetContactList();
         while (edge) {
            if (edge.other == bodyA) {
               edge.contact.FlagForFiltering();
            }
            edge = edge.next;
         }
      }
      return j;
   }
   b2World.prototype.DestroyJoint = function (j) {
      var collideConnected = j.m_collideConnected;
      if (j.m_prev) {
         j.m_prev.m_next = j.m_next;
      }
      if (j.m_next) {
         j.m_next.m_prev = j.m_prev;
      }
      if (j == this.m_jointList) {
         this.m_jointList = j.m_next;
      }
      var bodyA = j.m_bodyA;
      var bodyB = j.m_bodyB;
      bodyA.SetAwake(true);
      bodyB.SetAwake(true);
      if (j.m_edgeA.prev) {
         j.m_edgeA.prev.next = j.m_edgeA.next;
      }
      if (j.m_edgeA.next) {
         j.m_edgeA.next.prev = j.m_edgeA.prev;
      }
      if (j.m_edgeA == bodyA.m_jointList) {
         bodyA.m_jointList = j.m_edgeA.next;
      }
      j.m_edgeA.prev = null;
      j.m_edgeA.next = null;
      if (j.m_edgeB.prev) {
         j.m_edgeB.prev.next = j.m_edgeB.next;
      }
      if (j.m_edgeB.next) {
         j.m_edgeB.next.prev = j.m_edgeB.prev;
      }
      if (j.m_edgeB == bodyB.m_jointList) {
         bodyB.m_jointList = j.m_edgeB.next;
      }
      j.m_edgeB.prev = null;
      j.m_edgeB.next = null;
      b2Joint.Destroy(j, null);
      --this.m_jointCount;
      if (collideConnected == false) {
         var edge = bodyB.GetContactList();
         while (edge) {
            if (edge.other == bodyA) {
               edge.contact.FlagForFiltering();
            }
            edge = edge.next;
         }
      }
   }
   b2World.prototype.AddController = function (c) {
      c.m_next = this.m_controllerList;
      c.m_prev = null;
      this.m_controllerList = c;
      c.m_world = this;
      this.m_controllerCount++;
      return c;
   }
   b2World.prototype.RemoveController = function (c) {
      if (c.m_prev) c.m_prev.m_next = c.m_next;
      if (c.m_next) c.m_next.m_prev = c.m_prev;
      if (this.m_controllerList == c) this.m_controllerList = c.m_next;
      this.m_controllerCount--;
   }
   b2World.prototype.CreateController = function (controller) {
      if (controller.m_world != this) throw new Error("Controller can only be a member of one world");
      controller.m_next = this.m_controllerList;
      controller.m_prev = null;
      if (this.m_controllerList) this.m_controllerList.m_prev = controller;
      this.m_controllerList = controller;
      ++this.m_controllerCount;
      controller.m_world = this;
      return controller;
   }
   b2World.prototype.DestroyController = function (controller) {
      controller.Clear();
      if (controller.m_next) controller.m_next.m_prev = controller.m_prev;
      if (controller.m_prev) controller.m_prev.m_next = controller.m_next;
      if (controller == this.m_controllerList) this.m_controllerList = controller.m_next;
      --this.m_controllerCount;
   }
   b2World.prototype.SetWarmStarting = function (flag) {
      b2World.m_warmStarting = flag;
   }
   b2World.prototype.SetContinuousPhysics = function (flag) {
      b2World.m_continuousPhysics = flag;
   }
   b2World.prototype.GetBodyCount = function () {
      return this.m_bodyCount;
   }
   b2World.prototype.GetJointCount = function () {
      return this.m_jointCount;
   }
   b2World.prototype.GetContactCount = function () {
      return this.m_contactCount;
   }
   b2World.prototype.SetGravity = function (gravity) {
      this.m_gravity = gravity;
   }
   b2World.prototype.GetGravity = function () {
      return this.m_gravity;
   }
   b2World.prototype.GetGroundBody = function () {
      return this.m_groundBody;
   }
   b2World.prototype.Step = function (dt, velocityIterations, positionIterations) {
      if (dt === undefined) dt = 0;
      if (velocityIterations === undefined) velocityIterations = 0;
      if (positionIterations === undefined) positionIterations = 0;
      if (this.m_flags & b2World.e_newFixture) {
         this.m_contactManager.FindNewContacts();
         this.m_flags &= ~b2World.e_newFixture;
      }
      this.m_flags |= b2World.e_locked;
      var step = b2World.s_timestep2;
      step.dt = dt;
      step.velocityIterations = velocityIterations;
      step.positionIterations = positionIterations;
      if (dt > 0.0) {
         step.inv_dt = 1.0 / dt;
      }
      else {
         step.inv_dt = 0.0;
      }
      step.dtRatio = this.m_inv_dt0 * dt;
      step.warmStarting = b2World.m_warmStarting;
      this.m_contactManager.Collide();
      if (step.dt > 0.0) {
         this.Solve(step);
      }
      if (b2World.m_continuousPhysics && step.dt > 0.0) {
         this.SolveTOI(step);
      }
      if (step.dt > 0.0) {
         this.m_inv_dt0 = step.inv_dt;
      }
      this.m_flags &= ~b2World.e_locked;
   }
   b2World.prototype.ClearForces = function () {
      for (var body = this.m_bodyList; body; body = body.m_next) {
         body.m_force.SetZero();
         body.m_torque = 0.0;
      }
   }
   b2World.prototype.DrawDebugData = function () {
      if (this.m_debugDraw == null) {
         return;
      }
      this.m_debugDraw.m_sprite.graphics.clear();
      var flags = this.m_debugDraw.GetFlags();
      var i = 0;
      var b;
      var f;
      var s;
      var j;
      var bp;
      var invQ = new b2Vec2;
      var x1 = new b2Vec2;
      var x2 = new b2Vec2;
      var xf;
      var b1 = new b2AABB();
      var b2 = new b2AABB();
      var vs = [new b2Vec2(), new b2Vec2(), new b2Vec2(), new b2Vec2()];
      var color = new b2Color(0, 0, 0);
      if (flags & b2DebugDraw.e_shapeBit) {
         for (b = this.m_bodyList;
         b; b = b.m_next) {
			 // This is different from the original in that we check
			 // if the box2dNoDebug has been set first before drawing
			 // a debug shape for this body
			 if (!b._entity || !b._entity._box2dNoDebug) {
				xf = b.m_xf;
				for (f = b.GetFixtureList();
				f; f = f.m_next) {
				   s = f.GetShape();
				   if (b.IsActive() == false) {
					  color.Set(0.5, 0.5, 0.3);
					  this.DrawShape(s, xf, color);
				   }
				   else if (b.GetType() == b2Body.b2_staticBody) {
					  color.Set(0.5, 0.9, 0.5);
					  this.DrawShape(s, xf, color);
				   }
				   else if (b.GetType() == b2Body.b2_kinematicBody) {
					  color.Set(0.5, 0.5, 0.9);
					  this.DrawShape(s, xf, color);
				   }
				   else if (b.IsAwake() == false) {
					  color.Set(0.6, 0.6, 0.6);
					  this.DrawShape(s, xf, color);
				   }
				   else {
					  color.Set(0.9, 0.7, 0.7);
					  this.DrawShape(s, xf, color);
				   }
				}
			 }
         }
      }
      if (flags & b2DebugDraw.e_jointBit) {
         for (j = this.m_jointList;
         j; j = j.m_next) {
            this.DrawJoint(j);
         }
      }
      if (flags & b2DebugDraw.e_controllerBit) {
         for (var c = this.m_controllerList; c; c = c.m_next) {
            c.Draw(this.m_debugDraw);
         }
      }
      if (flags & b2DebugDraw.e_pairBit) {
         color.Set(0.3, 0.9, 0.9);
         for (var contact = this.m_contactManager.m_contactList; contact; contact = contact.GetNext()) {
            var fixtureA = contact.GetFixtureA();
            var fixtureB = contact.GetFixtureB();
            var cA = fixtureA.GetAABB().GetCenter();
            var cB = fixtureB.GetAABB().GetCenter();
            this.m_debugDraw.DrawSegment(cA, cB, color);
         }
      }
      if (flags & b2DebugDraw.e_aabbBit) {
         bp = this.m_contactManager.m_broadPhase;
         vs = [new b2Vec2(), new b2Vec2(), new b2Vec2(), new b2Vec2()];
         for (b = this.m_bodyList;
         b; b = b.GetNext()) {
            if (b.IsActive() == false) {
               continue;
            }
            for (f = b.GetFixtureList();
            f; f = f.GetNext()) {
               var aabb = bp.GetFatAABB(f.m_proxy);
               vs[0].Set(aabb.lowerBound.x, aabb.lowerBound.y);
               vs[1].Set(aabb.upperBound.x, aabb.lowerBound.y);
               vs[2].Set(aabb.upperBound.x, aabb.upperBound.y);
               vs[3].Set(aabb.lowerBound.x, aabb.upperBound.y);
               this.m_debugDraw.DrawPolygon(vs, 4, color);
            }
         }
      }
      if (flags & b2DebugDraw.e_centerOfMassBit) {
         for (b = this.m_bodyList;
         b; b = b.m_next) {
            xf = b2World.s_xf;
            xf.R = b.m_xf.R;
            xf.position = b.GetWorldCenter();
            this.m_debugDraw.DrawTransform(xf);
         }
      }
   }
   b2World.prototype.QueryAABB = function (callback, aabb) {
      var __this = this;
      var broadPhase = __this.m_contactManager.m_broadPhase;

      function WorldQueryWrapper(proxy) {
         return callback(broadPhase.GetUserData(proxy));
      };
      broadPhase.Query(WorldQueryWrapper, aabb);
   }
   b2World.prototype.QueryShape = function (callback, shape, transform) {
      var __this = this;
      if (transform === undefined) transform = null;
      if (transform == null) {
         transform = new b2Transform();
         transform.SetIdentity();
      }
      var broadPhase = __this.m_contactManager.m_broadPhase;

      function WorldQueryWrapper(proxy) {
         var fixture = (broadPhase.GetUserData(proxy) instanceof b2Fixture ? broadPhase.GetUserData(proxy) : null);
         if (b2Shape.TestOverlap(shape, transform, fixture.GetShape(), fixture.GetBody().GetTransform())) return callback(fixture);
         return true;
      };
      var aabb = new b2AABB();
      shape.ComputeAABB(aabb, transform);
      broadPhase.Query(WorldQueryWrapper, aabb);
   }
   b2World.prototype.QueryPoint = function (callback, p) {
      var __this = this;
      var broadPhase = __this.m_contactManager.m_broadPhase;

      function WorldQueryWrapper(proxy) {
         var fixture = (broadPhase.GetUserData(proxy) instanceof b2Fixture ? broadPhase.GetUserData(proxy) : null);
         if (fixture.TestPoint(p)) return callback(fixture);
         return true;
      };
      var aabb = new b2AABB();
      aabb.lowerBound.Set(p.x - b2Settings.b2_linearSlop, p.y - b2Settings.b2_linearSlop);
      aabb.upperBound.Set(p.x + b2Settings.b2_linearSlop, p.y + b2Settings.b2_linearSlop);
      broadPhase.Query(WorldQueryWrapper, aabb);
   }
   b2World.prototype.RayCast = function (callback, point1, point2) {
      var __this = this;
      var broadPhase = __this.m_contactManager.m_broadPhase;
      var output = new b2RayCastOutput;

      function RayCastWrapper(input, proxy) {
         var userData = broadPhase.GetUserData(proxy);
         var fixture = (userData instanceof b2Fixture ? userData : null);
         var hit = fixture.RayCast(output, input);
         if (hit) {
            var fraction = output.fraction;
            var point = new b2Vec2((1.0 - fraction) * point1.x + fraction * point2.x, (1.0 - fraction) * point1.y + fraction * point2.y);
            return callback(fixture, point, output.normal, fraction);
         }
         return input.maxFraction;
      };
      var input = new b2RayCastInput(point1, point2);
      broadPhase.RayCast(RayCastWrapper, input);
   }
   b2World.prototype.RayCastOne = function (point1, point2) {
      var __this = this;
      var result;

      function RayCastOneWrapper(fixture, point, normal, fraction) {
         if (fraction === undefined) fraction = 0;
         result = fixture;
         return fraction;
      };
      __this.RayCast(RayCastOneWrapper, point1, point2);
      return result;
   }
   b2World.prototype.RayCastAll = function (point1, point2) {
      var __this = this;
      var result = new Vector();

      function RayCastAllWrapper(fixture, point, normal, fraction) {
         if (fraction === undefined) fraction = 0;
         result[result.length] = fixture;
         return 1;
      };
      __this.RayCast(RayCastAllWrapper, point1, point2);
      return result;
   }
   b2World.prototype.GetBodyList = function () {
      return this.m_bodyList;
   }
   b2World.prototype.GetJointList = function () {
      return this.m_jointList;
   }
   b2World.prototype.GetContactList = function () {
      return this.m_contactList;
   }
   b2World.prototype.IsLocked = function () {
      return (this.m_flags & b2World.e_locked) > 0;
   }
   b2World.prototype.Solve = function (step) {
      var b;
      for (var controller = this.m_controllerList; controller; controller = controller.m_next) {
         controller.Step(step);
      }
      var island = this.m_island;
      island.Initialize(this.m_bodyCount, this.m_contactCount, this.m_jointCount, null, this.m_contactManager.m_contactListener, this.m_contactSolver);
      for (b = this.m_bodyList;
      b; b = b.m_next) {
         b.m_flags &= ~b2Body.e_islandFlag;
      }
      for (var c = this.m_contactList; c; c = c.m_next) {
         c.m_flags &= ~b2Contact.e_islandFlag;
      }
      for (var j = this.m_jointList; j; j = j.m_next) {
         j.m_islandFlag = false;
      }
      var stackSize = parseInt(this.m_bodyCount);
      var stack = this.s_stack;
      for (var seed = this.m_bodyList; seed; seed = seed.m_next) {
         if (seed.m_flags & b2Body.e_islandFlag) {
            continue;
         }
         if (seed.IsAwake() == false || seed.IsActive() == false) {
            continue;
         }
         if (seed.GetType() == b2Body.b2_staticBody) {
            continue;
         }
         island.Clear();
         var stackCount = 0;
         stack[stackCount++] = seed;
         seed.m_flags |= b2Body.e_islandFlag;
         while (stackCount > 0) {
            b = stack[--stackCount];
            island.AddBody(b);
            if (b.IsAwake() == false) {
               b.SetAwake(true);
            }
            if (b.GetType() == b2Body.b2_staticBody) {
               continue;
            }
            var other;
            for (var ce = b.m_contactList; ce; ce = ce.next) {
               if (ce.contact.m_flags & b2Contact.e_islandFlag) {
                  continue;
               }
               if (ce.contact.IsSensor() == true || ce.contact.IsEnabled() == false || ce.contact.IsTouching() == false) {
                  continue;
               }
               island.AddContact(ce.contact);
               ce.contact.m_flags |= b2Contact.e_islandFlag;
               other = ce.other;
               if (other.m_flags & b2Body.e_islandFlag) {
                  continue;
               }
               stack[stackCount++] = other;
               other.m_flags |= b2Body.e_islandFlag;
            }
            for (var jn = b.m_jointList; jn; jn = jn.next) {
               if (jn.joint.m_islandFlag == true) {
                  continue;
               }
               other = jn.other;
               if (other.IsActive() == false) {
                  continue;
               }
               island.AddJoint(jn.joint);
               jn.joint.m_islandFlag = true;
               if (other.m_flags & b2Body.e_islandFlag) {
                  continue;
               }
               stack[stackCount++] = other;
               other.m_flags |= b2Body.e_islandFlag;
            }
         }
         island.Solve(step, this.m_gravity, this.m_allowSleep);
         for (var i = 0; i < island.m_bodyCount; ++i) {
            b = island.m_bodies[i];
            if (b.GetType() == b2Body.b2_staticBody) {
               b.m_flags &= ~b2Body.e_islandFlag;
            }
         }
      }
      for (i = 0;
      i < stack.length; ++i) {
         if (!stack[i]) break;
         stack[i] = null;
      }
      for (b = this.m_bodyList;
      b; b = b.m_next) {
         if (b.IsAwake() == false || b.IsActive() == false) {
            continue;
         }
         if (b.GetType() == b2Body.b2_staticBody) {
            continue;
         }
         b.SynchronizeFixtures();
      }
      this.m_contactManager.FindNewContacts();
   }
   b2World.prototype.SolveTOI = function (step) {
      var b;
      var fA;
      var fB;
      var bA;
      var bB;
      var cEdge;
      var j;
      var island = this.m_island;
      island.Initialize(this.m_bodyCount, b2Settings.b2_maxTOIContactsPerIsland, b2Settings.b2_maxTOIJointsPerIsland, null, this.m_contactManager.m_contactListener, this.m_contactSolver);
      var queue = b2World.s_queue;
      for (b = this.m_bodyList;
      b; b = b.m_next) {
         b.m_flags &= ~b2Body.e_islandFlag;
         b.m_sweep.t0 = 0.0;
      }
      var c;
      for (c = this.m_contactList;
      c; c = c.m_next) {
         c.m_flags &= ~ (b2Contact.e_toiFlag | b2Contact.e_islandFlag);
      }
      for (j = this.m_jointList;
      j; j = j.m_next) {
         j.m_islandFlag = false;
      }
      for (;;) {
         var minContact = null;
         var minTOI = 1.0;
         for (c = this.m_contactList;
         c; c = c.m_next) {
            if (c.IsSensor() == true || c.IsEnabled() == false || c.IsContinuous() == false) {
               continue;
            }
            var toi = 1.0;
            if (c.m_flags & b2Contact.e_toiFlag) {
               toi = c.m_toi;
            }
            else {
               fA = c.m_fixtureA;
               fB = c.m_fixtureB;
               bA = fA.m_body;
               bB = fB.m_body;
               if ((bA.GetType() != b2Body.b2_dynamicBody || bA.IsAwake() == false) && (bB.GetType() != b2Body.b2_dynamicBody || bB.IsAwake() == false)) {
                  continue;
               }
               var t0 = bA.m_sweep.t0;
               if (bA.m_sweep.t0 < bB.m_sweep.t0) {
                  t0 = bB.m_sweep.t0;
                  bA.m_sweep.Advance(t0);
               }
               else if (bB.m_sweep.t0 < bA.m_sweep.t0) {
                  t0 = bA.m_sweep.t0;
                  bB.m_sweep.Advance(t0);
               }
               toi = c.ComputeTOI(bA.m_sweep, bB.m_sweep);
               b2Settings.b2Assert(0.0 <= toi && toi <= 1.0);
               if (toi > 0.0 && toi < 1.0) {
                  toi = (1.0 - toi) * t0 + toi;
                  if (toi > 1) toi = 1;
               }
               c.m_toi = toi;
               c.m_flags |= b2Contact.e_toiFlag;
            }
            if (Number.MIN_VALUE < toi && toi < minTOI) {
               minContact = c;
               minTOI = toi;
            }
         }
         if (minContact == null || 1.0 - 100.0 * Number.MIN_VALUE < minTOI) {
            break;
         }
         fA = minContact.m_fixtureA;
         fB = minContact.m_fixtureB;
         bA = fA.m_body;
         bB = fB.m_body;
         b2World.s_backupA.Set(bA.m_sweep);
         b2World.s_backupB.Set(bB.m_sweep);
         bA.Advance(minTOI);
         bB.Advance(minTOI);
         minContact.Update(this.m_contactManager.m_contactListener);
         minContact.m_flags &= ~b2Contact.e_toiFlag;
         if (minContact.IsSensor() == true || minContact.IsEnabled() == false) {
            bA.m_sweep.Set(b2World.s_backupA);
            bB.m_sweep.Set(b2World.s_backupB);
            bA.SynchronizeTransform();
            bB.SynchronizeTransform();
            continue;
         }
         if (minContact.IsTouching() == false) {
            continue;
         }
         var seed = bA;
         if (seed.GetType() != b2Body.b2_dynamicBody) {
            seed = bB;
         }
         island.Clear();
         var queueStart = 0;
         var queueSize = 0;
         queue[queueStart + queueSize++] = seed;
         seed.m_flags |= b2Body.e_islandFlag;
         while (queueSize > 0) {
            b = queue[queueStart++];
            --queueSize;
            island.AddBody(b);
            if (b.IsAwake() == false) {
               b.SetAwake(true);
            }
            if (b.GetType() != b2Body.b2_dynamicBody) {
               continue;
            }
            for (cEdge = b.m_contactList;
            cEdge; cEdge = cEdge.next) {
               if (island.m_contactCount == island.m_contactCapacity) {
                  break;
               }
               if (cEdge.contact.m_flags & b2Contact.e_islandFlag) {
                  continue;
               }
               if (cEdge.contact.IsSensor() == true || cEdge.contact.IsEnabled() == false || cEdge.contact.IsTouching() == false) {
                  continue;
               }
               island.AddContact(cEdge.contact);
               cEdge.contact.m_flags |= b2Contact.e_islandFlag;
               var other = cEdge.other;
               if (other.m_flags & b2Body.e_islandFlag) {
                  continue;
               }
               if (other.GetType() != b2Body.b2_staticBody) {
                  other.Advance(minTOI);
                  other.SetAwake(true);
               }
               queue[queueStart + queueSize] = other;
               ++queueSize;
               other.m_flags |= b2Body.e_islandFlag;
            }
            for (var jEdge = b.m_jointList; jEdge; jEdge = jEdge.next) {
               if (island.m_jointCount == island.m_jointCapacity) continue;
               if (jEdge.joint.m_islandFlag == true) continue;
               other = jEdge.other;
               if (other.IsActive() == false) {
                  continue;
               }
               island.AddJoint(jEdge.joint);
               jEdge.joint.m_islandFlag = true;
               if (other.m_flags & b2Body.e_islandFlag) continue;
               if (other.GetType() != b2Body.b2_staticBody) {
                  other.Advance(minTOI);
                  other.SetAwake(true);
               }
               queue[queueStart + queueSize] = other;
               ++queueSize;
               other.m_flags |= b2Body.e_islandFlag;
            }
         }
         var subStep = b2World.s_timestep;
         subStep.warmStarting = false;
         subStep.dt = (1.0 - minTOI) * step.dt;
         subStep.inv_dt = 1.0 / subStep.dt;
         subStep.dtRatio = 0.0;
         subStep.velocityIterations = step.velocityIterations;
         subStep.positionIterations = step.positionIterations;
         island.SolveTOI(subStep);
         var i = 0;
         for (i = 0;
         i < island.m_bodyCount; ++i) {
            b = island.m_bodies[i];
            b.m_flags &= ~b2Body.e_islandFlag;
            if (b.IsAwake() == false) {
               continue;
            }
            if (b.GetType() != b2Body.b2_dynamicBody) {
               continue;
            }
            b.SynchronizeFixtures();
            for (cEdge = b.m_contactList;
            cEdge; cEdge = cEdge.next) {
               cEdge.contact.m_flags &= ~b2Contact.e_toiFlag;
            }
         }
         for (i = 0;
         i < island.m_contactCount; ++i) {
            c = island.m_contacts[i];
            c.m_flags &= ~ (b2Contact.e_toiFlag | b2Contact.e_islandFlag);
         }
         for (i = 0;
         i < island.m_jointCount; ++i) {
            j = island.m_joints[i];
            j.m_islandFlag = false;
         }
         this.m_contactManager.FindNewContacts();
      }
   }
   b2World.prototype.DrawJoint = function (joint) {
      var b1 = joint.GetBodyA();
      var b2 = joint.GetBodyB();
      var xf1 = b1.m_xf;
      var xf2 = b2.m_xf;
      var x1 = xf1.position;
      var x2 = xf2.position;
      var p1 = joint.GetAnchorA();
      var p2 = joint.GetAnchorB();
      var color = b2World.s_jointColor;
      switch (joint.m_type) {
      case b2Joint.e_distanceJoint:
         this.m_debugDraw.DrawSegment(p1, p2, color);
         break;
      case b2Joint.e_pulleyJoint:
         {
            var pulley = ((joint instanceof b2PulleyJoint ? joint : null));
            var s1 = pulley.GetGroundAnchorA();
            var s2 = pulley.GetGroundAnchorB();
            this.m_debugDraw.DrawSegment(s1, p1, color);
            this.m_debugDraw.DrawSegment(s2, p2, color);
            this.m_debugDraw.DrawSegment(s1, s2, color);
         }
         break;
      case b2Joint.e_mouseJoint:
         this.m_debugDraw.DrawSegment(p1, p2, color);
         break;
      default:
         if (b1 != this.m_groundBody) this.m_debugDraw.DrawSegment(x1, p1, color);
         this.m_debugDraw.DrawSegment(p1, p2, color);
         if (b2 != this.m_groundBody) this.m_debugDraw.DrawSegment(x2, p2, color);
      }
   }
   b2World.prototype.DrawShape = function (shape, xf, color) {
      switch (shape.m_type) {
      case b2Shape.e_circleShape:
         {
            var circle = ((shape instanceof b2CircleShape ? shape : null));
            var center = b2Math.MulX(xf, circle.m_p);
            var radius = circle.m_radius;
            var axis = xf.R.col1;
            this.m_debugDraw.DrawSolidCircle(center, radius, axis, color);
         }
         break;
      case b2Shape.e_polygonShape:
         {
            var i = 0;
            var poly = ((shape instanceof b2PolygonShape ? shape : null));
            var vertexCount = parseInt(poly.GetVertexCount());
            var localVertices = poly.GetVertices();
            var vertices = new Vector(vertexCount);
            for (i = 0;
            i < vertexCount; ++i) {
               vertices[i] = b2Math.MulX(xf, localVertices[i]);
            }
            this.m_debugDraw.DrawSolidPolygon(vertices, vertexCount, color);
         }
         break;
      case b2Shape.e_edgeShape:
         {
            var edge = (shape instanceof b2EdgeShape ? shape : null);
            this.m_debugDraw.DrawSegment(b2Math.MulX(xf, edge.GetVertex1()), b2Math.MulX(xf, edge.GetVertex2()), color);
         }
         break;
      }
   }
   Box2D.postDefs.push(function () {
      Box2D.Dynamics.b2World.s_timestep2 = new b2TimeStep();
      Box2D.Dynamics.b2World.s_xf = new b2Transform();
      Box2D.Dynamics.b2World.s_backupA = new b2Sweep();
      Box2D.Dynamics.b2World.s_backupB = new b2Sweep();
      Box2D.Dynamics.b2World.s_timestep = new b2TimeStep();
      Box2D.Dynamics.b2World.s_queue = new Vector();
      Box2D.Dynamics.b2World.s_jointColor = new b2Color(0.5, 0.8, 0.8);
      Box2D.Dynamics.b2World.e_newFixture = 0x0001;
      Box2D.Dynamics.b2World.e_locked = 0x0002;
   });
})();
(function () {
   var b2CircleShape = Box2D.Collision.Shapes.b2CircleShape,
      b2EdgeChainDef = Box2D.Collision.Shapes.b2EdgeChainDef,
      b2EdgeShape = Box2D.Collision.Shapes.b2EdgeShape,
      b2MassData = Box2D.Collision.Shapes.b2MassData,
      b2PolygonShape = Box2D.Collision.Shapes.b2PolygonShape,
      b2Shape = Box2D.Collision.Shapes.b2Shape,
      b2CircleContact = Box2D.Dynamics.Contacts.b2CircleContact,
      b2Contact = Box2D.Dynamics.Contacts.b2Contact,
      b2ContactConstraint = Box2D.Dynamics.Contacts.b2ContactConstraint,
      b2ContactConstraintPoint = Box2D.Dynamics.Contacts.b2ContactConstraintPoint,
      b2ContactEdge = Box2D.Dynamics.Contacts.b2ContactEdge,
      b2ContactFactory = Box2D.Dynamics.Contacts.b2ContactFactory,
      b2ContactRegister = Box2D.Dynamics.Contacts.b2ContactRegister,
      b2ContactResult = Box2D.Dynamics.Contacts.b2ContactResult,
      b2ContactSolver = Box2D.Dynamics.Contacts.b2ContactSolver,
      b2EdgeAndCircleContact = Box2D.Dynamics.Contacts.b2EdgeAndCircleContact,
      b2NullContact = Box2D.Dynamics.Contacts.b2NullContact,
      b2PolyAndCircleContact = Box2D.Dynamics.Contacts.b2PolyAndCircleContact,
      b2PolyAndEdgeContact = Box2D.Dynamics.Contacts.b2PolyAndEdgeContact,
      b2PolygonContact = Box2D.Dynamics.Contacts.b2PolygonContact,
      b2PositionSolverManifold = Box2D.Dynamics.Contacts.b2PositionSolverManifold,
      b2Body = Box2D.Dynamics.b2Body,
      b2BodyDef = Box2D.Dynamics.b2BodyDef,
      b2ContactFilter = Box2D.Dynamics.b2ContactFilter,
      b2ContactImpulse = Box2D.Dynamics.b2ContactImpulse,
      b2ContactListener = Box2D.Dynamics.b2ContactListener,
      b2ContactManager = Box2D.Dynamics.b2ContactManager,
      b2DebugDraw = Box2D.Dynamics.b2DebugDraw,
      b2DestructionListener = Box2D.Dynamics.b2DestructionListener,
      b2FilterData = Box2D.Dynamics.b2FilterData,
      b2Fixture = Box2D.Dynamics.b2Fixture,
      b2FixtureDef = Box2D.Dynamics.b2FixtureDef,
      b2Island = Box2D.Dynamics.b2Island,
      b2TimeStep = Box2D.Dynamics.b2TimeStep,
      b2World = Box2D.Dynamics.b2World,
      b2Color = Box2D.Common.b2Color,
      b2internal = Box2D.Common.b2internal,
      b2Settings = Box2D.Common.b2Settings,
      b2Mat22 = Box2D.Common.Math.b2Mat22,
      b2Mat33 = Box2D.Common.Math.b2Mat33,
      b2Math = Box2D.Common.Math.b2Math,
      b2Sweep = Box2D.Common.Math.b2Sweep,
      b2Transform = Box2D.Common.Math.b2Transform,
      b2Vec2 = Box2D.Common.Math.b2Vec2,
      b2Vec3 = Box2D.Common.Math.b2Vec3,
      b2AABB = Box2D.Collision.b2AABB,
      b2Bound = Box2D.Collision.b2Bound,
      b2BoundValues = Box2D.Collision.b2BoundValues,
      b2Collision = Box2D.Collision.b2Collision,
      b2ContactID = Box2D.Collision.b2ContactID,
      b2ContactPoint = Box2D.Collision.b2ContactPoint,
      b2Distance = Box2D.Collision.b2Distance,
      b2DistanceInput = Box2D.Collision.b2DistanceInput,
      b2DistanceOutput = Box2D.Collision.b2DistanceOutput,
      b2DistanceProxy = Box2D.Collision.b2DistanceProxy,
      b2DynamicTree = Box2D.Collision.b2DynamicTree,
      b2DynamicTreeBroadPhase = Box2D.Collision.b2DynamicTreeBroadPhase,
      b2DynamicTreeNode = Box2D.Collision.b2DynamicTreeNode,
      b2DynamicTreePair = Box2D.Collision.b2DynamicTreePair,
      b2Manifold = Box2D.Collision.b2Manifold,
      b2ManifoldPoint = Box2D.Collision.b2ManifoldPoint,
      b2Point = Box2D.Collision.b2Point,
      b2RayCastInput = Box2D.Collision.b2RayCastInput,
      b2RayCastOutput = Box2D.Collision.b2RayCastOutput,
      b2Segment = Box2D.Collision.b2Segment,
      b2SeparationFunction = Box2D.Collision.b2SeparationFunction,
      b2Simplex = Box2D.Collision.b2Simplex,
      b2SimplexCache = Box2D.Collision.b2SimplexCache,
      b2SimplexVertex = Box2D.Collision.b2SimplexVertex,
      b2TimeOfImpact = Box2D.Collision.b2TimeOfImpact,
      b2TOIInput = Box2D.Collision.b2TOIInput,
      b2WorldManifold = Box2D.Collision.b2WorldManifold,
      ClipVertex = Box2D.Collision.ClipVertex,
      Features = Box2D.Collision.Features,
      IBroadPhase = Box2D.Collision.IBroadPhase;

   Box2D.inherit(b2CircleContact, Box2D.Dynamics.Contacts.b2Contact);
   b2CircleContact.prototype.__super = Box2D.Dynamics.Contacts.b2Contact.prototype;
   b2CircleContact.b2CircleContact = function () {
      Box2D.Dynamics.Contacts.b2Contact.b2Contact.apply(this, arguments);
   };
   b2CircleContact.Create = function (allocator) {
      return new b2CircleContact();
   }
   b2CircleContact.Destroy = function (contact, allocator) {}
   b2CircleContact.prototype.Reset = function (fixtureA, fixtureB) {
      this.__super.Reset.call(this, fixtureA, fixtureB);
   }
   b2CircleContact.prototype.Evaluate = function () {
      var bA = this.m_fixtureA.GetBody();
      var bB = this.m_fixtureB.GetBody();
      b2Collision.CollideCircles(this.m_manifold, (this.m_fixtureA.GetShape() instanceof b2CircleShape ? this.m_fixtureA.GetShape() : null), bA.m_xf, (this.m_fixtureB.GetShape() instanceof b2CircleShape ? this.m_fixtureB.GetShape() : null), bB.m_xf);
   }
   b2Contact.b2Contact = function () {
      this.m_nodeA = new b2ContactEdge();
      this.m_nodeB = new b2ContactEdge();
      this.m_manifold = new b2Manifold();
      this.m_oldManifold = new b2Manifold();
   };
   b2Contact.prototype.GetManifold = function () {
      return this.m_manifold;
   }
   b2Contact.prototype.GetWorldManifold = function (worldManifold) {
      var bodyA = this.m_fixtureA.GetBody();
      var bodyB = this.m_fixtureB.GetBody();
      var shapeA = this.m_fixtureA.GetShape();
      var shapeB = this.m_fixtureB.GetShape();
      worldManifold.Initialize(this.m_manifold, bodyA.GetTransform(), shapeA.m_radius, bodyB.GetTransform(), shapeB.m_radius);
   }
   b2Contact.prototype.IsTouching = function () {
      return (this.m_flags & b2Contact.e_touchingFlag) == b2Contact.e_touchingFlag;
   }
   b2Contact.prototype.IsContinuous = function () {
      return (this.m_flags & b2Contact.e_continuousFlag) == b2Contact.e_continuousFlag;
   }
   b2Contact.prototype.SetSensor = function (sensor) {
      if (sensor) {
         this.m_flags |= b2Contact.e_sensorFlag;
      }
      else {
         this.m_flags &= ~b2Contact.e_sensorFlag;
      }
   }
   b2Contact.prototype.IsSensor = function () {
      return (this.m_flags & b2Contact.e_sensorFlag) == b2Contact.e_sensorFlag;
   }
   b2Contact.prototype.SetEnabled = function (flag) {
      if (flag) {
         this.m_flags |= b2Contact.e_enabledFlag;
      }
      else {
         this.m_flags &= ~b2Contact.e_enabledFlag;
      }
   }
   b2Contact.prototype.IsEnabled = function () {
      return (this.m_flags & b2Contact.e_enabledFlag) == b2Contact.e_enabledFlag;
   }
   b2Contact.prototype.GetNext = function () {
      return this.m_next;
   }
   b2Contact.prototype.GetFixtureA = function () {
      return this.m_fixtureA;
   }
   b2Contact.prototype.GetFixtureB = function () {
      return this.m_fixtureB;
   }
   b2Contact.prototype.FlagForFiltering = function () {
      this.m_flags |= b2Contact.e_filterFlag;
   }
   b2Contact.prototype.b2Contact = function () {}
   b2Contact.prototype.Reset = function (fixtureA, fixtureB) {
      if (fixtureA === undefined) fixtureA = null;
      if (fixtureB === undefined) fixtureB = null;
      this.m_flags = b2Contact.e_enabledFlag;
      if (!fixtureA || !fixtureB) {
         this.m_fixtureA = null;
         this.m_fixtureB = null;
         return;
      }
      if (fixtureA.IsSensor() || fixtureB.IsSensor()) {
         this.m_flags |= b2Contact.e_sensorFlag;
      }
      var bodyA = fixtureA.GetBody();
      var bodyB = fixtureB.GetBody();
      if (bodyA.GetType() != b2Body.b2_dynamicBody || bodyA.IsBullet() || bodyB.GetType() != b2Body.b2_dynamicBody || bodyB.IsBullet()) {
         this.m_flags |= b2Contact.e_continuousFlag;
      }
      this.m_fixtureA = fixtureA;
      this.m_fixtureB = fixtureB;
      this.m_manifold.m_pointCount = 0;
      this.m_prev = null;
      this.m_next = null;
      this.m_nodeA.contact = null;
      this.m_nodeA.prev = null;
      this.m_nodeA.next = null;
      this.m_nodeA.other = null;
      this.m_nodeB.contact = null;
      this.m_nodeB.prev = null;
      this.m_nodeB.next = null;
      this.m_nodeB.other = null;
   }
   b2Contact.prototype.Update = function (listener) {
      var tManifold = this.m_oldManifold;
      this.m_oldManifold = this.m_manifold;
      this.m_manifold = tManifold;
      this.m_flags |= b2Contact.e_enabledFlag;
      var touching = false;
      var wasTouching = (this.m_flags & b2Contact.e_touchingFlag) == b2Contact.e_touchingFlag;
      var bodyA = this.m_fixtureA.m_body;
      var bodyB = this.m_fixtureB.m_body;
      var aabbOverlap = this.m_fixtureA.m_aabb.TestOverlap(this.m_fixtureB.m_aabb);
      if (this.m_flags & b2Contact.e_sensorFlag) {
         if (aabbOverlap) {
            var shapeA = this.m_fixtureA.GetShape();
            var shapeB = this.m_fixtureB.GetShape();
            var xfA = bodyA.GetTransform();
            var xfB = bodyB.GetTransform();
            touching = b2Shape.TestOverlap(shapeA, xfA, shapeB, xfB);
         }
         this.m_manifold.m_pointCount = 0;
      }
      else {
         if (bodyA.GetType() != b2Body.b2_dynamicBody || bodyA.IsBullet() || bodyB.GetType() != b2Body.b2_dynamicBody || bodyB.IsBullet()) {
            this.m_flags |= b2Contact.e_continuousFlag;
         }
         else {
            this.m_flags &= ~b2Contact.e_continuousFlag;
         }
         if (aabbOverlap) {
            this.Evaluate();
            touching = this.m_manifold.m_pointCount > 0;
            for (var i = 0; i < this.m_manifold.m_pointCount; ++i) {
               var mp2 = this.m_manifold.m_points[i];
               mp2.m_normalImpulse = 0.0;
               mp2.m_tangentImpulse = 0.0;
               var id2 = mp2.m_id;
               for (var j = 0; j < this.m_oldManifold.m_pointCount; ++j) {
                  var mp1 = this.m_oldManifold.m_points[j];
                  if (mp1.m_id.key == id2.key) {
                     mp2.m_normalImpulse = mp1.m_normalImpulse;
                     mp2.m_tangentImpulse = mp1.m_tangentImpulse;
                     break;
                  }
               }
            }
         }
         else {
            this.m_manifold.m_pointCount = 0;
         }
         if (touching != wasTouching) {
            bodyA.SetAwake(true);
            bodyB.SetAwake(true);
         }
      }
      if (touching) {
         this.m_flags |= b2Contact.e_touchingFlag;
      }
      else {
         this.m_flags &= ~b2Contact.e_touchingFlag;
      }
      if (wasTouching == false && touching == true) {
         listener.BeginContact(this);
      }
      if (wasTouching == true && touching == false) {
         listener.EndContact(this);
      }
      if ((this.m_flags & b2Contact.e_sensorFlag) == 0) {
         listener.PreSolve(this, this.m_oldManifold);
      }
   }
   b2Contact.prototype.Evaluate = function () {}
   b2Contact.prototype.ComputeTOI = function (sweepA, sweepB) {
      b2Contact.s_input.proxyA.Set(this.m_fixtureA.GetShape());
      b2Contact.s_input.proxyB.Set(this.m_fixtureB.GetShape());
      b2Contact.s_input.sweepA = sweepA;
      b2Contact.s_input.sweepB = sweepB;
      b2Contact.s_input.tolerance = b2Settings.b2_linearSlop;
      return b2TimeOfImpact.TimeOfImpact(b2Contact.s_input);
   }
   Box2D.postDefs.push(function () {
      Box2D.Dynamics.Contacts.b2Contact.e_sensorFlag = 0x0001;
      Box2D.Dynamics.Contacts.b2Contact.e_continuousFlag = 0x0002;
      Box2D.Dynamics.Contacts.b2Contact.e_islandFlag = 0x0004;
      Box2D.Dynamics.Contacts.b2Contact.e_toiFlag = 0x0008;
      Box2D.Dynamics.Contacts.b2Contact.e_touchingFlag = 0x0010;
      Box2D.Dynamics.Contacts.b2Contact.e_enabledFlag = 0x0020;
      Box2D.Dynamics.Contacts.b2Contact.e_filterFlag = 0x0040;
      Box2D.Dynamics.Contacts.b2Contact.s_input = new b2TOIInput();
   });
   b2ContactConstraint.b2ContactConstraint = function () {
      this.localPlaneNormal = new b2Vec2();
      this.localPoint = new b2Vec2();
      this.normal = new b2Vec2();
      this.normalMass = new b2Mat22();
      this.K = new b2Mat22();
   };
   b2ContactConstraint.prototype.b2ContactConstraint = function () {
      this.points = new Vector(b2Settings.b2_maxManifoldPoints);
      for (var i = 0; i < b2Settings.b2_maxManifoldPoints; i++) {
         this.points[i] = new b2ContactConstraintPoint();
      }
   }
   b2ContactConstraintPoint.b2ContactConstraintPoint = function () {
      this.localPoint = new b2Vec2();
      this.rA = new b2Vec2();
      this.rB = new b2Vec2();
   };
   b2ContactEdge.b2ContactEdge = function () {};
   b2ContactFactory.b2ContactFactory = function () {};
   b2ContactFactory.prototype.b2ContactFactory = function (allocator) {
      this.m_allocator = allocator;
      this.InitializeRegisters();
   }
   b2ContactFactory.prototype.AddType = function (createFcn, destroyFcn, type1, type2) {
      if (type1 === undefined) type1 = 0;
      if (type2 === undefined) type2 = 0;
      this.m_registers[type1][type2].createFcn = createFcn;
      this.m_registers[type1][type2].destroyFcn = destroyFcn;
      this.m_registers[type1][type2].primary = true;
      if (type1 != type2) {
         this.m_registers[type2][type1].createFcn = createFcn;
         this.m_registers[type2][type1].destroyFcn = destroyFcn;
         this.m_registers[type2][type1].primary = false;
      }
   }
   b2ContactFactory.prototype.InitializeRegisters = function () {
      this.m_registers = new Vector(b2Shape.e_shapeTypeCount);
      for (var i = 0; i < b2Shape.e_shapeTypeCount; i++) {
         this.m_registers[i] = new Vector(b2Shape.e_shapeTypeCount);
         for (var j = 0; j < b2Shape.e_shapeTypeCount; j++) {
            this.m_registers[i][j] = new b2ContactRegister();
         }
      }
      this.AddType(b2CircleContact.Create, b2CircleContact.Destroy, b2Shape.e_circleShape, b2Shape.e_circleShape);
      this.AddType(b2PolyAndCircleContact.Create, b2PolyAndCircleContact.Destroy, b2Shape.e_polygonShape, b2Shape.e_circleShape);
      this.AddType(b2PolygonContact.Create, b2PolygonContact.Destroy, b2Shape.e_polygonShape, b2Shape.e_polygonShape);
      this.AddType(b2EdgeAndCircleContact.Create, b2EdgeAndCircleContact.Destroy, b2Shape.e_edgeShape, b2Shape.e_circleShape);
      this.AddType(b2PolyAndEdgeContact.Create, b2PolyAndEdgeContact.Destroy, b2Shape.e_polygonShape, b2Shape.e_edgeShape);
   }
   b2ContactFactory.prototype.Create = function (fixtureA, fixtureB) {
      var type1 = parseInt(fixtureA.GetType());
      var type2 = parseInt(fixtureB.GetType());
      var reg = this.m_registers[type1][type2];
      var c;
      if (reg.pool) {
         c = reg.pool;
         reg.pool = c.m_next;
         reg.poolCount--;
         c.Reset(fixtureA, fixtureB);
         return c;
      }
      var createFcn = reg.createFcn;
      if (createFcn != null) {
         if (reg.primary) {
            c = createFcn(this.m_allocator);
            c.Reset(fixtureA, fixtureB);
            return c;
         }
         else {
            c = createFcn(this.m_allocator);
            c.Reset(fixtureB, fixtureA);
            return c;
         }
      }
      else {
         return null;
      }
   }
   b2ContactFactory.prototype.Destroy = function (contact) {
      if (contact.m_manifold.m_pointCount > 0) {
         contact.m_fixtureA.m_body.SetAwake(true);
         contact.m_fixtureB.m_body.SetAwake(true);
      }
      var type1 = parseInt(contact.m_fixtureA.GetType());
      var type2 = parseInt(contact.m_fixtureB.GetType());
      var reg = this.m_registers[type1][type2];
      if (true) {
         reg.poolCount++;
         contact.m_next = reg.pool;
         reg.pool = contact;
      }
      var destroyFcn = reg.destroyFcn;
      destroyFcn(contact, this.m_allocator);
   }
   b2ContactRegister.b2ContactRegister = function () {};
   b2ContactResult.b2ContactResult = function () {
      this.position = new b2Vec2();
      this.normal = new b2Vec2();
      this.id = new b2ContactID();
   };
   b2ContactSolver.b2ContactSolver = function () {
      this.m_step = new b2TimeStep();
      this.m_constraints = new Vector();
   };
   b2ContactSolver.prototype.b2ContactSolver = function () {}
   b2ContactSolver.prototype.Initialize = function (step, contacts, contactCount, allocator) {
      if (contactCount === undefined) contactCount = 0;
      var contact;
      this.m_step.Set(step);
      this.m_allocator = allocator;
      var i = 0;
      var tVec;
      var tMat;
      this.m_constraintCount = contactCount;
      while (this.m_constraints.length < this.m_constraintCount) {
         this.m_constraints[this.m_constraints.length] = new b2ContactConstraint();
      }
      for (i = 0;
      i < contactCount; ++i) {
         contact = contacts[i];
         var fixtureA = contact.m_fixtureA;
         var fixtureB = contact.m_fixtureB;
         var shapeA = fixtureA.m_shape;
         var shapeB = fixtureB.m_shape;
         var radiusA = shapeA.m_radius;
         var radiusB = shapeB.m_radius;
         var bodyA = fixtureA.m_body;
         var bodyB = fixtureB.m_body;
         var manifold = contact.GetManifold();
         var friction = b2Settings.b2MixFriction(fixtureA.GetFriction(), fixtureB.GetFriction());
         var restitution = b2Settings.b2MixRestitution(fixtureA.GetRestitution(), fixtureB.GetRestitution());
         var vAX = bodyA.m_linearVelocity.x;
         var vAY = bodyA.m_linearVelocity.y;
         var vBX = bodyB.m_linearVelocity.x;
         var vBY = bodyB.m_linearVelocity.y;
         var wA = bodyA.m_angularVelocity;
         var wB = bodyB.m_angularVelocity;
         b2Settings.b2Assert(manifold.m_pointCount > 0);
         b2ContactSolver.s_worldManifold.Initialize(manifold, bodyA.m_xf, radiusA, bodyB.m_xf, radiusB);
         var normalX = b2ContactSolver.s_worldManifold.m_normal.x;
         var normalY = b2ContactSolver.s_worldManifold.m_normal.y;
         var cc = this.m_constraints[i];
         cc.bodyA = bodyA;
         cc.bodyB = bodyB;
         cc.manifold = manifold;
         cc.normal.x = normalX;
         cc.normal.y = normalY;
         cc.pointCount = manifold.m_pointCount;
         cc.friction = friction;
         cc.restitution = restitution;
         cc.localPlaneNormal.x = manifold.m_localPlaneNormal.x;
         cc.localPlaneNormal.y = manifold.m_localPlaneNormal.y;
         cc.localPoint.x = manifold.m_localPoint.x;
         cc.localPoint.y = manifold.m_localPoint.y;
         cc.radius = radiusA + radiusB;
         cc.type = manifold.m_type;
         for (var k = 0; k < cc.pointCount; ++k) {
            var cp = manifold.m_points[k];
            var ccp = cc.points[k];
            ccp.normalImpulse = cp.m_normalImpulse;
            ccp.tangentImpulse = cp.m_tangentImpulse;
            ccp.localPoint.SetV(cp.m_localPoint);
            var rAX = ccp.rA.x = b2ContactSolver.s_worldManifold.m_points[k].x - bodyA.m_sweep.c.x;
            var rAY = ccp.rA.y = b2ContactSolver.s_worldManifold.m_points[k].y - bodyA.m_sweep.c.y;
            var rBX = ccp.rB.x = b2ContactSolver.s_worldManifold.m_points[k].x - bodyB.m_sweep.c.x;
            var rBY = ccp.rB.y = b2ContactSolver.s_worldManifold.m_points[k].y - bodyB.m_sweep.c.y;
            var rnA = rAX * normalY - rAY * normalX;
            var rnB = rBX * normalY - rBY * normalX;
            rnA *= rnA;
            rnB *= rnB;
            var kNormal = bodyA.m_invMass + bodyB.m_invMass + bodyA.m_invI * rnA + bodyB.m_invI * rnB;
            ccp.normalMass = 1.0 / kNormal;
            var kEqualized = bodyA.m_mass * bodyA.m_invMass + bodyB.m_mass * bodyB.m_invMass;
            kEqualized += bodyA.m_mass * bodyA.m_invI * rnA + bodyB.m_mass * bodyB.m_invI * rnB;
            ccp.equalizedMass = 1.0 / kEqualized;
            var tangentX = normalY;
            var tangentY = (-normalX);
            var rtA = rAX * tangentY - rAY * tangentX;
            var rtB = rBX * tangentY - rBY * tangentX;
            rtA *= rtA;
            rtB *= rtB;
            var kTangent = bodyA.m_invMass + bodyB.m_invMass + bodyA.m_invI * rtA + bodyB.m_invI * rtB;
            ccp.tangentMass = 1.0 / kTangent;
            ccp.velocityBias = 0.0;
            var tX = vBX + ((-wB * rBY)) - vAX - ((-wA * rAY));
            var tY = vBY + (wB * rBX) - vAY - (wA * rAX);
            var vRel = cc.normal.x * tX + cc.normal.y * tY;
            if (vRel < (-b2Settings.b2_velocityThreshold)) {
               ccp.velocityBias += (-cc.restitution * vRel);
            }
         }
         if (cc.pointCount == 2) {
            var ccp1 = cc.points[0];
            var ccp2 = cc.points[1];
            var invMassA = bodyA.m_invMass;
            var invIA = bodyA.m_invI;
            var invMassB = bodyB.m_invMass;
            var invIB = bodyB.m_invI;
            var rn1A = ccp1.rA.x * normalY - ccp1.rA.y * normalX;
            var rn1B = ccp1.rB.x * normalY - ccp1.rB.y * normalX;
            var rn2A = ccp2.rA.x * normalY - ccp2.rA.y * normalX;
            var rn2B = ccp2.rB.x * normalY - ccp2.rB.y * normalX;
            var k11 = invMassA + invMassB + invIA * rn1A * rn1A + invIB * rn1B * rn1B;
            var k22 = invMassA + invMassB + invIA * rn2A * rn2A + invIB * rn2B * rn2B;
            var k12 = invMassA + invMassB + invIA * rn1A * rn2A + invIB * rn1B * rn2B;
            var k_maxConditionNumber = 100.0;
            if (k11 * k11 < k_maxConditionNumber * (k11 * k22 - k12 * k12)) {
               cc.K.col1.Set(k11, k12);
               cc.K.col2.Set(k12, k22);
               cc.K.GetInverse(cc.normalMass);
            }
            else {
               cc.pointCount = 1;
            }
         }
      }
   }
   b2ContactSolver.prototype.InitVelocityConstraints = function (step) {
      var tVec;
      var tVec2;
      var tMat;
      for (var i = 0; i < this.m_constraintCount; ++i) {
         var c = this.m_constraints[i];
         var bodyA = c.bodyA;
         var bodyB = c.bodyB;
         var invMassA = bodyA.m_invMass;
         var invIA = bodyA.m_invI;
         var invMassB = bodyB.m_invMass;
         var invIB = bodyB.m_invI;
         var normalX = c.normal.x;
         var normalY = c.normal.y;
         var tangentX = normalY;
         var tangentY = (-normalX);
         var tX = 0;
         var j = 0;
         var tCount = 0;
         if (step.warmStarting) {
            tCount = c.pointCount;
            for (j = 0;
            j < tCount; ++j) {
               var ccp = c.points[j];
               ccp.normalImpulse *= step.dtRatio;
               ccp.tangentImpulse *= step.dtRatio;
               var PX = ccp.normalImpulse * normalX + ccp.tangentImpulse * tangentX;
               var PY = ccp.normalImpulse * normalY + ccp.tangentImpulse * tangentY;
               bodyA.m_angularVelocity -= invIA * (ccp.rA.x * PY - ccp.rA.y * PX);
               bodyA.m_linearVelocity.x -= invMassA * PX;
               bodyA.m_linearVelocity.y -= invMassA * PY;
               bodyB.m_angularVelocity += invIB * (ccp.rB.x * PY - ccp.rB.y * PX);
               bodyB.m_linearVelocity.x += invMassB * PX;
               bodyB.m_linearVelocity.y += invMassB * PY;
            }
         }
         else {
            tCount = c.pointCount;
            for (j = 0;
            j < tCount; ++j) {
               var ccp2 = c.points[j];
               ccp2.normalImpulse = 0.0;
               ccp2.tangentImpulse = 0.0;
            }
         }
      }
   }
   b2ContactSolver.prototype.SolveVelocityConstraints = function () {
      var j = 0;
      var ccp;
      var rAX = 0;
      var rAY = 0;
      var rBX = 0;
      var rBY = 0;
      var dvX = 0;
      var dvY = 0;
      var vn = 0;
      var vt = 0;
      var lambda = 0;
      var maxFriction = 0;
      var newImpulse = 0;
      var PX = 0;
      var PY = 0;
      var dX = 0;
      var dY = 0;
      var P1X = 0;
      var P1Y = 0;
      var P2X = 0;
      var P2Y = 0;
      var tMat;
      var tVec;
      for (var i = 0; i < this.m_constraintCount; ++i) {
         var c = this.m_constraints[i];
         var bodyA = c.bodyA;
         var bodyB = c.bodyB;
         var wA = bodyA.m_angularVelocity;
         var wB = bodyB.m_angularVelocity;
         var vA = bodyA.m_linearVelocity;
         var vB = bodyB.m_linearVelocity;
         var invMassA = bodyA.m_invMass;
         var invIA = bodyA.m_invI;
         var invMassB = bodyB.m_invMass;
         var invIB = bodyB.m_invI;
         var normalX = c.normal.x;
         var normalY = c.normal.y;
         var tangentX = normalY;
         var tangentY = (-normalX);
         var friction = c.friction;
         var tX = 0;
         for (j = 0;
         j < c.pointCount; j++) {
            ccp = c.points[j];
            dvX = vB.x - wB * ccp.rB.y - vA.x + wA * ccp.rA.y;
            dvY = vB.y + wB * ccp.rB.x - vA.y - wA * ccp.rA.x;
            vt = dvX * tangentX + dvY * tangentY;
            lambda = ccp.tangentMass * (-vt);
            maxFriction = friction * ccp.normalImpulse;
            newImpulse = b2Math.Clamp(ccp.tangentImpulse + lambda, (-maxFriction), maxFriction);
            lambda = newImpulse - ccp.tangentImpulse;
            PX = lambda * tangentX;
            PY = lambda * tangentY;
            vA.x -= invMassA * PX;
            vA.y -= invMassA * PY;
            wA -= invIA * (ccp.rA.x * PY - ccp.rA.y * PX);
            vB.x += invMassB * PX;
            vB.y += invMassB * PY;
            wB += invIB * (ccp.rB.x * PY - ccp.rB.y * PX);
            ccp.tangentImpulse = newImpulse;
         }
         var tCount = parseInt(c.pointCount);
         if (c.pointCount == 1) {
            ccp = c.points[0];
            dvX = vB.x + ((-wB * ccp.rB.y)) - vA.x - ((-wA * ccp.rA.y));
            dvY = vB.y + (wB * ccp.rB.x) - vA.y - (wA * ccp.rA.x);
            vn = dvX * normalX + dvY * normalY;
            lambda = (-ccp.normalMass * (vn - ccp.velocityBias));
            newImpulse = ccp.normalImpulse + lambda;
            newImpulse = newImpulse > 0 ? newImpulse : 0.0;
            lambda = newImpulse - ccp.normalImpulse;
            PX = lambda * normalX;
            PY = lambda * normalY;
            vA.x -= invMassA * PX;
            vA.y -= invMassA * PY;
            wA -= invIA * (ccp.rA.x * PY - ccp.rA.y * PX);
            vB.x += invMassB * PX;
            vB.y += invMassB * PY;
            wB += invIB * (ccp.rB.x * PY - ccp.rB.y * PX);
            ccp.normalImpulse = newImpulse;
         }
         else {
            var cp1 = c.points[0];
            var cp2 = c.points[1];
            var aX = cp1.normalImpulse;
            var aY = cp2.normalImpulse;
            var dv1X = vB.x - wB * cp1.rB.y - vA.x + wA * cp1.rA.y;
            var dv1Y = vB.y + wB * cp1.rB.x - vA.y - wA * cp1.rA.x;
            var dv2X = vB.x - wB * cp2.rB.y - vA.x + wA * cp2.rA.y;
            var dv2Y = vB.y + wB * cp2.rB.x - vA.y - wA * cp2.rA.x;
            var vn1 = dv1X * normalX + dv1Y * normalY;
            var vn2 = dv2X * normalX + dv2Y * normalY;
            var bX = vn1 - cp1.velocityBias;
            var bY = vn2 - cp2.velocityBias;
            tMat = c.K;
            bX -= tMat.col1.x * aX + tMat.col2.x * aY;
            bY -= tMat.col1.y * aX + tMat.col2.y * aY;
            var k_errorTol = 0.001;
            for (;;) {
               tMat = c.normalMass;
               var xX = (-(tMat.col1.x * bX + tMat.col2.x * bY));
               var xY = (-(tMat.col1.y * bX + tMat.col2.y * bY));
               if (xX >= 0.0 && xY >= 0.0) {
                  dX = xX - aX;
                  dY = xY - aY;
                  P1X = dX * normalX;
                  P1Y = dX * normalY;
                  P2X = dY * normalX;
                  P2Y = dY * normalY;
                  vA.x -= invMassA * (P1X + P2X);
                  vA.y -= invMassA * (P1Y + P2Y);
                  wA -= invIA * (cp1.rA.x * P1Y - cp1.rA.y * P1X + cp2.rA.x * P2Y - cp2.rA.y * P2X);
                  vB.x += invMassB * (P1X + P2X);
                  vB.y += invMassB * (P1Y + P2Y);
                  wB += invIB * (cp1.rB.x * P1Y - cp1.rB.y * P1X + cp2.rB.x * P2Y - cp2.rB.y * P2X);
                  cp1.normalImpulse = xX;
                  cp2.normalImpulse = xY;
                  break;
               }
               xX = (-cp1.normalMass * bX);
               xY = 0.0;
               vn1 = 0.0;
               vn2 = c.K.col1.y * xX + bY;
               if (xX >= 0.0 && vn2 >= 0.0) {
                  dX = xX - aX;
                  dY = xY - aY;
                  P1X = dX * normalX;
                  P1Y = dX * normalY;
                  P2X = dY * normalX;
                  P2Y = dY * normalY;
                  vA.x -= invMassA * (P1X + P2X);
                  vA.y -= invMassA * (P1Y + P2Y);
                  wA -= invIA * (cp1.rA.x * P1Y - cp1.rA.y * P1X + cp2.rA.x * P2Y - cp2.rA.y * P2X);
                  vB.x += invMassB * (P1X + P2X);
                  vB.y += invMassB * (P1Y + P2Y);
                  wB += invIB * (cp1.rB.x * P1Y - cp1.rB.y * P1X + cp2.rB.x * P2Y - cp2.rB.y * P2X);
                  cp1.normalImpulse = xX;
                  cp2.normalImpulse = xY;
                  break;
               }
               xX = 0.0;
               xY = (-cp2.normalMass * bY);
               vn1 = c.K.col2.x * xY + bX;
               vn2 = 0.0;
               if (xY >= 0.0 && vn1 >= 0.0) {
                  dX = xX - aX;
                  dY = xY - aY;
                  P1X = dX * normalX;
                  P1Y = dX * normalY;
                  P2X = dY * normalX;
                  P2Y = dY * normalY;
                  vA.x -= invMassA * (P1X + P2X);
                  vA.y -= invMassA * (P1Y + P2Y);
                  wA -= invIA * (cp1.rA.x * P1Y - cp1.rA.y * P1X + cp2.rA.x * P2Y - cp2.rA.y * P2X);
                  vB.x += invMassB * (P1X + P2X);
                  vB.y += invMassB * (P1Y + P2Y);
                  wB += invIB * (cp1.rB.x * P1Y - cp1.rB.y * P1X + cp2.rB.x * P2Y - cp2.rB.y * P2X);
                  cp1.normalImpulse = xX;
                  cp2.normalImpulse = xY;
                  break;
               }
               xX = 0.0;
               xY = 0.0;
               vn1 = bX;
               vn2 = bY;
               if (vn1 >= 0.0 && vn2 >= 0.0) {
                  dX = xX - aX;
                  dY = xY - aY;
                  P1X = dX * normalX;
                  P1Y = dX * normalY;
                  P2X = dY * normalX;
                  P2Y = dY * normalY;
                  vA.x -= invMassA * (P1X + P2X);
                  vA.y -= invMassA * (P1Y + P2Y);
                  wA -= invIA * (cp1.rA.x * P1Y - cp1.rA.y * P1X + cp2.rA.x * P2Y - cp2.rA.y * P2X);
                  vB.x += invMassB * (P1X + P2X);
                  vB.y += invMassB * (P1Y + P2Y);
                  wB += invIB * (cp1.rB.x * P1Y - cp1.rB.y * P1X + cp2.rB.x * P2Y - cp2.rB.y * P2X);
                  cp1.normalImpulse = xX;
                  cp2.normalImpulse = xY;
                  break;
               }
               break;
            }
         }
         bodyA.m_angularVelocity = wA;
         bodyB.m_angularVelocity = wB;
      }
   }
   b2ContactSolver.prototype.FinalizeVelocityConstraints = function () {
      for (var i = 0; i < this.m_constraintCount; ++i) {
         var c = this.m_constraints[i];
         var m = c.manifold;
         for (var j = 0; j < c.pointCount; ++j) {
            var point1 = m.m_points[j];
            var point2 = c.points[j];
            point1.m_normalImpulse = point2.normalImpulse;
            point1.m_tangentImpulse = point2.tangentImpulse;
         }
      }
   }
   b2ContactSolver.prototype.SolvePositionConstraints = function (baumgarte) {
      if (baumgarte === undefined) baumgarte = 0;
      var minSeparation = 0.0;
      for (var i = 0; i < this.m_constraintCount; i++) {
         var c = this.m_constraints[i];
         var bodyA = c.bodyA;
         var bodyB = c.bodyB;
         var invMassA = bodyA.m_mass * bodyA.m_invMass;
         var invIA = bodyA.m_mass * bodyA.m_invI;
         var invMassB = bodyB.m_mass * bodyB.m_invMass;
         var invIB = bodyB.m_mass * bodyB.m_invI;
         b2ContactSolver.s_psm.Initialize(c);
         var normal = b2ContactSolver.s_psm.m_normal;
         for (var j = 0; j < c.pointCount; j++) {
            var ccp = c.points[j];
            var point = b2ContactSolver.s_psm.m_points[j];
            var separation = b2ContactSolver.s_psm.m_separations[j];
            var rAX = point.x - bodyA.m_sweep.c.x;
            var rAY = point.y - bodyA.m_sweep.c.y;
            var rBX = point.x - bodyB.m_sweep.c.x;
            var rBY = point.y - bodyB.m_sweep.c.y;
            minSeparation = minSeparation < separation ? minSeparation : separation;
            var C = b2Math.Clamp(baumgarte * (separation + b2Settings.b2_linearSlop), (-b2Settings.b2_maxLinearCorrection), 0.0);
            var impulse = (-ccp.equalizedMass * C);
            var PX = impulse * normal.x;
            var PY = impulse * normal.y;bodyA.m_sweep.c.x -= invMassA * PX;
            bodyA.m_sweep.c.y -= invMassA * PY;
            bodyA.m_sweep.a -= invIA * (rAX * PY - rAY * PX);
            bodyA.SynchronizeTransform();
            bodyB.m_sweep.c.x += invMassB * PX;
            bodyB.m_sweep.c.y += invMassB * PY;
            bodyB.m_sweep.a += invIB * (rBX * PY - rBY * PX);
            bodyB.SynchronizeTransform();
         }
      }
      return minSeparation > (-1.5 * b2Settings.b2_linearSlop);
   }
   Box2D.postDefs.push(function () {
      Box2D.Dynamics.Contacts.b2ContactSolver.s_worldManifold = new b2WorldManifold();
      Box2D.Dynamics.Contacts.b2ContactSolver.s_psm = new b2PositionSolverManifold();
   });
   Box2D.inherit(b2EdgeAndCircleContact, Box2D.Dynamics.Contacts.b2Contact);
   b2EdgeAndCircleContact.prototype.__super = Box2D.Dynamics.Contacts.b2Contact.prototype;
   b2EdgeAndCircleContact.b2EdgeAndCircleContact = function () {
      Box2D.Dynamics.Contacts.b2Contact.b2Contact.apply(this, arguments);
   };
   b2EdgeAndCircleContact.Create = function (allocator) {
      return new b2EdgeAndCircleContact();
   }
   b2EdgeAndCircleContact.Destroy = function (contact, allocator) {}
   b2EdgeAndCircleContact.prototype.Reset = function (fixtureA, fixtureB) {
      this.__super.Reset.call(this, fixtureA, fixtureB);
   }
   b2EdgeAndCircleContact.prototype.Evaluate = function () {
      var bA = this.m_fixtureA.GetBody();
      var bB = this.m_fixtureB.GetBody();
      this.b2CollideEdgeAndCircle(this.m_manifold, (this.m_fixtureA.GetShape() instanceof b2EdgeShape ? this.m_fixtureA.GetShape() : null), bA.m_xf, (this.m_fixtureB.GetShape() instanceof b2CircleShape ? this.m_fixtureB.GetShape() : null), bB.m_xf);
   }
   b2EdgeAndCircleContact.prototype.b2CollideEdgeAndCircle = function (manifold, edge, xf1, circle, xf2) {}
   Box2D.inherit(b2NullContact, Box2D.Dynamics.Contacts.b2Contact);
   b2NullContact.prototype.__super = Box2D.Dynamics.Contacts.b2Contact.prototype;
   b2NullContact.b2NullContact = function () {
      Box2D.Dynamics.Contacts.b2Contact.b2Contact.apply(this, arguments);
   };
   b2NullContact.prototype.b2NullContact = function () {
      this.__super.b2Contact.call(this);
   }
   b2NullContact.prototype.Evaluate = function () {}
   Box2D.inherit(b2PolyAndCircleContact, Box2D.Dynamics.Contacts.b2Contact);
   b2PolyAndCircleContact.prototype.__super = Box2D.Dynamics.Contacts.b2Contact.prototype;
   b2PolyAndCircleContact.b2PolyAndCircleContact = function () {
      Box2D.Dynamics.Contacts.b2Contact.b2Contact.apply(this, arguments);
   };
   b2PolyAndCircleContact.Create = function (allocator) {
      return new b2PolyAndCircleContact();
   }
   b2PolyAndCircleContact.Destroy = function (contact, allocator) {}
   b2PolyAndCircleContact.prototype.Reset = function (fixtureA, fixtureB) {
      this.__super.Reset.call(this, fixtureA, fixtureB);
      b2Settings.b2Assert(fixtureA.GetType() == b2Shape.e_polygonShape);
      b2Settings.b2Assert(fixtureB.GetType() == b2Shape.e_circleShape);
   }
   b2PolyAndCircleContact.prototype.Evaluate = function () {
      var bA = this.m_fixtureA.m_body;
      var bB = this.m_fixtureB.m_body;
      b2Collision.CollidePolygonAndCircle(this.m_manifold, (this.m_fixtureA.GetShape() instanceof b2PolygonShape ? this.m_fixtureA.GetShape() : null), bA.m_xf, (this.m_fixtureB.GetShape() instanceof b2CircleShape ? this.m_fixtureB.GetShape() : null), bB.m_xf);
   }
   Box2D.inherit(b2PolyAndEdgeContact, Box2D.Dynamics.Contacts.b2Contact);
   b2PolyAndEdgeContact.prototype.__super = Box2D.Dynamics.Contacts.b2Contact.prototype;
   b2PolyAndEdgeContact.b2PolyAndEdgeContact = function () {
      Box2D.Dynamics.Contacts.b2Contact.b2Contact.apply(this, arguments);
   };
   b2PolyAndEdgeContact.Create = function (allocator) {
      return new b2PolyAndEdgeContact();
   }
   b2PolyAndEdgeContact.Destroy = function (contact, allocator) {}
   b2PolyAndEdgeContact.prototype.Reset = function (fixtureA, fixtureB) {
      this.__super.Reset.call(this, fixtureA, fixtureB);
      b2Settings.b2Assert(fixtureA.GetType() == b2Shape.e_polygonShape);
      b2Settings.b2Assert(fixtureB.GetType() == b2Shape.e_edgeShape);
   }
   b2PolyAndEdgeContact.prototype.Evaluate = function () {
      var bA = this.m_fixtureA.GetBody();
      var bB = this.m_fixtureB.GetBody();
      this.b2CollidePolyAndEdge(this.m_manifold, (this.m_fixtureA.GetShape() instanceof b2PolygonShape ? this.m_fixtureA.GetShape() : null), bA.m_xf, (this.m_fixtureB.GetShape() instanceof b2EdgeShape ? this.m_fixtureB.GetShape() : null), bB.m_xf);
   }
   b2PolyAndEdgeContact.prototype.b2CollidePolyAndEdge = function (manifold, polygon, xf1, edge, xf2) {}
   Box2D.inherit(b2PolygonContact, Box2D.Dynamics.Contacts.b2Contact);
   b2PolygonContact.prototype.__super = Box2D.Dynamics.Contacts.b2Contact.prototype;
   b2PolygonContact.b2PolygonContact = function () {
      Box2D.Dynamics.Contacts.b2Contact.b2Contact.apply(this, arguments);
   };
   b2PolygonContact.Create = function (allocator) {
      return new b2PolygonContact();
   }
   b2PolygonContact.Destroy = function (contact, allocator) {}
   b2PolygonContact.prototype.Reset = function (fixtureA, fixtureB) {
      this.__super.Reset.call(this, fixtureA, fixtureB);
   }
   b2PolygonContact.prototype.Evaluate = function () {
      var bA = this.m_fixtureA.GetBody();
      var bB = this.m_fixtureB.GetBody();
      b2Collision.CollidePolygons(this.m_manifold, (this.m_fixtureA.GetShape() instanceof b2PolygonShape ? this.m_fixtureA.GetShape() : null), bA.m_xf, (this.m_fixtureB.GetShape() instanceof b2PolygonShape ? this.m_fixtureB.GetShape() : null), bB.m_xf);
   }
   b2PositionSolverManifold.b2PositionSolverManifold = function () {};
   b2PositionSolverManifold.prototype.b2PositionSolverManifold = function () {
      this.m_normal = new b2Vec2();
      this.m_separations = new Vector_a2j_Number(b2Settings.b2_maxManifoldPoints);
      this.m_points = new Vector(b2Settings.b2_maxManifoldPoints);
      for (var i = 0; i < b2Settings.b2_maxManifoldPoints; i++) {
         this.m_points[i] = new b2Vec2();
      }
   }
   b2PositionSolverManifold.prototype.Initialize = function (cc) {
      b2Settings.b2Assert(cc.pointCount > 0);
      var i = 0;
      var clipPointX = 0;
      var clipPointY = 0;
      var tMat;
      var tVec;
      var planePointX = 0;
      var planePointY = 0;
      switch (cc.type) {
      case b2Manifold.e_circles:
         {
            tMat = cc.bodyA.m_xf.R;
            tVec = cc.localPoint;
            var pointAX = cc.bodyA.m_xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
            var pointAY = cc.bodyA.m_xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
            tMat = cc.bodyB.m_xf.R;
            tVec = cc.points[0].localPoint;
            var pointBX = cc.bodyB.m_xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
            var pointBY = cc.bodyB.m_xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
            var dX = pointBX - pointAX;
            var dY = pointBY - pointAY;
            var d2 = dX * dX + dY * dY;
            if (d2 > Number.MIN_VALUE * Number.MIN_VALUE) {
               var d = Math.sqrt(d2);
               this.m_normal.x = dX / d;
               this.m_normal.y = dY / d;
            }
            else {
               this.m_normal.x = 1.0;
               this.m_normal.y = 0.0;
            }
            this.m_points[0].x = 0.5 * (pointAX + pointBX);
            this.m_points[0].y = 0.5 * (pointAY + pointBY);
            this.m_separations[0] = dX * this.m_normal.x + dY * this.m_normal.y - cc.radius;
         }
         break;
      case b2Manifold.e_faceA:
         {
            tMat = cc.bodyA.m_xf.R;
            tVec = cc.localPlaneNormal;
            this.m_normal.x = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
            this.m_normal.y = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
            tMat = cc.bodyA.m_xf.R;
            tVec = cc.localPoint;
            planePointX = cc.bodyA.m_xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
            planePointY = cc.bodyA.m_xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
            tMat = cc.bodyB.m_xf.R;
            for (i = 0;
            i < cc.pointCount; ++i) {
               tVec = cc.points[i].localPoint;
               clipPointX = cc.bodyB.m_xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
               clipPointY = cc.bodyB.m_xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
               this.m_separations[i] = (clipPointX - planePointX) * this.m_normal.x + (clipPointY - planePointY) * this.m_normal.y - cc.radius;
               this.m_points[i].x = clipPointX;
               this.m_points[i].y = clipPointY;
            }
         }
         break;
      case b2Manifold.e_faceB:
         {
            tMat = cc.bodyB.m_xf.R;
            tVec = cc.localPlaneNormal;
            this.m_normal.x = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
            this.m_normal.y = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
            tMat = cc.bodyB.m_xf.R;
            tVec = cc.localPoint;
            planePointX = cc.bodyB.m_xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
            planePointY = cc.bodyB.m_xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
            tMat = cc.bodyA.m_xf.R;
            for (i = 0;
            i < cc.pointCount; ++i) {
               tVec = cc.points[i].localPoint;
               clipPointX = cc.bodyA.m_xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
               clipPointY = cc.bodyA.m_xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
               this.m_separations[i] = (clipPointX - planePointX) * this.m_normal.x + (clipPointY - planePointY) * this.m_normal.y - cc.radius;
               this.m_points[i].Set(clipPointX, clipPointY);
            }
            this.m_normal.x *= (-1);
            this.m_normal.y *= (-1);
         }
         break;
      }
   }
   Box2D.postDefs.push(function () {
      Box2D.Dynamics.Contacts.b2PositionSolverManifold.circlePointA = new b2Vec2();
      Box2D.Dynamics.Contacts.b2PositionSolverManifold.circlePointB = new b2Vec2();
   });
})();
(function () {
   var b2Body = Box2D.Dynamics.b2Body,
      b2BodyDef = Box2D.Dynamics.b2BodyDef,
      b2ContactFilter = Box2D.Dynamics.b2ContactFilter,
      b2ContactImpulse = Box2D.Dynamics.b2ContactImpulse,
      b2ContactListener = Box2D.Dynamics.b2ContactListener,
      b2ContactManager = Box2D.Dynamics.b2ContactManager,
      b2DebugDraw = Box2D.Dynamics.b2DebugDraw,
      b2DestructionListener = Box2D.Dynamics.b2DestructionListener,
      b2FilterData = Box2D.Dynamics.b2FilterData,
      b2Fixture = Box2D.Dynamics.b2Fixture,
      b2FixtureDef = Box2D.Dynamics.b2FixtureDef,
      b2Island = Box2D.Dynamics.b2Island,
      b2TimeStep = Box2D.Dynamics.b2TimeStep,
      b2World = Box2D.Dynamics.b2World,
      b2Mat22 = Box2D.Common.Math.b2Mat22,
      b2Mat33 = Box2D.Common.Math.b2Mat33,
      b2Math = Box2D.Common.Math.b2Math,
      b2Sweep = Box2D.Common.Math.b2Sweep,
      b2Transform = Box2D.Common.Math.b2Transform,
      b2Vec2 = Box2D.Common.Math.b2Vec2,
      b2Vec3 = Box2D.Common.Math.b2Vec3,
      b2Color = Box2D.Common.b2Color,
      b2internal = Box2D.Common.b2internal,
      b2Settings = Box2D.Common.b2Settings,
      b2CircleShape = Box2D.Collision.Shapes.b2CircleShape,
      b2EdgeChainDef = Box2D.Collision.Shapes.b2EdgeChainDef,
      b2EdgeShape = Box2D.Collision.Shapes.b2EdgeShape,
      b2MassData = Box2D.Collision.Shapes.b2MassData,
      b2PolygonShape = Box2D.Collision.Shapes.b2PolygonShape,
      b2Shape = Box2D.Collision.Shapes.b2Shape,
      b2BuoyancyController = Box2D.Dynamics.Controllers.b2BuoyancyController,
      b2ConstantAccelController = Box2D.Dynamics.Controllers.b2ConstantAccelController,
      b2ConstantForceController = Box2D.Dynamics.Controllers.b2ConstantForceController,
      b2Controller = Box2D.Dynamics.Controllers.b2Controller,
      b2ControllerEdge = Box2D.Dynamics.Controllers.b2ControllerEdge,
      b2GravityController = Box2D.Dynamics.Controllers.b2GravityController,
      b2TensorDampingController = Box2D.Dynamics.Controllers.b2TensorDampingController;

   Box2D.inherit(b2BuoyancyController, Box2D.Dynamics.Controllers.b2Controller);
   b2BuoyancyController.prototype.__super = Box2D.Dynamics.Controllers.b2Controller.prototype;
   b2BuoyancyController.b2BuoyancyController = function () {
      Box2D.Dynamics.Controllers.b2Controller.b2Controller.apply(this, arguments);
      this.normal = new b2Vec2(0, (-1));
      this.offset = 0;
      this.density = 0;
      this.velocity = new b2Vec2(0, 0);
      this.linearDrag = 2;
      this.angularDrag = 1;
      this.useDensity = false;
      this.useWorldGravity = true;
      this.gravity = null;
   };
   b2BuoyancyController.prototype.Step = function (step) {
      if (!this.m_bodyList) return;
      if (this.useWorldGravity) {
         this.gravity = this.GetWorld().GetGravity().Copy();
      }
      for (var i = this.m_bodyList; i; i = i.nextBody) {
         var body = i.body;
         if (body.IsAwake() == false) {
            continue;
         }
         var areac = new b2Vec2();
         var massc = new b2Vec2();
         var area = 0.0;
         var mass = 0.0;
         for (var fixture = body.GetFixtureList(); fixture; fixture = fixture.GetNext()) {
            var sc = new b2Vec2();
            var sarea = fixture.GetShape().ComputeSubmergedArea(this.normal, this.offset, body.GetTransform(), sc);
            area += sarea;
            areac.x += sarea * sc.x;
            areac.y += sarea * sc.y;
            var shapeDensity = 0;
            if (this.useDensity) {
               shapeDensity = 1;
            }
            else {
               shapeDensity = 1;
            }
            mass += sarea * shapeDensity;
            massc.x += sarea * sc.x * shapeDensity;
            massc.y += sarea * sc.y * shapeDensity;
         }
         areac.x /= area;
         areac.y /= area;
         massc.x /= mass;
         massc.y /= mass;
         if (area < Number.MIN_VALUE) continue;
         var buoyancyForce = this.gravity.GetNegative();
         buoyancyForce.Multiply(this.density * area);
         body.ApplyForce(buoyancyForce, massc);
         var dragForce = body.GetLinearVelocityFromWorldPoint(areac);
         dragForce.Subtract(this.velocity);
         dragForce.Multiply((-this.linearDrag * area));
         body.ApplyForce(dragForce, areac);
         body.ApplyTorque((-body.GetInertia() / body.GetMass() * area * body.GetAngularVelocity() * this.angularDrag));
      }
   }
   b2BuoyancyController.prototype.Draw = function (debugDraw) {
      var r = 1000;
      var p1 = new b2Vec2();
      var p2 = new b2Vec2();
      p1.x = this.normal.x * this.offset + this.normal.y * r;
      p1.y = this.normal.y * this.offset - this.normal.x * r;
      p2.x = this.normal.x * this.offset - this.normal.y * r;
      p2.y = this.normal.y * this.offset + this.normal.x * r;
      var color = new b2Color(0, 0, 1);
      debugDraw.DrawSegment(p1, p2, color);
   }
   Box2D.inherit(b2ConstantAccelController, Box2D.Dynamics.Controllers.b2Controller);
   b2ConstantAccelController.prototype.__super = Box2D.Dynamics.Controllers.b2Controller.prototype;
   b2ConstantAccelController.b2ConstantAccelController = function () {
      Box2D.Dynamics.Controllers.b2Controller.b2Controller.apply(this, arguments);
      this.A = new b2Vec2(0, 0);
   };
   b2ConstantAccelController.prototype.Step = function (step) {
      var smallA = new b2Vec2(this.A.x * step.dt, this.A.y * step.dt);
      for (var i = this.m_bodyList; i; i = i.nextBody) {
         var body = i.body;
         if (!body.IsAwake()) continue;
         body.SetLinearVelocity(new b2Vec2(body.GetLinearVelocity().x + smallA.x, body.GetLinearVelocity().y + smallA.y));
      }
   }
   Box2D.inherit(b2ConstantForceController, Box2D.Dynamics.Controllers.b2Controller);
   b2ConstantForceController.prototype.__super = Box2D.Dynamics.Controllers.b2Controller.prototype;
   b2ConstantForceController.b2ConstantForceController = function () {
      Box2D.Dynamics.Controllers.b2Controller.b2Controller.apply(this, arguments);
      this.F = new b2Vec2(0, 0);
   };
   b2ConstantForceController.prototype.Step = function (step) {
      for (var i = this.m_bodyList; i; i = i.nextBody) {
         var body = i.body;
         if (!body.IsAwake()) continue;
         body.ApplyForce(this.F, body.GetWorldCenter());
      }
   }
   b2Controller.b2Controller = function () {};
   b2Controller.prototype.Step = function (step) {}
   b2Controller.prototype.Draw = function (debugDraw) {}
   b2Controller.prototype.AddBody = function (body) {
      var edge = new b2ControllerEdge();
      edge.controller = this;
      edge.body = body;
      edge.nextBody = this.m_bodyList;
      edge.prevBody = null;
      this.m_bodyList = edge;
      if (edge.nextBody) edge.nextBody.prevBody = edge;
      this.m_bodyCount++;
      edge.nextController = body.m_controllerList;
      edge.prevController = null;
      body.m_controllerList = edge;
      if (edge.nextController) edge.nextController.prevController = edge;
      body.m_controllerCount++;
   }
   b2Controller.prototype.RemoveBody = function (body) {
      var edge = body.m_controllerList;
      while (edge && edge.controller != this)
      edge = edge.nextController;
      if (edge.prevBody) edge.prevBody.nextBody = edge.nextBody;
      if (edge.nextBody) edge.nextBody.prevBody = edge.prevBody;
      if (edge.nextController) edge.nextController.prevController = edge.prevController;
      if (edge.prevController) edge.prevController.nextController = edge.nextController;
      if (this.m_bodyList == edge) this.m_bodyList = edge.nextBody;
      if (body.m_controllerList == edge) body.m_controllerList = edge.nextController;
      body.m_controllerCount--;
      this.m_bodyCount--;
   }
   b2Controller.prototype.Clear = function () {
      while (this.m_bodyList)
      this.RemoveBody(this.m_bodyList.body);
   }
   b2Controller.prototype.GetNext = function () {
      return this.m_next;
   }
   b2Controller.prototype.GetWorld = function () {
      return this.m_world;
   }
   b2Controller.prototype.GetBodyList = function () {
      return this.m_bodyList;
   }
   b2ControllerEdge.b2ControllerEdge = function () {};
   Box2D.inherit(b2GravityController, Box2D.Dynamics.Controllers.b2Controller);
   b2GravityController.prototype.__super = Box2D.Dynamics.Controllers.b2Controller.prototype;
   b2GravityController.b2GravityController = function () {
      Box2D.Dynamics.Controllers.b2Controller.b2Controller.apply(this, arguments);
      this.G = 1;
      this.invSqr = true;
   };
   b2GravityController.prototype.Step = function (step) {
      var i = null;
      var body1 = null;
      var p1 = null;
      var mass1 = 0;
      var j = null;
      var body2 = null;
      var p2 = null;
      var dx = 0;
      var dy = 0;
      var r2 = 0;
      var f = null;
      if (this.invSqr) {
         for (i = this.m_bodyList;
         i; i = i.nextBody) {
            body1 = i.body;
            p1 = body1.GetWorldCenter();
            mass1 = body1.GetMass();
            for (j = this.m_bodyList;
            j != i; j = j.nextBody) {
               body2 = j.body;
               p2 = body2.GetWorldCenter();
               dx = p2.x - p1.x;
               dy = p2.y - p1.y;
               r2 = dx * dx + dy * dy;
               if (r2 < Number.MIN_VALUE) continue;
               f = new b2Vec2(dx, dy);
               f.Multiply(this.G / r2 / Math.sqrt(r2) * mass1 * body2.GetMass());
               if (body1.IsAwake()) body1.ApplyForce(f, p1);
               f.Multiply((-1));
               if (body2.IsAwake()) body2.ApplyForce(f, p2);
            }
         }
      }
      else {
         for (i = this.m_bodyList;
         i; i = i.nextBody) {
            body1 = i.body;
            p1 = body1.GetWorldCenter();
            mass1 = body1.GetMass();
            for (j = this.m_bodyList;
            j != i; j = j.nextBody) {
               body2 = j.body;
               p2 = body2.GetWorldCenter();
               dx = p2.x - p1.x;
               dy = p2.y - p1.y;
               r2 = dx * dx + dy * dy;
               if (r2 < Number.MIN_VALUE) continue;
               f = new b2Vec2(dx, dy);
               f.Multiply(this.G / r2 * mass1 * body2.GetMass());
               if (body1.IsAwake()) body1.ApplyForce(f, p1);
               f.Multiply((-1));
               if (body2.IsAwake()) body2.ApplyForce(f, p2);
            }
         }
      }
   }
   Box2D.inherit(b2TensorDampingController, Box2D.Dynamics.Controllers.b2Controller);
   b2TensorDampingController.prototype.__super = Box2D.Dynamics.Controllers.b2Controller.prototype;
   b2TensorDampingController.b2TensorDampingController = function () {
      Box2D.Dynamics.Controllers.b2Controller.b2Controller.apply(this, arguments);
      this.T = new b2Mat22();
      this.maxTimestep = 0;
   };
   b2TensorDampingController.prototype.SetAxisAligned = function (xDamping, yDamping) {
      if (xDamping === undefined) xDamping = 0;
      if (yDamping === undefined) yDamping = 0;
      this.T.col1.x = (-xDamping);
      this.T.col1.y = 0;
      this.T.col2.x = 0;
      this.T.col2.y = (-yDamping);
      if (xDamping > 0 || yDamping > 0) {
         this.maxTimestep = 1 / Math.max(xDamping, yDamping);
      }
      else {
         this.maxTimestep = 0;
      }
   }
   b2TensorDampingController.prototype.Step = function (step) {
      var timestep = step.dt;
      if (timestep <= Number.MIN_VALUE) return;
      if (timestep > this.maxTimestep && this.maxTimestep > 0) timestep = this.maxTimestep;
      for (var i = this.m_bodyList; i; i = i.nextBody) {
         var body = i.body;
         if (!body.IsAwake()) {
            continue;
         }
         var damping = body.GetWorldVector(b2Math.MulMV(this.T, body.GetLocalVector(body.GetLinearVelocity())));
         body.SetLinearVelocity(new b2Vec2(body.GetLinearVelocity().x + damping.x * timestep, body.GetLinearVelocity().y + damping.y * timestep));
      }
   }
})();
(function () {
   var b2Color = Box2D.Common.b2Color,
      b2internal = Box2D.Common.b2internal,
      b2Settings = Box2D.Common.b2Settings,
      b2Mat22 = Box2D.Common.Math.b2Mat22,
      b2Mat33 = Box2D.Common.Math.b2Mat33,
      b2Math = Box2D.Common.Math.b2Math,
      b2Sweep = Box2D.Common.Math.b2Sweep,
      b2Transform = Box2D.Common.Math.b2Transform,
      b2Vec2 = Box2D.Common.Math.b2Vec2,
      b2Vec3 = Box2D.Common.Math.b2Vec3,
      b2DistanceJoint = Box2D.Dynamics.Joints.b2DistanceJoint,
      b2DistanceJointDef = Box2D.Dynamics.Joints.b2DistanceJointDef,
      b2FrictionJoint = Box2D.Dynamics.Joints.b2FrictionJoint,
      b2FrictionJointDef = Box2D.Dynamics.Joints.b2FrictionJointDef,
      b2GearJoint = Box2D.Dynamics.Joints.b2GearJoint,
      b2GearJointDef = Box2D.Dynamics.Joints.b2GearJointDef,
      b2Jacobian = Box2D.Dynamics.Joints.b2Jacobian,
      b2Joint = Box2D.Dynamics.Joints.b2Joint,
      b2JointDef = Box2D.Dynamics.Joints.b2JointDef,
      b2JointEdge = Box2D.Dynamics.Joints.b2JointEdge,
      b2LineJoint = Box2D.Dynamics.Joints.b2LineJoint,
      b2LineJointDef = Box2D.Dynamics.Joints.b2LineJointDef,
      b2MouseJoint = Box2D.Dynamics.Joints.b2MouseJoint,
      b2MouseJointDef = Box2D.Dynamics.Joints.b2MouseJointDef,
      b2PrismaticJoint = Box2D.Dynamics.Joints.b2PrismaticJoint,
      b2PrismaticJointDef = Box2D.Dynamics.Joints.b2PrismaticJointDef,
      b2PulleyJoint = Box2D.Dynamics.Joints.b2PulleyJoint,
      b2PulleyJointDef = Box2D.Dynamics.Joints.b2PulleyJointDef,
      b2RevoluteJoint = Box2D.Dynamics.Joints.b2RevoluteJoint,
      b2RevoluteJointDef = Box2D.Dynamics.Joints.b2RevoluteJointDef,
      b2WeldJoint = Box2D.Dynamics.Joints.b2WeldJoint,
      b2WeldJointDef = Box2D.Dynamics.Joints.b2WeldJointDef,
      b2Body = Box2D.Dynamics.b2Body,
      b2BodyDef = Box2D.Dynamics.b2BodyDef,
      b2ContactFilter = Box2D.Dynamics.b2ContactFilter,
      b2ContactImpulse = Box2D.Dynamics.b2ContactImpulse,
      b2ContactListener = Box2D.Dynamics.b2ContactListener,
      b2ContactManager = Box2D.Dynamics.b2ContactManager,
      b2DebugDraw = Box2D.Dynamics.b2DebugDraw,
      b2DestructionListener = Box2D.Dynamics.b2DestructionListener,
      b2FilterData = Box2D.Dynamics.b2FilterData,
      b2Fixture = Box2D.Dynamics.b2Fixture,
      b2FixtureDef = Box2D.Dynamics.b2FixtureDef,
      b2Island = Box2D.Dynamics.b2Island,
      b2TimeStep = Box2D.Dynamics.b2TimeStep,
      b2World = Box2D.Dynamics.b2World;

   Box2D.inherit(b2DistanceJoint, Box2D.Dynamics.Joints.b2Joint);
   b2DistanceJoint.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype;
   b2DistanceJoint.b2DistanceJoint = function () {
      Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments);
      this.m_localAnchor1 = new b2Vec2();
      this.m_localAnchor2 = new b2Vec2();
      this.m_u = new b2Vec2();
   };
   b2DistanceJoint.prototype.GetAnchorA = function () {
      return this.m_bodyA.GetWorldPoint(this.m_localAnchor1);
   }
   b2DistanceJoint.prototype.GetAnchorB = function () {
      return this.m_bodyB.GetWorldPoint(this.m_localAnchor2);
   }
   b2DistanceJoint.prototype.GetReactionForce = function (inv_dt) {
      if (inv_dt === undefined) inv_dt = 0;
      return new b2Vec2(inv_dt * this.m_impulse * this.m_u.x, inv_dt * this.m_impulse * this.m_u.y);
   }
   b2DistanceJoint.prototype.GetReactionTorque = function (inv_dt) {
      if (inv_dt === undefined) inv_dt = 0;
      return 0.0;
   }
   b2DistanceJoint.prototype.GetLength = function () {
      return this.m_length;
   }
   b2DistanceJoint.prototype.SetLength = function (length) {
      if (length === undefined) length = 0;
      this.m_length = length;
   }
   b2DistanceJoint.prototype.GetFrequency = function () {
      return this.m_frequencyHz;
   }
   b2DistanceJoint.prototype.SetFrequency = function (hz) {
      if (hz === undefined) hz = 0;
      this.m_frequencyHz = hz;
   }
   b2DistanceJoint.prototype.GetDampingRatio = function () {
      return this.m_dampingRatio;
   }
   b2DistanceJoint.prototype.SetDampingRatio = function (ratio) {
      if (ratio === undefined) ratio = 0;
      this.m_dampingRatio = ratio;
   }
   b2DistanceJoint.prototype.b2DistanceJoint = function (def) {
      this.__super.b2Joint.call(this, def);
      var tMat;
      var tX = 0;
      var tY = 0;
      this.m_localAnchor1.SetV(def.localAnchorA);
      this.m_localAnchor2.SetV(def.localAnchorB);
      this.m_length = def.length;
      this.m_frequencyHz = def.frequencyHz;
      this.m_dampingRatio = def.dampingRatio;
      this.m_impulse = 0.0;
      this.m_gamma = 0.0;
      this.m_bias = 0.0;
   }
   b2DistanceJoint.prototype.InitVelocityConstraints = function (step) {
      var tMat;
      var tX = 0;
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      tMat = bA.m_xf.R;
      var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
      var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
      tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
      r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
      r1X = tX;
      tMat = bB.m_xf.R;
      var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
      var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
      tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
      r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
      r2X = tX;
      this.m_u.x = bB.m_sweep.c.x + r2X - bA.m_sweep.c.x - r1X;
      this.m_u.y = bB.m_sweep.c.y + r2Y - bA.m_sweep.c.y - r1Y;
      var length = Math.sqrt(this.m_u.x * this.m_u.x + this.m_u.y * this.m_u.y);
      if (length > b2Settings.b2_linearSlop) {
         this.m_u.Multiply(1.0 / length);
      }
      else {
         this.m_u.SetZero();
      }
      var cr1u = (r1X * this.m_u.y - r1Y * this.m_u.x);
      var cr2u = (r2X * this.m_u.y - r2Y * this.m_u.x);
      var invMass = bA.m_invMass + bA.m_invI * cr1u * cr1u + bB.m_invMass + bB.m_invI * cr2u * cr2u;
      this.m_mass = invMass != 0.0 ? 1.0 / invMass : 0.0;
      if (this.m_frequencyHz > 0.0) {
         var C = length - this.m_length;
         var omega = 2.0 * Math.PI * this.m_frequencyHz;
         var d = 2.0 * this.m_mass * this.m_dampingRatio * omega;
         var k = this.m_mass * omega * omega;
         this.m_gamma = step.dt * (d + step.dt * k);
         this.m_gamma = this.m_gamma != 0.0 ? 1 / this.m_gamma : 0.0;
         this.m_bias = C * step.dt * k * this.m_gamma;
         this.m_mass = invMass + this.m_gamma;
         this.m_mass = this.m_mass != 0.0 ? 1.0 / this.m_mass : 0.0;
      }
      if (step.warmStarting) {
         this.m_impulse *= step.dtRatio;
         var PX = this.m_impulse * this.m_u.x;
         var PY = this.m_impulse * this.m_u.y;
         bA.m_linearVelocity.x -= bA.m_invMass * PX;
         bA.m_linearVelocity.y -= bA.m_invMass * PY;
         bA.m_angularVelocity -= bA.m_invI * (r1X * PY - r1Y * PX);
         bB.m_linearVelocity.x += bB.m_invMass * PX;
         bB.m_linearVelocity.y += bB.m_invMass * PY;
         bB.m_angularVelocity += bB.m_invI * (r2X * PY - r2Y * PX);
      }
      else {
         this.m_impulse = 0.0;
      }
   }
   b2DistanceJoint.prototype.SolveVelocityConstraints = function (step) {
      var tMat;
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      tMat = bA.m_xf.R;
      var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
      var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
      var tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
      r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
      r1X = tX;
      tMat = bB.m_xf.R;
      var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
      var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
      tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
      r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
      r2X = tX;
      var v1X = bA.m_linearVelocity.x + ((-bA.m_angularVelocity * r1Y));
      var v1Y = bA.m_linearVelocity.y + (bA.m_angularVelocity * r1X);
      var v2X = bB.m_linearVelocity.x + ((-bB.m_angularVelocity * r2Y));
      var v2Y = bB.m_linearVelocity.y + (bB.m_angularVelocity * r2X);
      var Cdot = (this.m_u.x * (v2X - v1X) + this.m_u.y * (v2Y - v1Y));
      var impulse = (-this.m_mass * (Cdot + this.m_bias + this.m_gamma * this.m_impulse));
      this.m_impulse += impulse;
      var PX = impulse * this.m_u.x;
      var PY = impulse * this.m_u.y;
      bA.m_linearVelocity.x -= bA.m_invMass * PX;
      bA.m_linearVelocity.y -= bA.m_invMass * PY;
      bA.m_angularVelocity -= bA.m_invI * (r1X * PY - r1Y * PX);
      bB.m_linearVelocity.x += bB.m_invMass * PX;
      bB.m_linearVelocity.y += bB.m_invMass * PY;
      bB.m_angularVelocity += bB.m_invI * (r2X * PY - r2Y * PX);
   }
   b2DistanceJoint.prototype.SolvePositionConstraints = function (baumgarte) {
      if (baumgarte === undefined) baumgarte = 0;
      var tMat;
      if (this.m_frequencyHz > 0.0) {
         return true;
      }
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      tMat = bA.m_xf.R;
      var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
      var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
      var tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
      r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
      r1X = tX;
      tMat = bB.m_xf.R;
      var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
      var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
      tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
      r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
      r2X = tX;
      var dX = bB.m_sweep.c.x + r2X - bA.m_sweep.c.x - r1X;
      var dY = bB.m_sweep.c.y + r2Y - bA.m_sweep.c.y - r1Y;
      var length = Math.sqrt(dX * dX + dY * dY);
      dX /= length;
      dY /= length;
      var C = length - this.m_length;
      C = b2Math.Clamp(C, (-b2Settings.b2_maxLinearCorrection), b2Settings.b2_maxLinearCorrection);
      var impulse = (-this.m_mass * C);
      this.m_u.Set(dX, dY);
      var PX = impulse * this.m_u.x;
      var PY = impulse * this.m_u.y;
      bA.m_sweep.c.x -= bA.m_invMass * PX;
      bA.m_sweep.c.y -= bA.m_invMass * PY;
      bA.m_sweep.a -= bA.m_invI * (r1X * PY - r1Y * PX);
      bB.m_sweep.c.x += bB.m_invMass * PX;
      bB.m_sweep.c.y += bB.m_invMass * PY;
      bB.m_sweep.a += bB.m_invI * (r2X * PY - r2Y * PX);
      bA.SynchronizeTransform();
      bB.SynchronizeTransform();
      return b2Math.Abs(C) < b2Settings.b2_linearSlop;
   }
   Box2D.inherit(b2DistanceJointDef, Box2D.Dynamics.Joints.b2JointDef);
   b2DistanceJointDef.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype;
   b2DistanceJointDef.b2DistanceJointDef = function () {
      Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments);
      this.localAnchorA = new b2Vec2();
      this.localAnchorB = new b2Vec2();
   };
   b2DistanceJointDef.prototype.b2DistanceJointDef = function () {
      this.__super.b2JointDef.call(this);
      this.type = b2Joint.e_distanceJoint;
      this.length = 1.0;
      this.frequencyHz = 0.0;
      this.dampingRatio = 0.0;
   }
   b2DistanceJointDef.prototype.Initialize = function (bA, bB, anchorA, anchorB) {
      this.bodyA = bA;
      this.bodyB = bB;
      this.localAnchorA.SetV(this.bodyA.GetLocalPoint(anchorA));
      this.localAnchorB.SetV(this.bodyB.GetLocalPoint(anchorB));
      var dX = anchorB.x - anchorA.x;
      var dY = anchorB.y - anchorA.y;
      this.length = Math.sqrt(dX * dX + dY * dY);
      this.frequencyHz = 0.0;
      this.dampingRatio = 0.0;
   }
   Box2D.inherit(b2FrictionJoint, Box2D.Dynamics.Joints.b2Joint);
   b2FrictionJoint.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype;
   b2FrictionJoint.b2FrictionJoint = function () {
      Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments);
      this.m_localAnchorA = new b2Vec2();
      this.m_localAnchorB = new b2Vec2();
      this.m_linearMass = new b2Mat22();
      this.m_linearImpulse = new b2Vec2();
   };
   b2FrictionJoint.prototype.GetAnchorA = function () {
      return this.m_bodyA.GetWorldPoint(this.m_localAnchorA);
   }
   b2FrictionJoint.prototype.GetAnchorB = function () {
      return this.m_bodyB.GetWorldPoint(this.m_localAnchorB);
   }
   b2FrictionJoint.prototype.GetReactionForce = function (inv_dt) {
      if (inv_dt === undefined) inv_dt = 0;
      return new b2Vec2(inv_dt * this.m_linearImpulse.x, inv_dt * this.m_linearImpulse.y);
   }
   b2FrictionJoint.prototype.GetReactionTorque = function (inv_dt) {
      if (inv_dt === undefined) inv_dt = 0;
      return inv_dt * this.m_angularImpulse;
   }
   b2FrictionJoint.prototype.SetMaxForce = function (force) {
      if (force === undefined) force = 0;
      this.m_maxForce = force;
   }
   b2FrictionJoint.prototype.GetMaxForce = function () {
      return this.m_maxForce;
   }
   b2FrictionJoint.prototype.SetMaxTorque = function (torque) {
      if (torque === undefined) torque = 0;
      this.m_maxTorque = torque;
   }
   b2FrictionJoint.prototype.GetMaxTorque = function () {
      return this.m_maxTorque;
   }
   b2FrictionJoint.prototype.b2FrictionJoint = function (def) {
      this.__super.b2Joint.call(this, def);
      this.m_localAnchorA.SetV(def.localAnchorA);
      this.m_localAnchorB.SetV(def.localAnchorB);
      this.m_linearMass.SetZero();
      this.m_angularMass = 0.0;
      this.m_linearImpulse.SetZero();
      this.m_angularImpulse = 0.0;
      this.m_maxForce = def.maxForce;
      this.m_maxTorque = def.maxTorque;
   }
   b2FrictionJoint.prototype.InitVelocityConstraints = function (step) {
      var tMat;
      var tX = 0;
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      tMat = bA.m_xf.R;
      var rAX = this.m_localAnchorA.x - bA.m_sweep.localCenter.x;
      var rAY = this.m_localAnchorA.y - bA.m_sweep.localCenter.y;
      tX = (tMat.col1.x * rAX + tMat.col2.x * rAY);
      rAY = (tMat.col1.y * rAX + tMat.col2.y * rAY);
      rAX = tX;
      tMat = bB.m_xf.R;
      var rBX = this.m_localAnchorB.x - bB.m_sweep.localCenter.x;
      var rBY = this.m_localAnchorB.y - bB.m_sweep.localCenter.y;
      tX = (tMat.col1.x * rBX + tMat.col2.x * rBY);
      rBY = (tMat.col1.y * rBX + tMat.col2.y * rBY);
      rBX = tX;
      var mA = bA.m_invMass;
      var mB = bB.m_invMass;
      var iA = bA.m_invI;
      var iB = bB.m_invI;
      var K = new b2Mat22();
      K.col1.x = mA + mB;
      K.col2.x = 0.0;
      K.col1.y = 0.0;
      K.col2.y = mA + mB;
      K.col1.x += iA * rAY * rAY;
      K.col2.x += (-iA * rAX * rAY);
      K.col1.y += (-iA * rAX * rAY);
      K.col2.y += iA * rAX * rAX;
      K.col1.x += iB * rBY * rBY;
      K.col2.x += (-iB * rBX * rBY);
      K.col1.y += (-iB * rBX * rBY);
      K.col2.y += iB * rBX * rBX;
      K.GetInverse(this.m_linearMass);
      this.m_angularMass = iA + iB;
      if (this.m_angularMass > 0.0) {
         this.m_angularMass = 1.0 / this.m_angularMass;
      }
      if (step.warmStarting) {
         this.m_linearImpulse.x *= step.dtRatio;
         this.m_linearImpulse.y *= step.dtRatio;
         this.m_angularImpulse *= step.dtRatio;
         var P = this.m_linearImpulse;
         bA.m_linearVelocity.x -= mA * P.x;
         bA.m_linearVelocity.y -= mA * P.y;
         bA.m_angularVelocity -= iA * (rAX * P.y - rAY * P.x + this.m_angularImpulse);
         bB.m_linearVelocity.x += mB * P.x;
         bB.m_linearVelocity.y += mB * P.y;
         bB.m_angularVelocity += iB * (rBX * P.y - rBY * P.x + this.m_angularImpulse);
      }
      else {
         this.m_linearImpulse.SetZero();
         this.m_angularImpulse = 0.0;
      }
   }
   b2FrictionJoint.prototype.SolveVelocityConstraints = function (step) {
      var tMat;
      var tX = 0;
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var vA = bA.m_linearVelocity;
      var wA = bA.m_angularVelocity;
      var vB = bB.m_linearVelocity;
      var wB = bB.m_angularVelocity;
      var mA = bA.m_invMass;
      var mB = bB.m_invMass;
      var iA = bA.m_invI;
      var iB = bB.m_invI;
      tMat = bA.m_xf.R;
      var rAX = this.m_localAnchorA.x - bA.m_sweep.localCenter.x;
      var rAY = this.m_localAnchorA.y - bA.m_sweep.localCenter.y;
      tX = (tMat.col1.x * rAX + tMat.col2.x * rAY);
      rAY = (tMat.col1.y * rAX + tMat.col2.y * rAY);
      rAX = tX;
      tMat = bB.m_xf.R;
      var rBX = this.m_localAnchorB.x - bB.m_sweep.localCenter.x;
      var rBY = this.m_localAnchorB.y - bB.m_sweep.localCenter.y;
      tX = (tMat.col1.x * rBX + tMat.col2.x * rBY);
      rBY = (tMat.col1.y * rBX + tMat.col2.y * rBY);
      rBX = tX;
      var maxImpulse = 0; {
         var Cdot = wB - wA;
         var impulse = (-this.m_angularMass * Cdot);
         var oldImpulse = this.m_angularImpulse;
         maxImpulse = step.dt * this.m_maxTorque;
         this.m_angularImpulse = b2Math.Clamp(this.m_angularImpulse + impulse, (-maxImpulse), maxImpulse);
         impulse = this.m_angularImpulse - oldImpulse;
         wA -= iA * impulse;
         wB += iB * impulse;
      } {
         var CdotX = vB.x - wB * rBY - vA.x + wA * rAY;
         var CdotY = vB.y + wB * rBX - vA.y - wA * rAX;
         var impulseV = b2Math.MulMV(this.m_linearMass, new b2Vec2((-CdotX), (-CdotY)));
         var oldImpulseV = this.m_linearImpulse.Copy();
         this.m_linearImpulse.Add(impulseV);
         maxImpulse = step.dt * this.m_maxForce;
         if (this.m_linearImpulse.LengthSquared() > maxImpulse * maxImpulse) {
            this.m_linearImpulse.Normalize();
            this.m_linearImpulse.Multiply(maxImpulse);
         }
         impulseV = b2Math.SubtractVV(this.m_linearImpulse, oldImpulseV);
         vA.x -= mA * impulseV.x;
         vA.y -= mA * impulseV.y;
         wA -= iA * (rAX * impulseV.y - rAY * impulseV.x);
         vB.x += mB * impulseV.x;
         vB.y += mB * impulseV.y;
         wB += iB * (rBX * impulseV.y - rBY * impulseV.x);
      }
      bA.m_angularVelocity = wA;
      bB.m_angularVelocity = wB;
   }
   b2FrictionJoint.prototype.SolvePositionConstraints = function (baumgarte) {
      if (baumgarte === undefined) baumgarte = 0;
      return true;
   }
   Box2D.inherit(b2FrictionJointDef, Box2D.Dynamics.Joints.b2JointDef);
   b2FrictionJointDef.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype;
   b2FrictionJointDef.b2FrictionJointDef = function () {
      Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments);
      this.localAnchorA = new b2Vec2();
      this.localAnchorB = new b2Vec2();
   };
   b2FrictionJointDef.prototype.b2FrictionJointDef = function () {
      this.__super.b2JointDef.call(this);
      this.type = b2Joint.e_frictionJoint;
      this.maxForce = 0.0;
      this.maxTorque = 0.0;
   }
   b2FrictionJointDef.prototype.Initialize = function (bA, bB, anchor) {
      this.bodyA = bA;
      this.bodyB = bB;
      this.localAnchorA.SetV(this.bodyA.GetLocalPoint(anchor));
      this.localAnchorB.SetV(this.bodyB.GetLocalPoint(anchor));
   }
   Box2D.inherit(b2GearJoint, Box2D.Dynamics.Joints.b2Joint);
   b2GearJoint.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype;
   b2GearJoint.b2GearJoint = function () {
      Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments);
      this.m_groundAnchor1 = new b2Vec2();
      this.m_groundAnchor2 = new b2Vec2();
      this.m_localAnchor1 = new b2Vec2();
      this.m_localAnchor2 = new b2Vec2();
      this.m_J = new b2Jacobian();
   };
   b2GearJoint.prototype.GetAnchorA = function () {
      return this.m_bodyA.GetWorldPoint(this.m_localAnchor1);
   }
   b2GearJoint.prototype.GetAnchorB = function () {
      return this.m_bodyB.GetWorldPoint(this.m_localAnchor2);
   }
   b2GearJoint.prototype.GetReactionForce = function (inv_dt) {
      if (inv_dt === undefined) inv_dt = 0;
      return new b2Vec2(inv_dt * this.m_impulse * this.m_J.linearB.x, inv_dt * this.m_impulse * this.m_J.linearB.y);
   }
   b2GearJoint.prototype.GetReactionTorque = function (inv_dt) {
      if (inv_dt === undefined) inv_dt = 0;
      var tMat = this.m_bodyB.m_xf.R;
      var rX = this.m_localAnchor1.x - this.m_bodyB.m_sweep.localCenter.x;
      var rY = this.m_localAnchor1.y - this.m_bodyB.m_sweep.localCenter.y;
      var tX = tMat.col1.x * rX + tMat.col2.x * rY;
      rY = tMat.col1.y * rX + tMat.col2.y * rY;
      rX = tX;
      var PX = this.m_impulse * this.m_J.linearB.x;
      var PY = this.m_impulse * this.m_J.linearB.y;
      return inv_dt * (this.m_impulse * this.m_J.angularB - rX * PY + rY * PX);
   }
   b2GearJoint.prototype.GetRatio = function () {
      return this.m_ratio;
   }
   b2GearJoint.prototype.SetRatio = function (ratio) {
      if (ratio === undefined) ratio = 0;
      this.m_ratio = ratio;
   }
   b2GearJoint.prototype.b2GearJoint = function (def) {
      this.__super.b2Joint.call(this, def);
      var type1 = parseInt(def.joint1.m_type);
      var type2 = parseInt(def.joint2.m_type);
      this.m_revolute1 = null;
      this.m_prismatic1 = null;
      this.m_revolute2 = null;
      this.m_prismatic2 = null;
      var coordinate1 = 0;
      var coordinate2 = 0;
      this.m_ground1 = def.joint1.GetBodyA();
      this.m_bodyA = def.joint1.GetBodyB();
      if (type1 == b2Joint.e_revoluteJoint) {
         this.m_revolute1 = (def.joint1 instanceof b2RevoluteJoint ? def.joint1 : null);
         this.m_groundAnchor1.SetV(this.m_revolute1.m_localAnchor1);
         this.m_localAnchor1.SetV(this.m_revolute1.m_localAnchor2);
         coordinate1 = this.m_revolute1.GetJointAngle();
      }
      else {
         this.m_prismatic1 = (def.joint1 instanceof b2PrismaticJoint ? def.joint1 : null);
         this.m_groundAnchor1.SetV(this.m_prismatic1.m_localAnchor1);
         this.m_localAnchor1.SetV(this.m_prismatic1.m_localAnchor2);
         coordinate1 = this.m_prismatic1.GetJointTranslation();
      }
      this.m_ground2 = def.joint2.GetBodyA();
      this.m_bodyB = def.joint2.GetBodyB();
      if (type2 == b2Joint.e_revoluteJoint) {
         this.m_revolute2 = (def.joint2 instanceof b2RevoluteJoint ? def.joint2 : null);
         this.m_groundAnchor2.SetV(this.m_revolute2.m_localAnchor1);
         this.m_localAnchor2.SetV(this.m_revolute2.m_localAnchor2);
         coordinate2 = this.m_revolute2.GetJointAngle();
      }
      else {
         this.m_prismatic2 = (def.joint2 instanceof b2PrismaticJoint ? def.joint2 : null);
         this.m_groundAnchor2.SetV(this.m_prismatic2.m_localAnchor1);
         this.m_localAnchor2.SetV(this.m_prismatic2.m_localAnchor2);
         coordinate2 = this.m_prismatic2.GetJointTranslation();
      }
      this.m_ratio = def.ratio;
      this.m_constant = coordinate1 + this.m_ratio * coordinate2;
      this.m_impulse = 0.0;
   }
   b2GearJoint.prototype.InitVelocityConstraints = function (step) {
      var g1 = this.m_ground1;
      var g2 = this.m_ground2;
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var ugX = 0;
      var ugY = 0;
      var rX = 0;
      var rY = 0;
      var tMat;
      var tVec;
      var crug = 0;
      var tX = 0;
      var K = 0.0;
      this.m_J.SetZero();
      if (this.m_revolute1) {
         this.m_J.angularA = (-1.0);
         K += bA.m_invI;
      }
      else {
         tMat = g1.m_xf.R;
         tVec = this.m_prismatic1.m_localXAxis1;
         ugX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
         ugY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
         tMat = bA.m_xf.R;
         rX = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
         rY = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
         tX = tMat.col1.x * rX + tMat.col2.x * rY;
         rY = tMat.col1.y * rX + tMat.col2.y * rY;
         rX = tX;
         crug = rX * ugY - rY * ugX;
         this.m_J.linearA.Set((-ugX), (-ugY));
         this.m_J.angularA = (-crug);
         K += bA.m_invMass + bA.m_invI * crug * crug;
      }
      if (this.m_revolute2) {
         this.m_J.angularB = (-this.m_ratio);
         K += this.m_ratio * this.m_ratio * bB.m_invI;
      }
      else {
         tMat = g2.m_xf.R;
         tVec = this.m_prismatic2.m_localXAxis1;
         ugX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
         ugY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
         tMat = bB.m_xf.R;
         rX = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
         rY = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
         tX = tMat.col1.x * rX + tMat.col2.x * rY;
         rY = tMat.col1.y * rX + tMat.col2.y * rY;
         rX = tX;
         crug = rX * ugY - rY * ugX;
         this.m_J.linearB.Set((-this.m_ratio * ugX), (-this.m_ratio * ugY));
         this.m_J.angularB = (-this.m_ratio * crug);
         K += this.m_ratio * this.m_ratio * (bB.m_invMass + bB.m_invI * crug * crug);
      }
      this.m_mass = K > 0.0 ? 1.0 / K : 0.0;
      if (step.warmStarting) {
         bA.m_linearVelocity.x += bA.m_invMass * this.m_impulse * this.m_J.linearA.x;
         bA.m_linearVelocity.y += bA.m_invMass * this.m_impulse * this.m_J.linearA.y;
         bA.m_angularVelocity += bA.m_invI * this.m_impulse * this.m_J.angularA;
         bB.m_linearVelocity.x += bB.m_invMass * this.m_impulse * this.m_J.linearB.x;
         bB.m_linearVelocity.y += bB.m_invMass * this.m_impulse * this.m_J.linearB.y;
         bB.m_angularVelocity += bB.m_invI * this.m_impulse * this.m_J.angularB;
      }
      else {
         this.m_impulse = 0.0;
      }
   }
   b2GearJoint.prototype.SolveVelocityConstraints = function (step) {
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var Cdot = this.m_J.Compute(bA.m_linearVelocity, bA.m_angularVelocity, bB.m_linearVelocity, bB.m_angularVelocity);
      var impulse = (-this.m_mass * Cdot);
      this.m_impulse += impulse;
      bA.m_linearVelocity.x += bA.m_invMass * impulse * this.m_J.linearA.x;
      bA.m_linearVelocity.y += bA.m_invMass * impulse * this.m_J.linearA.y;
      bA.m_angularVelocity += bA.m_invI * impulse * this.m_J.angularA;
      bB.m_linearVelocity.x += bB.m_invMass * impulse * this.m_J.linearB.x;
      bB.m_linearVelocity.y += bB.m_invMass * impulse * this.m_J.linearB.y;
      bB.m_angularVelocity += bB.m_invI * impulse * this.m_J.angularB;
   }
   b2GearJoint.prototype.SolvePositionConstraints = function (baumgarte) {
      if (baumgarte === undefined) baumgarte = 0;
      var linearError = 0.0;
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var coordinate1 = 0;
      var coordinate2 = 0;
      if (this.m_revolute1) {
         coordinate1 = this.m_revolute1.GetJointAngle();
      }
      else {
         coordinate1 = this.m_prismatic1.GetJointTranslation();
      }
      if (this.m_revolute2) {
         coordinate2 = this.m_revolute2.GetJointAngle();
      }
      else {
         coordinate2 = this.m_prismatic2.GetJointTranslation();
      }
      var C = this.m_constant - (coordinate1 + this.m_ratio * coordinate2);
      var impulse = (-this.m_mass * C);
      bA.m_sweep.c.x += bA.m_invMass * impulse * this.m_J.linearA.x;
      bA.m_sweep.c.y += bA.m_invMass * impulse * this.m_J.linearA.y;
      bA.m_sweep.a += bA.m_invI * impulse * this.m_J.angularA;
      bB.m_sweep.c.x += bB.m_invMass * impulse * this.m_J.linearB.x;
      bB.m_sweep.c.y += bB.m_invMass * impulse * this.m_J.linearB.y;
      bB.m_sweep.a += bB.m_invI * impulse * this.m_J.angularB;
      bA.SynchronizeTransform();
      bB.SynchronizeTransform();
      return linearError < b2Settings.b2_linearSlop;
   }
   Box2D.inherit(b2GearJointDef, Box2D.Dynamics.Joints.b2JointDef);
   b2GearJointDef.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype;
   b2GearJointDef.b2GearJointDef = function () {
      Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments);
   };
   b2GearJointDef.prototype.b2GearJointDef = function () {
      this.__super.b2JointDef.call(this);
      this.type = b2Joint.e_gearJoint;
      this.joint1 = null;
      this.joint2 = null;
      this.ratio = 1.0;
   }
   b2Jacobian.b2Jacobian = function () {
      this.linearA = new b2Vec2();
      this.linearB = new b2Vec2();
   };
   b2Jacobian.prototype.SetZero = function () {
      this.linearA.SetZero();
      this.angularA = 0.0;
      this.linearB.SetZero();
      this.angularB = 0.0;
   }
   b2Jacobian.prototype.Set = function (x1, a1, x2, a2) {
      if (a1 === undefined) a1 = 0;
      if (a2 === undefined) a2 = 0;
      this.linearA.SetV(x1);
      this.angularA = a1;
      this.linearB.SetV(x2);
      this.angularB = a2;
   }
   b2Jacobian.prototype.Compute = function (x1, a1, x2, a2) {
      if (a1 === undefined) a1 = 0;
      if (a2 === undefined) a2 = 0;
      return (this.linearA.x * x1.x + this.linearA.y * x1.y) + this.angularA * a1 + (this.linearB.x * x2.x + this.linearB.y * x2.y) + this.angularB * a2;
   }
   b2Joint.b2Joint = function () {
      this.m_edgeA = new b2JointEdge();
      this.m_edgeB = new b2JointEdge();
      this.m_localCenterA = new b2Vec2();
      this.m_localCenterB = new b2Vec2();
   };
   b2Joint.prototype.GetType = function () {
      return this.m_type;
   }
   b2Joint.prototype.GetAnchorA = function () {
      return null;
   }
   b2Joint.prototype.GetAnchorB = function () {
      return null;
   }
   b2Joint.prototype.GetReactionForce = function (inv_dt) {
      if (inv_dt === undefined) inv_dt = 0;
      return null;
   }
   b2Joint.prototype.GetReactionTorque = function (inv_dt) {
      if (inv_dt === undefined) inv_dt = 0;
      return 0.0;
   }
   b2Joint.prototype.GetBodyA = function () {
      return this.m_bodyA;
   }
   b2Joint.prototype.GetBodyB = function () {
      return this.m_bodyB;
   }
   b2Joint.prototype.GetNext = function () {
      return this.m_next;
   }
   b2Joint.prototype.GetUserData = function () {
      return this.m_userData;
   }
   b2Joint.prototype.SetUserData = function (data) {
      this.m_userData = data;
   }
   b2Joint.prototype.IsActive = function () {
      return this.m_bodyA.IsActive() && this.m_bodyB.IsActive();
   }
   b2Joint.Create = function (def, allocator) {
      var joint = null;
      switch (def.type) {
      case b2Joint.e_distanceJoint:
         {
            joint = new b2DistanceJoint((def instanceof b2DistanceJointDef ? def : null));
         }
         break;
      case b2Joint.e_mouseJoint:
         {
            joint = new b2MouseJoint((def instanceof b2MouseJointDef ? def : null));
         }
         break;
      case b2Joint.e_prismaticJoint:
         {
            joint = new b2PrismaticJoint((def instanceof b2PrismaticJointDef ? def : null));
         }
         break;
      case b2Joint.e_revoluteJoint:
         {
            joint = new b2RevoluteJoint((def instanceof b2RevoluteJointDef ? def : null));
         }
         break;
      case b2Joint.e_pulleyJoint:
         {
            joint = new b2PulleyJoint((def instanceof b2PulleyJointDef ? def : null));
         }
         break;
      case b2Joint.e_gearJoint:
         {
            joint = new b2GearJoint((def instanceof b2GearJointDef ? def : null));
         }
         break;
      case b2Joint.e_lineJoint:
         {
            joint = new b2LineJoint((def instanceof b2LineJointDef ? def : null));
         }
         break;
      case b2Joint.e_weldJoint:
         {
            joint = new b2WeldJoint((def instanceof b2WeldJointDef ? def : null));
         }
         break;
      case b2Joint.e_frictionJoint:
         {
            joint = new b2FrictionJoint((def instanceof b2FrictionJointDef ? def : null));
         }
         break;
      default:
         break;
      }
      return joint;
   }
   b2Joint.Destroy = function (joint, allocator) {}
   b2Joint.prototype.b2Joint = function (def) {
      b2Settings.b2Assert(def.bodyA != def.bodyB);
      this.m_type = def.type;
      this.m_prev = null;
      this.m_next = null;
      this.m_bodyA = def.bodyA;
      this.m_bodyB = def.bodyB;
      this.m_collideConnected = def.collideConnected;
      this.m_islandFlag = false;
      this.m_userData = def.userData;
   }
   b2Joint.prototype.InitVelocityConstraints = function (step) {}
   b2Joint.prototype.SolveVelocityConstraints = function (step) {}
   b2Joint.prototype.FinalizeVelocityConstraints = function () {}
   b2Joint.prototype.SolvePositionConstraints = function (baumgarte) {
      if (baumgarte === undefined) baumgarte = 0;
      return false;
   }
   Box2D.postDefs.push(function () {
      Box2D.Dynamics.Joints.b2Joint.e_unknownJoint = 0;
      Box2D.Dynamics.Joints.b2Joint.e_revoluteJoint = 1;
      Box2D.Dynamics.Joints.b2Joint.e_prismaticJoint = 2;
      Box2D.Dynamics.Joints.b2Joint.e_distanceJoint = 3;
      Box2D.Dynamics.Joints.b2Joint.e_pulleyJoint = 4;
      Box2D.Dynamics.Joints.b2Joint.e_mouseJoint = 5;
      Box2D.Dynamics.Joints.b2Joint.e_gearJoint = 6;
      Box2D.Dynamics.Joints.b2Joint.e_lineJoint = 7;
      Box2D.Dynamics.Joints.b2Joint.e_weldJoint = 8;
      Box2D.Dynamics.Joints.b2Joint.e_frictionJoint = 9;
      Box2D.Dynamics.Joints.b2Joint.e_inactiveLimit = 0;
      Box2D.Dynamics.Joints.b2Joint.e_atLowerLimit = 1;
      Box2D.Dynamics.Joints.b2Joint.e_atUpperLimit = 2;
      Box2D.Dynamics.Joints.b2Joint.e_equalLimits = 3;
   });
   b2JointDef.b2JointDef = function () {};
   b2JointDef.prototype.b2JointDef = function () {
      this.type = b2Joint.e_unknownJoint;
      this.userData = null;
      this.bodyA = null;
      this.bodyB = null;
      this.collideConnected = false;
   }
   b2JointEdge.b2JointEdge = function () {};
   Box2D.inherit(b2LineJoint, Box2D.Dynamics.Joints.b2Joint);
   b2LineJoint.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype;
   b2LineJoint.b2LineJoint = function () {
      Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments);
      this.m_localAnchor1 = new b2Vec2();
      this.m_localAnchor2 = new b2Vec2();
      this.m_localXAxis1 = new b2Vec2();
      this.m_localYAxis1 = new b2Vec2();
      this.m_axis = new b2Vec2();
      this.m_perp = new b2Vec2();
      this.m_K = new b2Mat22();
      this.m_impulse = new b2Vec2();
   };
   b2LineJoint.prototype.GetAnchorA = function () {
      return this.m_bodyA.GetWorldPoint(this.m_localAnchor1);
   }
   b2LineJoint.prototype.GetAnchorB = function () {
      return this.m_bodyB.GetWorldPoint(this.m_localAnchor2);
   }
   b2LineJoint.prototype.GetReactionForce = function (inv_dt) {
      if (inv_dt === undefined) inv_dt = 0;
      return new b2Vec2(inv_dt * (this.m_impulse.x * this.m_perp.x + (this.m_motorImpulse + this.m_impulse.y) * this.m_axis.x), inv_dt * (this.m_impulse.x * this.m_perp.y + (this.m_motorImpulse + this.m_impulse.y) * this.m_axis.y));
   }
   b2LineJoint.prototype.GetReactionTorque = function (inv_dt) {
      if (inv_dt === undefined) inv_dt = 0;
      return inv_dt * this.m_impulse.y;
   }
   b2LineJoint.prototype.GetJointTranslation = function () {
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var tMat;
      var p1 = bA.GetWorldPoint(this.m_localAnchor1);
      var p2 = bB.GetWorldPoint(this.m_localAnchor2);
      var dX = p2.x - p1.x;
      var dY = p2.y - p1.y;
      var axis = bA.GetWorldVector(this.m_localXAxis1);
      var translation = axis.x * dX + axis.y * dY;
      return translation;
   }
   b2LineJoint.prototype.GetJointSpeed = function () {
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var tMat;
      tMat = bA.m_xf.R;
      var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
      var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
      var tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
      r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
      r1X = tX;
      tMat = bB.m_xf.R;
      var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
      var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
      tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
      r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
      r2X = tX;
      var p1X = bA.m_sweep.c.x + r1X;
      var p1Y = bA.m_sweep.c.y + r1Y;
      var p2X = bB.m_sweep.c.x + r2X;
      var p2Y = bB.m_sweep.c.y + r2Y;
      var dX = p2X - p1X;
      var dY = p2Y - p1Y;
      var axis = bA.GetWorldVector(this.m_localXAxis1);
      var v1 = bA.m_linearVelocity;
      var v2 = bB.m_linearVelocity;
      var w1 = bA.m_angularVelocity;
      var w2 = bB.m_angularVelocity;
      var speed = (dX * ((-w1 * axis.y)) + dY * (w1 * axis.x)) + (axis.x * (((v2.x + ((-w2 * r2Y))) - v1.x) - ((-w1 * r1Y))) + axis.y * (((v2.y + (w2 * r2X)) - v1.y) - (w1 * r1X)));
      return speed;
   }
   b2LineJoint.prototype.IsLimitEnabled = function () {
      return this.m_enableLimit;
   }
   b2LineJoint.prototype.EnableLimit = function (flag) {
      this.m_bodyA.SetAwake(true);
      this.m_bodyB.SetAwake(true);
      this.m_enableLimit = flag;
   }
   b2LineJoint.prototype.GetLowerLimit = function () {
      return this.m_lowerTranslation;
   }
   b2LineJoint.prototype.GetUpperLimit = function () {
      return this.m_upperTranslation;
   }
   b2LineJoint.prototype.SetLimits = function (lower, upper) {
      if (lower === undefined) lower = 0;
      if (upper === undefined) upper = 0;
      this.m_bodyA.SetAwake(true);
      this.m_bodyB.SetAwake(true);
      this.m_lowerTranslation = lower;
      this.m_upperTranslation = upper;
   }
   b2LineJoint.prototype.IsMotorEnabled = function () {
      return this.m_enableMotor;
   }
   b2LineJoint.prototype.EnableMotor = function (flag) {
      this.m_bodyA.SetAwake(true);
      this.m_bodyB.SetAwake(true);
      this.m_enableMotor = flag;
   }
   b2LineJoint.prototype.SetMotorSpeed = function (speed) {
      if (speed === undefined) speed = 0;
      this.m_bodyA.SetAwake(true);
      this.m_bodyB.SetAwake(true);
      this.m_motorSpeed = speed;
   }
   b2LineJoint.prototype.GetMotorSpeed = function () {
      return this.m_motorSpeed;
   }
   b2LineJoint.prototype.SetMaxMotorForce = function (force) {
      if (force === undefined) force = 0;
      this.m_bodyA.SetAwake(true);
      this.m_bodyB.SetAwake(true);
      this.m_maxMotorForce = force;
   }
   b2LineJoint.prototype.GetMaxMotorForce = function () {
      return this.m_maxMotorForce;
   }
   b2LineJoint.prototype.GetMotorForce = function () {
      return this.m_motorImpulse;
   }
   b2LineJoint.prototype.b2LineJoint = function (def) {
      this.__super.b2Joint.call(this, def);
      var tMat;
      var tX = 0;
      var tY = 0;
      this.m_localAnchor1.SetV(def.localAnchorA);
      this.m_localAnchor2.SetV(def.localAnchorB);
      this.m_localXAxis1.SetV(def.localAxisA);
      this.m_localYAxis1.x = (-this.m_localXAxis1.y);
      this.m_localYAxis1.y = this.m_localXAxis1.x;
      this.m_impulse.SetZero();
      this.m_motorMass = 0.0;
      this.m_motorImpulse = 0.0;
      this.m_lowerTranslation = def.lowerTranslation;
      this.m_upperTranslation = def.upperTranslation;
      this.m_maxMotorForce = def.maxMotorForce;
      this.m_motorSpeed = def.motorSpeed;
      this.m_enableLimit = def.enableLimit;
      this.m_enableMotor = def.enableMotor;
      this.m_limitState = b2Joint.e_inactiveLimit;
      this.m_axis.SetZero();
      this.m_perp.SetZero();
   }
   b2LineJoint.prototype.InitVelocityConstraints = function (step) {
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var tMat;
      var tX = 0;
      this.m_localCenterA.SetV(bA.GetLocalCenter());
      this.m_localCenterB.SetV(bB.GetLocalCenter());
      var xf1 = bA.GetTransform();
      var xf2 = bB.GetTransform();
      tMat = bA.m_xf.R;
      var r1X = this.m_localAnchor1.x - this.m_localCenterA.x;
      var r1Y = this.m_localAnchor1.y - this.m_localCenterA.y;
      tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
      r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
      r1X = tX;
      tMat = bB.m_xf.R;
      var r2X = this.m_localAnchor2.x - this.m_localCenterB.x;
      var r2Y = this.m_localAnchor2.y - this.m_localCenterB.y;
      tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
      r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
      r2X = tX;
      var dX = bB.m_sweep.c.x + r2X - bA.m_sweep.c.x - r1X;
      var dY = bB.m_sweep.c.y + r2Y - bA.m_sweep.c.y - r1Y;
      this.m_invMassA = bA.m_invMass;
      this.m_invMassB = bB.m_invMass;
      this.m_invIA = bA.m_invI;
      this.m_invIB = bB.m_invI; {
         this.m_axis.SetV(b2Math.MulMV(xf1.R, this.m_localXAxis1));
         this.m_a1 = (dX + r1X) * this.m_axis.y - (dY + r1Y) * this.m_axis.x;
         this.m_a2 = r2X * this.m_axis.y - r2Y * this.m_axis.x;
         this.m_motorMass = this.m_invMassA + this.m_invMassB + this.m_invIA * this.m_a1 * this.m_a1 + this.m_invIB * this.m_a2 * this.m_a2;
         this.m_motorMass = this.m_motorMass > Number.MIN_VALUE ? 1.0 / this.m_motorMass : 0.0;
      } {
         this.m_perp.SetV(b2Math.MulMV(xf1.R, this.m_localYAxis1));
         this.m_s1 = (dX + r1X) * this.m_perp.y - (dY + r1Y) * this.m_perp.x;
         this.m_s2 = r2X * this.m_perp.y - r2Y * this.m_perp.x;
         var m1 = this.m_invMassA;
         var m2 = this.m_invMassB;
         var i1 = this.m_invIA;
         var i2 = this.m_invIB;
         this.m_K.col1.x = m1 + m2 + i1 * this.m_s1 * this.m_s1 + i2 * this.m_s2 * this.m_s2;
         this.m_K.col1.y = i1 * this.m_s1 * this.m_a1 + i2 * this.m_s2 * this.m_a2;
         this.m_K.col2.x = this.m_K.col1.y;
         this.m_K.col2.y = m1 + m2 + i1 * this.m_a1 * this.m_a1 + i2 * this.m_a2 * this.m_a2;
      }
      if (this.m_enableLimit) {
         var jointTransition = this.m_axis.x * dX + this.m_axis.y * dY;
         if (b2Math.Abs(this.m_upperTranslation - this.m_lowerTranslation) < 2.0 * b2Settings.b2_linearSlop) {
            this.m_limitState = b2Joint.e_equalLimits;
         }
         else if (jointTransition <= this.m_lowerTranslation) {
            if (this.m_limitState != b2Joint.e_atLowerLimit) {
               this.m_limitState = b2Joint.e_atLowerLimit;
               this.m_impulse.y = 0.0;
            }
         }
         else if (jointTransition >= this.m_upperTranslation) {
            if (this.m_limitState != b2Joint.e_atUpperLimit) {
               this.m_limitState = b2Joint.e_atUpperLimit;
               this.m_impulse.y = 0.0;
            }
         }
         else {
            this.m_limitState = b2Joint.e_inactiveLimit;
            this.m_impulse.y = 0.0;
         }
      }
      else {
         this.m_limitState = b2Joint.e_inactiveLimit;
      }
      if (this.m_enableMotor == false) {
         this.m_motorImpulse = 0.0;
      }
      if (step.warmStarting) {
         this.m_impulse.x *= step.dtRatio;
         this.m_impulse.y *= step.dtRatio;
         this.m_motorImpulse *= step.dtRatio;
         var PX = this.m_impulse.x * this.m_perp.x + (this.m_motorImpulse + this.m_impulse.y) * this.m_axis.x;
         var PY = this.m_impulse.x * this.m_perp.y + (this.m_motorImpulse + this.m_impulse.y) * this.m_axis.y;
         var L1 = this.m_impulse.x * this.m_s1 + (this.m_motorImpulse + this.m_impulse.y) * this.m_a1;
         var L2 = this.m_impulse.x * this.m_s2 + (this.m_motorImpulse + this.m_impulse.y) * this.m_a2;
         bA.m_linearVelocity.x -= this.m_invMassA * PX;
         bA.m_linearVelocity.y -= this.m_invMassA * PY;
         bA.m_angularVelocity -= this.m_invIA * L1;
         bB.m_linearVelocity.x += this.m_invMassB * PX;
         bB.m_linearVelocity.y += this.m_invMassB * PY;
         bB.m_angularVelocity += this.m_invIB * L2;
      }
      else {
         this.m_impulse.SetZero();
         this.m_motorImpulse = 0.0;
      }
   }
   b2LineJoint.prototype.SolveVelocityConstraints = function (step) {
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var v1 = bA.m_linearVelocity;
      var w1 = bA.m_angularVelocity;
      var v2 = bB.m_linearVelocity;
      var w2 = bB.m_angularVelocity;
      var PX = 0;
      var PY = 0;
      var L1 = 0;
      var L2 = 0;
      if (this.m_enableMotor && this.m_limitState != b2Joint.e_equalLimits) {
         var Cdot = this.m_axis.x * (v2.x - v1.x) + this.m_axis.y * (v2.y - v1.y) + this.m_a2 * w2 - this.m_a1 * w1;
         var impulse = this.m_motorMass * (this.m_motorSpeed - Cdot);
         var oldImpulse = this.m_motorImpulse;
         var maxImpulse = step.dt * this.m_maxMotorForce;
         this.m_motorImpulse = b2Math.Clamp(this.m_motorImpulse + impulse, (-maxImpulse), maxImpulse);
         impulse = this.m_motorImpulse - oldImpulse;
         PX = impulse * this.m_axis.x;
         PY = impulse * this.m_axis.y;
         L1 = impulse * this.m_a1;
         L2 = impulse * this.m_a2;
         v1.x -= this.m_invMassA * PX;
         v1.y -= this.m_invMassA * PY;
         w1 -= this.m_invIA * L1;
         v2.x += this.m_invMassB * PX;
         v2.y += this.m_invMassB * PY;
         w2 += this.m_invIB * L2;
      }
      var Cdot1 = this.m_perp.x * (v2.x - v1.x) + this.m_perp.y * (v2.y - v1.y) + this.m_s2 * w2 - this.m_s1 * w1;
      if (this.m_enableLimit && this.m_limitState != b2Joint.e_inactiveLimit) {
         var Cdot2 = this.m_axis.x * (v2.x - v1.x) + this.m_axis.y * (v2.y - v1.y) + this.m_a2 * w2 - this.m_a1 * w1;
         var f1 = this.m_impulse.Copy();
         var df = this.m_K.Solve(new b2Vec2(), (-Cdot1), (-Cdot2));
         this.m_impulse.Add(df);
         if (this.m_limitState == b2Joint.e_atLowerLimit) {
            this.m_impulse.y = b2Math.Max(this.m_impulse.y, 0.0);
         }
         else if (this.m_limitState == b2Joint.e_atUpperLimit) {
            this.m_impulse.y = b2Math.Min(this.m_impulse.y, 0.0);
         }
         var b = (-Cdot1) - (this.m_impulse.y - f1.y) * this.m_K.col2.x;
         var f2r = 0;
         if (this.m_K.col1.x != 0.0) {
            f2r = b / this.m_K.col1.x + f1.x;
         }
         else {
            f2r = f1.x;
         }
         this.m_impulse.x = f2r;
         df.x = this.m_impulse.x - f1.x;
         df.y = this.m_impulse.y - f1.y;
         PX = df.x * this.m_perp.x + df.y * this.m_axis.x;
         PY = df.x * this.m_perp.y + df.y * this.m_axis.y;
         L1 = df.x * this.m_s1 + df.y * this.m_a1;
         L2 = df.x * this.m_s2 + df.y * this.m_a2;
         v1.x -= this.m_invMassA * PX;
         v1.y -= this.m_invMassA * PY;
         w1 -= this.m_invIA * L1;
         v2.x += this.m_invMassB * PX;
         v2.y += this.m_invMassB * PY;
         w2 += this.m_invIB * L2;
      }
      else {
         var df2 = 0;
         if (this.m_K.col1.x != 0.0) {
            df2 = ((-Cdot1)) / this.m_K.col1.x;
         }
         else {
            df2 = 0.0;
         }
         this.m_impulse.x += df2;
         PX = df2 * this.m_perp.x;
         PY = df2 * this.m_perp.y;
         L1 = df2 * this.m_s1;
         L2 = df2 * this.m_s2;
         v1.x -= this.m_invMassA * PX;
         v1.y -= this.m_invMassA * PY;
         w1 -= this.m_invIA * L1;
         v2.x += this.m_invMassB * PX;
         v2.y += this.m_invMassB * PY;
         w2 += this.m_invIB * L2;
      }
      bA.m_linearVelocity.SetV(v1);
      bA.m_angularVelocity = w1;
      bB.m_linearVelocity.SetV(v2);
      bB.m_angularVelocity = w2;
   }
   b2LineJoint.prototype.SolvePositionConstraints = function (baumgarte) {
      if (baumgarte === undefined) baumgarte = 0;
      var limitC = 0;
      var oldLimitImpulse = 0;
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var c1 = bA.m_sweep.c;
      var a1 = bA.m_sweep.a;
      var c2 = bB.m_sweep.c;
      var a2 = bB.m_sweep.a;
      var tMat;
      var tX = 0;
      var m1 = 0;
      var m2 = 0;
      var i1 = 0;
      var i2 = 0;
      var linearError = 0.0;
      var angularError = 0.0;
      var active = false;
      var C2 = 0.0;
      var R1 = b2Mat22.FromAngle(a1);
      var R2 = b2Mat22.FromAngle(a2);
      tMat = R1;
      var r1X = this.m_localAnchor1.x - this.m_localCenterA.x;
      var r1Y = this.m_localAnchor1.y - this.m_localCenterA.y;
      tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
      r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
      r1X = tX;
      tMat = R2;
      var r2X = this.m_localAnchor2.x - this.m_localCenterB.x;
      var r2Y = this.m_localAnchor2.y - this.m_localCenterB.y;
      tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
      r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
      r2X = tX;
      var dX = c2.x + r2X - c1.x - r1X;
      var dY = c2.y + r2Y - c1.y - r1Y;
      if (this.m_enableLimit) {
         this.m_axis = b2Math.MulMV(R1, this.m_localXAxis1);
         this.m_a1 = (dX + r1X) * this.m_axis.y - (dY + r1Y) * this.m_axis.x;
         this.m_a2 = r2X * this.m_axis.y - r2Y * this.m_axis.x;
         var translation = this.m_axis.x * dX + this.m_axis.y * dY;
         if (b2Math.Abs(this.m_upperTranslation - this.m_lowerTranslation) < 2.0 * b2Settings.b2_linearSlop) {
            C2 = b2Math.Clamp(translation, (-b2Settings.b2_maxLinearCorrection), b2Settings.b2_maxLinearCorrection);
            linearError = b2Math.Abs(translation);
            active = true;
         }
         else if (translation <= this.m_lowerTranslation) {
            C2 = b2Math.Clamp(translation - this.m_lowerTranslation + b2Settings.b2_linearSlop, (-b2Settings.b2_maxLinearCorrection), 0.0);
            linearError = this.m_lowerTranslation - translation;
            active = true;
         }
         else if (translation >= this.m_upperTranslation) {
            C2 = b2Math.Clamp(translation - this.m_upperTranslation + b2Settings.b2_linearSlop, 0.0, b2Settings.b2_maxLinearCorrection);
            linearError = translation - this.m_upperTranslation;
            active = true;
         }
      }
      this.m_perp = b2Math.MulMV(R1, this.m_localYAxis1);
      this.m_s1 = (dX + r1X) * this.m_perp.y - (dY + r1Y) * this.m_perp.x;
      this.m_s2 = r2X * this.m_perp.y - r2Y * this.m_perp.x;
      var impulse = new b2Vec2();
      var C1 = this.m_perp.x * dX + this.m_perp.y * dY;
      linearError = b2Math.Max(linearError, b2Math.Abs(C1));
      angularError = 0.0;
      if (active) {
         m1 = this.m_invMassA;
         m2 = this.m_invMassB;
         i1 = this.m_invIA;
         i2 = this.m_invIB;
         this.m_K.col1.x = m1 + m2 + i1 * this.m_s1 * this.m_s1 + i2 * this.m_s2 * this.m_s2;
         this.m_K.col1.y = i1 * this.m_s1 * this.m_a1 + i2 * this.m_s2 * this.m_a2;
         this.m_K.col2.x = this.m_K.col1.y;
         this.m_K.col2.y = m1 + m2 + i1 * this.m_a1 * this.m_a1 + i2 * this.m_a2 * this.m_a2;
         this.m_K.Solve(impulse, (-C1), (-C2));
      }
      else {
         m1 = this.m_invMassA;
         m2 = this.m_invMassB;
         i1 = this.m_invIA;
         i2 = this.m_invIB;
         var k11 = m1 + m2 + i1 * this.m_s1 * this.m_s1 + i2 * this.m_s2 * this.m_s2;
         var impulse1 = 0;
         if (k11 != 0.0) {
            impulse1 = ((-C1)) / k11;
         }
         else {
            impulse1 = 0.0;
         }
         impulse.x = impulse1;
         impulse.y = 0.0;
      }
      var PX = impulse.x * this.m_perp.x + impulse.y * this.m_axis.x;
      var PY = impulse.x * this.m_perp.y + impulse.y * this.m_axis.y;
      var L1 = impulse.x * this.m_s1 + impulse.y * this.m_a1;
      var L2 = impulse.x * this.m_s2 + impulse.y * this.m_a2;
      c1.x -= this.m_invMassA * PX;
      c1.y -= this.m_invMassA * PY;
      a1 -= this.m_invIA * L1;
      c2.x += this.m_invMassB * PX;
      c2.y += this.m_invMassB * PY;
      a2 += this.m_invIB * L2;
      bA.m_sweep.a = a1;
      bB.m_sweep.a = a2;
      bA.SynchronizeTransform();
      bB.SynchronizeTransform();
      return linearError <= b2Settings.b2_linearSlop && angularError <= b2Settings.b2_angularSlop;
   }
   Box2D.inherit(b2LineJointDef, Box2D.Dynamics.Joints.b2JointDef);
   b2LineJointDef.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype;
   b2LineJointDef.b2LineJointDef = function () {
      Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments);
      this.localAnchorA = new b2Vec2();
      this.localAnchorB = new b2Vec2();
      this.localAxisA = new b2Vec2();
   };
   b2LineJointDef.prototype.b2LineJointDef = function () {
      this.__super.b2JointDef.call(this);
      this.type = b2Joint.e_lineJoint;
      this.localAxisA.Set(1.0, 0.0);
      this.enableLimit = false;
      this.lowerTranslation = 0.0;
      this.upperTranslation = 0.0;
      this.enableMotor = false;
      this.maxMotorForce = 0.0;
      this.motorSpeed = 0.0;
   }
   b2LineJointDef.prototype.Initialize = function (bA, bB, anchor, axis) {
      this.bodyA = bA;
      this.bodyB = bB;
      this.localAnchorA = this.bodyA.GetLocalPoint(anchor);
      this.localAnchorB = this.bodyB.GetLocalPoint(anchor);
      this.localAxisA = this.bodyA.GetLocalVector(axis);
   }
   Box2D.inherit(b2MouseJoint, Box2D.Dynamics.Joints.b2Joint);
   b2MouseJoint.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype;
   b2MouseJoint.b2MouseJoint = function () {
      Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments);
      this.K = new b2Mat22();
      this.K1 = new b2Mat22();
      this.K2 = new b2Mat22();
      this.m_localAnchor = new b2Vec2();
      this.m_target = new b2Vec2();
      this.m_impulse = new b2Vec2();
      this.m_mass = new b2Mat22();
      this.m_C = new b2Vec2();
   };
   b2MouseJoint.prototype.GetAnchorA = function () {
      return this.m_target;
   }
   b2MouseJoint.prototype.GetAnchorB = function () {
      return this.m_bodyB.GetWorldPoint(this.m_localAnchor);
   }
   b2MouseJoint.prototype.GetReactionForce = function (inv_dt) {
      if (inv_dt === undefined) inv_dt = 0;
      return new b2Vec2(inv_dt * this.m_impulse.x, inv_dt * this.m_impulse.y);
   }
   b2MouseJoint.prototype.GetReactionTorque = function (inv_dt) {
      if (inv_dt === undefined) inv_dt = 0;
      return 0.0;
   }
   b2MouseJoint.prototype.GetTarget = function () {
      return this.m_target;
   }
   b2MouseJoint.prototype.SetTarget = function (target) {
      if (this.m_bodyB.IsAwake() == false) {
         this.m_bodyB.SetAwake(true);
      }
      this.m_target = target;
   }
   b2MouseJoint.prototype.GetMaxForce = function () {
      return this.m_maxForce;
   }
   b2MouseJoint.prototype.SetMaxForce = function (maxForce) {
      if (maxForce === undefined) maxForce = 0;
      this.m_maxForce = maxForce;
   }
   b2MouseJoint.prototype.GetFrequency = function () {
      return this.m_frequencyHz;
   }
   b2MouseJoint.prototype.SetFrequency = function (hz) {
      if (hz === undefined) hz = 0;
      this.m_frequencyHz = hz;
   }
   b2MouseJoint.prototype.GetDampingRatio = function () {
      return this.m_dampingRatio;
   }
   b2MouseJoint.prototype.SetDampingRatio = function (ratio) {
      if (ratio === undefined) ratio = 0;
      this.m_dampingRatio = ratio;
   }
   b2MouseJoint.prototype.b2MouseJoint = function (def) {
      this.__super.b2Joint.call(this, def);
      this.m_target.SetV(def.target);
      var tX = this.m_target.x - this.m_bodyB.m_xf.position.x;
      var tY = this.m_target.y - this.m_bodyB.m_xf.position.y;
      var tMat = this.m_bodyB.m_xf.R;
      this.m_localAnchor.x = (tX * tMat.col1.x + tY * tMat.col1.y);
      this.m_localAnchor.y = (tX * tMat.col2.x + tY * tMat.col2.y);
      this.m_maxForce = def.maxForce;
      this.m_impulse.SetZero();
      this.m_frequencyHz = def.frequencyHz;
      this.m_dampingRatio = def.dampingRatio;
      this.m_beta = 0.0;
      this.m_gamma = 0.0;
   }
   b2MouseJoint.prototype.InitVelocityConstraints = function (step) {
      var b = this.m_bodyB;
      var mass = b.GetMass();
      var omega = 2.0 * Math.PI * this.m_frequencyHz;
      var d = 2.0 * mass * this.m_dampingRatio * omega;
      var k = mass * omega * omega;
      this.m_gamma = step.dt * (d + step.dt * k);
      this.m_gamma = this.m_gamma != 0 ? 1 / this.m_gamma : 0.0;
      this.m_beta = step.dt * k * this.m_gamma;
      var tMat;tMat = b.m_xf.R;
      var rX = this.m_localAnchor.x - b.m_sweep.localCenter.x;
      var rY = this.m_localAnchor.y - b.m_sweep.localCenter.y;
      var tX = (tMat.col1.x * rX + tMat.col2.x * rY);rY = (tMat.col1.y * rX + tMat.col2.y * rY);
      rX = tX;
      var invMass = b.m_invMass;
      var invI = b.m_invI;this.K1.col1.x = invMass;
      this.K1.col2.x = 0.0;
      this.K1.col1.y = 0.0;
      this.K1.col2.y = invMass;
      this.K2.col1.x = invI * rY * rY;
      this.K2.col2.x = (-invI * rX * rY);
      this.K2.col1.y = (-invI * rX * rY);
      this.K2.col2.y = invI * rX * rX;
      this.K.SetM(this.K1);
      this.K.AddM(this.K2);
      this.K.col1.x += this.m_gamma;
      this.K.col2.y += this.m_gamma;
      this.K.GetInverse(this.m_mass);
      this.m_C.x = b.m_sweep.c.x + rX - this.m_target.x;
      this.m_C.y = b.m_sweep.c.y + rY - this.m_target.y;
      b.m_angularVelocity *= 0.98;
      this.m_impulse.x *= step.dtRatio;
      this.m_impulse.y *= step.dtRatio;
      b.m_linearVelocity.x += invMass * this.m_impulse.x;
      b.m_linearVelocity.y += invMass * this.m_impulse.y;
      b.m_angularVelocity += invI * (rX * this.m_impulse.y - rY * this.m_impulse.x);
   }
   b2MouseJoint.prototype.SolveVelocityConstraints = function (step) {
      var b = this.m_bodyB;
      var tMat;
      var tX = 0;
      var tY = 0;
      tMat = b.m_xf.R;
      var rX = this.m_localAnchor.x - b.m_sweep.localCenter.x;
      var rY = this.m_localAnchor.y - b.m_sweep.localCenter.y;
      tX = (tMat.col1.x * rX + tMat.col2.x * rY);
      rY = (tMat.col1.y * rX + tMat.col2.y * rY);
      rX = tX;
      var CdotX = b.m_linearVelocity.x + ((-b.m_angularVelocity * rY));
      var CdotY = b.m_linearVelocity.y + (b.m_angularVelocity * rX);
      tMat = this.m_mass;
      tX = CdotX + this.m_beta * this.m_C.x + this.m_gamma * this.m_impulse.x;
      tY = CdotY + this.m_beta * this.m_C.y + this.m_gamma * this.m_impulse.y;
      var impulseX = (-(tMat.col1.x * tX + tMat.col2.x * tY));
      var impulseY = (-(tMat.col1.y * tX + tMat.col2.y * tY));
      var oldImpulseX = this.m_impulse.x;
      var oldImpulseY = this.m_impulse.y;
      this.m_impulse.x += impulseX;
      this.m_impulse.y += impulseY;
      var maxImpulse = step.dt * this.m_maxForce;
      if (this.m_impulse.LengthSquared() > maxImpulse * maxImpulse) {
         this.m_impulse.Multiply(maxImpulse / this.m_impulse.Length());
      }
      impulseX = this.m_impulse.x - oldImpulseX;
      impulseY = this.m_impulse.y - oldImpulseY;
      b.m_linearVelocity.x += b.m_invMass * impulseX;
      b.m_linearVelocity.y += b.m_invMass * impulseY;
      b.m_angularVelocity += b.m_invI * (rX * impulseY - rY * impulseX);
   }
   b2MouseJoint.prototype.SolvePositionConstraints = function (baumgarte) {
      if (baumgarte === undefined) baumgarte = 0;
      return true;
   }
   Box2D.inherit(b2MouseJointDef, Box2D.Dynamics.Joints.b2JointDef);
   b2MouseJointDef.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype;
   b2MouseJointDef.b2MouseJointDef = function () {
      Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments);
      this.target = new b2Vec2();
   };
   b2MouseJointDef.prototype.b2MouseJointDef = function () {
      this.__super.b2JointDef.call(this);
      this.type = b2Joint.e_mouseJoint;
      this.maxForce = 0.0;
      this.frequencyHz = 5.0;
      this.dampingRatio = 0.7;
   }
   Box2D.inherit(b2PrismaticJoint, Box2D.Dynamics.Joints.b2Joint);
   b2PrismaticJoint.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype;
   b2PrismaticJoint.b2PrismaticJoint = function () {
      Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments);
      this.m_localAnchor1 = new b2Vec2();
      this.m_localAnchor2 = new b2Vec2();
      this.m_localXAxis1 = new b2Vec2();
      this.m_localYAxis1 = new b2Vec2();
      this.m_axis = new b2Vec2();
      this.m_perp = new b2Vec2();
      this.m_K = new b2Mat33();
      this.m_impulse = new b2Vec3();
   };
   b2PrismaticJoint.prototype.GetAnchorA = function () {
      return this.m_bodyA.GetWorldPoint(this.m_localAnchor1);
   }
   b2PrismaticJoint.prototype.GetAnchorB = function () {
      return this.m_bodyB.GetWorldPoint(this.m_localAnchor2);
   }
   b2PrismaticJoint.prototype.GetReactionForce = function (inv_dt) {
      if (inv_dt === undefined) inv_dt = 0;
      return new b2Vec2(inv_dt * (this.m_impulse.x * this.m_perp.x + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.x), inv_dt * (this.m_impulse.x * this.m_perp.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.y));
   }
   b2PrismaticJoint.prototype.GetReactionTorque = function (inv_dt) {
      if (inv_dt === undefined) inv_dt = 0;
      return inv_dt * this.m_impulse.y;
   }
   b2PrismaticJoint.prototype.GetJointTranslation = function () {
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var tMat;
      var p1 = bA.GetWorldPoint(this.m_localAnchor1);
      var p2 = bB.GetWorldPoint(this.m_localAnchor2);
      var dX = p2.x - p1.x;
      var dY = p2.y - p1.y;
      var axis = bA.GetWorldVector(this.m_localXAxis1);
      var translation = axis.x * dX + axis.y * dY;
      return translation;
   }
   b2PrismaticJoint.prototype.GetJointSpeed = function () {
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var tMat;
      tMat = bA.m_xf.R;
      var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
      var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
      var tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
      r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
      r1X = tX;
      tMat = bB.m_xf.R;
      var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
      var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
      tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
      r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
      r2X = tX;
      var p1X = bA.m_sweep.c.x + r1X;
      var p1Y = bA.m_sweep.c.y + r1Y;
      var p2X = bB.m_sweep.c.x + r2X;
      var p2Y = bB.m_sweep.c.y + r2Y;
      var dX = p2X - p1X;
      var dY = p2Y - p1Y;
      var axis = bA.GetWorldVector(this.m_localXAxis1);
      var v1 = bA.m_linearVelocity;
      var v2 = bB.m_linearVelocity;
      var w1 = bA.m_angularVelocity;
      var w2 = bB.m_angularVelocity;
      var speed = (dX * ((-w1 * axis.y)) + dY * (w1 * axis.x)) + (axis.x * (((v2.x + ((-w2 * r2Y))) - v1.x) - ((-w1 * r1Y))) + axis.y * (((v2.y + (w2 * r2X)) - v1.y) - (w1 * r1X)));
      return speed;
   }
   b2PrismaticJoint.prototype.IsLimitEnabled = function () {
      return this.m_enableLimit;
   }
   b2PrismaticJoint.prototype.EnableLimit = function (flag) {
      this.m_bodyA.SetAwake(true);
      this.m_bodyB.SetAwake(true);
      this.m_enableLimit = flag;
   }
   b2PrismaticJoint.prototype.GetLowerLimit = function () {
      return this.m_lowerTranslation;
   }
   b2PrismaticJoint.prototype.GetUpperLimit = function () {
      return this.m_upperTranslation;
   }
   b2PrismaticJoint.prototype.SetLimits = function (lower, upper) {
      if (lower === undefined) lower = 0;
      if (upper === undefined) upper = 0;
      this.m_bodyA.SetAwake(true);
      this.m_bodyB.SetAwake(true);
      this.m_lowerTranslation = lower;
      this.m_upperTranslation = upper;
   }
   b2PrismaticJoint.prototype.IsMotorEnabled = function () {
      return this.m_enableMotor;
   }
   b2PrismaticJoint.prototype.EnableMotor = function (flag) {
      this.m_bodyA.SetAwake(true);
      this.m_bodyB.SetAwake(true);
      this.m_enableMotor = flag;
   }
   b2PrismaticJoint.prototype.SetMotorSpeed = function (speed) {
      if (speed === undefined) speed = 0;
      this.m_bodyA.SetAwake(true);
      this.m_bodyB.SetAwake(true);
      this.m_motorSpeed = speed;
   }
   b2PrismaticJoint.prototype.GetMotorSpeed = function () {
      return this.m_motorSpeed;
   }
   b2PrismaticJoint.prototype.SetMaxMotorForce = function (force) {
      if (force === undefined) force = 0;
      this.m_bodyA.SetAwake(true);
      this.m_bodyB.SetAwake(true);
      this.m_maxMotorForce = force;
   }
   b2PrismaticJoint.prototype.GetMotorForce = function () {
      return this.m_motorImpulse;
   }
   b2PrismaticJoint.prototype.b2PrismaticJoint = function (def) {
      this.__super.b2Joint.call(this, def);
      var tMat;
      var tX = 0;
      var tY = 0;
      this.m_localAnchor1.SetV(def.localAnchorA);
      this.m_localAnchor2.SetV(def.localAnchorB);
      this.m_localXAxis1.SetV(def.localAxisA);
      this.m_localYAxis1.x = (-this.m_localXAxis1.y);
      this.m_localYAxis1.y = this.m_localXAxis1.x;
      this.m_refAngle = def.referenceAngle;
      this.m_impulse.SetZero();
      this.m_motorMass = 0.0;
      this.m_motorImpulse = 0.0;
      this.m_lowerTranslation = def.lowerTranslation;
      this.m_upperTranslation = def.upperTranslation;
      this.m_maxMotorForce = def.maxMotorForce;
      this.m_motorSpeed = def.motorSpeed;
      this.m_enableLimit = def.enableLimit;
      this.m_enableMotor = def.enableMotor;
      this.m_limitState = b2Joint.e_inactiveLimit;
      this.m_axis.SetZero();
      this.m_perp.SetZero();
   }
   b2PrismaticJoint.prototype.InitVelocityConstraints = function (step) {
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var tMat;
      var tX = 0;
      this.m_localCenterA.SetV(bA.GetLocalCenter());
      this.m_localCenterB.SetV(bB.GetLocalCenter());
      var xf1 = bA.GetTransform();
      var xf2 = bB.GetTransform();
      tMat = bA.m_xf.R;
      var r1X = this.m_localAnchor1.x - this.m_localCenterA.x;
      var r1Y = this.m_localAnchor1.y - this.m_localCenterA.y;
      tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
      r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
      r1X = tX;
      tMat = bB.m_xf.R;
      var r2X = this.m_localAnchor2.x - this.m_localCenterB.x;
      var r2Y = this.m_localAnchor2.y - this.m_localCenterB.y;
      tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
      r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
      r2X = tX;
      var dX = bB.m_sweep.c.x + r2X - bA.m_sweep.c.x - r1X;
      var dY = bB.m_sweep.c.y + r2Y - bA.m_sweep.c.y - r1Y;
      this.m_invMassA = bA.m_invMass;
      this.m_invMassB = bB.m_invMass;
      this.m_invIA = bA.m_invI;
      this.m_invIB = bB.m_invI; {
         this.m_axis.SetV(b2Math.MulMV(xf1.R, this.m_localXAxis1));
         this.m_a1 = (dX + r1X) * this.m_axis.y - (dY + r1Y) * this.m_axis.x;
         this.m_a2 = r2X * this.m_axis.y - r2Y * this.m_axis.x;
         this.m_motorMass = this.m_invMassA + this.m_invMassB + this.m_invIA * this.m_a1 * this.m_a1 + this.m_invIB * this.m_a2 * this.m_a2;
         if (this.m_motorMass > Number.MIN_VALUE) this.m_motorMass = 1.0 / this.m_motorMass;
      } {
         this.m_perp.SetV(b2Math.MulMV(xf1.R, this.m_localYAxis1));
         this.m_s1 = (dX + r1X) * this.m_perp.y - (dY + r1Y) * this.m_perp.x;
         this.m_s2 = r2X * this.m_perp.y - r2Y * this.m_perp.x;
         var m1 = this.m_invMassA;
         var m2 = this.m_invMassB;
         var i1 = this.m_invIA;
         var i2 = this.m_invIB;
         this.m_K.col1.x = m1 + m2 + i1 * this.m_s1 * this.m_s1 + i2 * this.m_s2 * this.m_s2;
         this.m_K.col1.y = i1 * this.m_s1 + i2 * this.m_s2;
         this.m_K.col1.z = i1 * this.m_s1 * this.m_a1 + i2 * this.m_s2 * this.m_a2;
         this.m_K.col2.x = this.m_K.col1.y;
         this.m_K.col2.y = i1 + i2;
         this.m_K.col2.z = i1 * this.m_a1 + i2 * this.m_a2;
         this.m_K.col3.x = this.m_K.col1.z;
         this.m_K.col3.y = this.m_K.col2.z;
         this.m_K.col3.z = m1 + m2 + i1 * this.m_a1 * this.m_a1 + i2 * this.m_a2 * this.m_a2;
      }
      if (this.m_enableLimit) {
         var jointTransition = this.m_axis.x * dX + this.m_axis.y * dY;
         if (b2Math.Abs(this.m_upperTranslation - this.m_lowerTranslation) < 2.0 * b2Settings.b2_linearSlop) {
            this.m_limitState = b2Joint.e_equalLimits;
         }
         else if (jointTransition <= this.m_lowerTranslation) {
            if (this.m_limitState != b2Joint.e_atLowerLimit) {
               this.m_limitState = b2Joint.e_atLowerLimit;
               this.m_impulse.z = 0.0;
            }
         }
         else if (jointTransition >= this.m_upperTranslation) {
            if (this.m_limitState != b2Joint.e_atUpperLimit) {
               this.m_limitState = b2Joint.e_atUpperLimit;
               this.m_impulse.z = 0.0;
            }
         }
         else {
            this.m_limitState = b2Joint.e_inactiveLimit;
            this.m_impulse.z = 0.0;
         }
      }
      else {
         this.m_limitState = b2Joint.e_inactiveLimit;
      }
      if (this.m_enableMotor == false) {
         this.m_motorImpulse = 0.0;
      }
      if (step.warmStarting) {
         this.m_impulse.x *= step.dtRatio;
         this.m_impulse.y *= step.dtRatio;
         this.m_motorImpulse *= step.dtRatio;
         var PX = this.m_impulse.x * this.m_perp.x + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.x;
         var PY = this.m_impulse.x * this.m_perp.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.y;
         var L1 = this.m_impulse.x * this.m_s1 + this.m_impulse.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_a1;
         var L2 = this.m_impulse.x * this.m_s2 + this.m_impulse.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_a2;
         bA.m_linearVelocity.x -= this.m_invMassA * PX;
         bA.m_linearVelocity.y -= this.m_invMassA * PY;
         bA.m_angularVelocity -= this.m_invIA * L1;
         bB.m_linearVelocity.x += this.m_invMassB * PX;
         bB.m_linearVelocity.y += this.m_invMassB * PY;
         bB.m_angularVelocity += this.m_invIB * L2;
      }
      else {
         this.m_impulse.SetZero();
         this.m_motorImpulse = 0.0;
      }
   }
   b2PrismaticJoint.prototype.SolveVelocityConstraints = function (step) {
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var v1 = bA.m_linearVelocity;
      var w1 = bA.m_angularVelocity;
      var v2 = bB.m_linearVelocity;
      var w2 = bB.m_angularVelocity;
      var PX = 0;
      var PY = 0;
      var L1 = 0;
      var L2 = 0;
      if (this.m_enableMotor && this.m_limitState != b2Joint.e_equalLimits) {
         var Cdot = this.m_axis.x * (v2.x - v1.x) + this.m_axis.y * (v2.y - v1.y) + this.m_a2 * w2 - this.m_a1 * w1;
         var impulse = this.m_motorMass * (this.m_motorSpeed - Cdot);
         var oldImpulse = this.m_motorImpulse;
         var maxImpulse = step.dt * this.m_maxMotorForce;
         this.m_motorImpulse = b2Math.Clamp(this.m_motorImpulse + impulse, (-maxImpulse), maxImpulse);
         impulse = this.m_motorImpulse - oldImpulse;
         PX = impulse * this.m_axis.x;
         PY = impulse * this.m_axis.y;
         L1 = impulse * this.m_a1;
         L2 = impulse * this.m_a2;
         v1.x -= this.m_invMassA * PX;
         v1.y -= this.m_invMassA * PY;
         w1 -= this.m_invIA * L1;
         v2.x += this.m_invMassB * PX;
         v2.y += this.m_invMassB * PY;
         w2 += this.m_invIB * L2;
      }
      var Cdot1X = this.m_perp.x * (v2.x - v1.x) + this.m_perp.y * (v2.y - v1.y) + this.m_s2 * w2 - this.m_s1 * w1;
      var Cdot1Y = w2 - w1;
      if (this.m_enableLimit && this.m_limitState != b2Joint.e_inactiveLimit) {
         var Cdot2 = this.m_axis.x * (v2.x - v1.x) + this.m_axis.y * (v2.y - v1.y) + this.m_a2 * w2 - this.m_a1 * w1;
         var f1 = this.m_impulse.Copy();
         var df = this.m_K.Solve33(new b2Vec3(), (-Cdot1X), (-Cdot1Y), (-Cdot2));
         this.m_impulse.Add(df);
         if (this.m_limitState == b2Joint.e_atLowerLimit) {
            this.m_impulse.z = b2Math.Max(this.m_impulse.z, 0.0);
         }
         else if (this.m_limitState == b2Joint.e_atUpperLimit) {
            this.m_impulse.z = b2Math.Min(this.m_impulse.z, 0.0);
         }
         var bX = (-Cdot1X) - (this.m_impulse.z - f1.z) * this.m_K.col3.x;
         var bY = (-Cdot1Y) - (this.m_impulse.z - f1.z) * this.m_K.col3.y;
         var f2r = this.m_K.Solve22(new b2Vec2(), bX, bY);
         f2r.x += f1.x;
         f2r.y += f1.y;
         this.m_impulse.x = f2r.x;
         this.m_impulse.y = f2r.y;
         df.x = this.m_impulse.x - f1.x;
         df.y = this.m_impulse.y - f1.y;
         df.z = this.m_impulse.z - f1.z;
         PX = df.x * this.m_perp.x + df.z * this.m_axis.x;
         PY = df.x * this.m_perp.y + df.z * this.m_axis.y;
         L1 = df.x * this.m_s1 + df.y + df.z * this.m_a1;
         L2 = df.x * this.m_s2 + df.y + df.z * this.m_a2;
         v1.x -= this.m_invMassA * PX;
         v1.y -= this.m_invMassA * PY;
         w1 -= this.m_invIA * L1;
         v2.x += this.m_invMassB * PX;
         v2.y += this.m_invMassB * PY;
         w2 += this.m_invIB * L2;
      }
      else {
         var df2 = this.m_K.Solve22(new b2Vec2(), (-Cdot1X), (-Cdot1Y));
         this.m_impulse.x += df2.x;
         this.m_impulse.y += df2.y;
         PX = df2.x * this.m_perp.x;
         PY = df2.x * this.m_perp.y;
         L1 = df2.x * this.m_s1 + df2.y;
         L2 = df2.x * this.m_s2 + df2.y;
         v1.x -= this.m_invMassA * PX;
         v1.y -= this.m_invMassA * PY;
         w1 -= this.m_invIA * L1;
         v2.x += this.m_invMassB * PX;
         v2.y += this.m_invMassB * PY;
         w2 += this.m_invIB * L2;
      }
      bA.m_linearVelocity.SetV(v1);
      bA.m_angularVelocity = w1;
      bB.m_linearVelocity.SetV(v2);
      bB.m_angularVelocity = w2;
   }
   b2PrismaticJoint.prototype.SolvePositionConstraints = function (baumgarte) {
      if (baumgarte === undefined) baumgarte = 0;
      var limitC = 0;
      var oldLimitImpulse = 0;
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var c1 = bA.m_sweep.c;
      var a1 = bA.m_sweep.a;
      var c2 = bB.m_sweep.c;
      var a2 = bB.m_sweep.a;
      var tMat;
      var tX = 0;
      var m1 = 0;
      var m2 = 0;
      var i1 = 0;
      var i2 = 0;
      var linearError = 0.0;
      var angularError = 0.0;
      var active = false;
      var C2 = 0.0;
      var R1 = b2Mat22.FromAngle(a1);
      var R2 = b2Mat22.FromAngle(a2);
      tMat = R1;
      var r1X = this.m_localAnchor1.x - this.m_localCenterA.x;
      var r1Y = this.m_localAnchor1.y - this.m_localCenterA.y;
      tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
      r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
      r1X = tX;
      tMat = R2;
      var r2X = this.m_localAnchor2.x - this.m_localCenterB.x;
      var r2Y = this.m_localAnchor2.y - this.m_localCenterB.y;
      tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
      r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
      r2X = tX;
      var dX = c2.x + r2X - c1.x - r1X;
      var dY = c2.y + r2Y - c1.y - r1Y;
      if (this.m_enableLimit) {
         this.m_axis = b2Math.MulMV(R1, this.m_localXAxis1);
         this.m_a1 = (dX + r1X) * this.m_axis.y - (dY + r1Y) * this.m_axis.x;
         this.m_a2 = r2X * this.m_axis.y - r2Y * this.m_axis.x;
         var translation = this.m_axis.x * dX + this.m_axis.y * dY;
         if (b2Math.Abs(this.m_upperTranslation - this.m_lowerTranslation) < 2.0 * b2Settings.b2_linearSlop) {
            C2 = b2Math.Clamp(translation, (-b2Settings.b2_maxLinearCorrection), b2Settings.b2_maxLinearCorrection);
            linearError = b2Math.Abs(translation);
            active = true;
         }
         else if (translation <= this.m_lowerTranslation) {
            C2 = b2Math.Clamp(translation - this.m_lowerTranslation + b2Settings.b2_linearSlop, (-b2Settings.b2_maxLinearCorrection), 0.0);
            linearError = this.m_lowerTranslation - translation;
            active = true;
         }
         else if (translation >= this.m_upperTranslation) {
            C2 = b2Math.Clamp(translation - this.m_upperTranslation + b2Settings.b2_linearSlop, 0.0, b2Settings.b2_maxLinearCorrection);
            linearError = translation - this.m_upperTranslation;
            active = true;
         }
      }
      this.m_perp = b2Math.MulMV(R1, this.m_localYAxis1);
      this.m_s1 = (dX + r1X) * this.m_perp.y - (dY + r1Y) * this.m_perp.x;
      this.m_s2 = r2X * this.m_perp.y - r2Y * this.m_perp.x;
      var impulse = new b2Vec3();
      var C1X = this.m_perp.x * dX + this.m_perp.y * dY;
      var C1Y = a2 - a1 - this.m_refAngle;
      linearError = b2Math.Max(linearError, b2Math.Abs(C1X));
      angularError = b2Math.Abs(C1Y);
      if (active) {
         m1 = this.m_invMassA;
         m2 = this.m_invMassB;
         i1 = this.m_invIA;
         i2 = this.m_invIB;
         this.m_K.col1.x = m1 + m2 + i1 * this.m_s1 * this.m_s1 + i2 * this.m_s2 * this.m_s2;
         this.m_K.col1.y = i1 * this.m_s1 + i2 * this.m_s2;
         this.m_K.col1.z = i1 * this.m_s1 * this.m_a1 + i2 * this.m_s2 * this.m_a2;
         this.m_K.col2.x = this.m_K.col1.y;
         this.m_K.col2.y = i1 + i2;
         this.m_K.col2.z = i1 * this.m_a1 + i2 * this.m_a2;
         this.m_K.col3.x = this.m_K.col1.z;
         this.m_K.col3.y = this.m_K.col2.z;
         this.m_K.col3.z = m1 + m2 + i1 * this.m_a1 * this.m_a1 + i2 * this.m_a2 * this.m_a2;
         this.m_K.Solve33(impulse, (-C1X), (-C1Y), (-C2));
      }
      else {
         m1 = this.m_invMassA;
         m2 = this.m_invMassB;
         i1 = this.m_invIA;
         i2 = this.m_invIB;
         var k11 = m1 + m2 + i1 * this.m_s1 * this.m_s1 + i2 * this.m_s2 * this.m_s2;
         var k12 = i1 * this.m_s1 + i2 * this.m_s2;
         var k22 = i1 + i2;
         this.m_K.col1.Set(k11, k12, 0.0);
         this.m_K.col2.Set(k12, k22, 0.0);
         var impulse1 = this.m_K.Solve22(new b2Vec2(), (-C1X), (-C1Y));
         impulse.x = impulse1.x;
         impulse.y = impulse1.y;
         impulse.z = 0.0;
      }
      var PX = impulse.x * this.m_perp.x + impulse.z * this.m_axis.x;
      var PY = impulse.x * this.m_perp.y + impulse.z * this.m_axis.y;
      var L1 = impulse.x * this.m_s1 + impulse.y + impulse.z * this.m_a1;
      var L2 = impulse.x * this.m_s2 + impulse.y + impulse.z * this.m_a2;
      c1.x -= this.m_invMassA * PX;
      c1.y -= this.m_invMassA * PY;
      a1 -= this.m_invIA * L1;
      c2.x += this.m_invMassB * PX;
      c2.y += this.m_invMassB * PY;
      a2 += this.m_invIB * L2;
      bA.m_sweep.a = a1;
      bB.m_sweep.a = a2;
      bA.SynchronizeTransform();
      bB.SynchronizeTransform();
      return linearError <= b2Settings.b2_linearSlop && angularError <= b2Settings.b2_angularSlop;
   }
   Box2D.inherit(b2PrismaticJointDef, Box2D.Dynamics.Joints.b2JointDef);
   b2PrismaticJointDef.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype;
   b2PrismaticJointDef.b2PrismaticJointDef = function () {
      Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments);
      this.localAnchorA = new b2Vec2();
      this.localAnchorB = new b2Vec2();
      this.localAxisA = new b2Vec2();
   };
   b2PrismaticJointDef.prototype.b2PrismaticJointDef = function () {
      this.__super.b2JointDef.call(this);
      this.type = b2Joint.e_prismaticJoint;
      this.localAxisA.Set(1.0, 0.0);
      this.referenceAngle = 0.0;
      this.enableLimit = false;
      this.lowerTranslation = 0.0;
      this.upperTranslation = 0.0;
      this.enableMotor = false;
      this.maxMotorForce = 0.0;
      this.motorSpeed = 0.0;
   }
   b2PrismaticJointDef.prototype.Initialize = function (bA, bB, anchor, axis) {
      this.bodyA = bA;
      this.bodyB = bB;
      this.localAnchorA = this.bodyA.GetLocalPoint(anchor);
      this.localAnchorB = this.bodyB.GetLocalPoint(anchor);
      this.localAxisA = this.bodyA.GetLocalVector(axis);
      this.referenceAngle = this.bodyB.GetAngle() - this.bodyA.GetAngle();
   }
   Box2D.inherit(b2PulleyJoint, Box2D.Dynamics.Joints.b2Joint);
   b2PulleyJoint.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype;
   b2PulleyJoint.b2PulleyJoint = function () {
      Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments);
      this.m_groundAnchor1 = new b2Vec2();
      this.m_groundAnchor2 = new b2Vec2();
      this.m_localAnchor1 = new b2Vec2();
      this.m_localAnchor2 = new b2Vec2();
      this.m_u1 = new b2Vec2();
      this.m_u2 = new b2Vec2();
   };
   b2PulleyJoint.prototype.GetAnchorA = function () {
      return this.m_bodyA.GetWorldPoint(this.m_localAnchor1);
   }
   b2PulleyJoint.prototype.GetAnchorB = function () {
      return this.m_bodyB.GetWorldPoint(this.m_localAnchor2);
   }
   b2PulleyJoint.prototype.GetReactionForce = function (inv_dt) {
      if (inv_dt === undefined) inv_dt = 0;
      return new b2Vec2(inv_dt * this.m_impulse * this.m_u2.x, inv_dt * this.m_impulse * this.m_u2.y);
   }
   b2PulleyJoint.prototype.GetReactionTorque = function (inv_dt) {
      if (inv_dt === undefined) inv_dt = 0;
      return 0.0;
   }
   b2PulleyJoint.prototype.GetGroundAnchorA = function () {
      var a = this.m_ground.m_xf.position.Copy();
      a.Add(this.m_groundAnchor1);
      return a;
   }
   b2PulleyJoint.prototype.GetGroundAnchorB = function () {
      var a = this.m_ground.m_xf.position.Copy();
      a.Add(this.m_groundAnchor2);
      return a;
   }
   b2PulleyJoint.prototype.GetLength1 = function () {
      var p = this.m_bodyA.GetWorldPoint(this.m_localAnchor1);
      var sX = this.m_ground.m_xf.position.x + this.m_groundAnchor1.x;
      var sY = this.m_ground.m_xf.position.y + this.m_groundAnchor1.y;
      var dX = p.x - sX;
      var dY = p.y - sY;
      return Math.sqrt(dX * dX + dY * dY);
   }
   b2PulleyJoint.prototype.GetLength2 = function () {
      var p = this.m_bodyB.GetWorldPoint(this.m_localAnchor2);
      var sX = this.m_ground.m_xf.position.x + this.m_groundAnchor2.x;
      var sY = this.m_ground.m_xf.position.y + this.m_groundAnchor2.y;
      var dX = p.x - sX;
      var dY = p.y - sY;
      return Math.sqrt(dX * dX + dY * dY);
   }
   b2PulleyJoint.prototype.GetRatio = function () {
      return this.m_ratio;
   }
   b2PulleyJoint.prototype.b2PulleyJoint = function (def) {
      this.__super.b2Joint.call(this, def);
      var tMat;
      var tX = 0;
      var tY = 0;
      this.m_ground = this.m_bodyA.m_world.m_groundBody;
      this.m_groundAnchor1.x = def.groundAnchorA.x - this.m_ground.m_xf.position.x;
      this.m_groundAnchor1.y = def.groundAnchorA.y - this.m_ground.m_xf.position.y;
      this.m_groundAnchor2.x = def.groundAnchorB.x - this.m_ground.m_xf.position.x;
      this.m_groundAnchor2.y = def.groundAnchorB.y - this.m_ground.m_xf.position.y;
      this.m_localAnchor1.SetV(def.localAnchorA);
      this.m_localAnchor2.SetV(def.localAnchorB);
      this.m_ratio = def.ratio;
      this.m_constant = def.lengthA + this.m_ratio * def.lengthB;
      this.m_maxLength1 = b2Math.Min(def.maxLengthA, this.m_constant - this.m_ratio * b2PulleyJoint.b2_minPulleyLength);
      this.m_maxLength2 = b2Math.Min(def.maxLengthB, (this.m_constant - b2PulleyJoint.b2_minPulleyLength) / this.m_ratio);
      this.m_impulse = 0.0;
      this.m_limitImpulse1 = 0.0;
      this.m_limitImpulse2 = 0.0;
   }
   b2PulleyJoint.prototype.InitVelocityConstraints = function (step) {
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var tMat;
      tMat = bA.m_xf.R;
      var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
      var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
      var tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
      r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
      r1X = tX;
      tMat = bB.m_xf.R;
      var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
      var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
      tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
      r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
      r2X = tX;
      var p1X = bA.m_sweep.c.x + r1X;
      var p1Y = bA.m_sweep.c.y + r1Y;
      var p2X = bB.m_sweep.c.x + r2X;
      var p2Y = bB.m_sweep.c.y + r2Y;
      var s1X = this.m_ground.m_xf.position.x + this.m_groundAnchor1.x;
      var s1Y = this.m_ground.m_xf.position.y + this.m_groundAnchor1.y;
      var s2X = this.m_ground.m_xf.position.x + this.m_groundAnchor2.x;
      var s2Y = this.m_ground.m_xf.position.y + this.m_groundAnchor2.y;
      this.m_u1.Set(p1X - s1X, p1Y - s1Y);
      this.m_u2.Set(p2X - s2X, p2Y - s2Y);
      var length1 = this.m_u1.Length();
      var length2 = this.m_u2.Length();
      if (length1 > b2Settings.b2_linearSlop) {
         this.m_u1.Multiply(1.0 / length1);
      }
      else {
         this.m_u1.SetZero();
      }
      if (length2 > b2Settings.b2_linearSlop) {
         this.m_u2.Multiply(1.0 / length2);
      }
      else {
         this.m_u2.SetZero();
      }
      var C = this.m_constant - length1 - this.m_ratio * length2;
      if (C > 0.0) {
         this.m_state = b2Joint.e_inactiveLimit;
         this.m_impulse = 0.0;
      }
      else {
         this.m_state = b2Joint.e_atUpperLimit;
      }
      if (length1 < this.m_maxLength1) {
         this.m_limitState1 = b2Joint.e_inactiveLimit;
         this.m_limitImpulse1 = 0.0;
      }
      else {
         this.m_limitState1 = b2Joint.e_atUpperLimit;
      }
      if (length2 < this.m_maxLength2) {
         this.m_limitState2 = b2Joint.e_inactiveLimit;
         this.m_limitImpulse2 = 0.0;
      }
      else {
         this.m_limitState2 = b2Joint.e_atUpperLimit;
      }
      var cr1u1 = r1X * this.m_u1.y - r1Y * this.m_u1.x;
      var cr2u2 = r2X * this.m_u2.y - r2Y * this.m_u2.x;
      this.m_limitMass1 = bA.m_invMass + bA.m_invI * cr1u1 * cr1u1;
      this.m_limitMass2 = bB.m_invMass + bB.m_invI * cr2u2 * cr2u2;
      this.m_pulleyMass = this.m_limitMass1 + this.m_ratio * this.m_ratio * this.m_limitMass2;
      this.m_limitMass1 = 1.0 / this.m_limitMass1;
      this.m_limitMass2 = 1.0 / this.m_limitMass2;
      this.m_pulleyMass = 1.0 / this.m_pulleyMass;
      if (step.warmStarting) {
         this.m_impulse *= step.dtRatio;
         this.m_limitImpulse1 *= step.dtRatio;
         this.m_limitImpulse2 *= step.dtRatio;
         var P1X = ((-this.m_impulse) - this.m_limitImpulse1) * this.m_u1.x;
         var P1Y = ((-this.m_impulse) - this.m_limitImpulse1) * this.m_u1.y;
         var P2X = ((-this.m_ratio * this.m_impulse) - this.m_limitImpulse2) * this.m_u2.x;
         var P2Y = ((-this.m_ratio * this.m_impulse) - this.m_limitImpulse2) * this.m_u2.y;
         bA.m_linearVelocity.x += bA.m_invMass * P1X;
         bA.m_linearVelocity.y += bA.m_invMass * P1Y;
         bA.m_angularVelocity += bA.m_invI * (r1X * P1Y - r1Y * P1X);
         bB.m_linearVelocity.x += bB.m_invMass * P2X;
         bB.m_linearVelocity.y += bB.m_invMass * P2Y;
         bB.m_angularVelocity += bB.m_invI * (r2X * P2Y - r2Y * P2X);
      }
      else {
         this.m_impulse = 0.0;
         this.m_limitImpulse1 = 0.0;
         this.m_limitImpulse2 = 0.0;
      }
   }
   b2PulleyJoint.prototype.SolveVelocityConstraints = function (step) {
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var tMat;
      tMat = bA.m_xf.R;
      var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
      var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
      var tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
      r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
      r1X = tX;
      tMat = bB.m_xf.R;
      var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
      var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
      tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
      r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
      r2X = tX;
      var v1X = 0;
      var v1Y = 0;
      var v2X = 0;
      var v2Y = 0;
      var P1X = 0;
      var P1Y = 0;
      var P2X = 0;
      var P2Y = 0;
      var Cdot = 0;
      var impulse = 0;
      var oldImpulse = 0;
      if (this.m_state == b2Joint.e_atUpperLimit) {
         v1X = bA.m_linearVelocity.x + ((-bA.m_angularVelocity * r1Y));
         v1Y = bA.m_linearVelocity.y + (bA.m_angularVelocity * r1X);
         v2X = bB.m_linearVelocity.x + ((-bB.m_angularVelocity * r2Y));
         v2Y = bB.m_linearVelocity.y + (bB.m_angularVelocity * r2X);
         Cdot = (-(this.m_u1.x * v1X + this.m_u1.y * v1Y)) - this.m_ratio * (this.m_u2.x * v2X + this.m_u2.y * v2Y);
         impulse = this.m_pulleyMass * ((-Cdot));
         oldImpulse = this.m_impulse;
         this.m_impulse = b2Math.Max(0.0, this.m_impulse + impulse);
         impulse = this.m_impulse - oldImpulse;
         P1X = (-impulse * this.m_u1.x);
         P1Y = (-impulse * this.m_u1.y);
         P2X = (-this.m_ratio * impulse * this.m_u2.x);
         P2Y = (-this.m_ratio * impulse * this.m_u2.y);
         bA.m_linearVelocity.x += bA.m_invMass * P1X;
         bA.m_linearVelocity.y += bA.m_invMass * P1Y;
         bA.m_angularVelocity += bA.m_invI * (r1X * P1Y - r1Y * P1X);
         bB.m_linearVelocity.x += bB.m_invMass * P2X;
         bB.m_linearVelocity.y += bB.m_invMass * P2Y;
         bB.m_angularVelocity += bB.m_invI * (r2X * P2Y - r2Y * P2X);
      }
      if (this.m_limitState1 == b2Joint.e_atUpperLimit) {
         v1X = bA.m_linearVelocity.x + ((-bA.m_angularVelocity * r1Y));
         v1Y = bA.m_linearVelocity.y + (bA.m_angularVelocity * r1X);
         Cdot = (-(this.m_u1.x * v1X + this.m_u1.y * v1Y));
         impulse = (-this.m_limitMass1 * Cdot);
         oldImpulse = this.m_limitImpulse1;
         this.m_limitImpulse1 = b2Math.Max(0.0, this.m_limitImpulse1 + impulse);
         impulse = this.m_limitImpulse1 - oldImpulse;
         P1X = (-impulse * this.m_u1.x);
         P1Y = (-impulse * this.m_u1.y);
         bA.m_linearVelocity.x += bA.m_invMass * P1X;
         bA.m_linearVelocity.y += bA.m_invMass * P1Y;
         bA.m_angularVelocity += bA.m_invI * (r1X * P1Y - r1Y * P1X);
      }
      if (this.m_limitState2 == b2Joint.e_atUpperLimit) {
         v2X = bB.m_linearVelocity.x + ((-bB.m_angularVelocity * r2Y));
         v2Y = bB.m_linearVelocity.y + (bB.m_angularVelocity * r2X);
         Cdot = (-(this.m_u2.x * v2X + this.m_u2.y * v2Y));
         impulse = (-this.m_limitMass2 * Cdot);
         oldImpulse = this.m_limitImpulse2;
         this.m_limitImpulse2 = b2Math.Max(0.0, this.m_limitImpulse2 + impulse);
         impulse = this.m_limitImpulse2 - oldImpulse;
         P2X = (-impulse * this.m_u2.x);
         P2Y = (-impulse * this.m_u2.y);
         bB.m_linearVelocity.x += bB.m_invMass * P2X;
         bB.m_linearVelocity.y += bB.m_invMass * P2Y;
         bB.m_angularVelocity += bB.m_invI * (r2X * P2Y - r2Y * P2X);
      }
   }
   b2PulleyJoint.prototype.SolvePositionConstraints = function (baumgarte) {
      if (baumgarte === undefined) baumgarte = 0;
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var tMat;
      var s1X = this.m_ground.m_xf.position.x + this.m_groundAnchor1.x;
      var s1Y = this.m_ground.m_xf.position.y + this.m_groundAnchor1.y;
      var s2X = this.m_ground.m_xf.position.x + this.m_groundAnchor2.x;
      var s2Y = this.m_ground.m_xf.position.y + this.m_groundAnchor2.y;
      var r1X = 0;
      var r1Y = 0;
      var r2X = 0;
      var r2Y = 0;
      var p1X = 0;
      var p1Y = 0;
      var p2X = 0;
      var p2Y = 0;
      var length1 = 0;
      var length2 = 0;
      var C = 0;
      var impulse = 0;
      var oldImpulse = 0;
      var oldLimitPositionImpulse = 0;
      var tX = 0;
      var linearError = 0.0;
      if (this.m_state == b2Joint.e_atUpperLimit) {
         tMat = bA.m_xf.R;
         r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
         r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
         tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
         r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
         r1X = tX;
         tMat = bB.m_xf.R;
         r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
         r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
         tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
         r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
         r2X = tX;
         p1X = bA.m_sweep.c.x + r1X;
         p1Y = bA.m_sweep.c.y + r1Y;
         p2X = bB.m_sweep.c.x + r2X;
         p2Y = bB.m_sweep.c.y + r2Y;
         this.m_u1.Set(p1X - s1X, p1Y - s1Y);
         this.m_u2.Set(p2X - s2X, p2Y - s2Y);
         length1 = this.m_u1.Length();
         length2 = this.m_u2.Length();
         if (length1 > b2Settings.b2_linearSlop) {
            this.m_u1.Multiply(1.0 / length1);
         }
         else {
            this.m_u1.SetZero();
         }
         if (length2 > b2Settings.b2_linearSlop) {
            this.m_u2.Multiply(1.0 / length2);
         }
         else {
            this.m_u2.SetZero();
         }
         C = this.m_constant - length1 - this.m_ratio * length2;
         linearError = b2Math.Max(linearError, (-C));
         C = b2Math.Clamp(C + b2Settings.b2_linearSlop, (-b2Settings.b2_maxLinearCorrection), 0.0);
         impulse = (-this.m_pulleyMass * C);
         p1X = (-impulse * this.m_u1.x);
         p1Y = (-impulse * this.m_u1.y);
         p2X = (-this.m_ratio * impulse * this.m_u2.x);
         p2Y = (-this.m_ratio * impulse * this.m_u2.y);
         bA.m_sweep.c.x += bA.m_invMass * p1X;
         bA.m_sweep.c.y += bA.m_invMass * p1Y;
         bA.m_sweep.a += bA.m_invI * (r1X * p1Y - r1Y * p1X);
         bB.m_sweep.c.x += bB.m_invMass * p2X;
         bB.m_sweep.c.y += bB.m_invMass * p2Y;
         bB.m_sweep.a += bB.m_invI * (r2X * p2Y - r2Y * p2X);
         bA.SynchronizeTransform();
         bB.SynchronizeTransform();
      }
      if (this.m_limitState1 == b2Joint.e_atUpperLimit) {
         tMat = bA.m_xf.R;
         r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
         r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
         tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
         r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
         r1X = tX;
         p1X = bA.m_sweep.c.x + r1X;
         p1Y = bA.m_sweep.c.y + r1Y;
         this.m_u1.Set(p1X - s1X, p1Y - s1Y);
         length1 = this.m_u1.Length();
         if (length1 > b2Settings.b2_linearSlop) {
            this.m_u1.x *= 1.0 / length1;
            this.m_u1.y *= 1.0 / length1;
         }
         else {
            this.m_u1.SetZero();
         }
         C = this.m_maxLength1 - length1;
         linearError = b2Math.Max(linearError, (-C));
         C = b2Math.Clamp(C + b2Settings.b2_linearSlop, (-b2Settings.b2_maxLinearCorrection), 0.0);
         impulse = (-this.m_limitMass1 * C);
         p1X = (-impulse * this.m_u1.x);
         p1Y = (-impulse * this.m_u1.y);
         bA.m_sweep.c.x += bA.m_invMass * p1X;
         bA.m_sweep.c.y += bA.m_invMass * p1Y;
         bA.m_sweep.a += bA.m_invI * (r1X * p1Y - r1Y * p1X);
         bA.SynchronizeTransform();
      }
      if (this.m_limitState2 == b2Joint.e_atUpperLimit) {
         tMat = bB.m_xf.R;
         r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
         r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
         tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
         r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
         r2X = tX;
         p2X = bB.m_sweep.c.x + r2X;
         p2Y = bB.m_sweep.c.y + r2Y;
         this.m_u2.Set(p2X - s2X, p2Y - s2Y);
         length2 = this.m_u2.Length();
         if (length2 > b2Settings.b2_linearSlop) {
            this.m_u2.x *= 1.0 / length2;
            this.m_u2.y *= 1.0 / length2;
         }
         else {
            this.m_u2.SetZero();
         }
         C = this.m_maxLength2 - length2;
         linearError = b2Math.Max(linearError, (-C));
         C = b2Math.Clamp(C + b2Settings.b2_linearSlop, (-b2Settings.b2_maxLinearCorrection), 0.0);
         impulse = (-this.m_limitMass2 * C);
         p2X = (-impulse * this.m_u2.x);
         p2Y = (-impulse * this.m_u2.y);
         bB.m_sweep.c.x += bB.m_invMass * p2X;
         bB.m_sweep.c.y += bB.m_invMass * p2Y;
         bB.m_sweep.a += bB.m_invI * (r2X * p2Y - r2Y * p2X);
         bB.SynchronizeTransform();
      }
      return linearError < b2Settings.b2_linearSlop;
   }
   Box2D.postDefs.push(function () {
      Box2D.Dynamics.Joints.b2PulleyJoint.b2_minPulleyLength = 2.0;
   });
   Box2D.inherit(b2PulleyJointDef, Box2D.Dynamics.Joints.b2JointDef);
   b2PulleyJointDef.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype;
   b2PulleyJointDef.b2PulleyJointDef = function () {
      Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments);
      this.groundAnchorA = new b2Vec2();
      this.groundAnchorB = new b2Vec2();
      this.localAnchorA = new b2Vec2();
      this.localAnchorB = new b2Vec2();
   };
   b2PulleyJointDef.prototype.b2PulleyJointDef = function () {
      this.__super.b2JointDef.call(this);
      this.type = b2Joint.e_pulleyJoint;
      this.groundAnchorA.Set((-1.0), 1.0);
      this.groundAnchorB.Set(1.0, 1.0);
      this.localAnchorA.Set((-1.0), 0.0);
      this.localAnchorB.Set(1.0, 0.0);
      this.lengthA = 0.0;
      this.maxLengthA = 0.0;
      this.lengthB = 0.0;
      this.maxLengthB = 0.0;
      this.ratio = 1.0;
      this.collideConnected = true;
   }
   b2PulleyJointDef.prototype.Initialize = function (bA, bB, gaA, gaB, anchorA, anchorB, r) {
      if (r === undefined) r = 0;
      this.bodyA = bA;
      this.bodyB = bB;
      this.groundAnchorA.SetV(gaA);
      this.groundAnchorB.SetV(gaB);
      this.localAnchorA = this.bodyA.GetLocalPoint(anchorA);
      this.localAnchorB = this.bodyB.GetLocalPoint(anchorB);
      var d1X = anchorA.x - gaA.x;
      var d1Y = anchorA.y - gaA.y;
      this.lengthA = Math.sqrt(d1X * d1X + d1Y * d1Y);
      var d2X = anchorB.x - gaB.x;
      var d2Y = anchorB.y - gaB.y;
      this.lengthB = Math.sqrt(d2X * d2X + d2Y * d2Y);
      this.ratio = r;
      var C = this.lengthA + this.ratio * this.lengthB;
      this.maxLengthA = C - this.ratio * b2PulleyJoint.b2_minPulleyLength;
      this.maxLengthB = (C - b2PulleyJoint.b2_minPulleyLength) / this.ratio;
   }
   Box2D.inherit(b2RevoluteJoint, Box2D.Dynamics.Joints.b2Joint);
   b2RevoluteJoint.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype;
   b2RevoluteJoint.b2RevoluteJoint = function () {
      Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments);
      this.K = new b2Mat22();
      this.K1 = new b2Mat22();
      this.K2 = new b2Mat22();
      this.K3 = new b2Mat22();
      this.impulse3 = new b2Vec3();
      this.impulse2 = new b2Vec2();
      this.reduced = new b2Vec2();
      this.m_localAnchor1 = new b2Vec2();
      this.m_localAnchor2 = new b2Vec2();
      this.m_impulse = new b2Vec3();
      this.m_mass = new b2Mat33();
   };
   b2RevoluteJoint.prototype.GetAnchorA = function () {
      return this.m_bodyA.GetWorldPoint(this.m_localAnchor1);
   }
   b2RevoluteJoint.prototype.GetAnchorB = function () {
      return this.m_bodyB.GetWorldPoint(this.m_localAnchor2);
   }
   b2RevoluteJoint.prototype.GetReactionForce = function (inv_dt) {
      if (inv_dt === undefined) inv_dt = 0;
      return new b2Vec2(inv_dt * this.m_impulse.x, inv_dt * this.m_impulse.y);
   }
   b2RevoluteJoint.prototype.GetReactionTorque = function (inv_dt) {
      if (inv_dt === undefined) inv_dt = 0;
      return inv_dt * this.m_impulse.z;
   }
   b2RevoluteJoint.prototype.GetJointAngle = function () {
      return this.m_bodyB.m_sweep.a - this.m_bodyA.m_sweep.a - this.m_referenceAngle;
   }
   b2RevoluteJoint.prototype.GetJointSpeed = function () {
      return this.m_bodyB.m_angularVelocity - this.m_bodyA.m_angularVelocity;
   }
   b2RevoluteJoint.prototype.IsLimitEnabled = function () {
      return this.m_enableLimit;
   }
   b2RevoluteJoint.prototype.EnableLimit = function (flag) {
      this.m_enableLimit = flag;
   }
   b2RevoluteJoint.prototype.GetLowerLimit = function () {
      return this.m_lowerAngle;
   }
   b2RevoluteJoint.prototype.GetUpperLimit = function () {
      return this.m_upperAngle;
   }
   b2RevoluteJoint.prototype.SetLimits = function (lower, upper) {
      if (lower === undefined) lower = 0;
      if (upper === undefined) upper = 0;
      this.m_lowerAngle = lower;
      this.m_upperAngle = upper;
   }
   b2RevoluteJoint.prototype.IsMotorEnabled = function () {
      this.m_bodyA.SetAwake(true);
      this.m_bodyB.SetAwake(true);
      return this.m_enableMotor;
   }
   b2RevoluteJoint.prototype.EnableMotor = function (flag) {
      this.m_enableMotor = flag;
   }
   b2RevoluteJoint.prototype.SetMotorSpeed = function (speed) {
      if (speed === undefined) speed = 0;
      this.m_bodyA.SetAwake(true);
      this.m_bodyB.SetAwake(true);
      this.m_motorSpeed = speed;
   }
   b2RevoluteJoint.prototype.GetMotorSpeed = function () {
      return this.m_motorSpeed;
   }
   b2RevoluteJoint.prototype.SetMaxMotorTorque = function (torque) {
      if (torque === undefined) torque = 0;
      this.m_maxMotorTorque = torque;
   }
   b2RevoluteJoint.prototype.GetMotorTorque = function () {
      return this.m_maxMotorTorque;
   }
   b2RevoluteJoint.prototype.b2RevoluteJoint = function (def) {
      this.__super.b2Joint.call(this, def);
      this.m_localAnchor1.SetV(def.localAnchorA);
      this.m_localAnchor2.SetV(def.localAnchorB);
      this.m_referenceAngle = def.referenceAngle;
      this.m_impulse.SetZero();
      this.m_motorImpulse = 0.0;
      this.m_lowerAngle = def.lowerAngle;
      this.m_upperAngle = def.upperAngle;
      this.m_maxMotorTorque = def.maxMotorTorque;
      this.m_motorSpeed = def.motorSpeed;
      this.m_enableLimit = def.enableLimit;
      this.m_enableMotor = def.enableMotor;
      this.m_limitState = b2Joint.e_inactiveLimit;
   }
   b2RevoluteJoint.prototype.InitVelocityConstraints = function (step) {
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var tMat;
      var tX = 0;
      if (this.m_enableMotor || this.m_enableLimit) {}
      tMat = bA.m_xf.R;
      var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
      var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
      tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
      r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
      r1X = tX;
      tMat = bB.m_xf.R;
      var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
      var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
      tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
      r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
      r2X = tX;
      var m1 = bA.m_invMass;
      var m2 = bB.m_invMass;
      var i1 = bA.m_invI;
      var i2 = bB.m_invI;
      this.m_mass.col1.x = m1 + m2 + r1Y * r1Y * i1 + r2Y * r2Y * i2;
      this.m_mass.col2.x = (-r1Y * r1X * i1) - r2Y * r2X * i2;
      this.m_mass.col3.x = (-r1Y * i1) - r2Y * i2;
      this.m_mass.col1.y = this.m_mass.col2.x;
      this.m_mass.col2.y = m1 + m2 + r1X * r1X * i1 + r2X * r2X * i2;
      this.m_mass.col3.y = r1X * i1 + r2X * i2;
      this.m_mass.col1.z = this.m_mass.col3.x;
      this.m_mass.col2.z = this.m_mass.col3.y;
      this.m_mass.col3.z = i1 + i2;
      this.m_motorMass = 1.0 / (i1 + i2);
      if (this.m_enableMotor == false) {
         this.m_motorImpulse = 0.0;
      }
      if (this.m_enableLimit) {
         var jointAngle = bB.m_sweep.a - bA.m_sweep.a - this.m_referenceAngle;
         if (b2Math.Abs(this.m_upperAngle - this.m_lowerAngle) < 2.0 * b2Settings.b2_angularSlop) {
            this.m_limitState = b2Joint.e_equalLimits;
         }
         else if (jointAngle <= this.m_lowerAngle) {
            if (this.m_limitState != b2Joint.e_atLowerLimit) {
               this.m_impulse.z = 0.0;
            }
            this.m_limitState = b2Joint.e_atLowerLimit;
         }
         else if (jointAngle >= this.m_upperAngle) {
            if (this.m_limitState != b2Joint.e_atUpperLimit) {
               this.m_impulse.z = 0.0;
            }
            this.m_limitState = b2Joint.e_atUpperLimit;
         }
         else {
            this.m_limitState = b2Joint.e_inactiveLimit;
            this.m_impulse.z = 0.0;
         }
      }
      else {
         this.m_limitState = b2Joint.e_inactiveLimit;
      }
      if (step.warmStarting) {
         this.m_impulse.x *= step.dtRatio;
         this.m_impulse.y *= step.dtRatio;
         this.m_motorImpulse *= step.dtRatio;
         var PX = this.m_impulse.x;
         var PY = this.m_impulse.y;
         bA.m_linearVelocity.x -= m1 * PX;
         bA.m_linearVelocity.y -= m1 * PY;
         bA.m_angularVelocity -= i1 * ((r1X * PY - r1Y * PX) + this.m_motorImpulse + this.m_impulse.z);
         bB.m_linearVelocity.x += m2 * PX;
         bB.m_linearVelocity.y += m2 * PY;
         bB.m_angularVelocity += i2 * ((r2X * PY - r2Y * PX) + this.m_motorImpulse + this.m_impulse.z);
      }
      else {
         this.m_impulse.SetZero();
         this.m_motorImpulse = 0.0;
      }
   }
   b2RevoluteJoint.prototype.SolveVelocityConstraints = function (step) {
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var tMat;
      var tX = 0;
      var newImpulse = 0;
      var r1X = 0;
      var r1Y = 0;
      var r2X = 0;
      var r2Y = 0;
      var v1 = bA.m_linearVelocity;
      var w1 = bA.m_angularVelocity;
      var v2 = bB.m_linearVelocity;
      var w2 = bB.m_angularVelocity;
      var m1 = bA.m_invMass;
      var m2 = bB.m_invMass;
      var i1 = bA.m_invI;
      var i2 = bB.m_invI;
      if (this.m_enableMotor && this.m_limitState != b2Joint.e_equalLimits) {
         var Cdot = w2 - w1 - this.m_motorSpeed;
         var impulse = this.m_motorMass * ((-Cdot));
         var oldImpulse = this.m_motorImpulse;
         var maxImpulse = step.dt * this.m_maxMotorTorque;
         this.m_motorImpulse = b2Math.Clamp(this.m_motorImpulse + impulse, (-maxImpulse), maxImpulse);
         impulse = this.m_motorImpulse - oldImpulse;
         w1 -= i1 * impulse;
         w2 += i2 * impulse;
      }
      if (this.m_enableLimit && this.m_limitState != b2Joint.e_inactiveLimit) {
         tMat = bA.m_xf.R;
         r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
         r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
         tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
         r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
         r1X = tX;
         tMat = bB.m_xf.R;
         r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
         r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
         tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
         r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
         r2X = tX;
         var Cdot1X = v2.x + ((-w2 * r2Y)) - v1.x - ((-w1 * r1Y));
         var Cdot1Y = v2.y + (w2 * r2X) - v1.y - (w1 * r1X);
         var Cdot2 = w2 - w1;
         this.m_mass.Solve33(this.impulse3, (-Cdot1X), (-Cdot1Y), (-Cdot2));
         if (this.m_limitState == b2Joint.e_equalLimits) {
            this.m_impulse.Add(this.impulse3);
         }
         else if (this.m_limitState == b2Joint.e_atLowerLimit) {
            newImpulse = this.m_impulse.z + this.impulse3.z;
            if (newImpulse < 0.0) {
               this.m_mass.Solve22(this.reduced, (-Cdot1X), (-Cdot1Y));
               this.impulse3.x = this.reduced.x;
               this.impulse3.y = this.reduced.y;
               this.impulse3.z = (-this.m_impulse.z);
               this.m_impulse.x += this.reduced.x;
               this.m_impulse.y += this.reduced.y;
               this.m_impulse.z = 0.0;
            }
         }
         else if (this.m_limitState == b2Joint.e_atUpperLimit) {
            newImpulse = this.m_impulse.z + this.impulse3.z;
            if (newImpulse > 0.0) {
               this.m_mass.Solve22(this.reduced, (-Cdot1X), (-Cdot1Y));
               this.impulse3.x = this.reduced.x;
               this.impulse3.y = this.reduced.y;
               this.impulse3.z = (-this.m_impulse.z);
               this.m_impulse.x += this.reduced.x;
               this.m_impulse.y += this.reduced.y;
               this.m_impulse.z = 0.0;
            }
         }
         v1.x -= m1 * this.impulse3.x;
         v1.y -= m1 * this.impulse3.y;
         w1 -= i1 * (r1X * this.impulse3.y - r1Y * this.impulse3.x + this.impulse3.z);
         v2.x += m2 * this.impulse3.x;
         v2.y += m2 * this.impulse3.y;
         w2 += i2 * (r2X * this.impulse3.y - r2Y * this.impulse3.x + this.impulse3.z);
      }
      else {
         tMat = bA.m_xf.R;
         r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
         r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
         tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
         r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
         r1X = tX;
         tMat = bB.m_xf.R;
         r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
         r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
         tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
         r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
         r2X = tX;
         var CdotX = v2.x + ((-w2 * r2Y)) - v1.x - ((-w1 * r1Y));
         var CdotY = v2.y + (w2 * r2X) - v1.y - (w1 * r1X);
         this.m_mass.Solve22(this.impulse2, (-CdotX), (-CdotY));
         this.m_impulse.x += this.impulse2.x;
         this.m_impulse.y += this.impulse2.y;
         v1.x -= m1 * this.impulse2.x;
         v1.y -= m1 * this.impulse2.y;
         w1 -= i1 * (r1X * this.impulse2.y - r1Y * this.impulse2.x);
         v2.x += m2 * this.impulse2.x;
         v2.y += m2 * this.impulse2.y;
         w2 += i2 * (r2X * this.impulse2.y - r2Y * this.impulse2.x);
      }
      bA.m_linearVelocity.SetV(v1);
      bA.m_angularVelocity = w1;
      bB.m_linearVelocity.SetV(v2);
      bB.m_angularVelocity = w2;
   }
   b2RevoluteJoint.prototype.SolvePositionConstraints = function (baumgarte) {
      if (baumgarte === undefined) baumgarte = 0;
      var oldLimitImpulse = 0;
      var C = 0;
      var tMat;
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var angularError = 0.0;
      var positionError = 0.0;
      var tX = 0;
      var impulseX = 0;
      var impulseY = 0;
      if (this.m_enableLimit && this.m_limitState != b2Joint.e_inactiveLimit) {
         var angle = bB.m_sweep.a - bA.m_sweep.a - this.m_referenceAngle;
         var limitImpulse = 0.0;
         if (this.m_limitState == b2Joint.e_equalLimits) {
            C = b2Math.Clamp(angle - this.m_lowerAngle, (-b2Settings.b2_maxAngularCorrection), b2Settings.b2_maxAngularCorrection);
            limitImpulse = (-this.m_motorMass * C);
            angularError = b2Math.Abs(C);
         }
         else if (this.m_limitState == b2Joint.e_atLowerLimit) {
            C = angle - this.m_lowerAngle;
            angularError = (-C);
            C = b2Math.Clamp(C + b2Settings.b2_angularSlop, (-b2Settings.b2_maxAngularCorrection), 0.0);
            limitImpulse = (-this.m_motorMass * C);
         }
         else if (this.m_limitState == b2Joint.e_atUpperLimit) {
            C = angle - this.m_upperAngle;
            angularError = C;
            C = b2Math.Clamp(C - b2Settings.b2_angularSlop, 0.0, b2Settings.b2_maxAngularCorrection);
            limitImpulse = (-this.m_motorMass * C);
         }
         bA.m_sweep.a -= bA.m_invI * limitImpulse;
         bB.m_sweep.a += bB.m_invI * limitImpulse;
         bA.SynchronizeTransform();
         bB.SynchronizeTransform();
      } {
         tMat = bA.m_xf.R;
         var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
         var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
         tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);
         r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);
         r1X = tX;
         tMat = bB.m_xf.R;
         var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
         var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
         tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);
         r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);
         r2X = tX;
         var CX = bB.m_sweep.c.x + r2X - bA.m_sweep.c.x - r1X;
         var CY = bB.m_sweep.c.y + r2Y - bA.m_sweep.c.y - r1Y;
         var CLengthSquared = CX * CX + CY * CY;
         var CLength = Math.sqrt(CLengthSquared);
         positionError = CLength;
         var invMass1 = bA.m_invMass;
         var invMass2 = bB.m_invMass;
         var invI1 = bA.m_invI;
         var invI2 = bB.m_invI;
         var k_allowedStretch = 10.0 * b2Settings.b2_linearSlop;
         if (CLengthSquared > k_allowedStretch * k_allowedStretch) {
            var uX = CX / CLength;
            var uY = CY / CLength;
            var k = invMass1 + invMass2;
            var m = 1.0 / k;
            impulseX = m * ((-CX));
            impulseY = m * ((-CY));
            var k_beta = 0.5;
            bA.m_sweep.c.x -= k_beta * invMass1 * impulseX;
            bA.m_sweep.c.y -= k_beta * invMass1 * impulseY;
            bB.m_sweep.c.x += k_beta * invMass2 * impulseX;
            bB.m_sweep.c.y += k_beta * invMass2 * impulseY;
            CX = bB.m_sweep.c.x + r2X - bA.m_sweep.c.x - r1X;
            CY = bB.m_sweep.c.y + r2Y - bA.m_sweep.c.y - r1Y;
         }
         this.K1.col1.x = invMass1 + invMass2;
         this.K1.col2.x = 0.0;
         this.K1.col1.y = 0.0;
         this.K1.col2.y = invMass1 + invMass2;
         this.K2.col1.x = invI1 * r1Y * r1Y;
         this.K2.col2.x = (-invI1 * r1X * r1Y);
         this.K2.col1.y = (-invI1 * r1X * r1Y);
         this.K2.col2.y = invI1 * r1X * r1X;
         this.K3.col1.x = invI2 * r2Y * r2Y;
         this.K3.col2.x = (-invI2 * r2X * r2Y);
         this.K3.col1.y = (-invI2 * r2X * r2Y);
         this.K3.col2.y = invI2 * r2X * r2X;
         this.K.SetM(this.K1);
         this.K.AddM(this.K2);
         this.K.AddM(this.K3);
         this.K.Solve(b2RevoluteJoint.tImpulse, (-CX), (-CY));
         impulseX = b2RevoluteJoint.tImpulse.x;
         impulseY = b2RevoluteJoint.tImpulse.y;
         bA.m_sweep.c.x -= bA.m_invMass * impulseX;
         bA.m_sweep.c.y -= bA.m_invMass * impulseY;
         bA.m_sweep.a -= bA.m_invI * (r1X * impulseY - r1Y * impulseX);
         bB.m_sweep.c.x += bB.m_invMass * impulseX;
         bB.m_sweep.c.y += bB.m_invMass * impulseY;
         bB.m_sweep.a += bB.m_invI * (r2X * impulseY - r2Y * impulseX);
         bA.SynchronizeTransform();
         bB.SynchronizeTransform();
      }
      return positionError <= b2Settings.b2_linearSlop && angularError <= b2Settings.b2_angularSlop;
   }
   Box2D.postDefs.push(function () {
      Box2D.Dynamics.Joints.b2RevoluteJoint.tImpulse = new b2Vec2();
   });
   Box2D.inherit(b2RevoluteJointDef, Box2D.Dynamics.Joints.b2JointDef);
   b2RevoluteJointDef.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype;
   b2RevoluteJointDef.b2RevoluteJointDef = function () {
      Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments);
      this.localAnchorA = new b2Vec2();
      this.localAnchorB = new b2Vec2();
   };
   b2RevoluteJointDef.prototype.b2RevoluteJointDef = function () {
      this.__super.b2JointDef.call(this);
      this.type = b2Joint.e_revoluteJoint;
      this.localAnchorA.Set(0.0, 0.0);
      this.localAnchorB.Set(0.0, 0.0);
      this.referenceAngle = 0.0;
      this.lowerAngle = 0.0;
      this.upperAngle = 0.0;
      this.maxMotorTorque = 0.0;
      this.motorSpeed = 0.0;
      this.enableLimit = false;
      this.enableMotor = false;
   }
   b2RevoluteJointDef.prototype.Initialize = function (bA, bB, anchor) {
      this.bodyA = bA;
      this.bodyB = bB;
      this.localAnchorA = this.bodyA.GetLocalPoint(anchor);
      this.localAnchorB = this.bodyB.GetLocalPoint(anchor);
      this.referenceAngle = this.bodyB.GetAngle() - this.bodyA.GetAngle();
   }
   Box2D.inherit(b2WeldJoint, Box2D.Dynamics.Joints.b2Joint);
   b2WeldJoint.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype;
   b2WeldJoint.b2WeldJoint = function () {
      Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments);
      this.m_localAnchorA = new b2Vec2();
      this.m_localAnchorB = new b2Vec2();
      this.m_impulse = new b2Vec3();
      this.m_mass = new b2Mat33();
   };
   b2WeldJoint.prototype.GetAnchorA = function () {
      return this.m_bodyA.GetWorldPoint(this.m_localAnchorA);
   }
   b2WeldJoint.prototype.GetAnchorB = function () {
      return this.m_bodyB.GetWorldPoint(this.m_localAnchorB);
   }
   b2WeldJoint.prototype.GetReactionForce = function (inv_dt) {
      if (inv_dt === undefined) inv_dt = 0;
      return new b2Vec2(inv_dt * this.m_impulse.x, inv_dt * this.m_impulse.y);
   }
   b2WeldJoint.prototype.GetReactionTorque = function (inv_dt) {
      if (inv_dt === undefined) inv_dt = 0;
      return inv_dt * this.m_impulse.z;
   }
   b2WeldJoint.prototype.b2WeldJoint = function (def) {
      this.__super.b2Joint.call(this, def);
      this.m_localAnchorA.SetV(def.localAnchorA);
      this.m_localAnchorB.SetV(def.localAnchorB);
      this.m_referenceAngle = def.referenceAngle;
      this.m_impulse.SetZero();
      this.m_mass = new b2Mat33();
   }
   b2WeldJoint.prototype.InitVelocityConstraints = function (step) {
      var tMat;
      var tX = 0;
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      tMat = bA.m_xf.R;
      var rAX = this.m_localAnchorA.x - bA.m_sweep.localCenter.x;
      var rAY = this.m_localAnchorA.y - bA.m_sweep.localCenter.y;
      tX = (tMat.col1.x * rAX + tMat.col2.x * rAY);
      rAY = (tMat.col1.y * rAX + tMat.col2.y * rAY);
      rAX = tX;
      tMat = bB.m_xf.R;
      var rBX = this.m_localAnchorB.x - bB.m_sweep.localCenter.x;
      var rBY = this.m_localAnchorB.y - bB.m_sweep.localCenter.y;
      tX = (tMat.col1.x * rBX + tMat.col2.x * rBY);
      rBY = (tMat.col1.y * rBX + tMat.col2.y * rBY);
      rBX = tX;
      var mA = bA.m_invMass;
      var mB = bB.m_invMass;
      var iA = bA.m_invI;
      var iB = bB.m_invI;
      this.m_mass.col1.x = mA + mB + rAY * rAY * iA + rBY * rBY * iB;
      this.m_mass.col2.x = (-rAY * rAX * iA) - rBY * rBX * iB;
      this.m_mass.col3.x = (-rAY * iA) - rBY * iB;
      this.m_mass.col1.y = this.m_mass.col2.x;
      this.m_mass.col2.y = mA + mB + rAX * rAX * iA + rBX * rBX * iB;
      this.m_mass.col3.y = rAX * iA + rBX * iB;
      this.m_mass.col1.z = this.m_mass.col3.x;
      this.m_mass.col2.z = this.m_mass.col3.y;
      this.m_mass.col3.z = iA + iB;
      if (step.warmStarting) {
         this.m_impulse.x *= step.dtRatio;
         this.m_impulse.y *= step.dtRatio;
         this.m_impulse.z *= step.dtRatio;
         bA.m_linearVelocity.x -= mA * this.m_impulse.x;
         bA.m_linearVelocity.y -= mA * this.m_impulse.y;
         bA.m_angularVelocity -= iA * (rAX * this.m_impulse.y - rAY * this.m_impulse.x + this.m_impulse.z);
         bB.m_linearVelocity.x += mB * this.m_impulse.x;
         bB.m_linearVelocity.y += mB * this.m_impulse.y;
         bB.m_angularVelocity += iB * (rBX * this.m_impulse.y - rBY * this.m_impulse.x + this.m_impulse.z);
      }
      else {
         this.m_impulse.SetZero();
      }
   }
   b2WeldJoint.prototype.SolveVelocityConstraints = function (step) {
      var tMat;
      var tX = 0;
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      var vA = bA.m_linearVelocity;
      var wA = bA.m_angularVelocity;
      var vB = bB.m_linearVelocity;
      var wB = bB.m_angularVelocity;
      var mA = bA.m_invMass;
      var mB = bB.m_invMass;
      var iA = bA.m_invI;
      var iB = bB.m_invI;
      tMat = bA.m_xf.R;
      var rAX = this.m_localAnchorA.x - bA.m_sweep.localCenter.x;
      var rAY = this.m_localAnchorA.y - bA.m_sweep.localCenter.y;
      tX = (tMat.col1.x * rAX + tMat.col2.x * rAY);
      rAY = (tMat.col1.y * rAX + tMat.col2.y * rAY);
      rAX = tX;
      tMat = bB.m_xf.R;
      var rBX = this.m_localAnchorB.x - bB.m_sweep.localCenter.x;
      var rBY = this.m_localAnchorB.y - bB.m_sweep.localCenter.y;
      tX = (tMat.col1.x * rBX + tMat.col2.x * rBY);
      rBY = (tMat.col1.y * rBX + tMat.col2.y * rBY);
      rBX = tX;
      var Cdot1X = vB.x - wB * rBY - vA.x + wA * rAY;
      var Cdot1Y = vB.y + wB * rBX - vA.y - wA * rAX;
      var Cdot2 = wB - wA;
      var impulse = new b2Vec3();
      this.m_mass.Solve33(impulse, (-Cdot1X), (-Cdot1Y), (-Cdot2));
      this.m_impulse.Add(impulse);
      vA.x -= mA * impulse.x;
      vA.y -= mA * impulse.y;
      wA -= iA * (rAX * impulse.y - rAY * impulse.x + impulse.z);
      vB.x += mB * impulse.x;
      vB.y += mB * impulse.y;
      wB += iB * (rBX * impulse.y - rBY * impulse.x + impulse.z);
      bA.m_angularVelocity = wA;
      bB.m_angularVelocity = wB;
   }
   b2WeldJoint.prototype.SolvePositionConstraints = function (baumgarte) {
      if (baumgarte === undefined) baumgarte = 0;
      var tMat;
      var tX = 0;
      var bA = this.m_bodyA;
      var bB = this.m_bodyB;
      tMat = bA.m_xf.R;
      var rAX = this.m_localAnchorA.x - bA.m_sweep.localCenter.x;
      var rAY = this.m_localAnchorA.y - bA.m_sweep.localCenter.y;
      tX = (tMat.col1.x * rAX + tMat.col2.x * rAY);
      rAY = (tMat.col1.y * rAX + tMat.col2.y * rAY);
      rAX = tX;
      tMat = bB.m_xf.R;
      var rBX = this.m_localAnchorB.x - bB.m_sweep.localCenter.x;
      var rBY = this.m_localAnchorB.y - bB.m_sweep.localCenter.y;
      tX = (tMat.col1.x * rBX + tMat.col2.x * rBY);
      rBY = (tMat.col1.y * rBX + tMat.col2.y * rBY);
      rBX = tX;
      var mA = bA.m_invMass;
      var mB = bB.m_invMass;
      var iA = bA.m_invI;
      var iB = bB.m_invI;
      var C1X = bB.m_sweep.c.x + rBX - bA.m_sweep.c.x - rAX;
      var C1Y = bB.m_sweep.c.y + rBY - bA.m_sweep.c.y - rAY;
      var C2 = bB.m_sweep.a - bA.m_sweep.a - this.m_referenceAngle;
      var k_allowedStretch = 10.0 * b2Settings.b2_linearSlop;
      var positionError = Math.sqrt(C1X * C1X + C1Y * C1Y);
      var angularError = b2Math.Abs(C2);
      if (positionError > k_allowedStretch) {
         iA *= 1.0;
         iB *= 1.0;
      }
      this.m_mass.col1.x = mA + mB + rAY * rAY * iA + rBY * rBY * iB;
      this.m_mass.col2.x = (-rAY * rAX * iA) - rBY * rBX * iB;
      this.m_mass.col3.x = (-rAY * iA) - rBY * iB;
      this.m_mass.col1.y = this.m_mass.col2.x;
      this.m_mass.col2.y = mA + mB + rAX * rAX * iA + rBX * rBX * iB;
      this.m_mass.col3.y = rAX * iA + rBX * iB;
      this.m_mass.col1.z = this.m_mass.col3.x;
      this.m_mass.col2.z = this.m_mass.col3.y;
      this.m_mass.col3.z = iA + iB;
      var impulse = new b2Vec3();
      this.m_mass.Solve33(impulse, (-C1X), (-C1Y), (-C2));
      bA.m_sweep.c.x -= mA * impulse.x;
      bA.m_sweep.c.y -= mA * impulse.y;
      bA.m_sweep.a -= iA * (rAX * impulse.y - rAY * impulse.x + impulse.z);
      bB.m_sweep.c.x += mB * impulse.x;
      bB.m_sweep.c.y += mB * impulse.y;
      bB.m_sweep.a += iB * (rBX * impulse.y - rBY * impulse.x + impulse.z);
      bA.SynchronizeTransform();
      bB.SynchronizeTransform();
      return positionError <= b2Settings.b2_linearSlop && angularError <= b2Settings.b2_angularSlop;
   }
   Box2D.inherit(b2WeldJointDef, Box2D.Dynamics.Joints.b2JointDef);
   b2WeldJointDef.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype;
   b2WeldJointDef.b2WeldJointDef = function () {
      Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments);
      this.localAnchorA = new b2Vec2();
      this.localAnchorB = new b2Vec2();
   };
   b2WeldJointDef.prototype.b2WeldJointDef = function () {
      this.__super.b2JointDef.call(this);
      this.type = b2Joint.e_weldJoint;
      this.referenceAngle = 0.0;
   }
   b2WeldJointDef.prototype.Initialize = function (bA, bB, anchor) {
      this.bodyA = bA;
      this.bodyB = bB;
      this.localAnchorA.SetV(this.bodyA.GetLocalPoint(anchor));
      this.localAnchorB.SetV(this.bodyB.GetLocalPoint(anchor));
      this.referenceAngle = this.bodyB.GetAngle() - this.bodyA.GetAngle();
   }
})();
(function () {
   var b2DebugDraw = Box2D.Dynamics.b2DebugDraw;
   b2DebugDraw.b2DebugDraw = function () {
      this.m_drawScale = 1.0;
      this.m_lineThickness = 1.0;
      this.m_alpha = 1.0;
      this.m_fillAlpha = 1.0;
      this.m_xformScale = 1.0;
      var __this = this;
      //#WORKAROUND
      this.m_sprite = {
         graphics: {
            clear: function () {
               //__this.m_ctx.clearRect(0, 0, __this.m_ctx.canvas.width, __this.m_ctx.canvas.height)
            },
			setTranslation: function (x, y) {
				__this.m_ctx.translate(x, y);
			},
         }
      };
   };
   b2DebugDraw.prototype._color = function (color, alpha) {
      return "rgba(" + ((color & 0xFF0000) >> 16) + "," + ((color & 0xFF00) >> 8) + "," + (color & 0xFF) + "," + alpha + ")";
   };
   b2DebugDraw.prototype.b2DebugDraw = function () {
      this.m_drawFlags = 0;
   };
   b2DebugDraw.prototype.SetFlags = function (flags) {
      if (flags === undefined) flags = 0;
      this.m_drawFlags = flags;
   };
   b2DebugDraw.prototype.GetFlags = function () {
      return this.m_drawFlags;
   };
   b2DebugDraw.prototype.AppendFlags = function (flags) {
      if (flags === undefined) flags = 0;
      this.m_drawFlags |= flags;
   };
   b2DebugDraw.prototype.ClearFlags = function (flags) {
      if (flags === undefined) flags = 0;
      this.m_drawFlags &= ~flags;
   };
   b2DebugDraw.prototype.SetSprite = function (sprite) {
      this.m_ctx = sprite;
   };
   b2DebugDraw.prototype.GetSprite = function () {
      return this.m_ctx;
   };
   b2DebugDraw.prototype.SetDrawScale = function (drawScale) {
      if (drawScale === undefined) drawScale = 0;
      this.m_drawScale = drawScale;
   };
   b2DebugDraw.prototype.GetDrawScale = function () {
      return this.m_drawScale;
   };
   b2DebugDraw.prototype.SetLineThickness = function (lineThickness) {
      if (lineThickness === undefined) lineThickness = 0;
      this.m_lineThickness = lineThickness;
      this.m_ctx.strokeWidth = lineThickness;
   };
   b2DebugDraw.prototype.GetLineThickness = function () {
      return this.m_lineThickness;
   };
   b2DebugDraw.prototype.SetAlpha = function (alpha) {
      if (alpha === undefined) alpha = 0;
      this.m_alpha = alpha;
   };
   b2DebugDraw.prototype.GetAlpha = function () {
      return this.m_alpha;
   };
   b2DebugDraw.prototype.SetFillAlpha = function (alpha) {
      if (alpha === undefined) alpha = 0;
      this.m_fillAlpha = alpha;
   };
   b2DebugDraw.prototype.GetFillAlpha = function () {
      return this.m_fillAlpha;
   };
   b2DebugDraw.prototype.SetXFormScale = function (xformScale) {
      if (xformScale === undefined) xformScale = 0;
      this.m_xformScale = xformScale;
   };
   b2DebugDraw.prototype.GetXFormScale = function () {
      return this.m_xformScale;
   };
   b2DebugDraw.prototype.DrawPolygon = function (vertices, vertexCount, color) {
      if (!vertexCount) return;
      var s = this.m_ctx;
      var drawScale = this.m_drawScale;
      s.beginPath();
      s.strokeStyle = this._color(color.color, this.m_alpha);
      s.moveTo(vertices[0].x * drawScale, vertices[0].y * drawScale);
      for (var i = 1; i < vertexCount; i++) {
         s.lineTo(vertices[i].x * drawScale, vertices[i].y * drawScale);
      }
      s.lineTo(vertices[0].x * drawScale, vertices[0].y * drawScale);
      s.closePath();
      s.stroke();
   };
   b2DebugDraw.prototype.DrawSolidPolygon = function (vertices, vertexCount, color) {
      if (!vertexCount) return;
      var s = this.m_ctx;
      var drawScale = this.m_drawScale;
      s.beginPath();
      s.strokeStyle = this._color(color.color, this.m_alpha);
      s.fillStyle = this._color(color.color, this.m_fillAlpha);
      s.moveTo(vertices[0].x * drawScale, vertices[0].y * drawScale);
      for (var i = 1; i < vertexCount; i++) {
         s.lineTo(vertices[i].x * drawScale, vertices[i].y * drawScale);
      }
      s.lineTo(vertices[0].x * drawScale, vertices[0].y * drawScale);
      s.closePath();
      s.fill();
      s.stroke();
   };
   b2DebugDraw.prototype.DrawCircle = function (center, radius, color) {
      if (!radius) return;
      var s = this.m_ctx;
      var drawScale = this.m_drawScale;
      s.beginPath();
      s.strokeStyle = this._color(color.color, this.m_alpha);
      s.arc(center.x * drawScale, center.y * drawScale, radius * drawScale, 0, Math.PI * 2, true);
      s.closePath();
      s.stroke();
   };
   b2DebugDraw.prototype.DrawSolidCircle = function (center, radius, axis, color) {
      if (!radius) return;
      var s = this.m_ctx,
         drawScale = this.m_drawScale,
         cx = center.x * drawScale,
         cy = center.y * drawScale;
      s.moveTo(0, 0);
      s.beginPath();
      s.strokeStyle = this._color(color.color, this.m_alpha);
      s.fillStyle = this._color(color.color, this.m_fillAlpha);
      s.arc(cx, cy, radius * drawScale, 0, Math.PI * 2, true);
      s.moveTo(cx, cy);
      s.lineTo((center.x + axis.x * radius) * drawScale, (center.y + axis.y * radius) * drawScale);
      s.closePath();
      s.fill();
      s.stroke();
   };
   b2DebugDraw.prototype.DrawSegment = function (p1, p2, color) {
      var s = this.m_ctx,
         drawScale = this.m_drawScale;
      s.strokeStyle = this._color(color.color, this.m_alpha);
      s.beginPath();
      s.moveTo(p1.x * drawScale, p1.y * drawScale);
      s.lineTo(p2.x * drawScale, p2.y * drawScale);
      s.closePath();
      s.stroke();
   };
   b2DebugDraw.prototype.DrawTransform = function (xf) {
      var s = this.m_ctx,
         drawScale = this.m_drawScale;
      s.beginPath();
      s.strokeStyle = this._color(0xff0000, this.m_alpha);
      s.moveTo(xf.position.x * drawScale, xf.position.y * drawScale);
      s.lineTo((xf.position.x + this.m_xformScale * xf.R.col1.x) * drawScale, (xf.position.y + this.m_xformScale * xf.R.col1.y) * drawScale);

      s.strokeStyle = this._color(0xff00, this.m_alpha);
      s.moveTo(xf.position.x * drawScale, xf.position.y * drawScale);
      s.lineTo((xf.position.x + this.m_xformScale * xf.R.col2.x) * drawScale, (xf.position.y + this.m_xformScale * xf.R.col2.y) * drawScale);
      s.closePath();
      s.stroke();
   };
})(); //post-definitions
var i;
for (i = 0; i < Box2D.postDefs.length; ++i) Box2D.postDefs[i]();
delete Box2D.postDefs;

if (typeof(window) == 'undefined') {
	exports.Box2D = Box2D;
}
/**
 * Copyright (c) 2012 cannon.js Authors
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
(function () {
	/**
	 * @mainpage Cannon.js
	 * A lightweight 3D physics engine for the web. See the github page for more information: https://github.com/schteppe/cannon.js
	 */

	var CANNON = CANNON || {};

// Maintain compatibility with older browsers
// @todo: check so ordinary Arrays work.
	if(!this.Int32Array){
		this.Int32Array=Array;
		this.Float32Array=Array;
	}/*global CANNON:true */

	/**
	 * @class CANNON.Broadphase
	 * @author schteppe
	 * @brief Base class for broadphase implementations
	 */
	CANNON.Broadphase = function(){
		/// The world to search for collisions in.
		this.world = null;
	};
	CANNON.Broadphase.prototype.constructor = CANNON.BroadPhase;

	/**
	 * @fn collisionPairs
	 * @memberof CANNON.Broadphase
	 * @brief Get the collision pairs from the world
	 * @param CANNON.World world The world to search in
	 * @return array An array with two subarrays of body indices
	 */
	CANNON.Broadphase.prototype.collisionPairs = function(world){
		throw "collisionPairs not implemented for this BroadPhase class!";
	};

	/*global CANNON:true */

	/**
	 * @class CANNON.NaiveBroadphase
	 * @brief Naive broadphase implementation, used in lack of better ones. The naive broadphase looks at all possible pairs without restriction, therefore it has complexity N^2 (which is bad)
	 * @extends CANNON.Broadphase
	 */
	CANNON.NaiveBroadphase = function(){
		this.temp = {
			r: new CANNON.Vec3(),
			normal: new CANNON.Vec3(),
			quat: new CANNON.Quaternion()
		};
	};
	CANNON.NaiveBroadphase.prototype = new CANNON.Broadphase();
	CANNON.NaiveBroadphase.prototype.constructor = CANNON.NaiveBroadphase;

	/**
	 * @fn collisionPairs
	 * @memberof CANNON.NaiveBroadphase
	 * @brief Get all the collision pairs in the physics world
	 * @param CANNON.World world
	 * @return array An array containing two arrays of integers. The integers corresponds to the body indices.
	 */
	CANNON.NaiveBroadphase.prototype.collisionPairs = function(world){
		var pairs1 = [], pairs2 = [];
		var n = world.numObjects(),
			bodies = world.bodies;

		// Local fast access
		var types = CANNON.Shape.types;
		var BOX_SPHERE_COMPOUND_CONVEX = types.SPHERE | types.BOX | types.COMPOUND | types.CONVEXPOLYHEDRON,
			PLANE = types.PLANE,
			STATIC_OR_KINEMATIC = CANNON.Body.STATIC | CANNON.Body.KINEMATIC;

		// Temp vecs
		var r = this.temp.r;
		var normal = this.temp.normal;
		var quat = this.temp.quat;

		// Naive N^2 ftw!
		for(var i=0; i<n; i++){
			for(var j=0; j<i; j++){
				var bi = bodies[i], bj = bodies[j];
				if(bi.shape && bj.shape){
					var ti = bi.shape.type, tj = bj.shape.type;

					if(((bi.motionstate & STATIC_OR_KINEMATIC)!==0 || bi.isSleeping()) &&
						((bj.motionstate & STATIC_OR_KINEMATIC)!==0 || bj.isSleeping())) {
						// Both bodies are static, kinematic or sleeping. Skip.
						continue;
					}

					// --- Box / sphere / compound / convexpolyhedron collision ---
					if((ti & BOX_SPHERE_COMPOUND_CONVEX) && (tj & BOX_SPHERE_COMPOUND_CONVEX)){
						// Rel. position
						bj.position.vsub(bi.position,r);

						var boundingRadiusSum = bi.shape.boundingSphereRadius() + bj.shape.boundingSphereRadius();
						if(r.norm2()<boundingRadiusSum*boundingRadiusSum){
							pairs1.push(bi);
							pairs2.push(bj);
						}

						// --- Sphere/box/compound/convexpoly versus plane ---
					} else if((ti & BOX_SPHERE_COMPOUND_CONVEX) && (tj & types.PLANE) || (tj & BOX_SPHERE_COMPOUND_CONVEX) && (ti & types.PLANE)){
						var pi = (ti===PLANE) ? i : j, // Plane
							oi = (ti!==PLANE) ? i : j; // Other

						// Rel. position
						bodies[oi].position.vsub(bodies[pi].position,r);
						bodies[pi].quaternion.vmult(bodies[pi].shape.normal,normal);

						var q = r.dot(normal) - bodies[oi].shape.boundingSphereRadius();
						if(q<0.0){
							pairs1.push(bi);
							pairs2.push(bj);
						}
					}
				}
			}
		}
		return [pairs1,pairs2];
	};
	/*global CANNON:true */

	/**
	 * @class CANNON.Ray
	 * @author Originally written by mr.doob / http://mrdoob.com/ for Three.js. Cannon.js-ified by schteppe.
	 * @brief A ray is a line in 3D space that can intersect bodies and return intersection points.
	 * @param CANNON.Vec3 origin
	 * @param CANNON.Vec3 direction
	 */
	CANNON.Ray = function(origin, direction){
		this.origin = origin || new CANNON.Vec3();
		this.direction = direction || new CANNON.Vec3();

		var precision = 0.0001;

		/**
		 * @fn setPrecision
		 * @memberof CANNON.Ray
		 * @param float value
		 * @brief Sets the precision of the ray. Used when checking parallelity etc.
		 */
		this.setPrecision = function ( value ) {
			precision = value;
		};

		var a = new CANNON.Vec3();
		var b = new CANNON.Vec3();
		var c = new CANNON.Vec3();
		var d = new CANNON.Vec3();

		var directionCopy = new CANNON.Vec3();

		var vector = new CANNON.Vec3();
		var normal = new CANNON.Vec3();
		var intersectPoint = new CANNON.Vec3()

		/**
		 * @fn intersectBody
		 * @memberof CANNON.Ray
		 * @param CANNON.RigidBody body
		 * @brief Shoot a ray at a body, get back information about the hit.
		 * @return Array An array of results. The result objects has properties: distance (float), point (CANNON.Vec3) and body (CANNON.RigidBody).
		 */
		this.intersectBody = function ( body ) {
			if(body.shape instanceof CANNON.ConvexPolyhedron){
				return this.intersectShape(body.shape,
					body.quaternion,
					body.position,
					body);
			} else if(body.shape instanceof CANNON.Box){
				return this.intersectShape(body.shape.convexPolyhedronRepresentation,
					body.quaternion,
					body.position,
					body);
			} else
				console.warn("Ray intersection is this far only implemented for ConvexPolyhedron and Box shapes.");
		};

		/**
		 * @fn intersectShape
		 * @memberof CANNON.Ray
		 * @param CANNON.Shape shape
		 * @param CANNON.Quaternion quat
		 * @param CANNON.Vec3 position
		 * @param CANNON.RigidBody body
		 * @return Array See intersectBody()
		 */
		this.intersectShape = function(shape,quat,position,body){

			var intersect, intersects = [];

			if ( shape instanceof CANNON.ConvexPolyhedron ) {
				// Checking boundingSphere

				var distance = distanceFromIntersection( this.origin, this.direction, position );
				if ( distance > shape.boundingSphereRadius() ) {
					return intersects;
				}

				// Checking faces
				var dot, scalar, faces = shape.faces, vertices = shape.vertices, normals = shape.faceNormals;

				for ( fi = 0; fi < faces.length; fi++ ) {

					var face = faces[ fi ];
					var faceNormal = normals[ fi ];
					var q = quat;
					var x = position;

					// determine if ray intersects the plane of the face
					// note: this works regardless of the direction of the face normal

					// Get plane point
					var vector = new CANNON.Vec3();
					vertices[face[0]].copy(vector);
					vector.vsub(this.origin,vector);
					q.vmult(vector,vector);
					vector.vadd(x,vector);

					// Get plane normal
					var normal = new CANNON.Vec3();
					q.vmult(faceNormal,normal);

					dot = this.direction.dot(normal);

					// bail if ray and plane are parallel

					if ( Math.abs( dot ) < precision ) continue;

					// calc distance to plane

					scalar = normal.dot( vector ) / dot;

					// if negative distance, then plane is behind ray
					if ( scalar < 0 ) continue;

					if (  dot < 0 ) {

						// Intersection point is origin + direction * scalar
						this.direction.mult(scalar,intersectPoint);
						intersectPoint.vadd(this.origin,intersectPoint);

						// a is the point we compare points b and c with.
						vertices[ face[0] ].copy(a);
						q.vmult(a,a);
						x.vadd(a,a);

						for(var i=1; i<face.length-1; i++){
							// Transform 3 vertices to world coords
							vertices[ face[i] ].copy(b);
							vertices[ face[i+1] ].copy(c);
							q.vmult(b,b);
							q.vmult(c,c);
							x.vadd(b,b);
							x.vadd(c,c);

							if ( pointInTriangle( intersectPoint, a, b, c ) ) {

								intersect = {

									distance: this.origin.distanceTo( intersectPoint ),
									point: intersectPoint.copy(),
									face: face,
									body: body

								};

								intersects.push( intersect );
								break;

							}

						}
					}

				}

			}


			return intersects;

		}

		/**
		 * @fn intersectBodies
		 * @memberof CANNON.Ray
		 * @param Array bodies An array of CANNON.RigidBody objects.
		 * @return Array See intersectBody
		 */
		this.intersectBodies = function ( bodies ) {

			var intersects = [];

			for ( var i = 0, l = bodies.length; i < l; i ++ ) {
				var result = this.intersectBody( bodies[ i ] );
				Array.prototype.push.apply( intersects, result );

			}

			intersects.sort( function ( a, b ) { return a.distance - b.distance; } );

			return intersects;

		};

		var v0 = new CANNON.Vec3(), intersect = new CANNON.Vec3();
		var dot, distance;

		function distanceFromIntersection( origin, direction, position ) {

			// v0 is vector from origin to position
			position.vsub(origin,v0);
			dot = v0.dot( direction );

			// intersect = direction*dot + origin
			direction.mult(dot,intersect);
			intersect.vadd(origin,intersect);

			distance = position.distanceTo( intersect );

			return distance;

		}

		// http://www.blackpawn.com/texts/pointinpoly/default.html

		var dot00, dot01, dot02, dot11, dot12, invDenom, u, v;
		var v1 = new CANNON.Vec3(), v2 = new CANNON.Vec3();

		function pointInTriangle( p, a, b, c ) {
			c.vsub(a,v0);
			b.vsub(a,v1);
			p.vsub(a,v2);

			dot00 = v0.dot( v0 );
			dot01 = v0.dot( v1 );
			dot02 = v0.dot( v2 );
			dot11 = v1.dot( v1 );
			dot12 = v1.dot( v2 );

			invDenom = 1 / ( dot00 * dot11 - dot01 * dot01 );
			u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;
			v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;

			return ( u >= 0 ) && ( v >= 0 ) && ( u + v < 1 );
		}
	};
	CANNON.Ray.prototype.constructor = CANNON.Ray;
	/*global CANNON:true */

	/**
	 * @class CANNON.Mat3
	 * @brief Produce a 3x3 matrix. Columns first!
	 * @param array elements Array of nine elements. Optional.
	 * @author schteppe / http://github.com/schteppe
	 */
	CANNON.Mat3 = function(elements){
		/**
		 * @property Float32Array elements
		 * @memberof CANNON.Mat3
		 * @brief A vector of length 9, containing all matrix elements
		 */
		if(elements){
			this.elements = new Float32Array(elements);
		} else {
			this.elements = new Float32Array(9);
		}
	};

	/**
	 * @fn identity
	 * @memberof CANNON.Mat3
	 * @brief Sets the matrix to identity
	 * @todo Should perhaps be renamed to setIdentity() to be more clear.
	 * @todo Create another function that immediately creates an identity matrix eg. eye()
	 */
	CANNON.Mat3.prototype.identity = function(){
		this.elements[0] = 1;
		this.elements[1] = 0;
		this.elements[2] = 0;

		this.elements[3] = 0;
		this.elements[4] = 1;
		this.elements[5] = 0;

		this.elements[6] = 0;
		this.elements[7] = 0;
		this.elements[8] = 1;
	};

	/**
	 * @fn vmult
	 * @memberof CANNON.vmult
	 * @brief Matrix-Vector multiplication
	 * @param CANNON.Vec3 v The vector to multiply with
	 * @param CANNON.Vec3 target Optional, target to save the result in.
	 */
	CANNON.Mat3.prototype.vmult = function(v,target){
		if(target===undefined){
			target = new CANNON.Vec3();
		}

		var vec = [v.x, v.y, v.z];
		var targetvec = [0, 0, 0];
		for(var i=0; i<3; i++){
			for(var j=0; j<3; j++){
				targetvec[i] += this.elements[i+3*j]*vec[i];
			}
		}

		target.x = targetvec[0];
		target.y = targetvec[1];
		target.z = targetvec[2];
		return target;
	};

	/**
	 * @fn smult
	 * @memberof CANNON.Mat3
	 * @brief Matrix-scalar multiplication
	 * @param float s
	 */
	CANNON.Mat3.prototype.smult = function(s){
		for(var i=0; i<this.elements.length; i++){
			this.elements[i] *= s;
		}
	};

	/**
	 * @fn mmult
	 * @memberof CANNON.Mat3
	 * @brief Matrix multiplication
	 * @param CANNON.Mat3 m Matrix to multiply with from left side.
	 * @return CANNON.Mat3 The result.
	 */
	CANNON.Mat3.prototype.mmult = function(m){
		var r = new CANNON.Mat3();
		for(var i=0; i<3; i++){
			for(var j=0; j<3; j++){
				var sum = 0.0;
				for(var k=0; k<3; k++){
					sum += this.elements[i+k] * m.elements[k+j*3];
				}
				r.elements[i+j*3] = sum;
			}
		}
		return r;
	};

	/**
	 * @fn solve
	 * @memberof CANNON.Mat3
	 * @brief Solve Ax=b
	 * @param CANNON.Vec3 b The right hand side
	 * @param CANNON.Vec3 target Optional. Target vector to save in.
	 * @return CANNON.Vec3 The solution x
	 */
	CANNON.Mat3.prototype.solve = function(b,target){

		target = target || new CANNON.Vec3();

		// Construct equations
		var nr = 3; // num rows
		var nc = 4; // num cols
		var eqns = new Float32Array(nr*nc);
		var i,j;
		for(i=0; i<3; i++){
			for(j=0; j<3; j++){
				eqns[i+nc*j] = this.elements[i+3*j];
			}
		}
		eqns[3+4*0] = b.x;
		eqns[3+4*1] = b.y;
		eqns[3+4*2] = b.z;

		// Compute right upper triangular version of the matrix - Gauss elimination
		var n = 3, k = n, np;
		var kp = 4; // num rows
		var p, els;
		do {
			i = k - n;
			if (eqns[i+nc*i] === 0) {
				for (j = i + 1; j < k; j++) {
					if (eqns[i+nc*j] !== 0) {
						els = [];
						np = kp;
						do {
							p = kp - np;
							els.push(eqns[p+nc*i] + eqns[p+nc*j]);
						} while (--np);
						eqns[i+nc*0] = els[0];
						eqns[i+nc*1] = els[1];
						eqns[i+nc*2] = els[2];
						break;
					}
				}
			}
			if (eqns[i+nc*i] !== 0) {
				for (j = i + 1; j < k; j++) {
					var multiplier = eqns[i+nc*j] / eqns[i+nc*i];
					els = [];
					np = kp;
					do {
						p = kp - np;
						els.push(p <= i ? 0 : eqns[p+nc*j] - eqns[p+nc*i] * multiplier);
					} while (--np);
					eqns[j+nc*0] = els[0];
					eqns[j+nc*1] = els[1];
					eqns[j+nc*2] = els[2];
				}
			}
		} while (--n);
		// Get the solution
		target.z = eqns[2*nc+3] / eqns[2*nc+2];
		target.y = (eqns[1*nc+3] - eqns[1*nc+2]*target.z) / eqns[1*nc+1];
		target.x = (eqns[0*nc+3] - eqns[0*nc+2]*target.z - eqns[0*nc+1]*target.y) / eqns[0*nc+0];

		if(isNaN(target.x) || isNaN(target.y) || isNaN(target.z) || target.x===Infinity || target.y===Infinity || target.z===Infinity){
			throw "Could not solve equation! Got x=["+target.toString()+"], b=["+b.toString()+"], A=["+this.toString()+"]";
		}

		return target;
	};

	/**
	 * @fn e
	 * @memberof CANNON.Mat3
	 * @brief Get an element in the matrix by index. Index starts at 0, not 1!!!
	 * @param int i
	 * @param int j
	 * @param float value Optional. If provided, the matrix element will be set to this value.
	 * @return float
	 */
	CANNON.Mat3.prototype.e = function(i,j,value){
		if(value===undefined){
			return this.elements[i+3*j];
		} else {
			// Set value
			this.elements[i+3*j] = value;
		}
	};

	/**
	 * @fn copy
	 * @memberof CANNON.Mat3
	 * @brief Copy the matrix
	 * @param CANNON.Mat3 target Optional. Target to save the copy in.
	 * @return CANNON.Mat3
	 */
	CANNON.Mat3.prototype.copy = function(target){
		target = target || new CANNON.Mat3();
		for(var i=0; i<this.elements.length; i++){
			target.elements[i] = this.elements[i];
		}
		return target;
	};

	/**
	 * @fn toString
	 * @memberof CANNON.Mat3
	 * @brief Returns a string representation of the matrix.
	 * @return string
	 */
	CANNON.Mat3.prototype.toString = function(){
		var r = "";
		var sep = ",";
		for(var i=0; i<9; i++){
			r += this.elements[i] + sep;
		}
		return r;
	};/*global CANNON:true */

	/**
	 * @class CANNON.Vec3
	 * @brief 3-dimensional vector
	 * @param float x
	 * @param float y
	 * @param float z
	 * @author schteppe
	 */
	CANNON.Vec3 = function(x,y,z){
		/**
		 * @property float x
		 * @memberof CANNON.Vec3
		 */
		this.x = x||0.0;
		/**
		 * @property float y
		 * @memberof CANNON.Vec3
		 */
		this.y = y||0.0;
		/**
		 * @property float z
		 * @memberof CANNON.Vec3
		 */
		this.z = z||0.0;
	};

	/**
	 * @fn cross
	 * @memberof CANNON.Vec3
	 * @brief Vector cross product
	 * @param CANNON.Vec3 v
	 * @param CANNON.Vec3 target Optional. Target to save in.
	 * @return CANNON.Vec3
	 */
	CANNON.Vec3.prototype.cross = function(v,target){
		target = target || new CANNON.Vec3();
		var A = [this.x, this.y, this.z];
		var B = [v.x, v.y, v.z];

		target.x = (A[1] * B[2]) - (A[2] * B[1]);
		target.y = (A[2] * B[0]) - (A[0] * B[2]);
		target.z = (A[0] * B[1]) - (A[1] * B[0]);

		return target;
	};

	/**
	 * @fn set
	 * @memberof CANNON.Vec3
	 * @brief Set the vectors' 3 elements
	 * @param float x
	 * @param float y
	 * @param float z
	 * @return CANNON.Vec3
	 */
	CANNON.Vec3.prototype.set = function(x,y,z){
		this.x = x;
		this.y = y;
		this.z = z;
		return this;
	};

	/**
	 * @fn vadd
	 * @memberof CANNON.Vec3
	 * @brief Vector addition
	 * @param CANNON.Vec3 v
	 * @param CANNON.Vec3 target Optional.
	 * @return CANNON.Vec3
	 */
	CANNON.Vec3.prototype.vadd = function(v,target){
		if(target){
			target.x = v.x + this.x;
			target.y = v.y + this.y;
			target.z = v.z + this.z;
		} else {
			return new CANNON.Vec3(this.x + v.x,
				this.y + v.y,
				this.z + v.z);
		}
	};

	/**
	 * @fn vsub
	 * @memberof CANNON.Vec3
	 * @brief Vector subtraction
	 * @param CANNON.Vec3 v
	 * @param CANNON.Vec3 target Optional. Target to save in.
	 * @return CANNON.Vec3
	 */
	CANNON.Vec3.prototype.vsub = function(v,target){
		if(target){
			target.x = this.x - v.x;
			target.y = this.y - v.y;
			target.z = this.z - v.z;
		} else {
			return new CANNON.Vec3(this.x-v.x,
				this.y-v.y,
				this.z-v.z);
		}
	};

	/**
	 * @fn crossmat
	 * @memberof CANNON.Vec3
	 * @brief Get the cross product matrix a_cross from a vector, such that a x b = a_cross * b = c
	 * @see http://www8.cs.umu.se/kurser/TDBD24/VT06/lectures/Lecture6.pdf
	 * @return CANNON.Mat3
	 */
	CANNON.Vec3.prototype.crossmat = function(){
		return new CANNON.Mat3([      0,  -this.z,   this.y,
			this.z,        0,  -this.x,
			-this.y,   this.x,        0]);
	};

	/**
	 * @fn normalize
	 * @memberof CANNON.Vec3
	 * @brief Normalize the vector. Note that this changes the values in the vector.
	 * @return float Returns the norm of the vector
	 */
	CANNON.Vec3.prototype.normalize = function(){
		var n = Math.sqrt(this.x*this.x + this.y*this.y + this.z*this.z);
		if(n>0.0){
			this.x /= n;
			this.y /= n;
			this.z /= n;
		} else {
			// Make something up
			this.x = 0;
			this.y = 0;
			this.z = 0;
		}
		return n;
	};

	/**
	 * @fn unit
	 * @memberof CANNON.Vec3
	 * @brief Get the version of this vector that is of length 1.
	 * @param CANNON.Vec3 target Optional target to save in
	 * @return CANNON.Vec3 Returns the unit vector
	 */
	CANNON.Vec3.prototype.unit = function(target){
		target = target || new CANNON.Vec3();
		var ninv = Math.sqrt(this.x*this.x + this.y*this.y + this.z*this.z);
		if(ninv>0.0){
			ninv = 1.0/ninv;
			target.x = this.x * ninv;
			target.y = this.y * ninv;
			target.z = this.z * ninv;
		} else {
			target.x = 0;
			target.y = 0;
			target.z = 0;
		}
		return target;
	};

	/**
	 * @fn norm
	 * @memberof CANNON.Vec3
	 * @brief Get the 2-norm (length) of the vector
	 * @return float
	 */
	CANNON.Vec3.prototype.norm = function(){
		return Math.sqrt(this.x*this.x + this.y*this.y + this.z*this.z);
	};

	/**
	 * @fn norm2
	 * @memberof CANNON.Vec3
	 * @brief Get the squared length of the vector
	 * @return float
	 */
	CANNON.Vec3.prototype.norm2 = function(){
		return this.dot(this);
	};

	CANNON.Vec3.prototype.distanceTo = function(p){
		return Math.sqrt((p.x-this.x)*(p.x-this.x)+
			(p.y-this.y)*(p.y-this.y)+
			(p.z-this.z)*(p.z-this.z));
	};

	/**
	 * @fn mult
	 * @memberof CANNON.Vec3
	 * @brief Multiply the vector with a scalar
	 * @param float scalar
	 * @param CANNON.Vec3 target
	 * @return CANNON.Vec3
	 */
	CANNON.Vec3.prototype.mult = function(scalar,target){
		if(!target)
			target = new CANNON.Vec3();
		target.x = scalar*this.x;
		target.y = scalar*this.y;
		target.z = scalar*this.z;
		return target;
	};

	/**
	 * @fn dot
	 * @memberof CANNON.Vec3
	 * @brief Calculate dot product
	 * @param CANNON.Vec3 v
	 * @return float
	 */
	CANNON.Vec3.prototype.dot = function(v){
		return (this.x * v.x + this.y * v.y + this.z * v.z);
	};

	/**
	 * @fn isZero
	 * @memberof CANNON.Vec3
	 * @return bool
	 */
	CANNON.Vec3.prototype.isZero = function(){
		return this.x===0 && this.y===0 && this.z===0;
	}

	/**
	 * @fn negate
	 * @memberof CANNON.Vec3
	 * @brief Make the vector point in the opposite direction.
	 * @param CANNON.Vec3 target Optional target to save in
	 * @return CANNON.Vec3
	 */
	CANNON.Vec3.prototype.negate = function(target){
		target = target || new CANNON.Vec3();
		target.x = -this.x;
		target.y = -this.y;
		target.z = -this.z;
		return target;
	};

	/**
	 * @fn tangents
	 * @memberof CANNON.Vec3
	 * @brief Compute two artificial tangents to the vector
	 * @param CANNON.Vec3 t1 Vector object to save the first tangent in
	 * @param CANNON.Vec3 t2 Vector object to save the second tangent in
	 */
	CANNON.Vec3.prototype.tangents = function(t1,t2){
		var norm = this.norm();
		if(norm>0.0){
			var n = new CANNON.Vec3(this.x/norm,
				this.y/norm,
				this.z/norm);
			if(n.x<0.9){
				var rand = Math.random();
				n.cross(new CANNON.Vec3(rand,0.0000001,0).unit(),t1);
			} else
				n.cross(new CANNON.Vec3(0.0000001,rand,0).unit(),t1);
			n.cross(t1,t2);
		} else {
			// The normal length is zero, make something up
			t1.set(1,0,0).normalize();
			t2.set(0,1,0).normalize();
		}
	};

	/**
	 * @fn toString
	 * @memberof CANNON.Vec3
	 * @brief Converts to a more readable format
	 * @return string
	 */
	CANNON.Vec3.prototype.toString = function(){
		return this.x+","+this.y+","+this.z;
	};

	/**
	 * @fn copy
	 * @memberof CANNON.Vec3
	 * @brief Copy the vector.
	 * @param CANNON.Vec3 target
	 * @return CANNON.Vec3
	 */
	CANNON.Vec3.prototype.copy = function(target){
		target = target || new CANNON.Vec3();
		target.x = this.x;
		target.y = this.y;
		target.z = this.z;
		return target;
	};


	/**
	 * @fn lerp
	 * @memberof CANNON.Vec3
	 * @brief Do a linear interpolation between two vectors
	 * @param CANNON.Vec3 v
	 * @param float t A number between 0 and 1. 0 will make this function return u, and 1 will make it return v. Numbers in between will generate a vector in between them.
	 * @param CANNON.Vec3 target
	 */
	CANNON.Vec3.prototype.lerp = function(v,t,target){
		target.x = this.x + (v.x-this.x)*t;
		target.y = this.y + (v.y-this.y)*t;
		target.z = this.z + (v.z-this.z)*t;
	};

	/**
	 * @fn almostEquals
	 * @memberof CANNON.Vec3
	 * @brief Check if a vector equals is almost equal to another one.
	 * @param CANNON.Vec3 v
	 * @param float precision
	 * @return bool
	 */
	CANNON.Vec3.prototype.almostEquals = function(v,precision){
		if(precision===undefined)
			precision = 1e-6;
		if(Math.abs(this.x-v.x)>precision ||
			Math.abs(this.y-v.y)>precision ||
			Math.abs(this.z-v.z)>precision)
			return false;
		return true;
	}

	/**
	 * Check if a vector is almost zero
	 */
	CANNON.Vec3.prototype.almostZero = function(precision){
		if(precision===undefined)
			precision = 1e-6;
		if(Math.abs(this.x)>precision ||
			Math.abs(this.y)>precision ||
			Math.abs(this.z)>precision)
			return false;
		return true;
	}/*global CANNON:true */

	/**
	 * @class CANNON.Quaternion
	 * @brief A Quaternion describes a rotation in 3D space. It is mathematically defined as Q = x*i + y*j + z*k + w, where (i,j,k) are imaginary basis vectors. (x,y,z) can be seen as a vector related to the axis of rotation, while the real multiplier, w, is related to the amount of rotation.
	 * @param float x Multiplier of the imaginary basis vector i.
	 * @param float y Multiplier of the imaginary basis vector j.
	 * @param float z Multiplier of the imaginary basis vector k.
	 * @param float w Multiplier of the real part.
	 * @see http://en.wikipedia.org/wiki/Quaternion
	 */
	CANNON.Quaternion = function(x,y,z,w){
		/**
		 * @property float x
		 * @memberof CANNON.Quaternion
		 */
		this.x = x!=undefined ? x : 0;
		/**
		 * @property float y
		 * @memberof CANNON.Quaternion
		 */
		this.y = y!=undefined ? y : 0;
		/**
		 * @property float z
		 * @memberof CANNON.Quaternion
		 */
		this.z = z!=undefined ? z : 0;
		/**
		 * @property float w
		 * @memberof CANNON.Quaternion
		 * @brief The multiplier of the real quaternion basis vector.
		 */
		this.w = w!=undefined ? w : 1;
	};

	/**
	 * Set the value of the quaternion.
	 */
	CANNON.Quaternion.prototype.set = function(x,y,z,w){
		this.x = x;
		this.y = y;
		this.z = z;
		this.w = w;
	};

	/**
	 * @fn toString
	 * @memberof CANNON.Quaternion
	 * @brief Convert to a readable format
	 * @return string
	 */
	CANNON.Quaternion.prototype.toString = function(){
		return this.x+","+this.y+","+this.z+","+this.w;
	};

	/**
	 * @fn setFromAxisAngle
	 * @memberof CANNON.Quaternion
	 * @brief Set the quaternion components given an axis and an angle.
	 * @param CANNON.Vec3 axis
	 * @param float angle in radians
	 */
	CANNON.Quaternion.prototype.setFromAxisAngle = function(axis,angle){
		var s = Math.sin(angle*0.5);
		this.x = axis.x * s;
		this.y = axis.y * s;
		this.z = axis.z * s;
		this.w = Math.cos(angle*0.5);
	};

// saves axis to targetAxis and returns 
	CANNON.Quaternion.prototype.toAxisAngle = function(targetAxis){
		targetAxis = targetAxis || new CANNON.Vec3();
		this.normalize(); // if w>1 acos and sqrt will produce errors, this cant happen if quaternion is normalised
		var angle = 2 * Math.acos(this.w);
		var s = Math.sqrt(1-this.w*this.w); // assuming quaternion normalised then w is less than 1, so term always positive.
		if (s < 0.001) { // test to avoid divide by zero, s is always positive due to sqrt
			// if s close to zero then direction of axis not important
			targetAxis.x = this.x; // if it is important that axis is normalised then replace with x=1; y=z=0;
			targetAxis.y = this.y;
			targetAxis.z = this.z;
		} else {
			targetAxis.x = this.x / s; // normalise axis
			targetAxis.y = this.y / s;
			targetAxis.z = this.z / s;
		}
		return [targetAxis,angle];
	};

	/**
	 * @fn setFromVectors
	 * @memberof CANNON.Quaternion
	 * @brief Set the quaternion value given two vectors. The resulting rotation will be the needed rotation to rotate u to v.
	 * @param CANNON.Vec3 u
	 * @param CANNON.Vec3 v
	 */
	CANNON.Quaternion.prototype.setFromVectors = function(u,v){
		var a = u.cross(v);
		this.x = a.x;
		this.y = a.y;
		this.z = a.z;
		this.w = Math.sqrt(Math.pow(u.norm(),2) * Math.pow(v.norm(),2)) + u.dot(v);
		this.normalize();
	};

	/**
	 * @fn mult
	 * @memberof CANNON.Quaternion
	 * @brief Quaternion multiplication
	 * @param CANNON.Quaternion q
	 * @param CANNON.Quaternion target Optional.
	 * @return CANNON.Quaternion
	 */
	CANNON.Quaternion.prototype.mult = function(q,target){
		if(target==undefined)
			target = new CANNON.Quaternion();

		var va = new CANNON.Vec3(this.x,this.y,this.z);
		var vb = new CANNON.Vec3(q.x,q.y,q.z);
		target.w = this.w*q.w - va.dot(vb);
		vaxvb = va.cross(vb);
		target.x = this.w * vb.x + q.w*va.x + vaxvb.x;
		target.y = this.w * vb.y + q.w*va.y + vaxvb.y;
		target.z = this.w * vb.z + q.w*va.z + vaxvb.z;
		return target;
	};

	/**
	 * @fn inverse
	 * @memberof CANNON.Quaternion
	 * @brief Get the inverse quaternion rotation.
	 * @param CANNON.Quaternion target
	 * @return CANNON.Quaternion
	 */
	CANNON.Quaternion.prototype.inverse = function(target){
		if(target==undefined)
			target = new CANNON.Quaternion();

		this.conjugate(target);
		var inorm2 = 1/(this.x*this.x + this.y*this.y + this.z*this.z + this.w*this.w);
		target.x *= inorm2;
		target.y *= inorm2;
		target.z *= inorm2;
		target.w *= inorm2;

		return target;
	};

	/**
	 * @fn conjugate
	 * @memberof CANNON.Quaternion
	 * @brief Get the quaternion conjugate
	 * @param CANNON.Quaternion target
	 * @return CANNON.Quaternion
	 */
	CANNON.Quaternion.prototype.conjugate = function(target){
		if(target==undefined)
			target = new CANNON.Quaternion();

		target.x = -this.x;
		target.y = -this.y;
		target.z = -this.z;
		target.w = this.w;

		return target;
	};

	/**
	 * @fn normalize
	 * @memberof CANNON.Quaternion
	 * @brief Normalize the quaternion. Note that this changes the values of the quaternion.
	 */
	CANNON.Quaternion.prototype.normalize = function(){
		var l = Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w);
		if ( l === 0 ) {
			this.x = 0;
			this.y = 0;
			this.z = 0;
			this.w = 0;
		} else {
			l = 1 / l;
			this.x *= l;
			this.y *= l;
			this.z *= l;
			this.w *= l;
		}
	};

	/**
	 * @fn normalizeFast
	 * @memberof CANNON.Quaternion
	 * @brief Approximation of quaternion normalization. Works best when quat is already almost-normalized.
	 * @see http://jsperf.com/fast-quaternion-normalization
	 * @author unphased, https://github.com/unphased
	 */
	CANNON.Quaternion.prototype.normalizeFast = function () {
		var f = (3.0-(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w))/2.0;
		if ( f === 0 ) {
			this.x = 0;
			this.y = 0;
			this.z = 0;
			this.w = 0;
		} else {
			this.x *= f;
			this.y *= f;
			this.z *= f;
			this.w *= f;
		}
	}

	/**
	 * @fn vmult
	 * @memberof CANNON.Quaternion
	 * @brief Multiply the quaternion by a vector
	 * @param CANNON.Vec3 v
	 * @param CANNON.Vec3 target Optional
	 * @return CANNON.Vec3
	 */
	CANNON.Quaternion.prototype.vmult = function(v,target){
		target = target || new CANNON.Vec3();
		if(this.w==0.0){
			target.x = v.x;
			target.y = v.y;
			target.z = v.z;
		} else {

			var x = v.x,
				y = v.y,
				z = v.z;

			var qx = this.x,
				qy = this.y,
				qz = this.z,
				qw = this.w;

			// q*v
			var ix =  qw * x + qy * z - qz * y,
				iy =  qw * y + qz * x - qx * z,
				iz =  qw * z + qx * y - qy * x,
				iw = -qx * x - qy * y - qz * z;

			target.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
			target.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
			target.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
		}

		return target;
	};

	/**
	 * @fn copy
	 * @memberof CANNON.Quaternion
	 * @param CANNON.Quaternion target
	 */
	CANNON.Quaternion.prototype.copy = function(target){
		target.x = this.x;
		target.y = this.y;
		target.z = this.z;
		target.w = this.w;
	};

	/**
	 * @fn toEuler
	 * @memberof CANNON.Quaternion
	 * @brief Convert the quaternion to euler angle representation. Order: YZX, as this page describes: http://www.euclideanspace.com/maths/standards/index.htm
	 * @param CANNON.Vec3 target
	 * @param string order Three-character string e.g. "YZX", which also is default.
	 */
	CANNON.Quaternion.prototype.toEuler = function(target,order){
		order = order || "YZX";

		var heading, attitude, bank;
		var x = this.x, y = this.y, z = this.z, w = this.w;

		switch(order){
			case "YZX":
				var test = x*y + z*w;
				if (test > 0.499) { // singularity at north pole
					heading = 2 * Math.atan2(x,w);
					attitude = Math.PI/2;
					bank = 0;
				}
				if (test < -0.499) { // singularity at south pole
					heading = -2 * Math.atan2(x,w);
					attitude = - Math.PI/2;
					bank = 0;
				}
				if(isNaN(heading)){
					var sqx = x*x;
					var sqy = y*y;
					var sqz = z*z;
					heading = Math.atan2(2*y*w - 2*x*z , 1 - 2*sqy - 2*sqz); // Heading
					attitude = Math.asin(2*test); // attitude
					bank = Math.atan2(2*x*w - 2*y*z , 1 - 2*sqx - 2*sqz); // bank
				}
				break;
			default:
				throw new Error("Euler order "+order+" not supported yet.");
				break;
		}

		target.y = heading;
		target.z = attitude;
		target.x = bank;
	};/*global CANNON:true */

	/**
	 * @class CANNON.Shape
	 * @author schteppe
	 * @brief Base class for shapes
	 */
	CANNON.Shape = function(){

		/**
		 * @property int type
		 * @memberof CANNON.Shape
		 * @brief The type of this shape. Must be set to an int > 0 by subclasses.
		 * @see CANNON.Shape.types
		 */
		this.type = 0;

		this.aabbmin = new CANNON.Vec3();
		this.aabbmax = new CANNON.Vec3();
	};
	CANNON.Shape.prototype.constructor = CANNON.Shape;

	/**
	 * @fn boundingSphereRadius
	 * @memberof CANNON.Shape
	 * @brief Get the bounding sphere radius from this shape
	 * @return float
	 */
	CANNON.Shape.prototype.boundingSphereRadius = function(){
		throw "boundingSphereRadius() not implemented for shape type "+this.type;
	};

	/**
	 * @fn volume
	 * @memberof CANNON.Shape
	 * @brief Get the volume of this shape
	 * @return float
	 */
	CANNON.Shape.prototype.volume = function(){
		throw "volume() not implemented for shape type "+this.type;
	};

	/**
	 * @fn calculateLocalInertia
	 * @memberof CANNON.Shape
	 * @brief Calculates the inertia in the local frame for this shape.
	 * @return CANNON.Vec3
	 * @see http://en.wikipedia.org/wiki/List_of_moments_of_inertia
	 */
	CANNON.Shape.prototype.calculateLocalInertia = function(mass,target){
		throw "calculateLocalInertia() not implemented for shape type "+this.type;
	};

	/**
	 * @fn calculateTransformedInertia
	 * @memberof CANNON.Shape
	 * @brief Calculates inertia in a specified frame for this shape.
	 * @return CANNON.Vec3
	 */
	CANNON.Shape.prototype.calculateTransformedInertia = function(mass,quat,target){
		if(target==undefined)
			target = new CANNON.Vec3();

		// Compute inertia in the world frame
		quat.normalize();
		var localInertia = this.calculateLocalInertia(mass);

		// @todo Is this rotation OK? Check!
		var worldInertia = quat.vmult(localInertia);
		target.x = Math.abs(worldInertia.x);
		target.y = Math.abs(worldInertia.y);
		target.z = Math.abs(worldInertia.z);
		return target;
		//throw "calculateInertia() not implemented for shape type "+this.type;
	};

	/**
	 * @enum CANNON.Shape.types
	 * @brief The available shape types.
	 */
	CANNON.Shape.types = {
		SPHERE:1,
		PLANE:2,
		BOX:4,
		COMPOUND:8,
		CONVEXPOLYHEDRON:16
	};

	/*global CANNON:true */

	/**
	 * @class CANNON.Body
	 * @brief Base class for all body types.
	 * @param string type
	 */
	CANNON.Body = function(type){

		CANNON.EventTarget.apply(this);

		this.type = type;

		var that = this;

		/**
		 * @property CANNON.World world
		 * @memberof CANNON.Body
		 * @brief Reference to the world the body is living in
		 */
		this.world = null;

		/**
		 * @property function preStep
		 * @memberof CANNON.Body
		 * @brief Callback function that is used BEFORE stepping the system. Use it to apply forces, for example. Inside the function, "this" will refer to this CANNON.Body object.
		 * @todo dispatch an event from the World instead
		 */
		this.preStep = null;

		/**
		 * @property function postStep
		 * @memberof CANNON.Body
		 * @brief Callback function that is used AFTER stepping the system. Inside the function, "this" will refer to this CANNON.Body object.
		 * @todo dispatch an event from the World instead
		 */
		this.postStep = null;
	};

	/**
	 * @brief A dynamic body is fully simulated. Can be moved manually by the user, but normally they move according to forces. A dynamic body can collide with all body types. A dynamic body always has finite, non-zero mass.
	 */
	CANNON.Body.DYNAMIC = 1;

	/**
	 * @brief A static body does not move during simulation and behaves as if it has infinite mass. Static bodies can be moved manually by setting the position of the body. The velocity of a static body is always zero. Static bodies do not collide with other static or kinematic bodies.
	 */
	CANNON.Body.STATIC = 2;

	/**
	 * A kinematic body moves under simulation according to its velocity. They do not respond to forces. They can be moved manually, but normally a kinematic body is moved by setting its velocity. A kinematic body behaves as if it has infinite mass. Kinematic bodies do not collide with other static or kinematic bodies.
	 */
	CANNON.Body.KINEMATIC = 4;/*global CANNON:true */

	/**
	 * @class CANNON.Particle
	 * @param float mass
	 * @param CANNON.Material material
	 */
	CANNON.Particle = function(mass,material){

		// Check input
		if(typeof(mass)!="number")
			throw new Error("Argument 1 (mass) must be a number.");
		if(typeof(material)!="undefined" && !(material instanceof(CANNON.Material)))
			throw new Error("Argument 3 (material) must be an instance of CANNON.Material.");

		CANNON.Body.call(this,"particle");

		var that = this;

		/**
		 * @property CANNON.Vec3 position
		 * @memberof CANNON.Particle
		 */
		this.position = new CANNON.Vec3();

		/**
		 * @property CANNON.Vec3 initPosition
		 * @memberof CANNON.Particle
		 * @brief Initial position of the body
		 */
		this.initPosition = new CANNON.Vec3();

		/**
		 * @property CANNON.Vec3 velocity
		 * @memberof CANNON.Particle
		 */
		this.velocity = new CANNON.Vec3();

		/**
		 * @property CANNON.Vec3 initVelocity
		 * @memberof CANNON.Particle
		 */
		this.initVelocity = new CANNON.Vec3();

		/**
		 * @property CANNON.Vec3 force
		 * @memberof CANNON.Particle
		 * @brief Linear force on the body
		 */
		this.force = new CANNON.Vec3();

		/**
		 * @property float mass
		 * @memberof CANNON.Particle
		 */
		this.mass = mass;

		/**
		 * @property float invMass
		 * @memberof CANNON.Particle
		 */
		this.invMass = mass>0 ? 1.0/mass : 0;

		/**
		 * @property CANNON.Material material
		 * @memberof CANNON.Particle
		 */
		this.material = material;

		/**
		 * @property float linearDamping
		 * @memberof CANNON.Particle
		 */
		this.linearDamping = 0.01; // Perhaps default should be zero here?

		/**
		 * @property int motionstate
		 * @memberof CANNON.Particle
		 * @brief One of the states CANNON.Body.DYNAMIC, CANNON.Body.STATIC and CANNON.Body.KINEMATIC
		 */
		this.motionstate = (mass <= 0.0 ? CANNON.Body.STATIC : CANNON.Body.DYNAMIC);

		/**
		 * @property bool allowSleep
		 * @memberof CANNON.Particle
		 * @brief If true, the body will automatically fall to sleep.
		 */
		this.allowSleep = true;

		// 0:awake, 1:sleepy, 2:sleeping
		var sleepState = 0;

		/**
		 * @fn isAwake
		 * @memberof CANNON.Particle
		 */
		this.isAwake = function(){ return sleepState == 0; }

		/**
		 * @fn isSleepy
		 * @memberof CANNON.Particle
		 */
		this.isSleepy = function(){ return sleepState == 1; }

		/**
		 * @fn isSleeping
		 * @memberof CANNON.Particle
		 */
		this.isSleeping = function(){ return sleepState == 2; }

		/**
		 * @property float sleepSpeedLimit
		 * @memberof CANNON.Particle
		 * @brief If the speed (the norm of the velocity) is smaller than this value, the body is considered sleepy.
		 */
		this.sleepSpeedLimit = 0.1;

		/**
		 * @property float sleepTimeLimit
		 * @memberof CANNON.Particle
		 * @brief If the body has been sleepy for this sleepTimeLimit milliseconds, it is considered sleeping.
		 */
		this.sleepTimeLimit = 1000;
		var timeLastSleepy = new Date().getTime();

		/**
		 * @fn wakeUp
		 * @memberof CANNON.Particle
		 * @brief Wake the body up.
		 */
		this.wakeUp = function(){
			sleepState = 0;
			that.dispatchEvent({type:"wakeup"});
		};

		/**
		 * @fn sleep
		 * @memberof CANNON.Particle
		 * @brief Force body sleep
		 */
		this.sleep = function(){
			sleepState = 2;
		};

		/**
		 * @fn sleepTick
		 * @memberof CANNON.Particle
		 * @brief Called every timestep to update internal sleep timer and change sleep state if needed.
		 */
		this.sleepTick = function(){
			if(that.allowSleep){
				if(sleepState==0 && that.velocity.norm()<that.sleepSpeedLimit){
					sleepState = 1; // Sleepy
					timeLastSleepy = new Date().getTime();
					that.dispatchEvent({type:"sleepy"});
				} else if(sleepState==1 && that.velocity.norm()>that.sleepSpeedLimit){
					that.wakeUp(); // Wake up
				} else if(sleepState==1 && (new Date().getTime() - timeLastSleepy)>that.sleepTimeLimit){
					sleepState = 2; // Sleeping
					that.dispatchEvent({type:"sleep"});
				}
			}
		};
	};
	/*global CANNON:true */

	/**
	 * @class CANNON.RigidBody
	 * @brief Rigid body base class
	 * @param float mass
	 * @param CANNON.Shape shape
	 * @param CANNON.Material material
	 */
	CANNON.RigidBody = function(mass,shape,material){

		// Check input
		if(typeof(mass)!="number")
			throw new Error("Argument 1 (mass) must be a number.");
		if(typeof(shape)!="object" || !(shape instanceof(CANNON.Shape)))
			throw new Error("Argument 2 (shape) must be an instance of CANNON.Shape.");
		if(typeof(material)!="undefined" && !(material instanceof(CANNON.Material)))
			throw new Error("Argument 3 (material) must be an instance of CANNON.Material.");

		CANNON.Particle.call(this,mass,material);

		var that = this;

		/**
		 * @property CANNON.Vec3 tau
		 * @memberof CANNON.RigidBody
		 * @brief Rotational force on the body, around center of mass
		 */
		this.tau = new CANNON.Vec3();

		/**
		 * @property CANNON.Quaternion quaternion
		 * @memberof CANNON.RigidBody
		 * @brief Orientation of the body
		 */
		this.quaternion = new CANNON.Quaternion();

		/**
		 * @property CANNON.Quaternion initQuaternion
		 * @memberof CANNON.RigidBody
		 */
		this.initQuaternion = new CANNON.Quaternion();

		/**
		 * @property CANNON.Vec3 angularVelocity
		 * @memberof CANNON.RigidBody
		 */
		this.angularVelocity = new CANNON.Vec3();

		/**
		 * @property CANNON.Vec3 initAngularVelocity
		 * @memberof CANNON.RigidBody
		 */
		this.initAngularVelocity = new CANNON.Vec3();

		/**
		 * @property CANNON.Shape shape
		 * @memberof CANNON.RigidBody
		 */
		this.shape = shape;

		/**
		 * @property CANNON.Vec3 inertia
		 * @memberof CANNON.RigidBody
		 */
		this.inertia = new CANNON.Vec3();
		shape.calculateLocalInertia(mass,this.inertia);

		/**
		 * @property CANNON.Vec3 intInertia
		 * @memberof CANNON.RigidBody
		 */
		this.invInertia = new CANNON.Vec3(this.inertia.x>0 ? 1.0/this.inertia.x : 0,
			this.inertia.y>0 ? 1.0/this.inertia.y : 0,
			this.inertia.z>0 ? 1.0/this.inertia.z : 0);

		/**
		 * @property float angularDamping
		 * @memberof CANNON.RigidBody
		 */
		this.angularDamping = 0.01; // Perhaps default should be zero here?
	};
	/*global CANNON:true */

	/**
	 * @brief Spherical rigid body
	 * @class CANNON.Sphere
	 * @extends CANNON.Shape
	 * @param float radius
	 * @author schteppe / http://github.com/schteppe
	 */
	CANNON.Sphere = function(radius){
		CANNON.Shape.call(this);
		this.radius = radius!=undefined ? Number(radius) : 1.0;
		this.type = CANNON.Shape.types.SPHERE;
	};
	CANNON.Sphere.prototype = new CANNON.Shape();
	CANNON.Sphere.prototype.constructor = CANNON.Sphere;

	CANNON.Sphere.prototype.calculateLocalInertia = function(mass,target){
		target = target || new CANNON.Vec3();
		var I = 2.0*mass*this.radius*this.radius/5.0;
		target.x = I;
		target.y = I;
		target.z = I;
		return target;
	};

	CANNON.Sphere.prototype.volume = function(){
		return 4.0 * Math.PI * this.radius / 3.0;
	};

	CANNON.Sphere.prototype.boundingSphereRadius = function(){
		return this.radius;
	};/*global CANNON:true */

	/**
	 * @class CANNON.Box
	 * @brief A 3d box shape.
	 * @param CANNON.Vec3 halfExtents
	 * @author schteppe
	 * @extends CANNON.Shape
	 */
	CANNON.Box = function(halfExtents){
		CANNON.Shape.call(this);

		/**
		 * @property CANNON.Vec3 halfExtents
		 * @memberof CANNON.Box
		 */
		this.halfExtents = halfExtents;
		this.type = CANNON.Shape.types.BOX;

		/**
		 *
		 */
		this.convexPolyhedronRepresentation = null;

		this.updateConvexPolyhedronRepresentation();
	};
	CANNON.Box.prototype = new CANNON.Shape();
	CANNON.Box.prototype.constructor = CANNON.Box;

	/**
	 * @fn updateConvexPolyhedronRepresentation
	 * @memberof CANNON.Box
	 * @brief Updates the local convex polyhedron representation used for some collisions.
	 */
	CANNON.Box.prototype.updateConvexPolyhedronRepresentation = function(){
		var sx = this.halfExtents.x;
		var sy = this.halfExtents.y;
		var sz = this.halfExtents.z;
		var v = CANNON.Vec3;
		var h = new CANNON.ConvexPolyhedron([new v(-sx,-sy,-sz),
			new v( sx,-sy,-sz),
			new v( sx, sy,-sz),
			new v(-sx, sy,-sz),
			new v(-sx,-sy, sz),
			new v( sx,-sy, sz),
			new v( sx, sy, sz),
			new v(-sx, sy, sz)],

			[
				[0,1,2,3], // -z
				[4,5,6,7], // +z
				[0,1,4,5], // -y
				[2,3,6,7], // +y
				[0,3,4,7], // -x
				[1,2,5,6], // +x
			],

			[new v( 0, 0,-1),
				new v( 0, 0, 1),
				new v( 0,-1, 0),
				new v( 0, 1, 0),
				new v(-1, 0, 0),
				new v( 1, 0, 0)]);
		this.convexPolyhedronRepresentation = h;
	};

	CANNON.Box.prototype.calculateLocalInertia = function(mass,target){
		target = target || new CANNON.Vec3();
		target.x = 1.0 / 12.0 * mass * (   2*this.halfExtents.y*2*this.halfExtents.y
			+ 2*this.halfExtents.z*2*this.halfExtents.z );
		target.y = 1.0 / 12.0 * mass * (   2*this.halfExtents.x*2*this.halfExtents.x
			+ 2*this.halfExtents.z*2*this.halfExtents.z );
		target.z = 1.0 / 12.0 * mass * (   2*this.halfExtents.y*2*this.halfExtents.y
			+ 2*this.halfExtents.x*2*this.halfExtents.x );
		return target;
	};

	/**
	 * @fn getCorners
	 * @memberof CANNON.Box
	 * @brief Get the box corners
	 * @param CANNON.Quaternion quat Orientation to apply to the corner vectors. If not provided, the vectors will be in respect to the local frame.
	 * @return array
	 */
	CANNON.Box.prototype.getCorners = function(quat){
		var corners = [];
		var ex = this.halfExtents;
		corners.push(new CANNON.Vec3(  ex.x,  ex.y,  ex.z));
		corners.push(new CANNON.Vec3( -ex.x,  ex.y,  ex.z));
		corners.push(new CANNON.Vec3( -ex.x, -ex.y,  ex.z));
		corners.push(new CANNON.Vec3( -ex.x, -ex.y, -ex.z));
		corners.push(new CANNON.Vec3(  ex.x, -ex.y, -ex.z));
		corners.push(new CANNON.Vec3(  ex.x,  ex.y, -ex.z));
		corners.push(new CANNON.Vec3( -ex.x,  ex.y, -ex.z));
		corners.push(new CANNON.Vec3(  ex.x, -ex.y,  ex.z));

		for(var i=0; quat!=undefined && i<corners.length; i++)
			quat.vmult(corners[i],corners[i]);

		return corners;
	};

	/**
	 * @fn getSideNormals
	 * @memberof CANNON.Box
	 * @brief Get the box 6 side normals
	 * @param bool includeNegative If true, this function returns 6 vectors. If false, it only returns 3 (but you get 6 by reversing those 3)
	 * @param CANNON.Quaternion quat Orientation to apply to the normal vectors. If not provided, the vectors will be in respect to the local frame.
	 * @return array
	 */
	CANNON.Box.prototype.getSideNormals = function(includeNegative,quat){
		var sides = [];
		var ex = this.halfExtents;
		sides.push(new CANNON.Vec3(  ex.x,     0,     0));
		sides.push(new CANNON.Vec3(     0,  ex.y,     0));
		sides.push(new CANNON.Vec3(     0,     0,  ex.z));
		if(includeNegative!=undefined && includeNegative){
			sides.push(new CANNON.Vec3( -ex.x,     0,     0));
			sides.push(new CANNON.Vec3(     0, -ex.y,     0));
			sides.push(new CANNON.Vec3(     0,     0, -ex.z));
		}

		for(var i=0; quat!=undefined && i<sides.length; i++)
			quat.vmult(sides[i],sides[i]);

		return sides;
	};

	CANNON.Box.prototype.volume = function(){
		return 8.0 * this.halfExtents.x * this.halfExtents.y * this.halfExtents.z;
	};

	CANNON.Box.prototype.boundingSphereRadius = function(){
		return this.halfExtents.norm();
	};/*global CANNON:true */

	/**
	 * @class CANNON.Plane
	 * @extends CANNON.Shape
	 * @param CANNON.Vec3 normal
	 * @brief An infinite plane, facing in the direction of the given normal.
	 * @author schteppe
	 */
	CANNON.Plane = function(normal){
		CANNON.Shape.call(this);
		normal.normalize();
		this.normal = normal;
		this.type = CANNON.Shape.types.PLANE;
	};
	CANNON.Plane.prototype = new CANNON.Shape();
	CANNON.Plane.prototype.constructor = CANNON.Plane;

	CANNON.Plane.prototype.calculateLocalInertia = function(mass,target){
		target = target || new CANNON.Vec3();
		return target;
	};

	CANNON.Plane.prototype.volume = function(){
		return Infinity; // The plane is infinite...
	};/*global CANNON:true */

	/**
	 * @class CANNON.Compound
	 * @extends CANNON.Shape
	 * @brief A shape that is built of several other shapes, in this context called child shapes.
	 * @author schteppe
	 */
	CANNON.Compound = function(){
		CANNON.Shape.call(this);
		this.type = CANNON.Shape.types.COMPOUND;
		this.childShapes = [];
		this.childOffsets = [];
		this.childOrientations = [];
	};
	CANNON.Compound.prototype = new CANNON.Shape();
	CANNON.Compound.prototype.constructor = CANNON.Compound;

	/**
	 * @fn addChild
	 * @memberof CANNON.Compound
	 * @brief Add a child shape.
	 * @param CANNON.Shape shape
	 * @param CANNON.Vec3 offset
	 * @param CANNON.Quaternion orientation
	 */
	CANNON.Compound.prototype.addChild = function(shape,offset,orientation){
		offset = offset || new CANNON.Vec3();
		orientation = orientation || new CANNON.Quaternion();
		this.childShapes.push(shape);
		this.childOffsets.push(offset);
		this.childOrientations.push(orientation);
	};

	CANNON.Compound.prototype.volume = function(){
		var r = 0.0;
		for(var i = 0; i<this.childShapes.length; i++)
			r += this.childShapes[i].volume();
		return r;
	};

	CANNON.Compound.prototype.calculateLocalInertia = function(mass,target){
		target = target || new CANNON.Vec3();

		// Calculate the total volume, we will spread out this objects' mass on the sub shapes
		var V = this.volume();

		for(var i = 0; i<this.childShapes.length; i++){
			// Get child information
			var b = this.childShapes[i];
			var o = this.childOffsets[i];
			var q = this.childOrientations[i];
			var m = b.volume() / V * mass;

			// Get the child inertia, transformed relative to local frame
			var inertia = b.calculateTransformedInertia(m,q);

			// Add its inertia using the parallel axis theorem, i.e.
			// I += I_child;    
			// I += m_child * r^2

			target.vadd(inertia,target);
			var mr2 = new CANNON.Vec3(m*o.x*o.x,
				m*o.y*o.y,
				m*o.z*o.z);
			target.vadd(mr2,target);
		}
		return target;
	};

	CANNON.Compound.prototype.boundingSphereRadius = function(){
		var r = 0.0;
		for(var i = 0; i<this.childShapes.length; i++){
			var candidate = this.childOffsets[i].norm() + this.childShapes[i].boundingSphereRadius();
			if(r < candidate)
				r = candidate;
		}
		return r;
	};/**
	 * @class CANNON.ConvexPolyhedron
	 * @extends CANNON.Shape
	 * @brief A set of points in space describing a convex shape.
	 * @author qiao / https://github.com/qiao (original author, see https://github.com/qiao/three.js/commit/85026f0c769e4000148a67d45a9e9b9c5108836f)
	 * @author schteppe / https://github.com/schteppe
	 * @see http://www.altdevblogaday.com/2011/05/13/contact-generation-between-3d-convex-meshes/
	 * @see http://bullet.googlecode.com/svn/trunk/src/BulletCollision/NarrowPhaseCollision/btPolyhedralContactClipping.cpp
	 * @todo move the clipping functions to ContactGenerator?
	 * @param array points An array of CANNON.Vec3's
	 * @param array faces Deprecated - fix autogenerator for these
	 * @param array normals Deprecated - fix autogenerator for these
	 */
	CANNON.ConvexPolyhedron = function( points , faces , normals ) {
		var that = this;
		CANNON.Shape.call( this );
		this.type = CANNON.Shape.types.CONVEXPOLYHEDRON;

		/**
		 * @property array vertices
		 * @memberof CANNON.ConvexPolyhedron
		 * @brief Array of CANNON.Vec3
		 */
		this.vertices = [];

		/**
		 * @property array faces
		 * @memberof CANNON.ConvexPolyhedron
		 * @brief Array of integer arrays, indicating which vertices each face consists of
		 * @todo Needed?
		 */
		this.faces = faces;

		/**
		 * @property array faceNormals
		 * @memberof CANNON.ConvexPolyhedron
		 * @brief Array of CANNON.Vec3
		 * @todo Needed?
		 */
		this.faceNormals = normals;

		/**
		 * @property array uniqueEdges
		 * @memberof CANNON.ConvexPolyhedron
		 * @brief Array of CANNON.Vec3
		 */
		this.uniqueEdges = [];

		for(pi in points){
			var p = points[pi];
			if(!(p instanceof CANNON.Vec3)){
				throw "Argument 1 must be instance of CANNON.Vec3";
				return false;
			}
			this.vertices.push(p);
		}

		for(var i=0; i<faces.length; i++){
			var numVertices = faces[i].length;
			var NbTris = numVertices;
			for(var j=0; j<NbTris; j++){
				var k = ( j+1 ) % numVertices;
				var edge = new CANNON.Vec3();
				this.vertices[faces[i][j]].vsub(this.vertices[faces[i][k]],edge);
				edge.normalize();
				var found = false;
				for(var p=0;p<this.uniqueEdges.length;p++){
					if (this.uniqueEdges[p].almostEquals(edge) ||
						this.uniqueEdges[p].almostEquals(edge)){
						found = true;
						break;
					}
				}

				// What is this for???
				if (!found){
					this.uniqueEdges.push(edge);
				}

				if (edge) {
					edge.face1 = i;
				} else {
					var ed;
					ed.m_face0 = i;
					edges.insert(vp,ed);
				}
			}
		}

		/**
		 * Get max and min dot product of a convex hull at position (pos,quat) projected onto an axis. Results are saved in the array maxmin.
		 * @param CANNON.ConvexPolyhedron hull
		 * @param CANNON.Vec3 axis
		 * @param CANNON.Vec3 pos
		 * @param CANNON.Quaternion quat
		 * @param array maxmin maxmin[0] and maxmin[1] will be set to maximum and minimum, respectively.
		 */
		function project(hull,axis,pos,quat,maxmin){
			var n = hull.vertices.length;
			var max = null;
			var min = null;
			var vs = hull.vertices;
			var worldVertex = new CANNON.Vec3();
			for(var i=0; i<n; i++){
				vs[i].copy(worldVertex);
				//console.log("orig:",worldVertex.toString());
				quat.vmult(worldVertex,worldVertex);
				//console.log("after the quat ",quat.toString(),":",worldVertex.toString());
				worldVertex.vadd(pos,worldVertex);
				//console.log("after adding pos",pos.toString(),"worldvertex:",worldVertex.toString());
				var val = worldVertex.dot(axis);
				if(max===null || val>max)
					max = val;
				if(min===null || val<min){
					min = val;
				}
			}

			if(min>max){
				// Inconsistent - swap
				var temp = min;
				min = max;
				max = temp;
			}

			// Output
			maxmin[0] = max;
			maxmin[1] = min;
		}

		/**
		 * @fn testSepAxis
		 * @memberof CANNON.ConvexPolyhedron
		 * @brief Test separating axis against two hulls. Both hulls are projected onto the axis and the overlap size is returned if there is one.
		 * @param CANNON.Vec3 axis
		 * @param CANNON.ConvexPolyhedron hullB
		 * @param CANNON.Vec3 posA
		 * @param CANNON.Quaternion quatA
		 * @param CANNON.Vec3 posB
		 * @param CANNON.Quaternion quatB
		 * @return float The overlap depth, or FALSE if no penetration.
		 */
		this.testSepAxis = function(axis, hullB, posA, quatA, posB, quatB){
			var maxminA=[], maxminB=[], hullA=this;
			project(hullA, axis, posA, quatA, maxminA);
			project(hullB, axis, posB, quatB, maxminB);
			var maxA = maxminA[0];
			var minA = maxminA[1];
			var maxB = maxminB[0];
			var minB = maxminB[1];
			if(maxA<minB || maxB<minA){
				//console.log(minA,maxA,minB,maxB);
				return false; // Separated
			}

			var d0 = maxA - minB;
			var d1 = maxB - minA;
			depth = d0<d1 ? d0:d1;
			return depth;
		}

		/**
		 * @fn findSeparatingAxis
		 * @memberof CANNON.ConvexPolyhedron
		 * @brief Find the separating axis between this hull and another
		 * @param CANNON.ConvexPolyhedron hullB
		 * @param CANNON.Vec3 posA
		 * @param CANNON.Quaternion quatA
		 * @param CANNON.Vec3 posB
		 * @param CANNON.Quaternion quatB
		 * @param CANNON.Vec3 target The target vector to save the axis in
		 * @return bool Returns false if a separation is found, else true
		 */
		this.findSeparatingAxis = function(hullB,posA,quatA,posB,quatB,target){
			var dmin = Infinity;
			var hullA = this;
			var curPlaneTests=0;
			var numFacesA = hullA.faces.length;

			// Test normals from hullA
			var faceANormalWS = new CANNON.Vec3();
			for(var i=0; i<numFacesA; i++){
				// Get world face normal
				hullA.faceNormals[i].copy(faceANormalWS);
				quatA.vmult(faceANormalWS,faceANormalWS);
				//posA.vadd(faceANormalWS,faceANormalWS); // Needed?
				//console.log("face normal:",hullA.faceNormals[i].toString(),"world face normal:",faceANormalWS);

				var d = hullA.testSepAxis(faceANormalWS, hullB, posA, quatA, posB, quatB);
				if(d===false){
					return false;
				}

				if(d<dmin){
					dmin = d;
					faceANormalWS.copy(target);
				}
			}

			// Test normals from hullB
			var WorldNormal = new CANNON.Vec3();
			var numFacesB = hullB.faces.length;
			for(var i=0;i<numFacesB;i++){
				hullB.faceNormals[i].copy(WorldNormal);
				quatB.vmult(WorldNormal,WorldNormal);
				//posB.vadd(WorldNormal,WorldNormal);
				//console.log("facenormal",hullB.faceNormals[i].toString(),"world:",WorldNormal.toString());
				curPlaneTests++;
				var d = hullA.testSepAxis(WorldNormal, hullB,posA,quatA,posB,quatB);
				if(d===false){
					return false;
				}

				if(d<dmin){
					dmin = d;
					WorldNormal.copy(target);
				}
			}

			var edgeAstart,edgeAend,edgeBstart,edgeBend;

			var curEdgeEdge = 0;
			// Test edges
			var WorldEdge0 = new CANNON.Vec3();
			var WorldEdge1 = new CANNON.Vec3();
			var Cross = new CANNON.Vec3();
			for(var e0=0; e0<hullA.uniqueEdges.length; e0++){
				// Get world edge
				hullA.uniqueEdges[e0].copy(WorldEdge0);
				quatA.vmult(WorldEdge0,WorldEdge0);
				//posA.vadd(WorldEdge0,WorldEdge0); // needed?

				//console.log("edge0:",WorldEdge0.toString());

				for(var e1=0; e1<hullB.uniqueEdges.length; e1++){
					hullB.uniqueEdges[e1].copy(WorldEdge1);
					quatB.vmult(WorldEdge1,WorldEdge1);
					//posB.vadd(WorldEdge1,WorldEdge1); // needed?
					//console.log("edge1:",WorldEdge1.toString());

					WorldEdge0.cross(WorldEdge1,Cross);

					curEdgeEdge++;
					if(!Cross.almostZero()){
						Cross.normalize();
						var dist = hullA.testSepAxis( Cross, hullB, posA,quatA,posB,quatB);
						if(dist===false){
							return false;
						}

						if(dist<dmin){
							dmin = dist;
							Cross.copy(target);
						}
					}
				}
			}

			var deltaC = new CANNON.Vec3();
			posB.vsub(posA,deltaC);
			if((deltaC.dot(target))>0.0)
				target.negate(target);

			return true;
		}

		/**
		 * @fn clipAgainstHull
		 * @memberof CANNON.ConvexPolyhedron
		 * @brief Clip this hull against another hull
		 * @param CANNON.Vec3 posA
		 * @param CANNON.Quaternion quatA
		 * @param CANNON.ConvexPolyhedron hullB
		 * @param CANNON.Vec3 posB
		 * @param CANNON.Quaternion quatB
		 * @param CANNON.Vec3 separatingNormal
		 * @param float minDist Clamp distance
		 * @param float maxDist
		 * @param array result The an array of contact point objects, see clipFaceAgainstHull
		 * @see http://bullet.googlecode.com/svn/trunk/src/BulletCollision/NarrowPhaseCollision/btPolyhedralContactClipping.cpp
		 */
		this.clipAgainstHull = function(posA,quatA,hullB,posB,quatB,separatingNormal,minDist,maxDist,result){
			if(!(posA instanceof CANNON.Vec3))
				throw new Error("posA must be Vec3");
			if(!(quatA instanceof CANNON.Quaternion))
				throw new Error("quatA must be Quaternion");
			var hullA = this;
			var curMaxDist = maxDist;
			var closestFaceB = -1;
			var dmax = -Infinity;
			var WorldNormal = new CANNON.Vec3();
			for(var face=0; face < hullB.faces.length; face++){
				hullB.faceNormals[face].copy(WorldNormal);
				quatB.vmult(WorldNormal,WorldNormal);
				posB.vadd(WorldNormal,WorldNormal);

				var d = WorldNormal.dot(separatingNormal);
				if (d > dmax){
					dmax = d;
					closestFaceB = face;
				}
			}
			var worldVertsB1 = [];
			polyB = hullB.faces[closestFaceB];
			var numVertices = polyB.length;
			for(var e0=0; e0<numVertices; e0++){
				var b = hullB.vertices[polyB[e0]];
				var worldb = new CANNON.Vec3();
				b.copy(worldb);
				quatB.vmult(worldb,worldb);
				posB.vadd(worldb,worldb);
				worldVertsB1.push(worldb);
			}
			//console.log("--- clipping face: ",worldVertsB1);
			if (closestFaceB>=0)
				this.clipFaceAgainstHull(separatingNormal,
					posA,
					quatA,
					worldVertsB1,
					minDist,
					maxDist,
					result);
		};

		/**
		 * @fn clipFaceAgainstHull
		 * @memberof CANNON.ConvexPolyhedron
		 * @brief Clip a face against a hull.
		 * @param CANNON.Vec3 separatingNormal
		 * @param CANNON.Vec3 posA
		 * @param CANNON.Quaternion quatA
		 * @param Array worldVertsB1 An array of CANNON.Vec3 with vertices in the world frame.
		 * @param float minDist Distance clamping
		 * @param float maxDist
		 * @param Array result Array to store resulting contact points in. Will be objects with properties: point, depth, normal. These are represented in world coordinates.
		 */
		this.clipFaceAgainstHull = function(separatingNormal, posA, quatA, worldVertsB1, minDist, maxDist,result){
			if(!(separatingNormal instanceof CANNON.Vec3))
				throw new Error("sep normal must be vector");
			if(!(worldVertsB1 instanceof Array))
				throw new Error("world verts must be array");
			minDist = Number(minDist);
			maxDist = Number(maxDist);
			var hullA = this;
			var worldVertsB2 = [];
			var pVtxIn = worldVertsB1;
			var pVtxOut = worldVertsB2;

			// Find the face with normal closest to the separating axis
			var closestFaceA = -1;
			var dmin = Infinity;
			var faceANormalWS = new CANNON.Vec3();
			for(var face=0; face<hullA.faces.length; face++){
				hullA.faceNormals[face].copy(faceANormalWS);
				quatA.vmult(faceANormalWS,faceANormalWS);
				posA.vadd(faceANormalWS,faceANormalWS);
				var d = faceANormalWS.dot(separatingNormal);
				if (d < dmin){
					dmin = d;
					closestFaceA = face;
				}
			}
			if (closestFaceA<0){
				console.log("--- did not find any closest face... ---");
				return;
			}
			//console.log("closest A: ",closestFaceA);

			// Get the face and construct connected faces
			var polyA = hullA.faces[closestFaceA];
			polyA.connectedFaces = [];
			for(var i=0; i<hullA.faces.length; i++)
				for(var j=0; j<hullA.faces[i].length; j++)
					if(polyA.indexOf(hullA.faces[i][j])!==-1 && // Sharing a vertex
						i!==closestFaceA && // Not the one we are looking for connections from
						polyA.connectedFaces.indexOf(i)===-1 // Not already added
						)
						polyA.connectedFaces.push(i);

			// Clip the polygon to the back of the planes of all faces of hull A, that are adjacent to the witness face
			var numContacts = pVtxIn.length;
			var numVerticesA = polyA.length;
			var edge0 = new CANNON.Vec3();
			var WorldEdge0 = new CANNON.Vec3();
			var worldPlaneAnormal1 = new CANNON.Vec3();
			var planeNormalWS1 = new CANNON.Vec3();
			var res = [];
			for(var e0=0; e0<numVerticesA; e0++){
				var a = hullA.vertices[polyA[e0]];
				var b = hullA.vertices[polyA[(e0+1)%numVerticesA]];
				a.vsub(b,edge0);
				edge0.copy(WorldEdge0);
				quatA.vmult(WorldEdge0,WorldEdge0);
				posA.vadd(WorldEdge0,WorldEdge0);
				this.faceNormals[closestFaceA].copy(worldPlaneAnormal1);//transA.getBasis()* btVector3(polyA.m_plane[0],polyA.m_plane[1],polyA.m_plane[2]);
				quatA.vmult(worldPlaneAnormal1,worldPlaneAnormal1);
				posA.vadd(worldPlaneAnormal1,worldPlaneAnormal1);
				WorldEdge0.cross(worldPlaneAnormal1,planeNormalWS1);
				planeNormalWS1.negate(planeNormalWS1);
				var worldA1 = new CANNON.Vec3();
				a.copy(worldA1);
				quatA.vmult(worldA1,worldA1);
				posA.vadd(worldA1,worldA1);
				var planeEqWS1 = -worldA1.dot(planeNormalWS1);

				if(true){
					var otherFace = polyA.connectedFaces[e0];
					var localPlaneNormal = new CANNON.Vec3();
					this.faceNormals[otherFace].copy(localPlaneNormal);
					var localPlaneEq = planeConstant(otherFace);

					var planeNormalWS = new CANNON.Vec3();
					localPlaneNormal.copy(planeNormalWS);
					quatA.vmult(planeNormalWS,planeNormalWS);
					//posA.vadd(planeNormalWS,planeNormalWS);
					var planeEqWS = localPlaneEq - planeNormalWS.dot(posA);
				} else  {
					var planeNormalWS = planeNormalWS1;
					var planeEqWS = planeEqWS1;
				}

				// Clip face against our constructed plane
				//console.log("clipping polygon ",printFace(closestFaceA)," against plane ",planeNormalWS, planeEqWS);
				this.clipFaceAgainstPlane(pVtxIn, pVtxOut, planeNormalWS, planeEqWS);
				//console.log(" - clip result: ",pVtxOut);

				// Throw away all clipped points, but save the reamining until next clip
				while(pVtxIn.length)  pVtxIn.shift();
				while(pVtxOut.length) pVtxIn.push(pVtxOut.shift());
			}

			//console.log("Resulting points after clip:",pVtxIn);

			// only keep contact points that are behind the witness face
			var localPlaneNormal = new CANNON.Vec3();
			this.faceNormals[closestFaceA].copy(localPlaneNormal);

			var localPlaneEq = planeConstant(closestFaceA);
			var planeNormalWS = new CANNON.Vec3();
			localPlaneNormal.copy(planeNormalWS);
			quatA.vmult(planeNormalWS,planeNormalWS);

			var planeEqWS = localPlaneEq - planeNormalWS.dot(posA);
			for (var i=0; i<pVtxIn.length; i++){
				var depth = planeNormalWS.dot(pVtxIn[i]) + planeEqWS; //???
				/*console.log("depth calc from normal=",planeNormalWS.toString()," and constant "+planeEqWS+" and vertex ",pVtxIn[i].toString()," gives "+depth);*/
				if (depth <=minDist){
					console.log("clamped: depth="+depth+" to minDist="+(minDist+""));
					depth = minDist;
				}

				if (depth <=maxDist){
					var point = pVtxIn[i];
					/*console.log("Got contact point ",point.toString(),
					 ", depth=",depth,
					 "contact normal=",separatingNormal.toString(),
					 "plane",planeNormalWS.toString(),
					 "planeConstant",planeEqWS);*/
					var p = {
						point:point,
						normal:planeNormalWS,
						depth: depth,
					};
					result.push(p);
				}
			}
		}

		/**
		 * @fn clipFaceAgainstPlane
		 * @memberof CANNON.ConvexPolyhedron
		 * @brief Clip a face in a hull against the back of a plane.
		 * @param Array inVertices
		 * @param Array outVertices
		 * @param CANNON.Vec3 planeNormal
		 * @param float planeConstant The constant in the mathematical plane equation
		 */
		this.clipFaceAgainstPlane = function(inVertices,outVertices, planeNormal, planeConstant){
			if(!(planeNormal instanceof CANNON.Vec3))
				throw new Error("planeNormal must be Vec3, "+planeNormal+" given");
			if(!(inVertices instanceof Array))
				throw new Error("invertices must be Array, "+inVertices+" given");
			if(!(outVertices instanceof Array))
				throw new Error("outvertices must be Array, "+outVertices+" given");
			var n_dot_first, n_dot_last;
			var numVerts = inVertices.length;

			if(numVerts < 2)
				return outVertices;

			var firstVertex = inVertices[inVertices.length-1];
			var lastVertex =   inVertices[0];

			n_dot_first = planeNormal.dot(firstVertex) + planeConstant;

			for(var vi = 0; vi < numVerts; vi++){
				lastVertex = inVertices[vi];
				n_dot_last = planeNormal.dot(lastVertex) + planeConstant;
				if(n_dot_first < 0){
					if(n_dot_last < 0){
						// Start < 0, end < 0, so output lastVertex
						var newv = new CANNON.Vec3();
						lastVertex.copy(newv);
						outVertices.push(newv);
					} else {
						// Start < 0, end >= 0, so output intersection
						var newv = new CANNON.Vec3();
						firstVertex.lerp(lastVertex,
							n_dot_first / (n_dot_first - n_dot_last),
							newv);
						outVertices.push(newv);
					}
				} else {
					if(n_dot_last<0){
						// Start >= 0, end < 0 so output intersection and end
						var newv = new CANNON.Vec3();
						firstVertex.lerp(lastVertex,
							n_dot_first / (n_dot_first - n_dot_last),
							newv);
						outVertices.push(newv);
						outVertices.push(lastVertex);
					}
				}
				firstVertex = lastVertex;
				n_dot_first = n_dot_last;
			}
			return outVertices;
		}

		/**
		 * Whether the face is visible from the vertex
		 * @param array face
		 * @param CANNON.Vec3 vertex
		 */
		function visible( face, vertex ) {
			var va = that.vertices[ face[ 0 ] ];
			var vb = that.vertices[ face[ 1 ] ];
			var vc = that.vertices[ face[ 2 ] ];

			var n = new CANNON.Vec3();
			normal( va, vb, vc, n );

			// distance from face to origin
			var dist = n.dot( va );

			return n.dot( vertex ) >= dist;
		}

		var that = this;
		function normalOfFace(i,target){
			var f = that.faces[i];
			var va = that.vertices[f[0]];
			var vb = that.vertices[f[1]];
			var vc = that.vertices[f[2]];
			return normal(va,vb,vc,target);
		}

		function planeConstant(face_i,target){
			var f = that.faces[face_i];
			var n = that.faceNormals[face_i];
			var v = that.vertices[f[0]];
			var c = -n.dot(v);
			return c;
		}

		/**
		 * @brief Get face normal given 3 vertices
		 * @param CANNON.Vec3 va
		 * @param CANNON.Vec3 vb
		 * @param CANNON.Vec3 vc
		 * @param CANNON.Vec3 target
		 * @todo unit test?
		 */
		function normal( va, vb, vc, target ) {
			var cb = new CANNON.Vec3();
			var ab = new CANNON.Vec3();

			vb.vsub(va,ab);
			vc.vsub(vb,cb);
			cb.cross(ab,target);

			if ( !target.isZero() ) {
				target.normalize();
			}
		}

		function printFace(i){
			var f = that.faces[i], s = "";
			for(var j=0; j<f.length; j++)
				s += " ("+that.vertices[f[j]]+")";
			return s;
		}

		/**
		 * Detect whether two edges are equal.
		 * Note that when constructing the convex hull, two same edges can only
		 * be of the negative direction.
		 * @return bool
		 */
		function equalEdge( ea, eb ) {
			return ea[ 0 ] === eb[ 1 ] && ea[ 1 ] === eb[ 0 ];
		}

		/**
		 * Create a random offset between -1e-6 and 1e-6.
		 * @return float
		 */
		function randomOffset() {
			return ( Math.random() - 0.5 ) * 2 * 1e-6;
		}

		this.calculateLocalInertia = function(mass,target){
			// Approximate with box inertia
			// Exact inertia calculation is overkill, but see http://geometrictools.com/Documentation/PolyhedralMassProperties.pdf for the correct way to do it
			var x = this.aabbmax.x - this.aabbmin.x,
				y = this.aabbmax.y - this.aabbmin.y,
				z = this.aabbmax.z - this.aabbmin.z;
			target.x = 1.0 / 12.0 * mass * ( 2*y*2*y + 2*z*2*z );
			target.y = 1.0 / 12.0 * mass * ( 2*x*2*x + 2*z*2*z );
			target.z = 1.0 / 12.0 * mass * ( 2*y*2*y + 2*x*2*x );
		}

		this.computeAABB = function(){
			var n = this.vertices.length,
				aabbmin = this.aabbmin,
				aabbmax = this.aabbmax,
				vertices = this.vertices;
			aabbmin.set(Infinity,Infinity,Infinity);
			aabbmax.set(-Infinity,-Infinity,-Infinity);
			for(var i=0; i<n; i++){
				var v = vertices[i];
				if     (v.x < aabbmin.x) aabbmin.x = v.x;
				else if(v.x > aabbmax.x) aabbmax.x = v.x;
				if     (v.y < aabbmin.y) aabbmin.y = v.y;
				else if(v.y > aabbmax.y) aabbmax.y = v.y;
				if     (v.z < aabbmin.z) aabbmin.z = v.z;
				else if(v.z > aabbmax.z) aabbmax.z = v.z;
			}
		}

		this.boundingSphereRadius = function(){
			// Assume points are distributed with local (0,0,0) as center
			var max2 = 0;
			for(var i=0; i<this.vertices.length; i++) {
				var norm2 = this.vertices[i].norm2();
				if(norm2>max2)
					max2 = norm2;
			}
			return Math.sqrt(max2);
		}

		this.computeAABB();
	};

	CANNON.ConvexPolyhedron.prototype = new CANNON.Shape();
	CANNON.ConvexPolyhedron.prototype.constructor = CANNON.ConvexPolyhedron;/*global CANNON:true */

	/**
	 * @class CANNON.Solver
	 * @brief Constraint solver.
	 * @todo The spook parameters should be specified for each constraint, not globally.
	 * @author schteppe / https://github.com/schteppe
	 * @see https://www8.cs.umu.se/kurser/5DV058/VT09/lectures/spooknotes.pdf
	 */
	CANNON.Solver = function(){

		/**
		 * @property int iterations
		 * @brief The number of solver iterations determines quality of the constraints in the world. The more iterations, the more correct simulation. More iterations need more computations though. If you have a large gravity force in your world, you will need more iterations.
		 * @todo write more about solver and iterations in the wiki
		 * @memberof CANNON.Solver
		 */
		this.iterations = 10;

		/**
		 * @property float h
		 * @brief Time step size. The larger timestep, the less computationally heavy will your simulation be. But watch out, you don't want your bodies to tunnel each instead of colliding!
		 * @memberof CANNON.Solver
		 */
		this.h = 1.0/60.0;

		/**
		 * @property float k
		 * @brief SPOOK parameter, spring stiffness
		 * @memberof CANNON.Solver
		 */
		this.k = 1000;

		/**
		 * @property float d
		 * @brief SPOOK parameter, similar to damping
		 * @memberof CANNON.Solver
		 */
		this.d = 4;

		/**
		 * @property float a
		 * @brief SPOOK parameter
		 * @memberof CANNON.Solver
		 */
		this.a = 0.0;

		/**
		 * @property float b
		 * @brief SPOOK parameter
		 * @memberof CANNON.Solver
		 */
		this.b = 0.0;

		/**
		 * @property float eps
		 * @brief SPOOK parameter
		 * @memberof CANNON.Solver
		 */
		this.eps = 0.0;

		this.setSpookParams(this.k,this.d);
		this.reset(0);

		/**
		 * @property bool debug
		 * @brief Debug flag, will output solver data to console if true
		 * @memberof CANNON.Solver
		 */
		this.debug = false;

		if(this.debug)
			console.log("a:",this.a,"b",this.b,"eps",this.eps,"k",this.k,"d",this.d);
	};

	/**
	 * @fn setSpookParams
	 * @memberof CANNON.Solver
	 * @brief Sets the SPOOK parameters k and d, and updates the other parameters a, b and eps accordingly.
	 * @param float k
	 * @param float d
	 */
	CANNON.Solver.prototype.setSpookParams = function(k,d){
		var h=this.h;

		this.k = k;
		this.d = d;
		this.a = 4.0 / (h * (1 + 4 * d));
		this.b = (4.0 * d) / (1 + 4 * d);
		this.eps = 4.0 / (h * h * k * (1 + 4 * d));
	};

	/**
	 * @fn reset
	 * @memberof CANNON.Solver
	 * @brief Resets the solver, removes all constraints and prepares for a new round of solving
	 * @param int numbodies The number of bodies in the new system
	 * @todo vlambda does not need to be instantiated again if the number of bodies is the same. Set to zero instead.
	 */
	CANNON.Solver.prototype.reset = function(numbodies){

		// Don't know number of constraints yet... Use dynamic arrays
		this.G = [];
		this.MinvTrace = [];
		this.Fext = [];
		this.q = [];
		this.qdot = [];
		this.n = 0;
		this.upper = [];
		this.lower = [];
		this.hasupper = [];
		this.haslower = [];
		this.i = []; // To keep track of body id's
		this.j = [];

		this.vxlambda = [];
		this.vylambda = [];
		this.vzlambda = [];
		this.wxlambda = [];
		this.wylambda = [];
		this.wzlambda = [];
		for(var i=0; i<numbodies; i++){
			this.vxlambda.push(0);
			this.vylambda.push(0);
			this.vzlambda.push(0);
			this.wxlambda.push(0);
			this.wylambda.push(0);
			this.wzlambda.push(0);
		}
	};

	/**
	 * @fn addConstraint
	 * @memberof CANNON.Solver
	 * @brief Add a constraint to the solver
	 * @param array G Jacobian vector, 12 elements (6 dof per body)
	 * @param array MinvTrace The trace of the Inverse mass matrix (12 elements). The mass matrix is 12x12 elements from the beginning and 6x6 matrix per body (mass matrix and inertia matrix).
	 * @param array q The constraint violation vector in generalized coordinates (12 elements)
	 * @param array qdot The time-derivative of the constraint violation vector q.
	 * @param array Fext External forces (12 elements)
	 * @param float lower Lower constraint force bound
	 * @param float upper Upper constraint force bound
	 * @param int body_i The first body index
	 * @param int body_j The second body index - set to -1 if none
	 * @see https://www8.cs.umu.se/kurser/5DV058/VT09/lectures/spooknotes.pdf
	 */
	CANNON.Solver.prototype.addConstraint = function(G,MinvTrace,q,qdot,Fext,lower,upper,body_i,body_j){
		if(this.debug){
			console.log("Adding constraint ",this.n," between body ",body_i," and ",body_j);
			console.log("G:",G);
			console.log("q:",q);
			console.log("qdot:",qdot);
			console.log("Fext:",Fext);
			console.log("lower:",lower);
			console.log("upper:",upper);
		}

		for(var i=0; i<12; i++){
			this.q.push(q[i]);
			this.qdot.push(qdot[i]);
			this.MinvTrace.push(MinvTrace[i]);
			this.G.push(G[i]);
			this.Fext.push(Fext[i]);
		}

		this.upper.push(upper);
		this.hasupper.push(!isNaN(upper));
		this.lower.push(lower);
		this.haslower.push(!isNaN(lower));

		this.i.push(body_i);
		this.j.push(body_j);

		this.n += 1;

		// Return result index
		return this.n - 1;
	};

	/**
	 * New version of the addConstraint function, still experimental
	 */
	CANNON.Solver.prototype.addConstraint2 = function(c,i,j){
		c.update();
		for(var k=0; k<c.equations.length; k++){
			var e = c.equations[k];
			this.addConstraint([e.G1.x,e.G1.y,e.G1.z,
				e.G2.x,e.G2.y,e.G2.z,
				e.G3.x,e.G3.y,e.G3.z,
				e.G4.x,e.G4.y,e.G4.z],

				[e.iM1.x,e.iM1.y,e.iM1.z,
					e.iM2.x,e.iM2.y,e.iM2.z,
					e.iM3.x,e.iM3.y,e.iM3.z,
					e.iM4.x,e.iM4.y,e.iM4.z],

				[e.g1.x,e.g1.y,e.g1.z,
					e.g2.x,e.g2.y,e.g2.z,
					e.g3.x,e.g3.y,e.g3.z,
					e.g4.x,e.g4.y,e.g4.z],

				[e.W1.x,e.W1.y,e.W1.z,
					e.W2.x,e.W2.y,e.W2.z,
					e.W3.x,e.W3.y,e.W3.z,
					e.W4.x,e.W4.y,e.W4.z],

				[e.f1.x,e.f1.y,e.f1.z,
					e.f2.x,e.f2.y,e.f2.z,
					e.f3.x,e.f3.y,e.f3.z,
					e.f4.x,e.f4.y,e.f4.z],

				e.lambdamin,
				e.lambdamax,

				i,
				j);
		}
	};


	/**
	 * @fn addNonPenetrationConstraint
	 * @memberof CANNON.Solver
	 * @brief Add a non-penetration constraint to the solver
	 * @param CANNON.Vec3 ni
	 * @param CANNON.Vec3 ri
	 * @param CANNON.Vec3 rj
	 * @param CANNON.Vec3 iMi
	 * @param CANNON.Vec3 iMj
	 * @param CANNON.Vec3 iIi
	 * @param CANNON.Vec3 iIj
	 * @param CANNON.Vec3 v1
	 * @param CANNON.Vec3 v2
	 * @param CANNON.Vec3 w1
	 * @param CANNON.Vec3 w2
	 */
	CANNON.Solver.prototype.addNonPenetrationConstraint
		= function(i,j,xi,xj,ni,ri,rj,iMi,iMj,iIi,iIj,vi,vj,wi,wj,fi,fj,taui,tauj){

		var rxn = ri.cross(ni);
		var u = vj.vsub(vi); // vj.vadd(rj.cross(wj)).vsub(vi.vadd(ri.cross(wi)));

		// g = ( xj + rj - xi - ri ) .dot ( ni )
		var qvec = xj.vadd(rj).vsub(xi.vadd(ri));
		var q = qvec.dot(ni);

		if(q<0.0){
			if(this.debug){
				console.log("i:",i,"j",j,"xi",xi.toString(),"xj",xj.toString());
				console.log("ni",ni.toString(),"ri",ri.toString(),"rj",rj.toString());
				console.log("iMi",iMi.toString(),"iMj",iMj.toString(),"iIi",iIi.toString(),"iIj",iIj.toString(),"vi",vi.toString(),"vj",vj.toString(),"wi",wi.toString(),"wj",wj.toString(),"fi",fi.toString(),"fj",fj.toString(),"taui",taui.toString(),"tauj",tauj.toString());
			}
			this.addConstraint( // Non-penetration constraint jacobian
				[ -ni.x,  -ni.y,  -ni.z,
					-rxn.x, -rxn.y, -rxn.z,
					ni.x,   ni.y,   ni.z,
					rxn.x,  rxn.y,  rxn.z],

				// Inverse mass matrix & inertia
				[iMi.x, iMi.y, iMi.z,
					iIi.z, iIi.y, iIi.z,
					iMj.x, iMj.y, iMj.z,
					iIj.z, iIj.y, iIj.z],

				// q - constraint violation
				[-qvec.x,-qvec.y,-qvec.z,
					0,0,0,
					qvec.x,qvec.y,qvec.z,
					0,0,0],

				// qdot - motion along penetration normal
				[-u.x, -u.y, -u.z,
					0,0,0,
					u.x, u.y, u.z,
					0,0,0],

				// External force - forces & torques
				[fi.x,fi.y,fi.z,
					taui.x,taui.y,taui.z,
					fj.x,fj.y,fj.z,
					tauj.x,tauj.y,tauj.z],

				0,
				'inf',
				i,
				j);
		}
	};

	/**
	 * @fn solve
	 * @memberof CANNON.Solver
	 * @brief Solves the system, and sets the vlambda and wlambda properties of the Solver object
	 */
	CANNON.Solver.prototype.solve = function(){
		var n = this.n,
			lambda = [],
			dlambda = [],
			ulambda = [],
			B = [],
			c = [],
			precomp = [],
			iterations = this.iterations,
			G = this.G,
			debug = this.debug,
			a = this.a,
			eps = this.eps;

		var lower = this.lower,
			haslower = this.haslower,
			upper = this.upper,
			hasupper = this.hasupper;

		var vxlambda = this.vxlambda,
			vylambda = this.vylambda,
			vzlambda = this.vzlambda,
			wxlambda = this.wxlambda,
			wylambda = this.wylambda,
			wzlambda = this.wzlambda;
		var MinvTrace = this.MinvTrace;

		for(var i=0; i<n; i++){
			lambda.push(0);
			dlambda.push(0);
			B.push(0);
			c.push(0);
			precomp.push(0);
			for(var j=0; j<12; j++)
				dlambda.push(0);
		}

		for(var k = 0; k<iterations; k++){
			for(var l=0; l<n; l++){

				// Bodies participating in constraint
				var body_i = this.i[l];
				var body_j = this.j[l];

				var l12 = 12*l;

				if(!precomp[l]){
					// Precompute constants c[l] and B[l] for contact l
					var G_Minv_Gt = 0.0;
					var Gq = 0.0;
					var GW = 0.0;
					var GMinvf = 0.0;
					// Only add normal contributions here? See eq. 27 in spooknotes
					for(var i=0; i<12; i++){
						var addi = l12+i;
						G_Minv_Gt += G[addi] * MinvTrace[addi] * G[addi];
						Gq +=        G[addi] * this.q[addi];
						GW +=        G[addi] * this.qdot[addi];
						GMinvf +=    G[addi] * MinvTrace[addi] * this.Fext[addi];
					}
					c[l] = 1.0 / (G_Minv_Gt + eps); // 1.0 / ( G*Minv*Gt + eps)
					B[l] = ( - a * Gq
						- this.b * GW
						- this.h * GMinvf);
					precomp[l] = 1;

					if(debug){
						console.log("G_Minv_Gt["+l+"]:",G_Minv_Gt);
						console.log("Gq["+l+"]:",Gq);
						console.log("GW["+l+"]:",GW);
						console.log("GMinvf["+l+"]:",GMinvf);
					}
				}

				var Gulambda = 0.0;

				//console.log("debuuug2.1",vxlambda[0],Gulambda,body_i);
				if(body_i>=0){
					Gulambda += G[0+l12] * vxlambda[body_i]; // previuously calculated lambdas
					Gulambda += G[1+l12] * vylambda[body_i];
					Gulambda += G[2+l12] * vzlambda[body_i];
					Gulambda += G[3+l12] * wxlambda[body_i];
					Gulambda += G[4+l12] * wylambda[body_i];
					Gulambda += G[5+l12] * wzlambda[body_i];
					if(debug && isNaN(Gulambda))
						console.log("found NaN Gulambda",vxlambda);
				}

				if(body_j!==-1){
					Gulambda += G[6+l12] * vxlambda[body_j];
					Gulambda += G[7+l12] * vylambda[body_j];
					Gulambda += G[8+l12] * vzlambda[body_j];
					Gulambda += G[9+l12] * wxlambda[body_j];
					Gulambda += G[10+l12] * wylambda[body_j];
					Gulambda += G[11+l12] * wzlambda[body_j];
				}

				dlambda[l] = c[l] * ( B[l] - Gulambda - eps * lambda[l]);
				if(debug)
					console.log("dlambda["+l+"]=",dlambda[l],"rest = ",c[l],B[l],Gulambda,eps,lambda[l],l,body_i,body_j);
				lambda[l] = lambda[l] + dlambda[l];

				// Clamp lambda if out of bounds
				// @todo check if limits are numbers
				if(haslower[l] && lambda[l]<lower[l]){
					if(debug)
						console.log("hit lower bound for constraint "+l+", truncating "+lambda[l]+" to the bound "+lower[l]);
					lambda[l] = lower[l];
					dlambda[l] = lower[l]-lambda[l];
				}
				if(hasupper && lambda[l]>upper[l]){
					if(debug)
						console.log("hit upper bound for constraint "+l+", truncating "+lambda[l]+" to the bound "+upper[l]);
					lambda[l] = upper[l];
					dlambda[l] = upper[l]-lambda[l];
				}

				// Add velocity changes to keep track of them
				if(body_i!==-1){
					vxlambda[body_i] += dlambda[l] * MinvTrace[l12+0] * G[l12+0];
					vylambda[body_i] += dlambda[l] * MinvTrace[l12+1] * G[l12+1];
					vzlambda[body_i] += dlambda[l] * MinvTrace[l12+2] * G[l12+2];
					wxlambda[body_i] += dlambda[l] * MinvTrace[l12+3] * G[l12+3];
					wylambda[body_i] += dlambda[l] * MinvTrace[l12+4] * G[l12+4];
					wzlambda[body_i] += dlambda[l] * MinvTrace[l12+5] * G[l12+5];
				}
				if(body_j!==-1){
					vxlambda[body_j] += dlambda[l] * MinvTrace[l12+6] * G[l12+6];
					vylambda[body_j] += dlambda[l] * MinvTrace[l12+7] * G[l12+7];
					vzlambda[body_j] += dlambda[l] * MinvTrace[l12+8] * G[l12+8];
					wxlambda[body_j] += dlambda[l] * MinvTrace[l12+9] * G[l12+9];
					wylambda[body_j] += dlambda[l] * MinvTrace[l12+10] * G[l12+10];
					wzlambda[body_j] += dlambda[l] * MinvTrace[l12+11] * G[l12+11];
				}
			}
		}

		if(debug)
			for(var i=0; i<this.vxlambda.length; i++)
				console.log("dv["+i+"]=",
					vxlambda[i],
					vylambda[i],
					vzlambda[i],
					wxlambda[i],
					wylambda[i],
					wzlambda[i]);
	};
	/*global CANNON:true */

	/**
	 * @class CANNON.EventTarget
	 * @see https://github.com/mrdoob/eventtarget.js/
	 */
	CANNON.EventTarget = function () {

		var listeners = {};

		this.addEventListener = function ( type, listener ) {

			if ( listeners[ type ] == undefined ) {

				listeners[ type ] = [];

			}

			if ( listeners[ type ].indexOf( listener ) === - 1 ) {

				listeners[ type ].push( listener );

			}

		};

		this.dispatchEvent = function ( event ) {

			for ( var listener in listeners[ event.type ] ) {

				listeners[ event.type ][ listener ]( event );

			}

		};

		this.removeEventListener = function ( type, listener ) {

			var index = listeners[ type ].indexOf( listener );

			if ( index !== - 1 ) {

				listeners[ type ].splice( index, 1 );

			}

		};

	};/*global CANNON:true */

	/**
	 * @class CANNON.ObjectPool
	 */
	CANNON.ObjectPool = function(){
		this.objects = [];
		this.type = Object;
	};

	CANNON.ObjectPool.prototype.release = function(){
		for(var i in arguments)
			this.objects.push(arguments[i]);
	};

	CANNON.ObjectPool.prototype.get = function(){
		if(this.objects.length===0)
			return this.constructObject();
		else
			return this.objects.pop();
	};

	CANNON.ObjectPool.prototype.constructObject = function(){
		throw new Error("constructObject() not implemented in this ObjectPool subclass yet!");
	};/*global CANNON:true */

	/**
	 * @class CANNON.Vec3Pool
	 */
	CANNON.Vec3Pool = function(){
		CANNON.ObjectPool.call(this);
		this.type = CANNON.Vec3;
	};
	CANNON.Vec3Pool.prototype = new CANNON.ObjectPool();

	CANNON.Vec3Pool.prototype.constructObject = function(){
		return new CANNON.Vec3();
	};/*global CANNON:true */

	/**
	 * @class CANNON.Material
	 * @brief Defines a physics material.
	 * @param string name
	 * @author schteppe
	 */
	CANNON.Material = function(name){
		/**
		 * @property string name
		 * @memberof CANNON.Material
		 */
		this.name = name;
		this.id = -1;
	};

	/*global CANNON:true */

	/**
	 * @class CANNON.ContactMaterial
	 * @brief Defines what happens when two materials meet.
	 * @param CANNON.Material m1
	 * @param CANNON.Material m2
	 * @param float friction
	 * @param float restitution
	 * @todo Contact solving parameters here too?
	 */
	CANNON.ContactMaterial = function(m1, m2, friction, restitution){

		/// Contact material index in the world, -1 until added to the world
		this.id = -1;

		/// The two materials participating in the contact
		this.materials = [m1,m2];

		/// Kinetic friction
		this.friction = friction!=undefined ? Number(friction) : 0.3;

		/// Restitution
		this.restitution =      restitution!=undefined ?      Number(restitution) :      0.3;

	};

	/*global CANNON:true */

	/**
	 * @class CANNON.World
	 * @brief The physics world
	 */
	CANNON.World = function(){

		CANNON.EventTarget.apply(this);

		/// Makes bodies go to sleep when they've been inactive
		this.allowSleep = false;

		/// The wall-clock time since simulation start
		this.time = 0.0;

		/// Number of timesteps taken since start
		this.stepnumber = 0;

		/// Default and last timestep sizes
		this.default_dt = 1/60;
		this.last_dt = this.default_dt;

		this.nextId = 0;
		this.gravity = new CANNON.Vec3();
		this.broadphase = null;
		this.bodies = [];

		var th = this;

		/// The constraint solver
		this.solver = new CANNON.Solver();

		// User defined constraints
		this.constraints = [];

		// Contact generator
		this.contactgen = new CANNON.ContactGenerator();

		// Materials
		this.materials = []; // References to all added materials
		this.contactmaterials = []; // All added contact materials
		this.mats2cmat = []; // Hash: (mat1_id, mat2_id) => contactmat_id

		this.temp = {
			gvec:new CANNON.Vec3(),
			vi:new CANNON.Vec3(),
			vj:new CANNON.Vec3(),
			wi:new CANNON.Vec3(),
			wj:new CANNON.Vec3(),
			t1:new CANNON.Vec3(),
			t2:new CANNON.Vec3(),
			rixn:new CANNON.Vec3(),
			rjxn:new CANNON.Vec3(),
			step_q:new CANNON.Quaternion(),
			step_w:new CANNON.Quaternion(),
			step_wq:new CANNON.Quaternion()
		};
	};

	/**
	 * @fn getContactMaterial
	 * @memberof CANNON.World
	 * @brief Get the contact material between materials m1 and m2
	 * @param CANNON.Material m1
	 * @param CANNON.Material m2
	 * @return CANNON.Contactmaterial The contact material if it was found.
	 */
	CANNON.World.prototype.getContactMaterial = function(m1,m2){
		if((m1 instanceof CANNON.Material) &&
			(m2 instanceof CANNON.Material)){

			var i = m1.id;
			var j = m2.id;

			if(i<j){
				var temp = i;
				i = j;
				j = temp;
			}
			return this.contactmaterials[this.mats2cmat[i+j*this.materials.length]];
		}
	};

	/**
	 * @private
	 * @fn _addImpulse
	 * @memberof CANNON.World
	 * @brief Add an impulse to the colliding bodies i and j
	 * @param int i Body number 1
	 * @param int i Body number 2
	 * @param CANNON.Vec3 ri Vector from body 1's center of mass to the contact point on its surface
	 * @param CANNON.Vec3 ri Vector from body 1's center of mass to the contact point on its surface
	 * @param CANNON.Vec3 ui The relative velocity eg. vj+wj*rj - (vi+wj*rj)
	 * @param CANNON.Vec3 ni The contact normal pointing out from body i.
	 * @param float e The coefficient of restitution
	 * @param float mu The contact friction
	 * @todo Use it in the code!
	 */
	CANNON.World.prototype._addImpulse = function(i,j,ri,rj,ui,ni,e,mu){

		var ri_star = ri.crossmat();
		var rj_star = rj.crossmat();

		// Inverse inertia matrices
		var ii = this.inertiax[i]>0 ? 1.0/this.inertiax[i] : 0.0;
		var Iinv_i = new CANNON.Mat3([ii,0,0,
			0,ii,0,
			0,0,ii]);
		ii = this.inertiax[j]>0 ? 1.0/this.inertiax[j] : 0.0;
		var Iinv_j = new CANNON.Mat3([ii,0,0,
			0,ii,0,
			0,0,ii]);

		// Collision matrix:
		// K = 1/mi + 1/mj - ri_star*I_inv_i*ri_star - rj_star*I_inv_j*rj_star;
		var im = this.invm[i] + this.invm[j];
		var K = new CANNON.Mat3([im,0,0,
			0,im,0,
			0,0,im]);
		var rIr_i = ri_star.mmult(Iinv_i.mmult(ri_star));
		var rIr_j = rj_star.mmult(Iinv_j.mmult(rj_star));

		/*
		 // @todo add back when this works
		 for(var el = 0; el<9; el++)
		 K.elements[el] -= (rIr_i.elements[el] + rIr_j.elements[el]);
		 */

		// First assume stick friction
		// Final velocity if stick:
		var v_f = ni.mult(-e * ui.dot(ni));

		var J =  K.solve(v_f.vsub(ui));

		// Check if slide mode (J_t > J_n) - outside friction cone
		var mu = 0.0; // quick fix
		if(mu>0){
			var J_n = ni.mult(J.dot(ni));
			var J_t = J.vsub(J_n);
			if(J_t.norm() > J_n.mult(mu).norm()){

				// Calculate impulse j = -(1+e)u_n / nK(n-mu*t)
				var v_tang = ui.vsub(ni.mult(ui.dot(ni)));
				var tangent = v_tang.mult(1.0/(v_tang.norm() + 0.0001));
				var impulse = -(1+e)*(ui.dot(ni))/(ni.dot(K.vmult((ni.vsub(tangent.mult(mu))))));
				J = ni.mult(impulse).vsub(tangent.mult(mu * impulse));
			}
		}

		// Add to velocities
		var imi = this.invm[i];
		var imj = this.invm[j];

		// du = uprim - u
		//   => uprim = du + u
		// vi = vi + J/mi
		// vj = vj - J/mj

		// Convert back to non-relative velocities:
		// u_rel = vj - vi
		// vi = vj - u_rel
		// vj = vi + u_rel

		this.vx[i] +=  J.x * imi - (this.vx[j] - ui.x);
		this.vy[i] +=  J.y * imi - (this.vy[j] - ui.y);
		this.vz[i] +=  J.z * imi - (this.vz[j] - ui.z);
		this.vx[j] -=  J.x * imj + (this.vx[i] + ui.x);
		this.vy[j] -=  J.y * imj + (this.vy[i] + ui.y);
		this.vz[j] -=  J.z * imj + (this.vz[i] + ui.z);

		var cr = ri.cross(J);
		var wadd = cr.mult(1.0/this.inertiax[i]);

		/*
		 // Add rotational impulses
		 this.wx[i] += wadd.x;
		 this.wy[i] += wadd.y;
		 this.wz[i] += wadd.z;
		 cr = rj.cross(J);
		 wadd = cr.mult(1.0/this.inertiax[j]); // @todo fix to suit asymmetric inertia
		 this.wx[j] -= wadd.x;
		 this.wy[j] -= wadd.y;
		 this.wz[j] -= wadd.z;
		 */
	};

	/**
	 * @fn numObjects
	 * @memberof CANNON.World
	 * @brief Get number of objects in the world.
	 * @return int
	 */
	CANNON.World.prototype.numObjects = function(){
		return this.bodies.length;
	};

	/**
	 * @fn clearCollisionState
	 * @memberof CANNON.World
	 * @brief Clear the contact state for a body.
	 * @param CANNON.Body body
	 */
	CANNON.World.prototype.clearCollisionState = function(body){
		var n = this.numObjects();
		var i = body.id;
		for(var idx=0; idx<n; idx++){
			var j = idx;
			if(i>j) this.collision_matrix[j+i*n] = 0;
			else    this.collision_matrix[i+j*n] = 0;
		}
	};

	/**
	 * @fn add
	 * @memberof CANNON.World
	 * @brief Add a rigid body to the simulation.
	 * @param CANNON.Body body
	 * @todo If the simulation has not yet started, why recrete and copy arrays for each body? Accumulate in dynamic arrays in this case.
	 * @todo Adding an array of bodies should be possible. This would save some loops too
	 */
	CANNON.World.prototype.add = function(body){
		var n = this.numObjects();
		this.bodies.push(body);
		body.id = this.id();
		body.world = this;
		body.position.copy(body.initPosition);
		body.velocity.copy(body.initVelocity);
		if(body instanceof CANNON.RigidBody){
			body.angularVelocity.copy(body.initAngularVelocity);
			body.quaternion.copy(body.initQuaternion);
		}

		// Create collision matrix
		this.collision_matrix = new Int16Array((n+1)*(n+1));
	};

	/**
	 * @fn addConstraint
	 * @memberof CANNON.World
	 * @brief Add a constraint to the simulation.
	 * @param CANNON.Constraint c
	 */
	CANNON.World.prototype.addConstraint = function(c){
		if(c instanceof CANNON.Constraint){
			this.constraints.push(c);
			c.id = this.id();
		}
	};

	/**
	 * @fn id
	 * @memberof CANNON.World
	 * @brief Generate a new unique integer identifyer
	 * @return int
	 */
	CANNON.World.prototype.id = function(){
		return this.nextId++;
	};

	/**
	 * @fn remove
	 * @memberof CANNON.World
	 * @brief Remove a rigid body from the simulation.
	 * @param CANNON.Body body
	 */
	CANNON.World.prototype.remove = function(body){
		body.world = null;
		var n = this.numObjects();
		var bodies = this.bodies;
		for(var i in bodies)
			if(bodies[i].id == body.id)
				bodies.splice(i,1);

		// Reset collision matrix
		this.collision_matrix = new Int16Array((n-1)*(n-1));
	};

	/**
	 * @fn addMaterial
	 * @memberof CANNON.World
	 * @brief Adds a material to the World. A material can only be added once, it's added more times then nothing will happen.
	 * @param CANNON.Material m
	 */
	CANNON.World.prototype.addMaterial = function(m){
		if(m.id==-1){
			this.materials.push(m);
			m.id = this.materials.length-1;

			// Enlarge matrix
			var newcm = new Int16Array((this.materials.length)
				* (this.materials.length));
			for(var i=0; i<newcm.length; i++)
				newcm[i] = -1;

			// Copy over old values
			for(var i=0; i<this.materials.length-1; i++)
				for(var j=0; j<this.materials.length-1; j++)
					newcm[i+this.materials.length*j] = this.mats2cmat[i+(this.materials.length-1)*j];
			this.mats2cmat = newcm;

		}
	};

	/**
	 * @fn addContactMaterial
	 * @memberof CANNON.World
	 * @brief Adds a contact material to the World
	 * @param CANNON.ContactMaterial cmat
	 */
	CANNON.World.prototype.addContactMaterial = function(cmat) {

		// Add materials if they aren't already added
		this.addMaterial(cmat.materials[0]);
		this.addMaterial(cmat.materials[1]);

		// Save (material1,material2) -> (contact material) reference for easy access later
		// Make sure i>j, ie upper right matrix
		if(cmat.materials[0].id > cmat.materials[1].id){
			i = cmat.materials[0].id;
			j = cmat.materials[1].id;
		} else {
			j = cmat.materials[0].id;
			i = cmat.materials[1].id;
		}

		// Add contact material
		this.contactmaterials.push(cmat);
		cmat.id = this.contactmaterials.length-1;

		// Add current contact material to the material table
		this.mats2cmat[i+this.materials.length*j] = cmat.id; // index of the contact material
	};

// Get the index given body id. Returns -1 on fail
	CANNON.World.prototype._id2index = function(id){
		// ugly but works
		for(var j=0; j<this.bodies.length; j++)
			if(this.bodies[j].id === id)
				return j;
		return -1;
	};

	/**
	 * @fn step
	 * @memberof CANNON.World
	 * @brief Step the simulation
	 * @param float dt
	 */
	CANNON.World.prototype.step = function(dt){
		var world = this,
			that = this,
			N = this.numObjects(),
			bodies = this.bodies;

		if(dt==undefined){
			if(this.last_dt)
				dt = this.last_dt;
			else
				dt = this.default_dt;
		}

		// Add gravity to all objects
		for(var i=0; i<N; i++){
			var bi = bodies[i];
			if(bi.motionstate & CANNON.Body.DYNAMIC){ // Only for dynamic bodies
				var f = bodies[i].force, m = bodies[i].mass;
				f.x += world.gravity.x * m;
				f.y += world.gravity.y * m;
				f.z += world.gravity.z * m;
			}
		}

		// 1. Collision detection
		var pairs = this.broadphase.collisionPairs(this);
		var p1 = pairs[0];
		var p2 = pairs[1];

		// Get references to things that are accessed often. Will save some lookup time.
		var SPHERE = CANNON.Shape.types.SPHERE;
		var PLANE = CANNON.Shape.types.PLANE;
		var BOX = CANNON.Shape.types.BOX;
		var COMPOUND = CANNON.Shape.types.COMPOUND;

		// Keep track of contacts for current and previous timestep
		// 0: No contact between i and j
		// 1: Contact
		function collisionMatrixGet(i,j,current){
			if(typeof(current)=="undefined") current = true;
			// i == column
			// j == row
			if((current && i<j) || // Current uses upper part of the matrix
				(!current && i>j)){ // Previous uses lower part of the matrix
				var temp = j;
				j = i;
				i = temp;
			}
			return that.collision_matrix[i+j*N];
		}

		function collisionMatrixSet(i,j,value,current){
			if(typeof(current)=="undefined") current = true;
			if((current && i<j) || // Current uses upper part of the matrix
				(!current && i>j)){ // Previous uses lower part of the matrix
				var temp = j;
				j = i;
				i = temp;
			}
			that.collision_matrix[i+j*N] = parseInt(value);
		}

		// transfer old contact state data to T-1
		function collisionMatrixTick(){
			for(var i=0; i<bodies.length; i++){
				for(var j=0; j<i; j++){
					var currentState = collisionMatrixGet(i,j,true);
					collisionMatrixSet(i,j,currentState,false);
					collisionMatrixSet(i,j,0,true);
				}
			}
		}

		collisionMatrixTick();

		// Reset contact solver
		this.solver.reset(N);

		// Generate contacts
		var oldcontacts = this.contacts;
		this.contacts = [];
		this.contactgen.getContacts(p1,p2,
			this,
			this.contacts,
			oldcontacts // To be reused
		);

		// Loop over all collisions
		var temp = this.temp;
		for(var k=0; k<this.contacts.length; k++){

			// Current contact
			var c = this.contacts[k];

			// Get current collision indeces
			var bi = c.bi,
				bj = c.bj;

			// Resolve indeces
			var i = this._id2index(bi.id),
				j = this._id2index(bj.id);

			// Check last step stats
			var lastCollisionState = collisionMatrixGet(i,j,false);

			// Get collision properties
			var mu = 0.3, e = 0.2;
			var cm = this.getContactMaterial(bi.material,
				bj.material);
			if(cm){
				mu = cm.friction;
				e = cm.restitution;
			}

			// g = ( xj + rj - xi - ri ) .dot ( ni )
			var gvec = temp.gvec;
			gvec.set(bj.position.x + c.rj.x - bi.position.x - c.ri.x,
				bj.position.y + c.rj.y - bi.position.y - c.ri.y,
				bj.position.z + c.rj.z - bi.position.z - c.ri.z);
			var g = gvec.dot(c.ni); // Gap, negative if penetration

			// Action if penetration
			if(g<0.0){
				// Now we know that i and j are in contact. Set collision matrix state
				collisionMatrixSet(i,j,1,true);

				if(collisionMatrixGet(i,j,true)!=collisionMatrixGet(i,j,false)){
					bi.dispatchEvent({type:"collide", "with":bj});
					bj.dispatchEvent({type:"collide", "with":bi});
					bi.wakeUp();
					bj.wakeUp();
				}

				var vi = bi.velocity;
				var wi = bi.angularVelocity;
				var vj = bj.velocity;
				var wj = bj.angularVelocity;

				var n = c.ni;
				var tangents = [temp.t1, temp.t2];
				n.tangents(tangents[0],tangents[1]);

				var v_contact_i = vi.vadd(wi.cross(c.ri));
				var v_contact_j = vj.vadd(wj.cross(c.rj));
				var u_rel = v_contact_j.vsub(v_contact_i);
				var w_rel = wj.cross(c.rj).vsub(wi.cross(c.ri));

				var u = (vj.vsub(vi)); // Contact velo
				var uw = (c.rj.cross(wj)).vsub(c.ri.cross(wi));
				u.vsub(uw,u);

				// Get mass properties
				var iMi = bi.invMass;
				var iMj = bj.invMass;
				var iIxi = bi.invInertia.x;
				var iIyi = bi.invInertia.y;
				var iIzi = bi.invInertia.z;
				var iIxj = bj.invInertia.x;
				var iIyj = bj.invInertia.y;
				var iIzj = bj.invInertia.z;

				// Add contact constraint
				var rixn = temp.rixn;
				var rjxn = temp.rjxn;
				c.ri.cross(n,rixn);
				c.rj.cross(n,rjxn);

				var un_rel = n.mult(u_rel.dot(n)*0.5);
				var u_rixn_rel = rixn.unit().mult(w_rel.dot(rixn.unit()));
				var u_rjxn_rel = rjxn.unit().mult(-w_rel.dot(rjxn.unit()));

				var gn = c.ni.mult(g);
				this.solver
					.addConstraint( // Non-penetration constraint jacobian
					[-n.x,-n.y,-n.z,
						-rixn.x,-rixn.y,-rixn.z,
						n.x,n.y,n.z,
						rjxn.x,rjxn.y,rjxn.z],

					// Inverse mass matrix
					[iMi,iMi,iMi,
						iIxi,iIyi,iIzi,
						iMj,iMj,iMj,
						iIxj,iIyj,iIzj],

					// g - constraint violation / gap
					[-gn.x,-gn.y,-gn.z,
						0,0,0,//-gn.x,-gn.y,-gn.z,
						gn.x,gn.y,gn.z,
						0,0,0//gn.x,gn.y,gn.z
					],

					[-un_rel.x,-un_rel.y,-un_rel.z,
						0,0,0,//-u_rixn_rel.x,-u_rixn_rel.y,-u_rixn_rel.z,
						un_rel.x,un_rel.y,un_rel.z,
						0,0,0//u_rjxn_rel.x,u_rjxn_rel.y,u_rjxn_rel.z
					],

					// External force - forces & torques
					[bi.force.x,bi.force.y,bi.force.z,
						bi.tau.x,bi.tau.y,bi.tau.z,
						-bj.force.x,-bj.force.y,-bj.force.z,
						-bj.tau.x,-bj.tau.y,-bj.tau.z],
					0,
					'inf',
					i, // These are id's, not indeces...
					j);

				// Friction constraints
				if(mu>0.0){
					var g = that.gravity.norm();
					for(var ti=0; ti<tangents.length; ti++){
						var t = tangents[ti];
						var rixt = c.ri.cross(t);
						var rjxt = c.rj.cross(t);

						var ut_rel = t.mult(u_rel.dot(t));
						var u_rixt_rel = rixt.unit().mult(u_rel.dot(rixt.unit()));
						var u_rjxt_rel = rjxt.unit().mult(-u_rel.dot(rjxt.unit()));
						this.solver
							.addConstraint( // Non-penetration constraint jacobian
							[-t.x,-t.y,-t.z,
								-rixt.x,-rixt.y,-rixt.z,
								t.x,t.y,t.z,
								rjxt.x,rjxt.y,rjxt.z
							],

							// Inverse mass matrix
							[iMi,iMi,iMi,
								iIxi,iIyi,iIzi,
								iMj,iMj,iMj,
								iIxj,iIyj,iIzj],

							// g - constraint violation / gap
							[0,0,0,
								0,0,0,
								0,0,0,
								0,0,0],

							[-ut_rel.x,-ut_rel.y,-ut_rel.z,
								0,0,0,//-u_rixt_rel.x,-u_rixt_rel.y,-u_rixt_rel.z,
								ut_rel.x,ut_rel.y,ut_rel.z,
								0,0,0//u_rjxt_rel.x,u_rjxt_rel.y,u_rjxt_rel.z
							],

							// External force - forces & torques
							[bi.force.x,bi.force.y,bi.force.z,
								bi.tau.x,bi.tau.y,bi.tau.z,
								bj.force.x,bj.force.y,bj.force.z,
								bj.tau.x,bj.tau.y,bj.tau.z],

							-mu*100*(bi.mass+bj.mass),
							mu*100*(bi.mass+bj.mass),

							i, // id, not index
							j);
					}
				}
			}
		}

		// Add user-defined constraints
		for(var i=0; i<this.constraints.length; i++){
			// Preliminary - ugly but works
			var bj=-1, bi=-1;
			for(var j=0; j<this.bodies.length; j++)
				if(this.bodies[j].id === this.constraints[i].body_i.id)
					bi = j;
				else if(this.bodies[j].id === this.constraints[i].body_j.id)
					bj = j;
			this.solver.addConstraint2(this.constraints[i],bi,bj);
		}

		var bi;
		if(this.solver.n){

			this.solver.h = dt;
			this.solver.solve();

			// Apply constraint velocities
			for(var i=0; i<N; i++){
				bi = bodies[i];
				if(bi.motionstate & CANNON.Body.DYNAMIC){ // Only for dynamic bodies
					var b = bodies[i];
					b.velocity.x += this.solver.vxlambda[i];
					b.velocity.y += this.solver.vylambda[i];
					b.velocity.z += this.solver.vzlambda[i];
					if(b.angularVelocity){
						b.angularVelocity.x += this.solver.wxlambda[i];
						b.angularVelocity.y += this.solver.wylambda[i];
						b.angularVelocity.z += this.solver.wzlambda[i];
					}
				}
			}
		}

		// Apply damping
		for(var i=0; i<N; i++){
			bi = bodies[i];
			if(bi.motionstate & CANNON.Body.DYNAMIC){ // Only for dynamic bodies
				var ld = 1.0 - bi.linearDamping;
				var ad = 1.0 - bi.angularDamping;
				bi.velocity.mult(ld,bi.velocity);
				if(bi.angularVelocity)
					bi.angularVelocity.mult(ad,bi.angularVelocity);
			}
		}

		that.dispatchEvent({type:"preStep"});

		// Invoke pre-step callbacks
		for(var i in bodies){
			var bi = bodies[i];
			bi.preStep && bi.preStep.call(bi);
		}

		// Leap frog
		// vnew = v + h*f/m
		// xnew = x + h*vnew
		var q = temp.step_q;
		var w = temp.step_w;
		var wq = temp.step_wq;
		var DYNAMIC_OR_KINEMATIC = CANNON.Body.DYNAMIC | CANNON.Body.KINEMATIC;
		for(var i=0; i<N; i++){
			var b = bodies[i];
			if((b.motionstate & DYNAMIC_OR_KINEMATIC)){ // Only for dynamic

				b.velocity.x += b.force.x * b.invMass * dt;
				b.velocity.y += b.force.y * b.invMass * dt;
				b.velocity.z += b.force.z * b.invMass * dt;

				if(b.angularVelocity){
					b.angularVelocity.x += b.tau.x * b.invInertia.x * dt;
					b.angularVelocity.y += b.tau.y * b.invInertia.y * dt;
					b.angularVelocity.z += b.tau.z * b.invInertia.z * dt;
				}

				// Use new velocity  - leap frog
				if(!b.isSleeping()){
					b.position.x += b.velocity.x * dt;
					b.position.y += b.velocity.y * dt;
					b.position.z += b.velocity.z * dt;

					if(b.angularVelocity){
						w.set(b.angularVelocity.x,
							b.angularVelocity.y,
							b.angularVelocity.z,
							0);
						w.mult(b.quaternion,wq);

						b.quaternion.x += dt * 0.5 * wq.x;
						b.quaternion.y += dt * 0.5 * wq.y;
						b.quaternion.z += dt * 0.5 * wq.z;
						b.quaternion.w += dt * 0.5 * wq.w;
						if(world.stepnumber % 3 === 0)
							b.quaternion.normalizeFast();
					}
				}
			}
			b.force.set(0,0,0);
			if(b.tau) b.tau.set(0,0,0);
		}

		// Update world time
		world.time += dt;
		world.stepnumber += 1;

		that.dispatchEvent({type:"postStep"});

		// Invoke post-step callbacks
		for(var i in bodies){
			var bi = bodies[i];
			bi.postStep && bi.postStep.call(bi);
		}

		// Sleeping update
		if(world.allowSleep){
			for(var i=0; i<N; i++){
				var bi = bodies[i];
				bi.sleepTick();
			}
		}
	};

	/**
	 * @class ContactPoint
	 * @brief A representation of a contact point between two bodies. Should be generated by the ContactGenerator
	 * @param CANNON.Body bi
	 * @param CANNON.Body bj
	 * @param CANNON.Vec3 ri Optional. The vector from the center of mass of bi to the contact.
	 * @param CANNON.Vec3 rj Optional. The vector from the center of mass of bj to the contact.
	 * @param CANNON.Vec3 ni Optional. Contact normal vector, pointing out of body bi.
	 */
	CANNON.ContactPoint = function(bi,bj,ri,rj,ni){
		/**
		 * @property CANNON.Vec3 ri
		 * @memberof CANNON.ContactPoint
		 */
		this.ri = new CANNON.Vec3();

		/**
		 * @property CANNON.Vec3 rj
		 * @memberof CANNON.ContactPoint
		 */
		this.rj = new CANNON.Vec3();

		/**
		 * @property CANNON.Vec3 ni
		 * @memberof CANNON.ContactPoint
		 */
		this.ni = new CANNON.Vec3();

		// Copy over data if arguments were passed
		if(ri) ri.copy(this.ri);
		if(rj) rj.copy(this.rj);
		if(ni) ni.copy(this.ni);

		/**
		 * @property CANNON.Body bi
		 * @memberof CANNON.ContactPoint
		 */
		this.bi = bi;

		/**
		 * @property CANNON.Body bj
		 * @memberof CANNON.ContactPoint
		 */
		this.bj = bj;
	};/*global CANNON:true */

	/**
	 * @class CANNON.ContactGenerator
	 * @brief Helper class for the World. Generates ContactPoints.
	 */
	CANNON.ContactGenerator = function(){

		/**
		 * @property bool contactReduction
		 * @memberof CANNON.ContactGenerator
		 * @brief Turns on or off contact reduction. Can be handy to turn off when debugging new collision types.
		 */
		this.contactReduction = true;

		// Contact point objects that can be reused
		var contactPointPool = [];

		var v3pool = new CANNON.Vec3Pool();

		/**
		 * Near phase calculation, get the contact point, normal, etc.
		 * @param array result The result one will get back with all the contact point information
		 * @param Shape si Colliding shape
		 * @param Shape sj
		 * @param Vec3 xi Position of the center of mass
		 * @param Vec3 xj
		 * @param Quaternion qi Rotation around the center of mass
		 * @param Quaternion qj
		 * @todo All collision cases
		 */
		function nearPhase(result,si,sj,xi,xj,qi,qj,bi,bj){
			var swapped = false;
			if(si.type>sj.type){
				var temp;
				temp=sj;   sj=si;   si=temp;
				temp=xj;   xj=xi;   xi=temp;
				temp=qj;   qj=qi;   qi=temp;
				temp=bj;   bj=bi;   bi=temp;
				swapped = true;
			}

			/**
			 * Make a contact object.
			 * @return object
			 * @todo reuse old contact point objects
			 */
			function makeResult(bi,bj){
				if(contactPointPool.length){
					var c = contactPointPool.pop();
					c.bi = bi;
					c.bj = bj;
					return c;
				} else
					return new CANNON.ContactPoint(bi,bj);
			}

			/**
			 * Swaps the body references in the contact
			 * @param object r
			 */
			function swapResult(r){
				var temp;
				temp = r.ri; r.ri = r.rj; r.rj = temp;
				r.ni.negate(r.ni);
				temp = r.bi; r.bi = r.bj; r.bj = temp;
			}

			/**
			 * Go recursive for compound shapes
			 * @param Shape si
			 * @param CompoundShape sj
			 */
			function recurseCompound(result,si,sj,xi,xj,qi,qj,bi,bj){
				for(var i=0; i<sj.childShapes.length; i++){
					var r = [];
					nearPhase(r,
						si,
						sj.childShapes[i],
						xi,
						xj.vadd(qj.vmult(sj.childOffsets[i])), // Transform the shape to its local frame
						qi,
						qj.mult(sj.childOrientations[i]),
						bi,
						bj);
					// Transform back
					for(var j=0; j<r.length; j++){
						r[j].rj.vadd(qj.vmult(sj.childOffsets[i]),r[j].rj);
						result.push(r[j]);
					}
				}
			}

			if(si.type==CANNON.Shape.types.SPHERE){
				if(sj.type==CANNON.Shape.types.SPHERE){ // sphere-sphere

					// We will have one contact in this case
					var r = makeResult(bi,bj);

					// Contact normal
					xj.vsub(xi,r.ni);
					r.ni.normalize();

					// Contact point locations
					r.ni.copy(r.ri);
					r.ni.copy(r.rj);
					r.ri.mult(si.radius,r.ri);
					r.rj.mult(-sj.radius,r.rj);
					result.push(r);

				} else if(sj.type==CANNON.Shape.types.PLANE){ // sphere-plane

					// We will have one contact in this case
					var r = makeResult(bi,bj);

					// Contact normal
					sj.normal.copy(r.ni);
					qj.vmult(r.ni,r.ni);
					r.ni.negate(r.ni); // body i is the sphere, flip normal
					r.ni.normalize();

					// Vector from sphere center to contact point
					r.ni.mult(si.radius,r.ri);

					// Project down sphere on plane
					var point_on_plane_to_sphere = xi.vsub(xj);
					var plane_to_sphere_ortho = r.ni.mult(r.ni.dot(point_on_plane_to_sphere));
					r.rj = point_on_plane_to_sphere.vsub(plane_to_sphere_ortho); // The sphere position projected to plane
					if(plane_to_sphere_ortho.norm() <= si.radius)
						result.push(r);

				} else if(sj.type==CANNON.Shape.types.BOX){ // sphere-box

					// we refer to the box as body j
					var box_to_sphere =  xi.vsub(xj);
					var sides = sj.getSideNormals(true,qj);
					var R =     si.radius;
					var penetrating_sides = [];

					// Check side (plane) intersections
					var found = false;
					for(var idx=0; idx<sides.length && !found; idx++){ // Max 3 penetrating sides
						var ns = sides[idx].copy();
						var h = ns.norm();
						ns.normalize();
						var dot = box_to_sphere.dot(ns);
						if(dot<h+R && dot>0){
							// Intersects plane. Now check the other two dimensions
							var ns1 = sides[(idx+1)%3].copy();
							var ns2 = sides[(idx+2)%3].copy();
							var h1 = ns1.norm();
							var h2 = ns2.norm();
							ns1.normalize();
							ns2.normalize();
							var dot1 = box_to_sphere.dot(ns1);
							var dot2 = box_to_sphere.dot(ns2);
							if(dot1<h1 && dot1>-h1 && dot2<h2 && dot2>-h2){
								found = true;
								var r = makeResult(bi,bj);
								ns.mult(-R,r.ri); // Sphere r
								ns.copy(r.ni);
								r.ni.negate(r.ni); // Normal should be out of sphere
								ns.mult(h).vadd(ns1.mult(dot1)).vadd(ns2.mult(dot2),r.rj); // box
								result.push(r);
							}
						}
					}

					// Check corners
					var rj = v3pool.get();
					for(var j=0; j<2 && !found; j++){
						for(var k=0; k<2 && !found; k++){
							for(var l=0; l<2 && !found; l++){
								rj.set(0,0,0);
								if(j) rj.vadd(sides[0],rj);
								else  rj.vsub(sides[0],rj);
								if(k) rj.vadd(sides[1],rj);
								else  rj.vsub(sides[1],rj);
								if(l) rj.vadd(sides[2],rj);
								else  rj.vsub(sides[2],rj);

								// World position of corner
								var sphere_to_corner = xj.vadd(rj).vsub(xi);
								if(sphere_to_corner.norm()<R){
									found = true;
									var r = makeResult(bi,bj);
									sphere_to_corner.copy(r.ri);
									r.ri.normalize();
									r.ri.copy(r.ni);
									r.ri.mult(R,r.ri);
									rj.copy(r.rj);
									result.push(r);
								}
							}
						}
					}
					v3pool.release(rj);
					rj = null;

					// Check edges
					var edgeTangent = v3pool.get();
					var edgeCenter = v3pool.get();
					var r = v3pool.get(); // r = edge center to sphere center
					var orthogonal = v3pool.get();
					var dist = v3pool.get();
					for(var j=0; j<sides.length && !found; j++){
						for(var k=0; k<sides.length && !found; k++){
							if(j%3!=k%3){
								// Get edge tangent
								sides[k].cross(sides[j],edgeTangent);
								edgeTangent.normalize();
								sides[j].vadd(sides[k], edgeCenter);
								xi.copy(r);
								r.vsub(edgeCenter,r);
								r.vsub(xj,r);
								var orthonorm = r.dot(edgeTangent); // distance from edge center to sphere center in the tangent direction
								edgeTangent.mult(orthonorm,orthogonal); // Vector from edge center to sphere center in the tangent direction

								// Find the third side orthogonal to this one
								var l = 0;
								while(l==j%3 || l==k%3) l++;

								// vec from edge center to sphere projected to the plane orthogonal to the edge tangent
								xi.copy(dist);
								dist.vsub(orthogonal,dist);
								dist.vsub(edgeCenter,dist);
								dist.vsub(xj,dist);

								// Distances in tangent direction and distance in the plane orthogonal to it
								var tdist = Math.abs(orthonorm);
								var ndist = dist.norm();

								if(tdist < sides[l].norm() && ndist<R){
									found = true;
									var res = makeResult(bi,bj);
									edgeCenter.vadd(orthogonal,res.rj); // box rj
									res.rj.copy(res.rj);
									dist.negate(res.ni);
									res.ni.normalize();

									res.rj.copy(res.ri);
									res.ri.vadd(xj,res.ri);
									res.ri.vsub(xi,res.ri);
									res.ri.normalize();
									res.ri.mult(R,res.ri);

									result.push(res);
								}
							}
						}
					}
					v3pool.release(edgeTangent,edgeCenter,r,orthogonal,dist);

				} else if(sj.type==CANNON.Shape.types.COMPOUND){ // sphere-compound
					recurseCompound(result,si,sj,xi,xj,qi,qj,bi,bj);

				} else if(sj.type==CANNON.Shape.types.CONVEXPOLYHEDRON){ // sphere-convexpolyhedron
					throw new Error("sphere/convexpolyhedron contacts not implemented yet.");
				}

			} else if(si.type==CANNON.Shape.types.PLANE){

				if(sj.type==CANNON.Shape.types.PLANE){ // plane-plane
					throw "Plane-plane collision... wait, you did WHAT?";

				} else if(sj.type==CANNON.Shape.types.BOX){ // plane-box

					// Collision normal
					var n = si.normal.copy();

					// Loop over corners
					var numcontacts = 0;
					var corners = sj.getCorners(qj);
					for(var idx=0; idx<corners.length && numcontacts<=4; idx++){ // max 4 corners against plane
						var r = makeResult(bi,bj);
						var worldCorner = corners[idx].vadd(xj);
						corners[idx].copy(r.rj);

						// Project down corner to plane to get xj
						var point_on_plane_to_corner = worldCorner.vsub(xi);
						var d = n.dot(point_on_plane_to_corner);
						if(d<=0){
							numcontacts++;
							var plane_to_corner = n.mult(d);
							point_on_plane_to_corner.vsub(plane_to_corner,r.ri);

							// Set contact normal
							n.copy(r.ni);

							// Add contact
							result.push(r);
						}
					}

				} else if(sj.type==CANNON.Shape.types.COMPOUND){ // plane-compound
					recurseCompound(result,si,sj,xi,xj,qi,qj,bi,bj);

				} else if(sj.type==CANNON.Shape.types.CONVEXPOLYHEDRON){ // plane-convex polyhedron
					// Separating axis is the plane normal
					// Create a virtual box polyhedron for the plane
					var t1 = v3pool.get();
					var t2 = v3pool.get();
					si.normal.tangents(t1,t2);
					t1.mult(100000,t1);
					t2.mult(100000,t2);
					var n = v3pool.get();
					si.normal.copy(n);
					var verts = [new CANNON.Vec3(-t1.x -t2.x -n.x, -t1.y -t2.y -n.y, -t1.z -t2.z -n.z), // ---
						new CANNON.Vec3( t1.x -t2.x +0*n.x,  t1.y -t2.y +0*n.y,  t1.z -t2.z +0*n.z), // +-+
						new CANNON.Vec3( t1.x +t2.x -n.x,  t1.y +t2.y -n.y,  t1.z +t2.z -n.z), // ++- 
						new CANNON.Vec3(-t1.x +t2.x -n.x, -t1.y +t2.y -n.y, -t1.z +t2.z -n.z), // -+-
						new CANNON.Vec3(-t1.x -t2.x +0*n.x, -t1.y -t2.y +0*n.y, -t1.z -t2.z +0*n.z), // --+
						new CANNON.Vec3(+t1.x -t2.x +0*n.x,  t1.y -t2.y +0*n.y,  t1.z -t2.z +0*n.z), // +-+
						new CANNON.Vec3(+t1.x +t2.x +0*n.x, +t1.y +t2.y +0*n.y,  t1.z +t2.z +0*n.z), // +++
						new CANNON.Vec3(-t1.x +t2.x +0*n.x, -t1.y +t2.y +0*n.y, -t1.z +t2.z +0*n.z)]; // -++
					t1.normalize();
					t2.normalize();
					var planehull = new CANNON.ConvexPolyhedron(verts,
						[
							[0,1,2,3], // -z
							[4,5,6,7], // +z
							[0,1,4,5], // -y
							[2,3,6,7], // +y
							[0,3,4,7], // -x
							[1,2,5,6], // +x
						],

						[new CANNON.Vec3( -n.x, -n.y, -n.z),
							new CANNON.Vec3(  n.x,  n.y,  n.z),
							new CANNON.Vec3(-t2.x,-t2.y,-t2.z),
							new CANNON.Vec3( t2.x, t2.y, t2.z),
							new CANNON.Vec3(-t1.x,-t1.y,-t1.z),
							new CANNON.Vec3( t1.x, t1.y, t1.z)]);

					var sepAxis = v3pool.get();
					n.negate(sepAxis);
					var q = v3pool.get();
					if(sj.testSepAxis(sepAxis,planehull,xj,qj,xi,qi)!==false){
						var res = [];
						planehull.clipAgainstHull(xi,qi,sj,xj,qj,sepAxis,-100,100,res);
						for(var j=0; j<res.length; j++){
							var r = makeResult(bi,bj);
							sepAxis.negate(r.ni);
							res[j].normal.negate(q);
							q.mult(res[j].depth,q);
							r.ri.set(res[j].point.x + q.x,
								res[j].point.y + q.y,
								res[j].point.z + q.z);
							r.rj.set(res[j].point.x,
								res[j].point.y,
								res[j].point.z);
							// Contact points are in world coordinates. Transform back to relative
							r.rj.vsub(xj,r.rj);
							r.ri.vsub(xi,r.ri);
							result.push(r);
						}
					}
					v3pool.release(q,t1,t2,sepAxis,n);
				}

			} else if(si.type==CANNON.Shape.types.BOX){

				if(sj.type==CANNON.Shape.types.BOX){ // box-box
					// Do convex polyhedron instead
					nearPhase(result,
						si.convexPolyhedronRepresentation,
						sj.convexPolyhedronRepresentation,
						xi,xj,qi,qj,bi,bj);

				} else if(sj.type==CANNON.Shape.types.COMPOUND){ // box-compound
					recurseCompound(result,si,sj,xi,xj,qi,qj,bi,bj);

				} else if(sj.type==CANNON.Shape.types.CONVEXPOLYHEDRON){ // box-convexpolyhedron
					nearPhase(result,
						si.convexPolyhedronRepresentation,
						sj,xi,xj,qi,qj,bi,bj);
				}

			} else if(si.type==CANNON.Shape.types.COMPOUND){

				if(sj.type==CANNON.Shape.types.COMPOUND){ // compound-compound
					recurseCompound(result,si,sj,xi,xj,qi,qj,bi,bj);

				} else if(sj.type==CANNON.Shape.types.CONVEXPOLYHEDRON){ // compound-convex polyhedron
					recurseCompound(result,sj,si,xj,xi,qj,qi,bj,bi);
				}

			} else if(si.type==CANNON.Shape.types.CONVEXPOLYHEDRON){

				if(sj.type==CANNON.Shape.types.CONVEXPOLYHEDRON){ // convex polyhedron - convex polyhedron
					var sepAxis = new CANNON.Vec3();
					if(si.findSeparatingAxis(sj,xi,qi,xj,qj,sepAxis)){
						var res = [];
						var q = new CANNON.Vec3();
						si.clipAgainstHull(xi,qi,sj,xj,qj,sepAxis,-100,100,res);
						for(var j=0; j<res.length; j++){
							var r = makeResult(bi,bj);
							sepAxis.negate(r.ni);
							res[j].normal.negate(q);
							q.mult(res[j].depth,q);
							r.ri.set(res[j].point.x + q.x,
								res[j].point.y + q.y,
								res[j].point.z + q.z);
							r.rj.set(res[j].point.x,
								res[j].point.y,
								res[j].point.z);
							// Contact points are in world coordinates. Transform back to relative
							r.rj.vsub(xj,r.rj);
							r.ri.vsub(xi,r.ri);
							result.push(r);
						}
					}
				}
			}

			// Swap back if we swapped bodies in the beginning
			for(var i=0; swapped && i<result.length; i++)
				swapResult(result[i]);
		}

		/**
		 * @fn reduceContacts
		 * @memberof CANNON.ContactGenerator
		 * @brief Removes unnecessary members of an array of CANNON.ContactPoint.
		 */
		this.reduceContacts = function(contacts){

		}

		/**
		 * @fn getContacts
		 * @memberof CANNON.ContactGenerator
		 * @param array p1 Array of body indices
		 * @param array p2 Array of body indices
		 * @param CANNON.World world
		 * @param array result Array to store generated contacts
		 * @param array oldcontacts Optional. Array of reusable contact objects
		 */
		this.getContacts = function(p1,p2,world,result,oldcontacts){

			// Save old contact objects
			for(var i=0; oldcontacts && i<oldcontacts.length; i++)
				contactPointPool.push(oldcontacts[i]);

			for(var k=0; k<p1.length; k++){
				// Get current collision indeces
				var bi = p1[k],
					bj = p2[k];

				// Get contacts
				nearPhase(result,
					bi.shape,
					bj.shape,
					bi.position,
					bj.position,
					bi.quaternion,
					bj.quaternion,
					bi,
					bj
				);
			}
		}
	};/*global CANNON:true */

	/**
	 * Constraint base class
	 * @author schteppe
	 */
	CANNON.Constraint = function(){

		/**
		 * @property array equations
		 * @brief A number of CANNON.Equation's that belongs to this Constraint
		 */
		this.equations = [];

		this.id = -1;

	};
	CANNON.Constraint.prototype.constructor = CANNON.Constraint;

	/**
	 * @brief Updates the internal numbers, calculates the Jacobian etc.
	 */
	CANNON.Constraint.prototype.update = function(){
		throw "update() not implemented in this Constraint subclass!";
	};
	/**
	 * Contact constraint class
	 * @author schteppe
	 * @param CANNON.RigidBody bodyA
	 * @param CANNON.RigidBody bodyB
	 * @param float friction
	 * @todo test
	 */
	CANNON.ContactConstraint = function(bodyA,bodyB,slipForce){
		CANNON.Constraint.call(this);
		this.body_i = bodyA;
		this.body_j = bodyB;
		this.contact = contact;
		this.slipForce = slipForce;
		this.unused_equations = [];
		this.temp = {
			rixn:new CANNON.Vec3(),
			rjxn:new CANNON.Vec3(),
			t1:new CANNON.Vec3(),
			t2:new CANNON.Vec3()
		};
	};

	CANNON.ContactConstraint.prototype = new CANNON.Constraint();
	CANNON.ContactConstraint.prototype.constructor = CANNON.ContactConstraint;

	CANNON.ContactConstraint.prototype.update = function(){

		/*
		 if(friction>0.0){
		 for(var i=0; i<3; i++)
		 this.equations.push(new CANNON.Equation(bodyA,bodyB)); // Normal+2tangents
		 } else
		 this.equations.push(new CANNON.Equation(bodyA,bodyB)); // Normal
		 */

		var bi = this.body_i,
			bj = this.body_j;

		var vi = bi.velocity,
			wi = bi.angularVelocity,
			vj = bj.velocity,
			wj = bj.angularVelocity;

		var tangents = [this.temp.t1, this.temp.t2];
		for(var i in bi.contacts){
			for(var j in bj.contacts){
				if(bi.contacts[i].to.id==bj.id && bj.contacts[j].to.id==bi.id){
					var ri = bi.contacts[i].r,
						rj = bj.contacts[j].r,
						ni = bi.contacts[i].n; // normals should be the same anyways

					n.tangents(tangents[0],tangents[1]);

					var v_contact_i = vi.vadd(wi.cross(c.ri));
					var v_contact_j = vj.vadd(wj.cross(c.rj));
					var u_rel = v_contact_j.vsub(v_contact_i);
					var w_rel = wj.cross(c.rj).vsub(wi.cross(c.ri));

					var u = (vj.vsub(vi));
					var uw = (c.rj.cross(wj)).vsub(c.ri.cross(wi));
					u.vsub(uw,u);

					// Get mass properties
					var iMi = bi.invMass;
					var iMj = bj.invMass;
					var iIxi = bi.invInertia.x;
					var iIyi = bi.invInertia.y;
					var iIzi = bi.invInertia.z;
					var iIxj = bj.invInertia.x;
					var iIyj = bj.invInertia.y;
					var iIzj = bj.invInertia.z;

					// Add contact constraint
					var rixn = this.temp.rixn;
					var rjxn = this.temp.rjxn;
					c.ri.cross(n,rixn);
					c.rj.cross(n,rjxn);

					var un_rel = n.mult(u_rel.dot(n));
					var u_rixn_rel = rixn.unit().mult(w_rel.dot(rixn.unit()));
					var u_rjxn_rel = rjxn.unit().mult(-w_rel.dot(rjxn.unit()));

					var gn = c.ni.mult(g);

					// Jacobian, eq. 25 in spooknotes
					n.negate(eq.G1);
					rixn.negate(eq.G2);
					n.copy(eq.G3);
					rjxn.copy(eq.G4);

					eq.setDefaultMassProps();

					// g - constraint violation / gap
					gn.negate(eq.g1);
					gn.copy(eq.g3);

					// W
					un_rel.negate(eq.W1);
					un_rel.copy(eq.W3);

					// External force - forces & torques
					bi.force.copy(eq.f1);
					bi.tau.copy(eq.f2);
					bj.force.copy(eq.f3);
					bj.tau.copy(eq.f4);

					eq.lambdamin = 0;
					eq.lambdamax = 'inf';
					/*
					 // Friction constraints
					 if(mu>0.0){
					 var g = that.gravity.norm();
					 for(var ti=0; ti<tangents.length; ti++){
					 var t = tangents[ti];
					 var rixt = c.ri.cross(t);
					 var rjxt = c.rj.cross(t);

					 var ut_rel = t.mult(u_rel.dot(t));
					 var u_rixt_rel = rixt.unit().mult(u_rel.dot(rixt.unit()));
					 var u_rjxt_rel = rjxt.unit().mult(-u_rel.dot(rjxt.unit()));
					 this.solver
					 .addConstraint( // Non-penetration constraint jacobian
					 [-t.x,-t.y,-t.z,
					 -rixt.x,-rixt.y,-rixt.z,
					 t.x,t.y,t.z,
					 rjxt.x,rjxt.y,rjxt.z
					 ],

					 // Inverse mass matrix
					 [iMi,iMi,iMi,
					 iIxi,iIyi,iIzi,
					 iMj,iMj,iMj,
					 iIxj,iIyj,iIzj],

					 // g - constraint violation / gap
					 [0,0,0,
					 0,0,0,
					 0,0,0,
					 0,0,0],

					 [-ut_rel.x,-ut_rel.y,-ut_rel.z,
					 0,0,0,//-u_rixt_rel.x,-u_rixt_rel.y,-u_rixt_rel.z,
					 ut_rel.x,ut_rel.y,ut_rel.z,
					 0,0,0//u_rjxt_rel.x,u_rjxt_rel.y,u_rjxt_rel.z
					 ],

					 // External force - forces & torques
					 [bi.force.x,bi.force.y,bi.force.z,
					 bi.tau.x,bi.tau.y,bi.tau.z,
					 bj.force.x,bj.force.y,bj.force.z,
					 bj.tau.x,bj.tau.y,bj.tau.z],

					 -mu*g*(bi.mass+bj.mass),
					 mu*g*(bi.mass+bj.mass),

					 i,
					 j);
					 }
					 }
					 */

				}
			}
		}
	};
	/**
	 * Distance constraint class
	 * @author schteppe
	 * @param CANNON.Body bodyA
	 * @param CANNON.Body bodyB Could optionally be a CANNON.Vec3 to constrain a body to a static point in space
	 * @param float distance
	 * @todo test
	 */
	CANNON.DistanceConstraint = function(bodyA,bodyB,distance){
		CANNON.Constraint.call(this);
		this.body_i = bodyA;
		this.body_j = bodyB;
		this.distance = Number(distance);
		var eq = new CANNON.Equation(bodyA, bodyB instanceof CANNON.Vec3 ? null : bodyB);
		this.equations.push(eq);
	};

	CANNON.DistanceConstraint.prototype = new CANNON.Constraint();
	CANNON.DistanceConstraint.prototype.constructor = CANNON.DistanceConstraint;

	CANNON.DistanceConstraint.prototype.update = function(){
		var eq = this.equations[0], bi = this.body_i, bj = this.body_j;
		var pair = typeof(bj.mass)=="number";

		// Jacobian is the distance unit vector
		if(pair)
			bj.position.vsub(bi.position, eq.G1);
		else{
			bi.position.vsub(bj,eq.G1);
		}
		eq.G1.normalize();
		if(eq.G1.isZero()) eq.G1.set(1,0,0);
		eq.G1.negate(eq.G3);
		//console.log(eq.G1.toString());

		// Mass properties
		eq.setDefaultMassProps();
		eq.setDefaultForce();

		// Constraint violation
		eq.g1.set((pair ? bj.position.x : bj.x) - bi.position.x - eq.G1.x*this.distance,
			(pair ? bj.position.y : bj.y) - bi.position.y - eq.G1.y*this.distance,
			(pair ? bj.position.z : bj.z) - bi.position.z - eq.G1.z*this.distance);
		eq.g1.negate(eq.g1);
		eq.g1.negate(eq.g3);
	};

	CANNON.DistanceConstraint.prototype.setMaxForce = function(f){
		// @todo rescale with masses
		this.equations[0].lambdamax = Math.abs(f);
		this.equations[0].lambdamin = -this.equations[0].lambdamax;
	};/**
	 * Equation class
	 * @author schteppe
	 * @brief Something for the solver to chew on. Its mostly a holder of vectors
	 * @todo try with the solver
	 * @param CANNON.Body bi Could optionally be null
	 * @param CANNON.Body bj Could optionally be null
	 */
	CANNON.Equation = function(bi,bj){

		// Jacobian
		this.G1 = new CANNON.Vec3();
		this.G2 = new CANNON.Vec3();
		this.G3 = new CANNON.Vec3();
		this.G4 = new CANNON.Vec3();

		// Inverse mass matrix
		this.iM1 = new CANNON.Vec3();
		this.iM2 = new CANNON.Vec3();
		this.iM3 = new CANNON.Vec3();
		this.iM4 = new CANNON.Vec3();

		// Constraint violation, g
		this.g1 = new CANNON.Vec3();
		this.g2 = new CANNON.Vec3();
		this.g3 = new CANNON.Vec3();
		this.g4 = new CANNON.Vec3();

		// Derivative of g, gdot
		this.W1 = new CANNON.Vec3();
		this.W2 = new CANNON.Vec3();
		this.W3 = new CANNON.Vec3();
		this.W4 = new CANNON.Vec3();

		// External force, f
		this.f1 = new CANNON.Vec3();
		this.f2 = new CANNON.Vec3();
		this.f3 = new CANNON.Vec3();
		this.f4 = new CANNON.Vec3();

		// Clamping for multipliers (see as max constraint force)
		this.lambdamax =  1e6;
		this.lambdamin = -1e6;

		// Bodies to apply the constraint forces on
		this.body_i = bi;
		this.body_j = bj;
	};

	CANNON.Equation.prototype.setDefaultMassProps = function(){
		var bi = this.body_i, bj = this.body_j;
		if(bi){
			this.iM1.set(bi.invMass,
				bi.invMass,
				bi.invMass);
			if(bi.invInertia)
				bi.invInertia.copy(this.iM2);
		}
		if(bj){
			this.iM3.set(bj.invMass,
				bj.invMass,
				bj.invMass);
			if(bj.invInertia)
				bj.invInertia.copy(this.iM4);
		}
	};

	CANNON.Equation.prototype.setDefaultForce = function(){
		var bi = this.body_i, bj = this.body_j;
		if(bi){
			bi.force.copy(this.f1);
			if(bi.tau) bi.tau.copy(this.f2);
		}
		if(bj){
			bj.force.copy(this.f3);
			if(bj.tau) bj.tau.copy(this.f4);
		}
	};/*global CANNON:true */

	/**
	 * Point to point constraint class
	 * @author schteppe
	 * @param CANNON.Body bodyA
	 * @param CANNON.Vec3 pivotA The point relative to the center of mass of bodyA which bodyA is constrained to.
	 * @param CANNON.Body bodyB Optional. If specified, pivotB must also be specified, and bodyB will be constrained in a similar way to the same point as bodyA. We will therefore get sort of a link between bodyA and bodyB. If not specified, bodyA will be constrained to a static point.
	 * @param CANNON.Vec3 pivotB Optional.
	 */
	CANNON.PointToPointConstraint = function(bodyA,pivotA,bodyB,pivotB){
		CANNON.Constraint.call(this);
		this.body_i = bodyA;
		this.body_j = bodyB;
		this.pivot_i = pivotA;
		this.pivot_j = pivotB;

		// Need 3 equations, 1 normal + 2 tangent
		for(var i=0; i<3; i++)
			this.equations.push(new Equation(bodyA,bodyB));
	};

	CANNON.PointToPointConstraint.prototype = new CANNON.Constraint();
	CANNON.PointToPointConstraint.prototype.constructor = CANNON.PointToPointConstraint;

	/**
	 * @todo
	 */
	CANNON.PointToPointConstraint.prototype.update = function(){
		/*
		 var eq = this.equations[0], bi = this.body_i, bj = this.body_j;

		 // Jacobian is the distance unit vector
		 bj.position.vsub(bi.position,eq.G1);
		 eq.G1.normalize();
		 eq.G1.negate(eq.G3);

		 // Mass properties
		 eq.setDefaultMassProps();
		 eq.setDefaultForce();

		 // Constraint violation
		 eq.g1.set(bj.position.x - bi.position.x - eq.G1.x*dist,
		 bj.position.y - bi.position.y - eq.G1.y*dist,
		 bj.position.z - bi.position.z - eq.G1.z*dist);
		 eq.g1.negate(eq.g3);  
		 */
	};if (typeof module !== 'undefined') {
		// export for node
		module.exports = CANNON;
	} else {
		// assign to window
		this.CANNON = CANNON;
	}

}).apply(this);
var IgeCannonComponent = IgeEventingClass.extend({
	classId: 'IgeCannonComponent',
	componentId: 'cannon',

	init: function (entity, options) {
		this._entity = entity;
		this._options = options;

		this._active = true;
		this._sleep = true;
		this._scaleRatio = 1;
		this._solverIterations = 10;
		this._gravity = new CANNON.Vec3(0, 0, -60);
		this._broadphase = new CANNON.NaiveBroadphase();

		this._removeWhenReady = [];

		// Materials
		this._normalMaterial = new CANNON.Material("normalMaterial");

		// Create a slippery material (friction coefficient = 0.0)
		this._slipperyMaterial = new CANNON.Material("slipperyMaterial");

		// The ContactMaterial defines what happens when two materials meet.
		// In this case we want friction coefficient = 0.0 when the slippery material touches ground.
		this._slipperyNormalCm = new CANNON.ContactMaterial(
			this._normalMaterial,
			this._slipperyMaterial,
			0.0, // friction coefficient
			0.3  // restitution
		);

		// Add the cannon behaviour to the ige
		ige.addBehaviour('cannonStep', this._behaviour);
	},

	/**
	 * Gets / sets if the world should allow sleep or not.
	 * @param {Boolean=} val
	 * @return {*}
	 */
	sleep: function (val) {
		if (val !== undefined) {
			this._sleep = val;
			return this._entity;
		}

		return this._sleep;
	},

	/**
	 * Gets / sets the current engine to cannon scaling ratio.
	 * @param val
	 * @return {*}
	 */
	scaleRatio: function (val) {
		if (val !== undefined) {
			this._scaleRatio = val;
			return this._entity;
		}

		return this._scaleRatio;
	},

	/**
	 * Gets / sets the gravity vector.
	 * @return {*}
	 */
	gravity: function (x, y, z) {
		if (x !== undefined && y !== undefined) {
			this._gravity = new CANNON.Vec3(x, y, z);
			if (this._world) {
				this._world.gravity.set(this._gravity.x, this._gravity.y, this._gravity.z);
			}
			return this._entity;
		}

		return this._gravity;
	},

	solverIterations: function () {
		if (val !== undefined) {
			this._solverIterations = val;
			return this._entity;
		}

		return this._solverIterations;
	},

	createWorld: function () {
		this._world = new CANNON.World();
		this._world.gravity.set(this._gravity.x, this._gravity.y, this._gravity.z);
		this._world.broadphase = this._broadphase;
		this._world.solver.iterations = this._solverIterations;
		this._world.allowSleep = this._sleep;

		// We must add the contact materials to the world
		this._world.addContactMaterial(this._slipperyNormalCm);

		return this._entity;
	},

	createFloor: function (normalX, normalY, normalZ) {
		var groundShape = new CANNON.Plane(new CANNON.Vec3(normalX, normalY, normalZ)),
			groundBody = new CANNON.RigidBody(0, groundShape, this._slipperyMaterial);

		this._world.add(groundBody);
	},

	createBody: function (entity, body) {
		var param,
			type,
			fixtureDef,
			tempShape,
			tempBod,
			i;

		// Process body definition and create a cannon body for it
		switch (body.type) {
			case 'static':
				type = CANNON.Body.STATIC;
				break;

			case 'kinematic':
				type = CANNON.Body.KINEMATIC;
				break;

			case 'dynamic':
				type = CANNON.Body.DYNAMIC;
				break;
		}

		// Now apply any post-creation attributes we need to
		for (param in body) {
			if (body.hasOwnProperty(param)) {
				switch (param) {
					case 'fixtures':
						for (i = 0; i < body.fixtures.length; i++) {
							// Grab the fixture definition
							fixtureDef = body.fixtures[i];

							// Check for a shape definition for the fixture
							if (fixtureDef.shape) {
								// Create based on the shape type
								switch (fixtureDef.shape.type) {
									case 'box':
										if (fixtureDef.shape.data) {
											// Use defined data to create the shape
											if (fixtureDef.shape.data.sizeX !== undefined && fixtureDef.shape.data.sizeY !== undefined && fixtureDef.shape.data.sizeZ !== undefined) {
												tempShape = new CANNON.Box(new CANNON.Vec3(fixtureDef.shape.data.sizeX / this._scaleRatio, fixtureDef.shape.data.sizeY / this._scaleRatio, fixtureDef.shape.data.sizeZ / this._scaleRatio));
											} else {
												tempShape = new CANNON.Box(new CANNON.Vec3(entity._bounds3d.x2 + 1 / this._scaleRatio, entity._bounds3d.y2 / this._scaleRatio, entity._bounds3d.z2 / this._scaleRatio));
											}
										} else {
											tempShape = new CANNON.Box(new CANNON.Vec3(entity._bounds3d.x2 + 1 / this._scaleRatio, entity._bounds3d.y2 + 1 / this._scaleRatio, entity._bounds3d.z2 + 1 / this._scaleRatio));
										}
										break;
								}
							}
						}
						break;
				}
			}
		}

		tempBod = new CANNON.RigidBody(body.mass, tempShape, this._normalMaterial);
		tempBod.sleepSpeedLimit = 0.1;
		tempBod.sleepTimeLimit = 1000;

		if (body.allowSleep !== undefined) { tempBod.allowSleep = body.allowSleep; }
		if (body.sleepSpeedLimit !== undefined) { tempBod.sleepSpeedLimit = body.sleepSpeedLimit; }
		if (body.sleepTimeLimit !== undefined) { tempBod.sleepTimeLimit = body.sleepTimeLimit; }

		if (body.angularDamping !== undefined) { tempBod.angularDamping = body.angularDamping; }
		if (body.linearDamping !== undefined) { tempBod.linearDamping = body.linearDamping; }

		// Set the position
		tempBod.position.set(entity._translate.x / this._scaleRatio, entity._translate.y / this._scaleRatio, (entity._translate.z + entity._bounds3d.z2)  / this._scaleRatio);

		// Store the entity that is linked to this body
		tempBod._igeEntity = entity;

		// Add the body to the world
		this._world.add(tempBod);

		return tempBod;
	},

	enableDebug: function (canvasId) {
		// Define the debug drawing instance
		var debugDraw = new this.b2DebugDraw();
		this._cannonDebug = true;
		this._debugCanvas = document.getElementById(canvasId);
		this._debugCtx = this._debugCanvas.getContext('2d');

		debugDraw.SetSprite(this._debugCtx);
		debugDraw.SetDrawScale(this._scaleRatio);
		debugDraw.SetFillAlpha(0.3);
		debugDraw.SetLineThickness(1.0);
		debugDraw.SetFlags(
			this.b2DebugDraw.e_controllerBit
			| this.b2DebugDraw.e_jointBit
			| this.b2DebugDraw.e_pairBit
			| this.b2DebugDraw.e_shapeBit
			//| this.b2DebugDraw.e_aabbBit
			//| this.b2DebugDraw.e_centerOfMassBit
		);

		// Set the debug draw for the world
		this._world.SetDebugDraw(debugDraw);
	},

	/** step - Step the simulation forward. {
	 category:"method",
	 } **/
	_behaviour: function (ctx) {
		var self = ige.cannon,
			bodiesArr = self._world.bodies,
			bodyCount = bodiesArr.length,
			tempBod, entity;

		if (self._active) {
			// Call the world step
			self._world.step(1 / 60);

			while (bodyCount--) {
				tempBod = bodiesArr[bodyCount];

				// Check if the body has an IGE entity attached to it
				if (tempBod._igeEntity) {
					if (tempBod.isAwake()) {
						entity = tempBod._igeEntity;

						// Update the entity data to match the body data
						tempBod._igeUpdating = true;
						entity.translateTo(Math.ceil(tempBod.position.x * self._scaleRatio), Math.ceil(tempBod.position.y * self._scaleRatio), Math.ceil((tempBod.position.z * self._scaleRatio) - entity._bounds3d.z2));
						//entity.rotateTo(entity._rotate.x, entity._rotate.y, tempBod.GetAngle());
						tempBod._igeUpdating = false;
					}
				}
			}

			/*// Remove any bodies that were queued for removal
			removeWhenReady = self._removeWhenReady;
			count = removeWhenReady.length;

			if (count) {
				destroyBody = self._world.DestroyBody;
				while (count--) {
					destroyBody.apply(self._world, [removeWhenReady[count]]);
				}
				self._removeWhenReady = [];
				removeWhenReady = null;
			}

			// Call the world step; frame-rate, velocity iterations, position iterations
			self._world.Step(1 / 60, 8, 8);

			// Loop the physics objects and move the entities they are assigned to
			tempBod = self._world.GetBodyList();
			while (tempBod) {
				if (tempBod._entity) {
					// Body has an entity assigned to it
					entity = tempBod._entity; //self.ige.entities.read(tempBod.m_userData);
					entityCannonBody = entity._cannonBody;

					// Check if the body is awake and is dynamic (we don't transform static bodies)
					if (tempBod.IsAwake()) {
						// Update the entity data to match the body data
						entityCannonBody.updating = true;
						entity.translateTo(tempBod.m_xf.position.x * self._scaleRatio, tempBod.m_xf.position.y * self._scaleRatio, entity._translate.z);
						entity.rotateTo(entity._rotate.x, entity._rotate.y, tempBod.GetAngle());
						entityCannonBody.updating = false;

						if (entityCannonBody.asleep) {
							// The body was asleep last frame, fire an awake event
							entityCannonBody.asleep = false;
							self.emit('afterAwake', entity);
						}
					} else {
						if (!entityCannonBody.asleep) {
							// The body was awake last frame, fire an asleep event
							entityCannonBody.asleep = true;
							self.emit('afterAsleep', entity);
						}
					}
				}

				tempBod = tempBod.GetNext();
			}

			if (self._cannonDebug && this._currentCamera) {
				// Draw the debug data
				self._debugCanvas.width = ige._bounds2d.x;
				self._debugCanvas.height = ige._bounds2d.y;

				self._debugCtx.save();
				this._currentCamera._transformContext(self._debugCtx);
				self._debugCtx.translate(ige._bounds2d.x2, ige._bounds2d.y2);
				self._world.DrawDebugData();
				self._debugCtx.restore();
			}

			// Clear forces because we have ended our physics simulation frame
			self._world.ClearForces();

			tempBod = null;
			entity = null;*/

			if (typeof(self._updateCallback) === 'function') {
				self._updateCallback();
			}
		}
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = IgeCannonComponent; }

/**
 * Adds client/server time sync capabilities to the network system.
 * This handles calculating the time difference between the clock
 * on the server and the clock on connected clients.
 */
var IgeTimeSyncExtension = {
	/**
	 * Gets / sets the number of milliseconds between client/server
	 * clock sync events. The shorter the time, the more accurate the
	 * client simulation will be but the more network traffic you
	 * will transceive. Default value of ten seconds (10000) is usually
	 * enough to provide very accurate results without over-using the
	 * bandwidth.
	 * @param val
	 * @return {*}
	 */
	timeSyncInterval: function (val) {
		if (val !== undefined) {
			this._timeSyncInterval = val;
			return this._entity;
		}

		return this._timeSyncInterval;
	},

	/* CEXCLUDE */
	timeSyncStart: function () {
		if (ige.isServer) {
			this._timeSyncStarted = true;

			// Send a time sync request now so we
			// have a starting value to work with
			this._sendTimeSync();

			var self = this;

			this.log('Starting client/server clock sync...');
			this._timeSyncTimer = setInterval(function () { self._sendTimeSync(); }, this._timeSyncInterval);
		}

		return this._entity;
	},

	timeSyncStop: function () {
		this.log('Stopping client/server clock sync...');
		clearInterval(this._timeSyncTimer);
		this._timeSyncStarted = false;

		return this._entity;
	},
	/* CEXCLUDE */
	
	_sendTimeSync: function (data, clientId) {
		if (!data) {
			data = ige._currentTime;
		}

		// Send the time sync command
		this.send('_igeNetTimeSync', data, clientId);
	},

	/**
	 * Converts a timestamp on the client to approx. time
	 * on the server using the difference in client/server
	 * clocks and the network latency between this client
	 * and the server.
	 * @param {Number} time The client timestamp (usually
	 * the result of new Date().getTime() or
	 * ige.currentTime()).
	 */
	timeToServerTime: function (time) {
		if (time !== undefined) {
			return time + this._latency;
		}

		return this._latency;
	},

	_onTimeSync: function (data, clientId) {
		var localTime = Math.floor(ige._currentTime),
			sendTime,
			roundTrip,
			direction;

		if (ige.isClient) {
			sendTime = parseInt(data, 10);

			this._latency = localTime - sendTime;

			/*if (localTime < sendTime) {
				direction = 'behind';
			} else if (localTime > sendTime) {
				direction = 'in front of';
			} else {
				direction = 'same as';
			}

			this.log('Time sync, client clock ' + (localTime - sendTime) + 'ms ' + direction + ' server, send timestamp: ' + sendTime + ', local timestamp: ' + localTime);*/

			// Send a response with out current clock time to the server
			this._sendTimeSync([data, localTime]);
		}
		
		/* CEXCLUDE */
		if (ige.isServer) {
			sendTime = parseInt(data[1], 10);
			roundTrip = (localTime - parseInt(data[0], 10));

			/*if (localTime < sendTime) {
				direction = 'behind';
			} else if (localTime > sendTime) {
				direction = 'in front of';
			} else {
				direction = 'same as';
			}

			this.log('Time sync, server clock ' + (localTime - sendTime) + 'ms ' + direction + ' client, roundtrip: ' + roundTrip + 'ms, send timestamp: ' + parseInt(data[0], 10) + ', local timestamp: ' + localTime);*/

			this._timeSyncLog[clientId] = localTime - sendTime;
		}
		/* CEXCLUDE */
	}
};

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = IgeTimeSyncExtension; }
/**
 * Adds stream capabilities to the network system.
 */
var IgeStreamComponent = IgeEventingClass.extend({
	classId: 'IgeStreamComponent',
	componentId: 'stream',

	/**
	 * @constructor
	 * @param entity
	 * @param options
	 */
	init: function (entity, options) {
		this._entity = entity;
		this._options = options;

		var self = this;
		
		// Set the stream data section designator character
		this._sectionDesignator = '¬';

		/* CEXCLUDE */
		if (ige.isServer) {
			// Define the network stream command
			this._entity.define('_igeStreamCreate');
			this._entity.define('_igeStreamDestroy');
			this._entity.define('_igeStreamData');
			this._entity.define('_igeStreamTime');

			// Define the object that will hold the stream data queue
			this._queuedData = {};

			// Set some stream data containers
			this._streamClientData = {};
			this._streamClientCreated = {};
		}
		/* CEXCLUDE */

		if (ige.isClient) {
			// Define the network stream command
			this._entity.define('_igeStreamCreate', function () { self._onStreamCreate.apply(self, arguments); });
			this._entity.define('_igeStreamDestroy', function () { self._onStreamDestroy.apply(self, arguments); });
			this._entity.define('_igeStreamData', function () { self._onStreamData.apply(self, arguments); });
			this._entity.define('_igeStreamTime', function () { self._onStreamTime.apply(self, arguments); });
		}

		// Set some defaults
		this._renderLatency = 100;
		this._streamInterval = 50;
	},

	/**
	 * Gets /Sets the amount of milliseconds in the past that the renderer will
	 * show updates from the stream. This allows us to interpolate from a previous
	 * position to the next position in the stream update. Updates come in and
	 * are already in the past when they are received so we need to set this
	 * latency value to something greater than the highest level of acceptable
	 * network latency. Usually this is a value between 100 and 200ms. If your
	 * game requires much tighter latency you will have to reduce the number of
	 * players / network updates / data size in order to compensate. A value of
	 * 100 in this call is the standard that most triple-A FPS games accept as
	 * normal render latency and should be OK for your game.
	 *
	 * @param latency
	 */
	renderLatency: function (latency) {
		if (latency !== undefined) {
			this._renderLatency = latency;
			return this._entity;
		}

		return this._renderLatency;
	},

	/* CEXCLUDE */
	/**
	 * Gets / sets the interval by which updates to the game world are packaged
	 * and transmitted to connected clients. The greater the value, the less
	 * updates are sent per second.
	 * @param {Number=} ms The number of milliseconds between stream messages.
	 */
	sendInterval: function (ms) {
		if (ms !== undefined) {
			this.log('Setting delta stream interval to ' + (ms / ige._timeScale) + 'ms');
			this._streamInterval = ms / ige._timeScale;
			return this._entity;
		}

		return this._streamInterval;
	},

	/**
	 * Starts the stream of world updates to connected clients.
	 */
	start: function () {
		var self = this;

		this.log('Starting delta stream...');
		this._streamTimer = setInterval(function () { self._sendQueue(); }, this._streamInterval);

		return this._entity;
	},

	/**
	 * Stops the stream of world updates to connected clients.
	 */
	stop: function () {
		this._stopTimeSync();

		this.log('Stopping delta stream...');
		clearInterval(this._streamTimer);

		return this._entity;
	},

	/**
	 * Queues stream data to be sent during the next stream data interval.
	 * @param {String} id The id of the entity that this data belongs to.
	 * @param {String} data The data queued for delivery to the client.
	 * @param {String} clientId The client id this data is queued for.
	 * @return {*}
	 */
	queue: function (id, data, clientId) {
		this._queuedData[id] = [data, clientId];
		return this._entity;
	},

	/**
	 * Asks the server to send the data packets for all the queued stream
	 * data to the specified clients.
	 * @private
	 */
	_sendQueue: function () {
		var st = new Date().getTime(),
			ct,
			dt,
			arr = this._queuedData,
			arrIndex,
			network = this._entity,
			item, currentTime = ige._currentTime,
			clientSentTimeData = {};

		// Send the stream data
		for (arrIndex in arr) {
			if (arr.hasOwnProperty(arrIndex)) {
				item = arr[arrIndex];

				// Check if we've already sent this client the starting
				// time of the stream data
				if (!clientSentTimeData[item[1]]) {
					// Send the stream start time
					network.send('_igeStreamTime', currentTime, item[1]);
					clientSentTimeData[item[1]] = true;
				}
				network.send('_igeStreamData', item[0], item[1]);

				delete arr[arrIndex];
			}

			ct = new Date().getTime();
			dt = ct - st;

			if (dt > this._streamInterval) {
				console.log('WARNING, Stream send is taking too long: ' + dt + 'ms');
				break;
			}
		}
	},
	/* CEXCLUDE */

	/**
	 * Handles receiving the start time of the stream data.
	 * @param data
	 * @private
	 */
	_onStreamTime: function (data) {
		this._streamDataTime = data;
	},

	_onStreamCreate: function (data) {
		var classId = data[0],
			entityId = data[1],
			parentId = data[2],
			transformData = data[3],
			createData = data[4],
			parent = ige.$(parentId),
			classConstructor,
			entity;

		// Check the required class exists
		if (parent) {
			// Check that the entity doesn't already exist
			if (!ige.$(entityId)) {
				classConstructor = igeClassStore[classId];

				if (classConstructor) {
					// The entity does not currently exist so create it!
					entity = new classConstructor(createData)
						.id(entityId)
						.mount(parent);
					
					entity.streamSectionData('transform', transformData, true);

					// Set the just created flag which will stop the renderer
					// from handling this entity until after the first stream
					// data has been received for it
					entity._streamJustCreated = true;
					
					if (entity._streamEmitCreated) {
						entity.emit('streamCreated');
					}

					// Since we just created an entity through receiving stream
					// data, inform any interested listeners
					this.emit('entityCreated', entity);
				} else {
					ige.network.stop();
					ige.stop();

					this.log('Network stream cannot create entity with class ' + classId + ' because the class has not been defined! The engine will now stop.', 'error');
				}
			}
		} else {
			this.log('Cannot properly handle network streamed entity with id ' + entityId + ' because it\'s parent with id ' + parentId + ' does not exist on the scenegraph!', 'warning');
		}
	},

	_onStreamDestroy: function (data) {
		var entity = ige.$(data[1]),
			self = this;
		
		if (entity) {
			// Calculate how much time we have left before the entity
			// should be removed from the simulation given the render
			// latency setting and the current time
			var destroyDelta = ige.network.stream._renderLatency + (ige._currentTime - data[0]);
			
			if (destroyDelta > 0) {
				// Give the entity a lifespan to destroy it in x ms
				entity.lifeSpan(destroyDelta, function () {
					self.emit('entityDestroyed', entity);
				});
			} else {
				// Destroy immediately
				self.emit('entityDestroyed', entity);
				entity.destroy();
			}
		}
	},

	/**
	 * Called when the client receives data from the stream system.
	 * Handles decoding the data and calling the relevant entity
	 * _onStreamData() methods.
	 * @param data
	 * @private
	 */
	_onStreamData: function (data) {
		// Read the packet data into variables
		var entityId,
			entity,
			sectionArr,
			sectionDataArr = data.split(ige.network.stream._sectionDesignator),
			sectionDataCount = sectionDataArr.length,
			sectionIndex,
			justCreated;

		// We know the first bit of data will always be the
		// target entity's ID
		entityId = sectionDataArr.shift();

		// Check if the entity with this ID currently exists
		entity = ige.$(entityId);

		if (entity) {
			// Hold the entity's just created flag
			justCreated = entity._streamJustCreated;

			// Get the entity stream section array
			sectionArr = entity._streamSections;

			// Now loop the data sections array and compile the rest of the
			// data string from the data section return data
			for (sectionIndex = 0; sectionIndex < sectionDataCount; sectionIndex++) {
				// Tell the entity to handle this section's data
				entity.streamSectionData(sectionArr[sectionIndex], sectionDataArr[sectionIndex], justCreated);
			}

			// Now that the entity has had it's first bit of data
			// reset the just created flag
			delete entity._streamJustCreated;
		} else {
			this.log('+++ Stream: Data received for unknown entity (' + entityId +')');
		}
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = IgeStreamComponent; }
/*! Socket.IO.min.js build:0.9.11, production. Copyright(c) 2011 LearnBoost <dev@learnboost.com> MIT Licensed */
var io="undefined"==typeof module?{}:module.exports;(function(){(function(a,b){var c=a;c.version="0.9.11",c.protocol=1,c.transports=[],c.j=[],c.sockets={},c.connect=function(a,d){var e=c.util.parseUri(a),f,g;b&&b.location&&(e.protocol=e.protocol||b.location.protocol.slice(0,-1),e.host=e.host||(b.document?b.document.domain:b.location.hostname),e.port=e.port||b.location.port),f=c.util.uniqueUri(e);var h={host:e.host,secure:"https"==e.protocol,port:e.port||("https"==e.protocol?443:80),query:e.query||""};c.util.merge(h,d);if(h["force new connection"]||!c.sockets[f])g=new c.Socket(h);return!h["force new connection"]&&g&&(c.sockets[f]=g),g=g||c.sockets[f],g.of(e.path.length>1?e.path:"")}})("object"==typeof module?module.exports:this.io={},this),function(a,b){var c=a.util={},d=/^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/,e=["source","protocol","authority","userInfo","user","password","host","port","relative","path","directory","file","query","anchor"];c.parseUri=function(a){var b=d.exec(a||""),c={},f=14;while(f--)c[e[f]]=b[f]||"";return c},c.uniqueUri=function(a){var c=a.protocol,d=a.host,e=a.port;return"document"in b?(d=d||document.domain,e=e||(c=="https"&&document.location.protocol!=="https:"?443:document.location.port)):(d=d||"localhost",!e&&c=="https"&&(e=443)),(c||"http")+"://"+d+":"+(e||80)},c.query=function(a,b){var d=c.chunkQuery(a||""),e=[];c.merge(d,c.chunkQuery(b||""));for(var f in d)d.hasOwnProperty(f)&&e.push(f+"="+d[f]);return e.length?"?"+e.join("&"):""},c.chunkQuery=function(a){var b={},c=a.split("&"),d=0,e=c.length,f;for(;d<e;++d)f=c[d].split("="),f[0]&&(b[f[0]]=f[1]);return b};var f=!1;c.load=function(a){if("document"in b&&document.readyState==="complete"||f)return a();c.on(b,"load",a,!1)},c.on=function(a,b,c,d){a.attachEvent?a.attachEvent("on"+b,c):a.addEventListener&&a.addEventListener(b,c,d)},c.request=function(a){if(a&&"undefined"!=typeof XDomainRequest&&!c.ua.hasCORS)return new XDomainRequest;if("undefined"!=typeof XMLHttpRequest&&(!a||c.ua.hasCORS))return new XMLHttpRequest;if(!a)try{return new(window[["Active"].concat("Object").join("X")])("Microsoft.XMLHTTP")}catch(b){}return null},"undefined"!=typeof window&&c.load(function(){f=!0}),c.defer=function(a){if(!c.ua.webkit||"undefined"!=typeof importScripts)return a();c.load(function(){setTimeout(a,100)})},c.merge=function(b,d,e,f){var g=f||[],h=typeof e=="undefined"?2:e,i;for(i in d)d.hasOwnProperty(i)&&c.indexOf(g,i)<0&&(typeof b[i]!="object"||!h?(b[i]=d[i],g.push(d[i])):c.merge(b[i],d[i],h-1,g));return b},c.mixin=function(a,b){c.merge(a.prototype,b.prototype)},c.inherit=function(a,b){function c(){}c.prototype=b.prototype,a.prototype=new c},c.isArray=Array.isArray||function(a){return Object.prototype.toString.call(a)==="[object Array]"},c.intersect=function(a,b){var d=[],e=a.length>b.length?a:b,f=a.length>b.length?b:a;for(var g=0,h=f.length;g<h;g++)~c.indexOf(e,f[g])&&d.push(f[g]);return d},c.indexOf=function(a,b,c){for(var d=a.length,c=c<0?c+d<0?0:c+d:c||0;c<d&&a[c]!==b;c++);return d<=c?-1:c},c.toArray=function(a){var b=[];for(var c=0,d=a.length;c<d;c++)b.push(a[c]);return b},c.ua={},c.ua.hasCORS="undefined"!=typeof XMLHttpRequest&&function(){try{var a=new XMLHttpRequest}catch(b){return!1}return a.withCredentials!=undefined}(),c.ua.webkit="undefined"!=typeof navigator&&/webkit/i.test(navigator.userAgent),c.ua.iDevice="undefined"!=typeof navigator&&/iPad|iPhone|iPod/i.test(navigator.userAgent)}("undefined"!=typeof io?io:module.exports,this),function(a,b){function c(){}a.EventEmitter=c,c.prototype.on=function(a,c){return this.$events||(this.$events={}),this.$events[a]?b.util.isArray(this.$events[a])?this.$events[a].push(c):this.$events[a]=[this.$events[a],c]:this.$events[a]=c,this},c.prototype.addListener=c.prototype.on,c.prototype.once=function(a,b){function d(){c.removeListener(a,d),b.apply(this,arguments)}var c=this;return d.listener=b,this.on(a,d),this},c.prototype.removeListener=function(a,c){if(this.$events&&this.$events[a]){var d=this.$events[a];if(b.util.isArray(d)){var e=-1;for(var f=0,g=d.length;f<g;f++)if(d[f]===c||d[f].listener&&d[f].listener===c){e=f;break}if(e<0)return this;d.splice(e,1),d.length||delete this.$events[a]}else(d===c||d.listener&&d.listener===c)&&delete this.$events[a]}return this},c.prototype.removeAllListeners=function(a){return a===undefined?(this.$events={},this):(this.$events&&this.$events[a]&&(this.$events[a]=null),this)},c.prototype.listeners=function(a){return this.$events||(this.$events={}),this.$events[a]||(this.$events[a]=[]),b.util.isArray(this.$events[a])||(this.$events[a]=[this.$events[a]]),this.$events[a]},c.prototype.emit=function(a){if(!this.$events)return!1;var c=this.$events[a];if(!c)return!1;var d=Array.prototype.slice.call(arguments,1);if("function"==typeof c)c.apply(this,d);else{if(!b.util.isArray(c))return!1;var e=c.slice();for(var f=0,g=e.length;f<g;f++)e[f].apply(this,d)}return!0}}("undefined"!=typeof io?io:module.exports,"undefined"!=typeof io?io:module.parent.exports),function(exports,nativeJSON){function f(a){return a<10?"0"+a:a}function date(a,b){return isFinite(a.valueOf())?a.getUTCFullYear()+"-"+f(a.getUTCMonth()+1)+"-"+f(a.getUTCDate())+"T"+f(a.getUTCHours())+":"+f(a.getUTCMinutes())+":"+f(a.getUTCSeconds())+"Z":null}function quote(a){return escapable.lastIndex=0,escapable.test(a)?'"'+a.replace(escapable,function(a){var b=meta[a];return typeof b=="string"?b:"\\u"+("0000"+a.charCodeAt(0).toString(16)).slice(-4)})+'"':'"'+a+'"'}function str(a,b){var c,d,e,f,g=gap,h,i=b[a];i instanceof Date&&(i=date(a)),typeof rep=="function"&&(i=rep.call(b,a,i));switch(typeof i){case"string":return quote(i);case"number":return isFinite(i)?String(i):"null";case"boolean":case"null":return String(i);case"object":if(!i)return"null";gap+=indent,h=[];if(Object.prototype.toString.apply(i)==="[object Array]"){f=i.length;for(c=0;c<f;c+=1)h[c]=str(c,i)||"null";return e=h.length===0?"[]":gap?"[\n"+gap+h.join(",\n"+gap)+"\n"+g+"]":"["+h.join(",")+"]",gap=g,e}if(rep&&typeof rep=="object"){f=rep.length;for(c=0;c<f;c+=1)typeof rep[c]=="string"&&(d=rep[c],e=str(d,i),e&&h.push(quote(d)+(gap?": ":":")+e))}else for(d in i)Object.prototype.hasOwnProperty.call(i,d)&&(e=str(d,i),e&&h.push(quote(d)+(gap?": ":":")+e));return e=h.length===0?"{}":gap?"{\n"+gap+h.join(",\n"+gap)+"\n"+g+"}":"{"+h.join(",")+"}",gap=g,e}}"use strict";if(nativeJSON&&nativeJSON.parse)return exports.JSON={parse:nativeJSON.parse,stringify:nativeJSON.stringify};var JSON=exports.JSON={},cx=/[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,escapable=/[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,gap,indent,meta={"\b":"\\b","\t":"\\t","\n":"\\n","\f":"\\f","\r":"\\r",'"':'\\"',"\\":"\\\\"},rep;JSON.stringify=function(a,b,c){var d;gap="",indent="";if(typeof c=="number")for(d=0;d<c;d+=1)indent+=" ";else typeof c=="string"&&(indent=c);rep=b;if(!b||typeof b=="function"||typeof b=="object"&&typeof b.length=="number")return str("",{"":a});throw new Error("JSON.stringify")},JSON.parse=function(text,reviver){function walk(a,b){var c,d,e=a[b];if(e&&typeof e=="object")for(c in e)Object.prototype.hasOwnProperty.call(e,c)&&(d=walk(e,c),d!==undefined?e[c]=d:delete e[c]);return reviver.call(a,b,e)}var j;text=String(text),cx.lastIndex=0,cx.test(text)&&(text=text.replace(cx,function(a){return"\\u"+("0000"+a.charCodeAt(0).toString(16)).slice(-4)}));if(/^[\],:{}\s]*$/.test(text.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g,"@").replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,"]").replace(/(?:^|:|,)(?:\s*\[)+/g,"")))return j=eval("("+text+")"),typeof reviver=="function"?walk({"":j},""):j;throw new SyntaxError("JSON.parse")}}("undefined"!=typeof io?io:module.exports,typeof JSON!="undefined"?JSON:undefined),function(a,b){var c=a.parser={},d=c.packets=["disconnect","connect","heartbeat","message","json","event","ack","error","noop"],e=c.reasons=["transport not supported","client not handshaken","unauthorized"],f=c.advice=["reconnect"],g=b.JSON,h=b.util.indexOf;c.encodePacket=function(a){var b=h(d,a.type),c=a.id||"",i=a.endpoint||"",j=a.ack,k=null;switch(a.type){case"error":var l=a.reason?h(e,a.reason):"",m=a.advice?h(f,a.advice):"";if(l!==""||m!=="")k=l+(m!==""?"+"+m:"");break;case"message":a.data!==""&&(k=a.data);break;case"event":var n={name:a.name};a.args&&a.args.length&&(n.args=a.args),k=g.stringify(n);break;case"json":k=g.stringify(a.data);break;case"connect":a.qs&&(k=a.qs);break;case"ack":k=a.ackId+(a.args&&a.args.length?"+"+g.stringify(a.args):"")}var o=[b,c+(j=="data"?"+":""),i];return k!==null&&k!==undefined&&o.push(k),o.join(":")},c.encodePayload=function(a){var b="";if(a.length==1)return a[0];for(var c=0,d=a.length;c<d;c++){var e=a[c];b+="\ufffd"+e.length+"\ufffd"+a[c]}return b};var i=/([^:]+):([0-9]+)?(\+)?:([^:]+)?:?([\s\S]*)?/;c.decodePacket=function(a){var b=a.match(i);if(!b)return{};var c=b[2]||"",a=b[5]||"",h={type:d[b[1]],endpoint:b[4]||""};c&&(h.id=c,b[3]?h.ack="data":h.ack=!0);switch(h.type){case"error":var b=a.split("+");h.reason=e[b[0]]||"",h.advice=f[b[1]]||"";break;case"message":h.data=a||"";break;case"event":try{var j=g.parse(a);h.name=j.name,h.args=j.args}catch(k){}h.args=h.args||[];break;case"json":try{h.data=g.parse(a)}catch(k){}break;case"connect":h.qs=a||"";break;case"ack":var b=a.match(/^([0-9]+)(\+)?(.*)/);if(b){h.ackId=b[1],h.args=[];if(b[3])try{h.args=b[3]?g.parse(b[3]):[]}catch(k){}}break;case"disconnect":case"heartbeat":}return h},c.decodePayload=function(a){if(a.charAt(0)=="\ufffd"){var b=[];for(var d=1,e="";d<a.length;d++)a.charAt(d)=="\ufffd"?(b.push(c.decodePacket(a.substr(d+1).substr(0,e))),d+=Number(e)+1,e=""):e+=a.charAt(d);return b}return[c.decodePacket(a)]}}("undefined"!=typeof io?io:module.exports,"undefined"!=typeof io?io:module.parent.exports),function(a,b){function c(a,b){this.socket=a,this.sessid=b}a.Transport=c,b.util.mixin(c,b.EventEmitter),c.prototype.heartbeats=function(){return!0},c.prototype.onData=function(a){this.clearCloseTimeout(),(this.socket.connected||this.socket.connecting||this.socket.reconnecting)&&this.setCloseTimeout();if(a!==""){var c=b.parser.decodePayload(a);if(c&&c.length)for(var d=0,e=c.length;d<e;d++)this.onPacket(c[d])}return this},c.prototype.onPacket=function(a){return this.socket.setHeartbeatTimeout(),a.type=="heartbeat"?this.onHeartbeat():(a.type=="connect"&&a.endpoint==""&&this.onConnect(),a.type=="error"&&a.advice=="reconnect"&&(this.isOpen=!1),this.socket.onPacket(a),this)},c.prototype.setCloseTimeout=function(){if(!this.closeTimeout){var a=this;this.closeTimeout=setTimeout(function(){a.onDisconnect()},this.socket.closeTimeout)}},c.prototype.onDisconnect=function(){return this.isOpen&&this.close(),this.clearTimeouts(),this.socket.onDisconnect(),this},c.prototype.onConnect=function(){return this.socket.onConnect(),this},c.prototype.clearCloseTimeout=function(){this.closeTimeout&&(clearTimeout(this.closeTimeout),this.closeTimeout=null)},c.prototype.clearTimeouts=function(){this.clearCloseTimeout(),this.reopenTimeout&&clearTimeout(this.reopenTimeout)},c.prototype.packet=function(a){this.send(b.parser.encodePacket(a))},c.prototype.onHeartbeat=function(a){this.packet({type:"heartbeat"})},c.prototype.onOpen=function(){this.isOpen=!0,this.clearCloseTimeout(),this.socket.onOpen()},c.prototype.onClose=function(){var a=this;this.isOpen=!1,this.socket.onClose(),this.onDisconnect()},c.prototype.prepareUrl=function(){var a=this.socket.options;return this.scheme()+"://"+a.host+":"+a.port+"/"+a.resource+"/"+b.protocol+"/"+this.name+"/"+this.sessid},c.prototype.ready=function(a,b){b.call(this)}}("undefined"!=typeof io?io:module.exports,"undefined"!=typeof io?io:module.parent.exports),function(a,b,c){function d(a){this.options={port:80,secure:!1,document:"document"in c?document:!1,resource:"socket.io",transports:b.transports,"connect timeout":1e4,"try multiple transports":!0,reconnect:!0,"reconnection delay":500,"reconnection limit":Infinity,"reopen delay":3e3,"max reconnection attempts":10,"sync disconnect on unload":!1,"auto connect":!0,"flash policy port":10843,manualFlush:!1},b.util.merge(this.options,a),this.connected=!1,this.open=!1,this.connecting=!1,this.reconnecting=!1,this.namespaces={},this.buffer=[],this.doBuffer=!1;if(this.options["sync disconnect on unload"]&&(!this.isXDomain()||b.util.ua.hasCORS)){var d=this;b.util.on(c,"beforeunload",function(){d.disconnectSync()},!1)}this.options["auto connect"]&&this.connect()}function e(){}a.Socket=d,b.util.mixin(d,b.EventEmitter),d.prototype.of=function(a){return this.namespaces[a]||(this.namespaces[a]=new b.SocketNamespace(this,a),a!==""&&this.namespaces[a].packet({type:"connect"})),this.namespaces[a]},d.prototype.publish=function(){this.emit.apply(this,arguments);var a;for(var b in this.namespaces)this.namespaces.hasOwnProperty(b)&&(a=this.of(b),a.$emit.apply(a,arguments))},d.prototype.handshake=function(a){function f(b){b instanceof Error?(c.connecting=!1,c.onError(b.message)):a.apply(null,b.split(":"))}var c=this,d=this.options,g=["http"+(d.secure?"s":"")+":/",d.host+":"+d.port,d.resource,b.protocol,b.util.query(this.options.query,"t="+ +(new Date))].join("/");if(this.isXDomain()&&!b.util.ua.hasCORS){var h=document.getElementsByTagName("script")[0],i=document.createElement("script");i.src=g+"&jsonp="+b.j.length,h.parentNode.insertBefore(i,h),b.j.push(function(a){f(a),i.parentNode.removeChild(i)})}else{var j=b.util.request();j.open("GET",g,!0),this.isXDomain()&&(j.withCredentials=!0),j.onreadystatechange=function(){j.readyState==4&&(j.onreadystatechange=e,j.status==200?f(j.responseText):j.status==403?c.onError(j.responseText):(c.connecting=!1,!c.reconnecting&&c.onError(j.responseText)))},j.send(null)}},d.prototype.getTransport=function(a){var c=a||this.transports,d;for(var e=0,f;f=c[e];e++)if(b.Transport[f]&&b.Transport[f].check(this)&&(!this.isXDomain()||b.Transport[f].xdomainCheck(this)))return new b.Transport[f](this,this.sessionid);return null},d.prototype.connect=function(a){if(this.connecting)return this;var c=this;return c.connecting=!0,this.handshake(function(d,e,f,g){function h(a){c.transport&&c.transport.clearTimeouts(),c.transport=c.getTransport(a);if(!c.transport)return c.publish("connect_failed");c.transport.ready(c,function(){c.connecting=!0,c.publish("connecting",c.transport.name),c.transport.open(),c.options["connect timeout"]&&(c.connectTimeoutTimer=setTimeout(function(){if(!c.connected){c.connecting=!1;if(c.options["try multiple transports"]){var a=c.transports;while(a.length>0&&a.splice(0,1)[0]!=c.transport.name);a.length?h(a):c.publish("connect_failed")}}},c.options["connect timeout"]))})}c.sessionid=d,c.closeTimeout=f*1e3,c.heartbeatTimeout=e*1e3,c.transports||(c.transports=c.origTransports=g?b.util.intersect(g.split(","),c.options.transports):c.options.transports),c.setHeartbeatTimeout(),h(c.transports),c.once("connect",function(){clearTimeout(c.connectTimeoutTimer),a&&typeof a=="function"&&a()})}),this},d.prototype.setHeartbeatTimeout=function(){clearTimeout(this.heartbeatTimeoutTimer);if(this.transport&&!this.transport.heartbeats())return;var a=this;this.heartbeatTimeoutTimer=setTimeout(function(){a.transport.onClose()},this.heartbeatTimeout)},d.prototype.packet=function(a){return this.connected&&!this.doBuffer?this.transport.packet(a):this.buffer.push(a),this},d.prototype.setBuffer=function(a){this.doBuffer=a,!a&&this.connected&&this.buffer.length&&(this.options.manualFlush||this.flushBuffer())},d.prototype.flushBuffer=function(){this.transport.payload(this.buffer),this.buffer=[]},d.prototype.disconnect=function(){if(this.connected||this.connecting)this.open&&this.of("").packet({type:"disconnect"}),this.onDisconnect("booted");return this},d.prototype.disconnectSync=function(){var a=b.util.request(),c=["http"+(this.options.secure?"s":"")+":/",this.options.host+":"+this.options.port,this.options.resource,b.protocol,"",this.sessionid].join("/")+"/?disconnect=1";a.open("GET",c,!1),a.send(null),this.onDisconnect("booted")},d.prototype.isXDomain=function(){var a=c.location.port||("https:"==c.location.protocol?443:80);return this.options.host!==c.location.hostname||this.options.port!=a},d.prototype.onConnect=function(){this.connected||(this.connected=!0,this.connecting=!1,this.doBuffer||this.setBuffer(!1),this.emit("connect"))},d.prototype.onOpen=function(){this.open=!0},d.prototype.onClose=function(){this.open=!1,clearTimeout(this.heartbeatTimeoutTimer)},d.prototype.onPacket=function(a){this.of(a.endpoint).onPacket(a)},d.prototype.onError=function(a){a&&a.advice&&a.advice==="reconnect"&&(this.connected||this.connecting)&&(this.disconnect(),this.options.reconnect&&this.reconnect()),this.publish("error",a&&a.reason?a.reason:a)},d.prototype.onDisconnect=function(a){var b=this.connected,c=this.connecting;this.connected=!1,this.connecting=!1,this.open=!1;if(b||c)this.transport.close(),this.transport.clearTimeouts(),b&&(this.publish("disconnect",a),"booted"!=a&&this.options.reconnect&&!this.reconnecting&&this.reconnect())},d.prototype.reconnect=function(){function e(){if(a.connected){for(var b in a.namespaces)a.namespaces.hasOwnProperty(b)&&""!==b&&a.namespaces[b].packet({type:"connect"});a.publish("reconnect",a.transport.name,a.reconnectionAttempts)}clearTimeout(a.reconnectionTimer),a.removeListener("connect_failed",f),a.removeListener("connect",f),a.reconnecting=!1,delete a.reconnectionAttempts,delete a.reconnectionDelay,delete a.reconnectionTimer,delete a.redoTransports,a.options["try multiple transports"]=c}function f(){if(!a.reconnecting)return;if(a.connected)return e();if(a.connecting&&a.reconnecting)return a.reconnectionTimer=setTimeout(f,1e3);a.reconnectionAttempts++>=b?a.redoTransports?(a.publish("reconnect_failed"),e()):(a.on("connect_failed",f),a.options["try multiple transports"]=!0,a.transports=a.origTransports,a.transport=a.getTransport(),a.redoTransports=!0,a.connect()):(a.reconnectionDelay<d&&(a.reconnectionDelay*=2),a.connect(),a.publish("reconnecting",a.reconnectionDelay,a.reconnectionAttempts),a.reconnectionTimer=setTimeout(f,a.reconnectionDelay))}this.reconnecting=!0,this.reconnectionAttempts=0,this.reconnectionDelay=this.options["reconnection delay"];var a=this,b=this.options["max reconnection attempts"],c=this.options["try multiple transports"],d=this.options["reconnection limit"];this.options["try multiple transports"]=!1,this.reconnectionTimer=setTimeout(f,this.reconnectionDelay),this.on("connect",f)}}("undefined"!=typeof io?io:module.exports,"undefined"!=typeof io?io:module.parent.exports,this),function(a,b){function c(a,b){this.socket=a,this.name=b||"",this.flags={},this.json=new d(this,"json"),this.ackPackets=0,this.acks={}}function d(a,b){this.namespace=a,this.name=b}a.SocketNamespace=c,b.util.mixin(c,b.EventEmitter),c.prototype.$emit=b.EventEmitter.prototype.emit,c.prototype.of=function(){return this.socket.of.apply(this.socket,arguments)},c.prototype.packet=function(a){return a.endpoint=this.name,this.socket.packet(a),this.flags={},this},c.prototype.send=function(a,b){var c={type:this.flags.json?"json":"message",data:a};return"function"==typeof b&&(c.id=++this.ackPackets,c.ack=!0,this.acks[c.id]=b),this.packet(c)},c.prototype.emit=function(a){var b=Array.prototype.slice.call(arguments,1),c=b[b.length-1],d={type:"event",name:a};return"function"==typeof c&&(d.id=++this.ackPackets,d.ack="data",this.acks[d.id]=c,b=b.slice(0,b.length-1)),d.args=b,this.packet(d)},c.prototype.disconnect=function(){return this.name===""?this.socket.disconnect():(this.packet({type:"disconnect"}),this.$emit("disconnect")),this},c.prototype.onPacket=function(a){function d(){c.packet({type:"ack",args:b.util.toArray(arguments),ackId:a.id})}var c=this;switch(a.type){case"connect":this.$emit("connect");break;case"disconnect":this.name===""?this.socket.onDisconnect(a.reason||"booted"):this.$emit("disconnect",a.reason);break;case"message":case"json":var e=["message",a.data];a.ack=="data"?e.push(d):a.ack&&this.packet({type:"ack",ackId:a.id}),this.$emit.apply(this,e);break;case"event":var e=[a.name].concat(a.args);a.ack=="data"&&e.push(d),this.$emit.apply(this,e);break;case"ack":this.acks[a.ackId]&&(this.acks[a.ackId].apply(this,a.args),delete this.acks[a.ackId]);break;case"error":a.advice?this.socket.onError(a):a.reason=="unauthorized"?this.$emit("connect_failed",a.reason):this.$emit("error",a.reason)}},d.prototype.send=function(){this.namespace.flags[this.name]=!0,this.namespace.send.apply(this.namespace,arguments)},d.prototype.emit=function(){this.namespace.flags[this.name]=!0,this.namespace.emit.apply(this.namespace,arguments)}}("undefined"!=typeof io?io:module.exports,"undefined"!=typeof io?io:module.parent.exports),function(a,b,c){function d(a){b.Transport.apply(this,arguments)}a.websocket=d,b.util.inherit(d,b.Transport),d.prototype.name="websocket",d.prototype.open=function(){var a=b.util.query(this.socket.options.query),d=this,e;return e||(e=c.MozWebSocket||c.WebSocket),this.websocket=new e(this.prepareUrl()+a),this.websocket.onopen=function(){d.onOpen(),d.socket.setBuffer(!1)},this.websocket.onmessage=function(a){d.onData(a.data)},this.websocket.onclose=function(){d.onClose(),d.socket.setBuffer(!0)},this.websocket.onerror=function(a){d.onError(a)},this},b.util.ua.iDevice?d.prototype.send=function(a){var b=this;return setTimeout(function(){b.websocket.send(a)},0),this}:d.prototype.send=function(a){return this.websocket.send(a),this},d.prototype.payload=function(a){for(var b=0,c=a.length;b<c;b++)this.packet(a[b]);return this},d.prototype.close=function(){return this.websocket.close(),this},d.prototype.onError=function(a){this.socket.onError(a)},d.prototype.scheme=function(){return this.socket.options.secure?"wss":"ws"},d.check=function(){return"WebSocket"in c&&!("__addTask"in WebSocket)||"MozWebSocket"in c},d.xdomainCheck=function(){return!0},b.transports.push("websocket")}("undefined"!=typeof io?io.Transport:module.exports,"undefined"!=typeof io?io:module.parent.exports,this),function(a,b){function c(){b.Transport.websocket.apply(this,arguments)}a.flashsocket=c,b.util.inherit(c,b.Transport.websocket),c.prototype.name="flashsocket",c.prototype.open=function(){var a=this,c=arguments;return WebSocket.__addTask(function(){b.Transport.websocket.prototype.open.apply(a,c)}),this},c.prototype.send=function(){var a=this,c=arguments;return WebSocket.__addTask(function(){b.Transport.websocket.prototype.send.apply(a,c)}),this},c.prototype.close=function(){return WebSocket.__tasks.length=0,b.Transport.websocket.prototype.close.call(this),this},c.prototype.ready=function(a,d){function e(){var b=a.options,e=b["flash policy port"],g=["http"+(b.secure?"s":"")+":/",b.host+":"+b.port,b.resource,"static/flashsocket","WebSocketMain"+(a.isXDomain()?"Insecure":"")+".swf"];c.loaded||(typeof WEB_SOCKET_SWF_LOCATION=="undefined"&&(WEB_SOCKET_SWF_LOCATION=g.join("/")),e!==843&&WebSocket.loadFlashPolicyFile("xmlsocket://"+b.host+":"+e),WebSocket.__initialize(),c.loaded=!0),d.call(f)}var f=this;if(document.body)return e();b.util.load(e)},c.check=function(){return typeof WebSocket!="undefined"&&"__initialize"in WebSocket&&!!swfobject?swfobject.getFlashPlayerVersion().major>=10:!1},c.xdomainCheck=function(){return!0},typeof window!="undefined"&&(WEB_SOCKET_DISABLE_AUTO_INITIALIZATION=!0),b.transports.push("flashsocket")}("undefined"!=typeof io?io.Transport:module.exports,"undefined"!=typeof io?io:module.parent.exports);if("undefined"!=typeof window)var swfobject=function(){function A(){if(t)return;try{var a=i.getElementsByTagName("body")[0].appendChild(Q("span"));a.parentNode.removeChild(a)}catch(b){return}t=!0;var c=l.length;for(var d=0;d<c;d++)l[d]()}function B(a){t?a():l[l.length]=a}function C(b){if(typeof h.addEventListener!=a)h.addEventListener("load",b,!1);else if(typeof i.addEventListener!=a)i.addEventListener("load",b,!1);else if(typeof h.attachEvent!=a)R(h,"onload",b);else if(typeof h.onload=="function"){var c=h.onload;h.onload=function(){c(),b()}}else h.onload=b}function D(){k?E():F()}function E(){var c=i.getElementsByTagName("body")[0],d=Q(b);d.setAttribute("type",e);var f=c.appendChild(d);if(f){var g=0;(function(){if(typeof f.GetVariable!=a){var b=f.GetVariable("$version");b&&(b=b.split(" ")[1].split(","),y.pv=[parseInt(b[0],10),parseInt(b[1],10),parseInt(b[2],10)])}else if(g<10){g++,setTimeout(arguments.callee,10);return}c.removeChild(d),f=null,F()})()}else F()}function F(){var b=m.length;if(b>0)for(var c=0;c<b;c++){var d=m[c].id,e=m[c].callbackFn,f={success:!1,id:d};if(y.pv[0]>0){var g=P(d);if(g)if(S(m[c].swfVersion)&&!(y.wk&&y.wk<312))U(d,!0),e&&(f.success=!0,f.ref=G(d),e(f));else if(m[c].expressInstall&&H()){var h={};h.data=m[c].expressInstall,h.width=g.getAttribute("width")||"0",h.height=g.getAttribute("height")||"0",g.getAttribute("class")&&(h.styleclass=g.getAttribute("class")),g.getAttribute("align")&&(h.align=g.getAttribute("align"));var i={},j=g.getElementsByTagName("param"),k=j.length;for(var l=0;l<k;l++)j[l].getAttribute("name").toLowerCase()!="movie"&&(i[j[l].getAttribute("name")]=j[l].getAttribute("value"));I(h,i,d,e)}else J(g),e&&e(f)}else{U(d,!0);if(e){var n=G(d);n&&typeof n.SetVariable!=a&&(f.success=!0,f.ref=n),e(f)}}}}function G(c){var d=null,e=P(c);if(e&&e.nodeName=="OBJECT")if(typeof e.SetVariable!=a)d=e;else{var f=e.getElementsByTagName(b)[0];f&&(d=f)}return d}function H(){return!u&&S("6.0.65")&&(y.win||y.mac)&&!(y.wk&&y.wk<312)}function I(b,c,d,e){u=!0,r=e||null,s={success:!1,id:d};var g=P(d);if(g){g.nodeName=="OBJECT"?(p=K(g),q=null):(p=g,q=d),b.id=f;if(typeof b.width==a||!/%$/.test(b.width)&&parseInt(b.width,10)<310)b.width="310";if(typeof b.height==a||!/%$/.test(b.height)&&parseInt(b.height,10)<137)b.height="137";i.title=i.title.slice(0,47)+" - Flash Player Installation";var j=y.ie&&y.win?["Active"].concat("").join("X"):"PlugIn",k="MMredirectURL="+h.location.toString().replace(/&/g,"%26")+"&MMplayerType="+j+"&MMdoctitle="+i.title;typeof c.flashvars!=a?c.flashvars+="&"+k:c.flashvars=k;if(y.ie&&y.win&&g.readyState!=4){var l=Q("div");d+="SWFObjectNew",l.setAttribute("id",d),g.parentNode.insertBefore(l,g),g.style.display="none",function(){g.readyState==4?g.parentNode.removeChild(g):setTimeout(arguments.callee,10)}()}L(b,c,d)}}function J(a){if(y.ie&&y.win&&a.readyState!=4){var b=Q("div");a.parentNode.insertBefore(b,a),b.parentNode.replaceChild(K(a),b),a.style.display="none",function(){a.readyState==4?a.parentNode.removeChild(a):setTimeout(arguments.callee,10)}()}else a.parentNode.replaceChild(K(a),a)}function K(a){var c=Q("div");if(y.win&&y.ie)c.innerHTML=a.innerHTML;else{var d=a.getElementsByTagName(b)[0];if(d){var e=d.childNodes;if(e){var f=e.length;for(var g=0;g<f;g++)(e[g].nodeType!=1||e[g].nodeName!="PARAM")&&e[g].nodeType!=8&&c.appendChild(e[g].cloneNode(!0))}}}return c}function L(c,d,f){var g,h=P(f);if(y.wk&&y.wk<312)return g;if(h){typeof c.id==a&&(c.id=f);if(y.ie&&y.win){var i="";for(var j in c)c[j]!=Object.prototype[j]&&(j.toLowerCase()=="data"?d.movie=c[j]:j.toLowerCase()=="styleclass"?i+=' class="'+c[j]+'"':j.toLowerCase()!="classid"&&(i+=" "+j+'="'+c[j]+'"'));var k="";for(var l in d)d[l]!=Object.prototype[l]&&(k+='<param name="'+l+'" value="'+d[l]+'" />');h.outerHTML='<object classid="clsid:D27CDB6E-AE6D-11cf-96B8-444553540000"'+i+">"+k+"</object>",n[n.length]=c.id,g=P(c.id)}else{var m=Q(b);m.setAttribute("type",e);for(var o in c)c[o]!=Object.prototype[o]&&(o.toLowerCase()=="styleclass"?m.setAttribute("class",c[o]):o.toLowerCase()!="classid"&&m.setAttribute(o,c[o]));for(var p in d)d[p]!=Object.prototype[p]&&p.toLowerCase()!="movie"&&M(m,p,d[p]);h.parentNode.replaceChild(m,h),g=m}}return g}function M(a,b,c){var d=Q("param");d.setAttribute("name",b),d.setAttribute("value",c),a.appendChild(d)}function N(a){var b=P(a);b&&b.nodeName=="OBJECT"&&(y.ie&&y.win?(b.style.display="none",function(){b.readyState==4?O(a):setTimeout(arguments.callee,10)}()):b.parentNode.removeChild(b))}function O(a){var b=P(a);if(b){for(var c in b)typeof b[c]=="function"&&(b[c]=null);b.parentNode.removeChild(b)}}function P(a){var b=null;try{b=i.getElementById(a)}catch(c){}return b}function Q(a){return i.createElement(a)}function R(a,b,c){a.attachEvent(b,c),o[o.length]=[a,b,c]}function S(a){var b=y.pv,c=a.split(".");return c[0]=parseInt(c[0],10),c[1]=parseInt(c[1],10)||0,c[2]=parseInt(c[2],10)||0,b[0]>c[0]||b[0]==c[0]&&b[1]>c[1]||b[0]==c[0]&&b[1]==c[1]&&b[2]>=c[2]?!0:!1}function T(c,d,e,f){if(y.ie&&y.mac)return;var g=i.getElementsByTagName("head")[0];if(!g)return;var h=e&&typeof e=="string"?e:"screen";f&&(v=null,w=null);if(!v||w!=h){var j=Q("style");j.setAttribute("type","text/css"),j.setAttribute("media",h),v=g.appendChild(j),y.ie&&y.win&&typeof i.styleSheets!=a&&i.styleSheets.length>0&&(v=i.styleSheets[i.styleSheets.length-1]),w=h}y.ie&&y.win?v&&typeof v.addRule==b&&v.addRule(c,d):v&&typeof i.createTextNode!=a&&v.appendChild(i.createTextNode(c+" {"+d+"}"))}function U(a,b){if(!x)return;var c=b?"visible":"hidden";t&&P(a)?P(a).style.visibility=c:T("#"+a,"visibility:"+c)}function V(b){var c=/[\\\"<>\.;]/,d=c.exec(b)!=null;return d&&typeof encodeURIComponent!=a?encodeURIComponent(b):b}var a="undefined",b="object",c="Shockwave Flash",d="ShockwaveFlash.ShockwaveFlash",e="application/x-shockwave-flash",f="SWFObjectExprInst",g="onreadystatechange",h=window,i=document,j=navigator,k=!1,l=[D],m=[],n=[],o=[],p,q,r,s,t=!1,u=!1,v,w,x=!0,y=function(){var f=typeof i.getElementById!=a&&typeof i.getElementsByTagName!=a&&typeof i.createElement!=a,g=j.userAgent.toLowerCase(),l=j.platform.toLowerCase(),m=l?/win/.test(l):/win/.test(g),n=l?/mac/.test(l):/mac/.test(g),o=/webkit/.test(g)?parseFloat(g.replace(/^.*webkit\/(\d+(\.\d+)?).*$/,"$1")):!1,p=!1,q=[0,0,0],r=null;if(typeof j.plugins!=a&&typeof j.plugins[c]==b)r=j.plugins[c].description,r&&(typeof j.mimeTypes==a||!j.mimeTypes[e]||!!j.mimeTypes[e].enabledPlugin)&&(k=!0,p=!1,r=r.replace(/^.*\s+(\S+\s+\S+$)/,"$1"),q[0]=parseInt(r.replace(/^(.*)\..*$/,"$1"),10),q[1]=parseInt(r.replace(/^.*\.(.*)\s.*$/,"$1"),10),q[2]=/[a-zA-Z]/.test(r)?parseInt(r.replace(/^.*[a-zA-Z]+(.*)$/,"$1"),10):0);else if(typeof h[["Active"].concat("Object").join("X")]!=a)try{var s=new(window[["Active"].concat("Object").join("X")])(d);s&&(r=s.GetVariable("$version"),r&&(p=!0,r=r.split(" ")[1].split(","),q=[parseInt(r[0],10),parseInt(r[1],10),parseInt(r[2],10)]))}catch(t){}return{w3:f,pv:q,wk:o,ie:p,win:m,mac:n}}(),z=function(){if(!y.w3)return;(typeof i.readyState!=a&&i.readyState=="complete"||typeof i.readyState==a&&(i.getElementsByTagName("body")[0]||i.body))&&A(),t||(typeof i.addEventListener!=a&&i.addEventListener("DOMContentLoaded",A,!1),y.ie&&y.win&&(i.attachEvent(g,function(){i.readyState=="complete"&&(i.detachEvent(g,arguments.callee),A())}),h==top&&function(){if(t)return;try{i.documentElement.doScroll("left")}catch(a){setTimeout(arguments.callee,0);return}A()}()),y.wk&&function(){if(t)return;if(!/loaded|complete/.test(i.readyState)){setTimeout(arguments.callee,0);return}A()}(),C(A))}(),W=function(){y.ie&&y.win&&window.attachEvent("onunload",function(){var a=o.length;for(var b=0;b<a;b++)o[b][0].detachEvent(o[b][1],o[b][2]);var c=n.length;for(var d=0;d<c;d++)N(n[d]);for(var e in y)y[e]=null;y=null;for(var f in swfobject)swfobject[f]=null;swfobject=null})}();return{registerObject:function(a,b,c,d){if(y.w3&&a&&b){var e={};e.id=a,e.swfVersion=b,e.expressInstall=c,e.callbackFn=d,m[m.length]=e,U(a,!1)}else d&&d({success:!1,id:a})},getObjectById:function(a){if(y.w3)return G(a)},embedSWF:function(c,d,e,f,g,h,i,j,k,l){var m={success:!1,id:d};y.w3&&!(y.wk&&y.wk<312)&&c&&d&&e&&f&&g?(U(d,!1),B(function(){e+="",f+="";var n={};if(k&&typeof k===b)for(var o in k)n[o]=k[o];n.data=c,n.width=e,n.height=f;var p={};if(j&&typeof j===b)for(var q in j)p[q]=j[q];if(i&&typeof i===b)for(var r in i)typeof p.flashvars!=a?p.flashvars+="&"+r+"="+i[r]:p.flashvars=r+"="+i[r];if(S(g)){var s=L(n,p,d);n.id==d&&U(d,!0),m.success=!0,m.ref=s}else{if(h&&H()){n.data=h,I(n,p,d,l);return}U(d,!0)}l&&l(m)})):l&&l(m)},switchOffAutoHideShow:function(){x=!1},ua:y,getFlashPlayerVersion:function(){return{major:y.pv[0],minor:y.pv[1],release:y.pv[2]}},hasFlashPlayerVersion:S,createSWF:function(a,b,c){return y.w3?L(a,b,c):undefined},showExpressInstall:function(a,b,c,d){y.w3&&H()&&I(a,b,c,d)},removeSWF:function(a){y.w3&&N(a)},createCSS:function(a,b,c,d){y.w3&&T(a,b,c,d)},addDomLoadEvent:B,addLoadEvent:C,getQueryParamValue:function(a){var b=i.location.search||i.location.hash;if(b){/\?/.test(b)&&(b=b.split("?")[1]);if(a==null)return V(b);var c=b.split("&");for(var d=0;d<c.length;d++)if(c[d].substring(0,c[d].indexOf("="))==a)return V(c[d].substring(c[d].indexOf("=")+1))}return""},expressInstallCallback:function(){if(u){var a=P(f);a&&p&&(a.parentNode.replaceChild(p,a),q&&(U(q,!0),y.ie&&y.win&&(p.style.display="block")),r&&r(s)),u=!1}}}}();(function(){if("undefined"==typeof window||window.WebSocket)return;var a=window.console;if(!a||!a.log||!a.error)a={log:function(){},error:function(){}};if(!swfobject.hasFlashPlayerVersion("10.0.0")){a.error("Flash Player >= 10.0.0 is required.");return}location.protocol=="file:"&&a.error("WARNING: web-socket-js doesn't work in file:///... URL unless you set Flash Security Settings properly. Open the page via Web server i.e. http://..."),WebSocket=function(a,b,c,d,e){var f=this;f.__id=WebSocket.__nextId++,WebSocket.__instances[f.__id]=f,f.readyState=WebSocket.CONNECTING,f.bufferedAmount=0,f.__events={},b?typeof b=="string"&&(b=[b]):b=[],setTimeout(function(){WebSocket.__addTask(function(){WebSocket.__flash.create(f.__id,a,b,c||null,d||0,e||null)})},0)},WebSocket.prototype.send=function(a){if(this.readyState==WebSocket.CONNECTING)throw"INVALID_STATE_ERR: Web Socket connection has not been established";var b=WebSocket.__flash.send(this.__id,encodeURIComponent(a));return b<0?!0:(this.bufferedAmount+=b,!1)},WebSocket.prototype.close=function(){if(this.readyState==WebSocket.CLOSED||this.readyState==WebSocket.CLOSING)return;this.readyState=WebSocket.CLOSING,WebSocket.__flash.close(this.__id)},WebSocket.prototype.addEventListener=function(a,b,c){a in this.__events||(this.__events[a]=[]),this.__events[a].push(b)},WebSocket.prototype.removeEventListener=function(a,b,c){if(!(a in this.__events))return;var d=this.__events[a];for(var e=d.length-1;e>=0;--e)if(d[e]===b){d.splice(e,1);break}},WebSocket.prototype.dispatchEvent=function(a){var b=this.__events[a.type]||[];for(var c=0;c<b.length;++c)b[c](a);var d=this["on"+a.type];d&&d(a)},WebSocket.prototype.__handleEvent=function(a){"readyState"in a&&(this.readyState=a.readyState),"protocol"in a&&(this.protocol=a.protocol);var b;if(a.type=="open"||a.type=="error")b=this.__createSimpleEvent(a.type);else if(a.type=="close")b=this.__createSimpleEvent("close");else{if(a.type!="message")throw"unknown event type: "+a.type;var c=decodeURIComponent(a.message);b=this.__createMessageEvent("message",c)}this.dispatchEvent(b)},WebSocket.prototype.__createSimpleEvent=function(a){if(document.createEvent&&window.Event){var b=document.createEvent("Event");return b.initEvent(a,!1,!1),b}return{type:a,bubbles:!1,cancelable:!1}},WebSocket.prototype.__createMessageEvent=function(a,b){if(document.createEvent&&window.MessageEvent&&!window.opera){var c=document.createEvent("MessageEvent");return c.initMessageEvent("message",!1,!1,b,null,null,window,null),c}return{type:a,data:b,bubbles:!1,cancelable:!1}},WebSocket.CONNECTING=0,WebSocket.OPEN=1,WebSocket.CLOSING=2,WebSocket.CLOSED=3,WebSocket.__flash=null,WebSocket.__instances={},WebSocket.__tasks=[],WebSocket.__nextId=0,WebSocket.loadFlashPolicyFile=function(a){WebSocket.__addTask(function(){WebSocket.__flash.loadManualPolicyFile(a)})},WebSocket.__initialize=function(){if(WebSocket.__flash)return;WebSocket.__swfLocation&&(window.WEB_SOCKET_SWF_LOCATION=WebSocket.__swfLocation);if(!window.WEB_SOCKET_SWF_LOCATION){a.error("[WebSocket] set WEB_SOCKET_SWF_LOCATION to location of WebSocketMain.swf");return}var b=document.createElement("div");b.id="webSocketContainer",b.style.position="absolute",WebSocket.__isFlashLite()?(b.style.left="0px",b.style.top="0px"):(b.style.left="-100px",b.style.top="-100px");var c=document.createElement("div");c.id="webSocketFlash",b.appendChild(c),document.body.appendChild(b),swfobject.embedSWF(WEB_SOCKET_SWF_LOCATION,"webSocketFlash","1","1","10.0.0",null,null,{hasPriority:!0,swliveconnect:!0,allowScriptAccess:"always"},null,function(b){b.success||a.error("[WebSocket] swfobject.embedSWF failed")})},WebSocket.__onFlashInitialized=function(){setTimeout(function(){WebSocket.__flash=document.getElementById("webSocketFlash"),WebSocket.__flash.setCallerUrl(location.href),WebSocket.__flash.setDebug(!!window.WEB_SOCKET_DEBUG);for(var a=0;a<WebSocket.__tasks.length;++a)WebSocket.__tasks[a]();WebSocket.__tasks=[]},0)},WebSocket.__onFlashEvent=function(){return setTimeout(function(){try{var b=WebSocket.__flash.receiveEvents();for(var c=0;c<b.length;++c)WebSocket.__instances[b[c].webSocketId].__handleEvent(b[c])}catch(d){a.error(d)}},0),!0},WebSocket.__log=function(b){a.log(decodeURIComponent(b))},WebSocket.__error=function(b){a.error(decodeURIComponent(b))},WebSocket.__addTask=function(a){WebSocket.__flash?a():WebSocket.__tasks.push(a)},WebSocket.__isFlashLite=function(){if(!window.navigator||!window.navigator.mimeTypes)return!1;var a=window.navigator.mimeTypes["application/x-shockwave-flash"];return!a||!a.enabledPlugin||!a.enabledPlugin.filename?!1:a.enabledPlugin.filename.match(/flashlite/i)?!0:!1},window.WEB_SOCKET_DISABLE_AUTO_INITIALIZATION||(window.addEventListener?window.addEventListener("load",function(){WebSocket.__initialize()},!1):window.attachEvent("onload",function(){WebSocket.__initialize()}))})(),function(a,b,c){function d(a){if(!a)return;b.Transport.apply(this,arguments),this.sendBuffer=[]}function e(){}a.XHR=d,b.util.inherit(d,b.Transport),d.prototype.open=function(){return this.socket.setBuffer(!1),this.onOpen(),this.get(),this.setCloseTimeout(),this},d.prototype.payload=function(a){var c=[];for(var d=0,e=a.length;d<e;d++)c.push(b.parser.encodePacket(a[d]));this.send(b.parser.encodePayload(c))},d.prototype.send=function(a){return this.post(a),this},d.prototype.post=function(a){function d(){this.readyState==4&&(this.onreadystatechange=e,b.posting=!1,this.status==200?b.socket.setBuffer(!1):b.onClose())}function f(){this.onload=e,b.socket.setBuffer(!1)}var b=this;this.socket.setBuffer(!0),this.sendXHR=this.request("POST"),c.XDomainRequest&&this.sendXHR instanceof XDomainRequest?this.sendXHR.onload=this.sendXHR.onerror=f:this.sendXHR.onreadystatechange=d,this.sendXHR.send(a)},d.prototype.close=function(){return this.onClose(),this},d.prototype.request=function(a){var c=b.util.request(this.socket.isXDomain()),d=b.util.query(this.socket.options.query,"t="+ +(new Date));c.open(a||"GET",this.prepareUrl()+d,!0);if(a=="POST")try{c.setRequestHeader?c.setRequestHeader("Content-type","text/plain;charset=UTF-8"):c.contentType="text/plain"}catch(e){}return c},d.prototype.scheme=function(){return this.socket.options.secure?"https":"http"},d.check=function(a,d){try{var e=b.util.request(d),f=c.XDomainRequest&&e instanceof XDomainRequest,g=a&&a.options&&a.options.secure?"https:":"http:",h=c.location&&g!=c.location.protocol;if(e&&(!f||!h))return!0}catch(i){}return!1},d.xdomainCheck=function(a){return d.check(a,!0)}}("undefined"!=typeof io?io.Transport:module.exports,"undefined"!=typeof io?io:module.parent.exports,this),function(a,b){function c(a){b.Transport.XHR.apply(this,arguments)}a.htmlfile=c,b.util.inherit(c,b.Transport.XHR),c.prototype.name="htmlfile",c.prototype.get=function(){this.doc=new(window[["Active"].concat("Object").join("X")])("htmlfile"),this.doc.open(),this.doc.write("<html></html>"),this.doc.close(),this.doc.parentWindow.s=this;var a=this.doc.createElement("div");a.className="socketio",this.doc.body.appendChild(a),this.iframe=this.doc.createElement("iframe"),a.appendChild(this.iframe);var c=this,d=b.util.query(this.socket.options.query,"t="+ +(new Date));this.iframe.src=this.prepareUrl()+d,b.util.on(window,"unload",function(){c.destroy()})},c.prototype._=function(a,b){this.onData(a);try{var c=b.getElementsByTagName("script")[0];c.parentNode.removeChild(c)}catch(d){}},c.prototype.destroy=function(){if(this.iframe){try{this.iframe.src="about:blank"}catch(a){}this.doc=null,this.iframe.parentNode.removeChild(this.iframe),this.iframe=null,CollectGarbage()}},c.prototype.close=function(){return this.destroy(),b.Transport.XHR.prototype.close.call(this)},c.check=function(a){if(typeof window!="undefined"&&["Active"].concat("Object").join("X")in window)try{var c=new(window[["Active"].concat("Object").join("X")])("htmlfile");return c&&b.Transport.XHR.check(a)}catch(d){}return!1},c.xdomainCheck=function(){return!1},b.transports.push("htmlfile")}("undefined"!=typeof io?io.Transport:module.exports,"undefined"!=typeof io?io:module.parent.exports),function(a,b,c){function d(){b.Transport.XHR.apply(this,arguments)}function e(){}a["xhr-polling"]=d,b.util.inherit(d,b.Transport.XHR),b.util.merge(d,b.Transport.XHR),d.prototype.name="xhr-polling",d.prototype.heartbeats=function(){return!1},d.prototype.open=function(){var a=this;return b.Transport.XHR.prototype.open.call(a),!1},d.prototype.get=function(){function b(){this.readyState==4&&(this.onreadystatechange=e,this.status==200?(a.onData(this.responseText),a.get()):a.onClose())}function d(){this.onload=e,this.onerror=e,a.retryCounter=1,a.onData(this.responseText),a.get()}function f(){a.retryCounter++,!a.retryCounter||a.retryCounter>3?a.onClose():a.get()}if(!this.isOpen)return;var a=this;this.xhr=this.request(),c.XDomainRequest&&this.xhr instanceof XDomainRequest?(this.xhr.onload=d,this.xhr.onerror=f):this.xhr.onreadystatechange=b,this.xhr.send(null)},d.prototype.onClose=function(){b.Transport.XHR.prototype.onClose.call(this);if(this.xhr){this.xhr.onreadystatechange=this.xhr.onload=this.xhr.onerror=e;try{this.xhr.abort()}catch(a){}this.xhr=null}},d.prototype.ready=function(a,c){var d=this;b.util.defer(function(){c.call(d)})},b.transports.push("xhr-polling")}("undefined"!=typeof io?io.Transport:module.exports,"undefined"!=typeof io?io:module.parent.exports,this),function(a,b,c){function e(a){b.Transport["xhr-polling"].apply(this,arguments),this.index=b.j.length;var c=this;b.j.push(function(a){c._(a)})}var d=c.document&&"MozAppearance"in c.document.documentElement.style;a["jsonp-polling"]=e,b.util.inherit(e,b.Transport["xhr-polling"]),e.prototype.name="jsonp-polling",e.prototype.post=function(a){function i(){j(),c.socket.setBuffer(!1)}function j(){c.iframe&&c.form.removeChild(c.iframe);try{h=document.createElement('<iframe name="'+c.iframeId+'">')}catch(a){h=document.createElement("iframe"),h.name=c.iframeId}h.id=c.iframeId,c.form.appendChild(h),c.iframe=h}var c=this,d=b.util.query(this.socket.options.query,"t="+ +(new Date)+"&i="+this.index);if(!this.form){var e=document.createElement("form"),f=document.createElement("textarea"),g=this.iframeId="socketio_iframe_"+this.index,h;e.className="socketio",e.style.position="absolute",e.style.top="0px",e.style.left="0px",e.style.display="none",e.target=g,e.method="POST",e.setAttribute("accept-charset","utf-8"),f.name="d",e.appendChild(f),document.body.appendChild(e),this.form=e,this.area=f}this.form.action=this.prepareUrl()+d,j(),this.area.value=b.JSON.stringify(a);try{this.form.submit()}catch(k){}this.iframe.attachEvent?h.onreadystatechange=function(){c.iframe.readyState=="complete"&&i()}:this.iframe.onload=i,this.socket.setBuffer(!0)},e.prototype.get=function(){var a=this,c=document.createElement("script"),e=b.util.query(this.socket.options.query,"t="+ +(new Date)+"&i="+this.index);this.script&&(this.script.parentNode.removeChild(this.script),this.script=null),c.async=!0,c.src=this.prepareUrl()+e,c.onerror=function(){a.onClose()};var f=document.getElementsByTagName("script")[0];f.parentNode.insertBefore(c,f),this.script=c,d&&setTimeout(function(){var a=document.createElement("iframe");document.body.appendChild(a),document.body.removeChild(a)},100)},e.prototype._=function(a){return this.onData(a),this.isOpen&&this.get(),this},e.prototype.ready=function(a,c){var e=this;if(!d)return c.call(this);b.util.load(function(){c.call(e)})},e.check=function(){return"document"in c},e.xdomainCheck=function(){return!0},b.transports.push("jsonp-polling")}("undefined"!=typeof io?io.Transport:module.exports,"undefined"!=typeof io?io:module.parent.exports,this),typeof define=="function"&&define.amd&&define([],function(){return io})})()
/**
 * The client-side socket.io component. Handles all client-side
 * networking systems.
 */
var IgeSocketIoClient = {
	_initDone: false,
	_idCounter: 0,
	_requests: {},

	/**
	 * Gets the current socket id.
	 * @returns {String} The id of the socket connection to the server.
	 */
	id: function () {
		if (this._io && this._io.socket) {
			return this._io.socket.sessionid;
		} else {
			return '';
		}
	},
	
	/**
	 * Starts the network for the client.
	 * @param {*} data The game server URL.
	 * @param {Function=} callback A callback method to call once the
	 * network has started.
	 */
	start: function (data, callback) {
		var self = this;

		// Check if the io library exists and use ioNoDom otherwise
		if (typeof(io) === 'undefined') {
			io = ioNoDom;
		}

		self._startCallback = callback;

		if (typeof(data) !== 'undefined') {
			this._port = data;
		}

		this.log('Connecting to socket.io server at "' + this._port + '"...');

		this._io = io.connect(data);

		// Define connect listener
		this._io.on('connect', function () {
			self._onConnectToServer.apply(self, arguments);
		});

		// Define message listener
		this._io.on('message', function (data) {
			if (!self._initDone) {
				var i, commandCount = 0;

				// Check if the data is an init packet
				if (data.cmd === 'init') {
					// Set flag to show we've now received an init command
					self._initDone = true;

					// Setup the network commands storage
					self._networkCommandsLookup = data.ncmds;

					// Fill the reverse lookup on the commands
					for (i in self._networkCommandsLookup) {
						if (self._networkCommandsLookup.hasOwnProperty(i)) {
							self._networkCommandsIndex[self._networkCommandsLookup[i]] = i;
							commandCount++;
						}
					}

					// Setup default command listeners
					self.define('_igeRequest', function () { self._onRequest.apply(self, arguments); });
					self.define('_igeResponse', function () { self._onResponse.apply(self, arguments); });
					self.define('_igeNetTimeSync', function () { self._onTimeSync.apply(self, arguments); });

					self.log('Received network command list with count: ' + commandCount);

					// Now fire the start() callback
					if (typeof(self._startCallback) === 'function') {
						self._startCallback();
						delete self._startCallback;
					}
				}
			}

			self._onMessageFromServer.apply(self, arguments);
		});

		// Define disconnect listener
		this._io.on('disconnect', function () {
			self._onDisconnectFromServer.apply(self, arguments);
		});
	},

	/**
	 * Gets / sets a network command and callback. When a network command
	 * is received by the client, the callback set up for that command will
	 * automatically be called and passed the data from the incoming network
	 * packet.
	 * @param {String} commandName The name of the command to define.
	 * @param {Function} callback A function to call when the defined network
	 * command is received by the network.
	 * @return {*}
	 */
	define: function (commandName, callback) {
		if (commandName !== undefined && callback !== undefined) {
			// Check if this command has been defined by the server
			if (this._networkCommandsLookup[commandName] !== undefined) {
				this._networkCommands[commandName] = callback;
			} else {
				this.log('Cannot define network command "' + commandName + '" because it does not exist on the server. Please edit your server code and define the network command there before trying to define it on the client!', 'error');
			}

			return this._entity;
		} else {
			this.log('Cannot define network command either the commandName or callback parameters were undefined!', 'error');
		}
	},

	send: function (commandName, data) {
		var commandIndex = this._networkCommandsLookup[commandName];

		if (commandIndex !== undefined) {
			this._io.json.send([commandIndex, data]);
		} else {
			this.log('Cannot send network packet with command "' + commandName + '" because the command has not been defined!', 'error');
		}
	},
	
	/**
	 * Sends a network request. This is different from a standard
	 * call to send() because the recipient code will be able to
	 * respond by calling ige.network.response(). When the response
	 * is received, the callback method that was passed in the
	 * callback parameter will be fired with the response data.
	 * @param {String} commandName
	 * @param {Object} data
	 * @param {Function} callback
	 */
	request: function (commandName, data, callback) {
		// Build the request object
		var req = {
			id: this.newIdHex(),
			cmd: commandName,
			data: data,
			callback: callback,
			timestamp: new Date().getTime()
		};

		// Store the request object
		this._requests[req.id] = req;

		// Send the network request packet
		this.send(
			'_igeRequest',
			{
				id: req.id,
				cmd: commandName,
				data: req.data
			}
		);
	},

	/**
	 * Sends a response to a network request.
	 * @param {String} requestId
	 * @param {Object} data
	 */
	response: function (requestId, data) {
		// Grab the original request object
		var req = this._requests[requestId];

		if (req) {
			// Send the network response packet
			this.send(
				'_igeResponse',
				{
					id: requestId,
					cmd: req.commandName,
					data: data
				}
			);

			// Remove the request as we've now responded!
			delete this._requests[requestId];
		}
	},
	
	/**
	 * Generates a new 16-character hexadecimal unique ID
	 * @return {String}
	 */
	newIdHex: function () {
		this._idCounter++;
		return (this._idCounter + (Math.random() * Math.pow(10, 17) + Math.random() * Math.pow(10, 17) + Math.random() * Math.pow(10, 17) + Math.random() * Math.pow(10, 17))).toString(16);
	},
	
	_onRequest: function (data) {
		// The message is a network request so fire
		// the command event with the request id and
		// the request data
		this._requests[data.id] = data;

		if (this.debug()) {
			console.log('onRequest', data);
			this._debugCounter++;
		}

		if (this._networkCommands[data.cmd]) {
			this._networkCommands[data.cmd](data.id, data.data);
		}

		this.emit(data.cmd, [data.id, data.data]);
	},

	_onResponse: function (data) {
		// The message is a network response
		// to a request we sent earlier
		var id = data.id;

		// Get the original request object from
		// the request id
		var req = this._requests[id];

		if (this.debug()) {
			console.log('onResponse', data);
			this._debugCounter++;
		}

		if (req) {
			// Fire the request callback!
			if (req.callback) {
				req.callback(req.cmd, data.data);
			}

			// Delete the request from memory
			delete this._requests[id];
		}
	},

	/**
	 * Called when the network connects to the server.
	 * @private
	 */
	_onConnectToServer: function () {
		this.log('Connected to server!');
		this.emit('connected');
	},

	/**
	 * Called when data from the server is received on the client.
	 * @param data
	 * @private
	 */
	_onMessageFromServer: function (data) {
		var commandName = this._networkCommandsIndex[data[0]];
		if (this._networkCommands[commandName]) {
			this._networkCommands[commandName](data[1]);
		}
		this.emit(commandName, data[1]);
	},

	/**
	 * Called when the client is disconnected from the server.
	 * @param data
	 * @private
	 */
	_onDisconnectFromServer: function (data) {
		if (data === 'booted') {
			this.log('Server rejected our connection because it is not accepting connections at this time!', 'warning');
		} else {
			this.log('Disconnected from server!');
		}
		this.emit('disconnected');
	}
};

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = IgeSocketIoClient; }

var IgeSocketIoComponent = IgeEventingClass.extend([
	{extension: IgeTimeSyncExtension, overwrite: false}
], {
	classId: 'IgeSocketIoComponent',
	componentId: 'network',

	init: function (entity, options) {
		this._entity = entity;
		this._options = options;

		// Setup the network commands storage
		this._networkCommands = {};
		this._networkCommandsIndex = [];
		this._networkCommandsLookup = {};

		// Set some defaults
		this._port = 8000;
		this._debug = false;
		this._debugMax = 0;
		this._clientRooms = {};

		// Time sync defaults
		this._timeSyncInterval = 10000; // Sync the client/server clocks every ten seconds by default
		this._timeSyncLog = {};
		this._latency = 0;

		/* CEXCLUDE */
		if (ige.isServer) {
			this.implement(IgeSocketIoServer);
			this._socketio = require('../../../' + modulePath + 'socket.io');
			this._acceptConnections = false;
		}
		/* CEXCLUDE */

		if (ige.isClient) {
			this._socketio = IgeSocketIoClient;
			this.implement(IgeSocketIoClient);
		}

		this.log('Network component initiated with socket.io version: ' + this._socketio.version);
	},

	/**
	 * Gets / sets debug flag that determines if debug output
	 * is logged to the console.
	 * @param {Boolean=} val
	 * @return {*}
	 */
	debug: function (val) {
		if (val !== undefined) {
			this._debug = val;
			return this._entity;
		}

		// Check the debug counter settings
		if (this._debugMax > 0 && this._debugCounter >= this._debugMax) {
			this._debug = false;
			this._debugCounter = 0;
		}

		return this._debug;
	},

	/**
	 * Gets / sets the maximum number of debug messages that
	 * should be allowed to be output to the console before
	 * debugging is automatically turned off. This is useful
	 * if you want to sample a certain number of outputs and
	 * then automatically disable output so your console is
	 * not flooded.
	 * @param {Number=} val Number of debug messages to allow
	 * to be output to the console. Set to zero to allow
	 * infinite amounts.
	 * @return {*}
	 */
	debugMax: function (val) {
		if (val !== undefined) {
			this._debugMax = val;
			return this._entity;
		}

		return this._debugMax;
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = IgeSocketIoComponent; }
// Our namespace
var NetIo = {};

/**
 * Define the debug options object.
 * @type {Object}
 * @private
 */
NetIo._debug = {
	_enabled: true,
	_node: typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined',
	_level: ['log', 'warning', 'error'],
	_stacks: false,
	_throwErrors: true,
	_trace: {
		setup: false,
		enabled: false,
		match: ''
	},
	enabled: function (val) {
		if (val !== undefined) {
			this._enabled = val;
			return this;
		}

		return this._enabled;
	}
};

/**
 * Define the class system.
 * @type {*}
 */
NetIo.Class = IgeClass;

NetIo.EventingClass = IgeEventingClass;

NetIo.Client = NetIo.EventingClass.extend({
	classId: 'NetIo.Client',

	init: function (url, options) {
		this.log('Net.io client starting...');
		this._options = options || {};
		this._socket = null;
		this._state = 0;
		this._debug = false;
		this._connectionAttempts = 0;

		// Set some default options
		if (this._options.connectionRetry === undefined) { this._options.connectionRetry = true; }
		if (this._options.connectionRetryMax === undefined) { this._options.connectionRetryMax = 10; }
		if (this._options.reconnect === undefined) { this._options.reconnect = true; }

		// If we were passed a url, connect to it
		if (url !== undefined) {
			this.connect(url);
		}
	},

	/**
	 * Gets / sets the debug flag. If set to true, net.io
	 * will output debug data about every network event as
	 * it occurs to the console.
	 * @param {Boolean=} val
	 * @return {*}
	 */
	debug: function (val) {
		if (val !== undefined) {
			this._debug = val;
			return this;
		}

		return this._debug;
	},

	connect: function (url) {
		this.log('Connecting to server at ' + url);
		var self = this;

		// Set the state to connecting
		this._state = 1;

		// Replace http:// with ws://
		url = url.replace('http://', 'ws://');

		// Create new websocket to the url
		this._socket = new WebSocket(url, 'netio1');

		// Setup event listeners
		this._socket.onopen = function () { self._onOpen.apply(self, arguments); };
		this._socket.onmessage = function () { self._onData.apply(self, arguments); };
		this._socket.onclose = function () { self._onClose.apply(self, arguments); };
		this._socket.onerror = function () { self._onError.apply(self, arguments); };
	},

	disconnect: function (reason) {
		this._socket.close(1000, reason);
	},

	send: function (data) {
		this._socket.send(this._encode(data));
	},

	_onOpen: function () {
		this._state = 2;
	},

	_onData: function (data) {
		// Decode packet and emit message event
		var packet = this._decode(data.data);

		// Output debug if required
		if (this._debug) {
			console.log('Incoming data (event, decoded data):', data, packet);
		}

		if (packet._netioCmd) {
			// The packet is a netio command
			switch (packet._netioCmd) {
				case 'id':
					// Store the new id in the socket
					this.id = packet.data;

					// Now we have an id, set the state to connected
					this._state = 3;

					// Emit the connect event
					this.emit('connect', this.id);
					break;

				case 'close':
					// The server told us our connection has been closed
					// so store the reason the server gave us!
					this._disconnectReason = packet.data;
					break;
			}
		} else {
			// The packet is normal data
			this.emit('message', [packet]);
		}
	},

	_onClose: function (code, reason, wasClean) {
		// If we are already connected and have an id...
		if (this._state === 3) {
			this._state = 0;
			this.emit('disconnect', {reason: this._disconnectReason, wasClean: wasClean, code:code});
		}

		// If we are connected but have no id...
		if (this._state === 2) {
			this._state = 0;
			this.emit('disconnect', {reason: this._disconnectReason, wasClean: wasClean, code:code});
		}

		// If we were trying to connect...
		if (this._state === 1) {
			this._state = 0;
			this.emit('error', {reason: 'Cannot establish connection, is server running?'});
		}

		// Remove the last disconnect reason
		delete this._disconnectReason;
	},

	_onError: function () {
		this.log('An error occurred with the net.io socket!', 'error', arguments);
		this.emit('error', arguments);
	},

	_encode: function (data) {
		return JSON.stringify(data);
	},

	_decode: function (data) {
		return JSON.parse(data);
	}
});
/**
 * The client-side net.io component. Handles all client-side
 * networking systems.
 */
var IgeNetIoClient = {
	version: '1.0.0',
	_initDone: false,
	_idCounter: 0,
	_requests: {},
	_state: 0,

	/**
	 * Gets the current socket id.
	 * @returns {String} The id of the socket connection to the server.
	 */
	id: function () {
		return this._id || '';
	},
	
	/**
	 * Starts the network for the client.
	 * @param {*} url The game server URL.
	 * @param {Function=} callback A callback method to call once the
	 * network has started.
	 */
	start: function (url, callback) {
		if (this._state === 3) {
			// We're already connected
			if (typeof(callback) === 'function') {
				callback();
			}
		} else {
			var self = this;

			self._startCallback = callback;

			if (typeof(url) !== 'undefined') {
				this._url = url;
			}

			this.log('Connecting to net.io server at "' + this._url + '"...');

			if (typeof(WebSocket) !== 'undefined') {
				this._io = new NetIo.Client(url);
				self._state = 1; // Connecting

				// Define connect listener
				this._io.on('connect', function (clientId) {
					self._state = 2; // Connected
					self._id = clientId;
					self._onConnectToServer.apply(self, arguments);
				});

				// Define message listener
				this._io.on('message', function (data) {
					if (!self._initDone) {
						var i, commandCount = 0;

						// Check if the data is an init packet
						if (data.cmd === 'init') {
							// Set flag to show we've now received an init command
							self._initDone = true;
							self._state = 3; // Connected and init done

							// Setup the network commands storage
							self._networkCommandsLookup = data.ncmds;

							// Fill the reverse lookup on the commands
							for (i in self._networkCommandsLookup) {
								if (self._networkCommandsLookup.hasOwnProperty(i)) {
									self._networkCommandsIndex[self._networkCommandsLookup[i]] = i;
									commandCount++;
								}
							}

							// Setup default commands
							self.define('_igeRequest', function () { self._onRequest.apply(self, arguments); });
							self.define('_igeResponse', function () { self._onResponse.apply(self, arguments); });
							self.define('_igeNetTimeSync', function () { self._onTimeSync.apply(self, arguments); });

							self.log('Received network command list with count: ' + commandCount);

							// Setup time scale and current time
							ige.timeScale(parseFloat(data.ts));
							ige._currentTime = parseInt(data.ct);

							// Now fire the start() callback
							if (typeof(self._startCallback) === 'function') {
								self._startCallback();
								delete self._startCallback;
							}
						}
					} else {
						self._onMessageFromServer.apply(self, arguments);
					}
				});

				// Define disconnect listener
				this._io.on('disconnect', function () {
					self._state = 0; // Disconnected
					self._onDisconnectFromServer.apply(self, arguments);
				});

				// Define error listener
				this._io.on('error', function () {
					self._onError.apply(self, arguments);
				});
			}
		}
	},

	stop: function () {
		// Check we are connected
		if (self._state === 3) {
			this._io.disconnect('Client requested disconnect');
		}
	},

	/**
	 * Gets / sets a network command and callback. When a network command
	 * is received by the client, the callback set up for that command will
	 * automatically be called and passed the data from the incoming network
	 * packet.
	 * @param {String} commandName The name of the command to define.
	 * @param {Function} callback A function to call when the defined network
	 * command is received by the network.
	 * @return {*}
	 */
	define: function (commandName, callback) {
		if (commandName !== undefined && callback !== undefined) {
			// Check if this command has been defined by the server
			if (this._networkCommandsLookup[commandName] !== undefined) {
				this._networkCommands[commandName] = callback;
			} else {
				this.log('Cannot define network command "' + commandName + '" because it does not exist on the server. Please edit your server code and define the network command there before trying to define it on the client!', 'error');
			}

			return this._entity;
		} else {
			this.log('Cannot define network command either the commandName or callback parameters were undefined!', 'error');
		}
	},

	/**
	 * Sends a network message with the given command name
	 * and data.
	 * @param commandName
	 * @param data
	 */
	send: function (commandName, data) {
		var commandIndex = this._networkCommandsLookup[commandName],
			ciEncoded;

		if (commandIndex !== undefined) {
			if (this.debug()) {
				console.log('Sending "' + commandName + '" (index ' + commandIndex + ') with data:', data);
				this._debugCounter++;
			}
			ciEncoded = String.fromCharCode(commandIndex);
			this._io.send([ciEncoded, data]);
		} else {
			this.log('Cannot send network packet with command "' + commandName + '" because the command has not been defined!', 'error');
		}
	},

	/**
	 * Sends a network request. This is different from a standard
	 * call to send() because the recipient code will be able to
	 * respond by calling ige.network.response(). When the response
	 * is received, the callback method that was passed in the
	 * callback parameter will be fired with the response data.
	 * @param {String} commandName
	 * @param {Object} data
	 * @param {Function} callback
	 */
	request: function (commandName, data, callback) {
		// Build the request object
		var req = {
			id: this.newIdHex(),
			cmd: commandName,
			data: data,
			callback: callback,
			timestamp: new Date().getTime()
		};

		// Store the request object
		this._requests[req.id] = req;

		// Send the network request packet
		this.send(
			'_igeRequest',
			{
				id: req.id,
				cmd: commandName,
				data: req.data
			}
		);
	},

	/**
	 * Sends a response to a network request.
	 * @param {String} requestId
	 * @param {Object} data
	 */
	response: function (requestId, data) {
		// Grab the original request object
		var req = this._requests[requestId];

		if (req) {
			// Send the network response packet
			this.send(
				'_igeResponse',
				{
					id: requestId,
					cmd: req.commandName,
					data: data
				}
			);

			// Remove the request as we've now responded!
			delete this._requests[requestId];
		}
	},

	/**
	 * Generates a new 16-character hexadecimal unique ID
	 * @return {String}
	 */
	newIdHex: function () {
		this._idCounter++;
		return (this._idCounter + (Math.random() * Math.pow(10, 17) + Math.random() * Math.pow(10, 17) + Math.random() * Math.pow(10, 17) + Math.random() * Math.pow(10, 17))).toString(16);
	},

	_onRequest: function (data) {
		// The message is a network request so fire
		// the command event with the request id and
		// the request data
		this._requests[data.id] = data;

		if (this.debug()) {
			console.log('onRequest', data);
			this._debugCounter++;
		}

		if (this._networkCommands[data.cmd]) {
			this._networkCommands[data.cmd](data.id, data.data);
		}

		this.emit(data.cmd, [data.id, data.data]);
	},

	_onResponse: function (data) {
		var id,
			req;
		
		// The message is a network response
		// to a request we sent earlier
		id = data.id;

		// Get the original request object from
		// the request id
		req = this._requests[id];

		if (this.debug()) {
			console.log('onResponse', data);
			this._debugCounter++;
		}

		if (req) {
			// Fire the request callback!
			req.callback(req.cmd, data.data);

			// Delete the request from memory
			delete this._requests[id];
		}
	},

	/**
	 * Called when the network connects to the server.
	 * @private
	 */
	_onConnectToServer: function () {
		this.log('Connected to server!');
		this.emit('connected');
	},

	/**
	 * Called when data from the server is received on the client.
	 * @param data
	 * @private
	 */
	_onMessageFromServer: function (data) {
		var ciDecoded = data[0].charCodeAt(0),
			commandName = this._networkCommandsIndex[ciDecoded];

		if (this._networkCommands[commandName]) {
			if (this.debug()) {
				console.log('Received "' + commandName + '" (index ' + ciDecoded + ') with data:', data[1]);
				this._debugCounter++;
			}

			this._networkCommands[commandName](data[1]);
		}

		this.emit(commandName, data[1]);
	},

	/**
	 * Called when the client is disconnected from the server.
	 * @param data
	 * @private
	 */
	_onDisconnectFromServer: function (data) {
		if (data === 'booted') {
			this.log('Server rejected our connection because it is not accepting connections at this time!', 'warning');
		} else {
			this.log('Disconnected from server!');
		}
		this.emit('disconnected');
	},

	/**
	 * Called when the client has an error with the connection.
	 * @param {Object} data
	 * @private
	 */
	_onError: function (data) {
		this.log('Error with connection: ' + data.reason, 'error');
	}
};

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = IgeNetIoClient; }
var IgeNetIoComponent = IgeEventingClass.extend([
	{extension: IgeTimeSyncExtension, overwrite: false}
], {
	classId: 'IgeNetIoComponent',
	componentId: 'network',

	init: function (entity, options) {
		this._entity = entity;
		this._options = options;

		// Setup the network commands storage
		this._networkCommands = {};
		this._networkCommandsIndex = [];
		this._networkCommandsLookup = {};

		// Set some defaults
		this._port = 8000;
		this._debug = false;
		this._debugCounter = 0;
		this._debugMax = 0;
		this._clientRooms = {};

		// Time sync defaults
		this._timeSyncInterval = 10000; // Sync the client/server clocks every ten seconds by default
		this._timeSyncLog = {};
		this._latency = 0;

		/* CEXCLUDE */
		if (ige.isServer) {
			this.implement(IgeNetIoServer);
			this._netio = require('../../../' + modulePath + 'net.io-server').Server;
			this._acceptConnections = false;
		}
		/* CEXCLUDE */

		if (ige.isClient) {
			this._netio = IgeNetIoClient;
			this.implement(IgeNetIoClient);
		}

		this.log('Network component initiated with Net.IO version: ' + this._netio.version);
	},

	/**
	 * Gets / sets debug flag that determines if debug output
	 * is logged to the console.
	 * @param {Boolean=} val
	 * @return {*}
	 */
	debug: function (val) {
		if (val !== undefined) {
			this._debug = val;
			return this._entity;
		}

		// Check the debug counter settings
		if (this._debugMax > 0 && this._debugCounter >= this._debugMax) {
			this._debug = false;
			this._debugCounter = 0;
		}

		return this._debug;
	},

	/**
	 * Gets / sets the maximum number of debug messages that
	 * should be allowed to be output to the console before
	 * debugging is automatically turned off. This is useful
	 * if you want to sample a certain number of outputs and
	 * then automatically disable output so your console is
	 * not flooded.
	 * @param {Number=} val Number of debug messages to allow
	 * to be output to the console. Set to zero to allow
	 * infinite amounts.
	 * @return {*}
	 */
	debugMax: function (val) {
		if (val !== undefined) {
			this._debugMax = val;
			return this._entity;
		}

		return this._debugMax;
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = IgeNetIoComponent; }
/**
 * The client-side chat component. Handles all client-side
 * chat methods and events.
 */
var IgeChatClient = {
	/**
	 * Asks the serve to let us join the room specified.
	 * @param {String} roomId The room id of the room to join.
	 */
	joinRoom: function (roomId) {
		ige.network.send('igeChatJoinRoom', roomId);
	},

	sendToRoom: function (roomId, message, to) {
		if (roomId !== undefined && message !== undefined) {
			msg = {
				roomId: roomId,
				text: message,
				to: to
			};

			ige.network.send('igeChatMsg', msg);
		}
	},

	_onMessageFromServer: function (data) {
		var self = ige.chat;

		// Emit the event and if it wasn't cancelled (by returning true) then
		// process this ourselves
		if (!self.emit('messageFromServer', [data])) {
			console.log('Server sent us a message in the room "' + data.roomId + '" from the user id "' + data.from + '":', data.text);
		}
	},

	_onJoinedRoom: function (data) {
		var self = ige.chat;

		// Emit the event and if it wasn't cancelled (by returning true) then
		// process this ourselves
		if (!self.emit('joinedRoom', [data])) {
			if (data.joined === true) {
				console.log('Server says we have joined room:', data.roomId);
			} else {
				console.log('Server says we failed to join room:', data.roomId);
			}
		}
	},

	_onLeftRoom: function (data) {
		var self = ige.chat;

		// Emit the event and if it wasn't cancelled (by returning true) then
		// process this ourselves
		if (!self.emit('leftRoom', [data])) {
			console.log('We have left room:', data);
		}
	},

	_onServerSentRoomList: function (data) {
		var self = ige.chat;

		// Emit the event and if it wasn't cancelled (by returning true) then
		// process this ourselves
		if (!self.emit('roomList', [data])) {
			console.log('Server sent room list:', data);
		}
	},

	_onServerSentRoomUserList: function (data) {
		var self = ige.chat;

		// Emit the event and if it wasn't cancelled (by returning true) then
		// process this ourselves
		if (!self.emit('roomUserList', [data])) {
			console.log('Server sent room user list:', data);
		}
	},

	_onRoomCreated: function (data) {
		var self = ige.chat;

		// Emit the event and if it wasn't cancelled (by returning true) then
		// process this ourselves
		if (!self.emit('roomCreated', [data])) {
			console.log('Server told us room was created:', data);
		}
	},

	_onRoomRemoved: function (data) {
		var self = ige.chat;
		
		// Emit the event and if it wasn't cancelled (by returning true) then
		// process this ourselves
		if (!self.emit('roomRemoved', [data])) {
			console.log('Server told us room was removed:', data);
		}
	}
};

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = IgeChatClient; }
var IgeChatComponent = IgeEventingClass.extend({
    classId: 'IgeChatComponent',
    componentId: 'chat',

    init: function (entity, options) {
        this._entity = entity;
        this._options = options;

        this._rooms = {};

        /* CEXCLUDE */
        if (ige.isServer) {
            this.implement(IgeChatServer);

            // Define the chat system network commands
            this._entity
				.network.define('igeChatMsg', this._onMessageFromClient)
				.network.define('igeChatJoinRoom', this._onJoinRoomRequestFromClient)
				.network.define('igeChatLeaveRoom', this._onLeaveRoomRequestFromClient)
				.network.define('igeChatRoomList', this._onClientWantsRoomList)
				.network.define('igeChatRoomUserList', this._onClientWantsRoomUserList)
				.network.define('igeChatRoomCreated')
				.network.define('igeChatRoomRemoved');
        }
        /* CEXCLUDE */

        if (ige.isClient) {
            this.implement(IgeChatClient);

            // Define the chat system network command listeners
            this._entity
				.network.define('igeChatMsg', this._onMessageFromServer)
				.network.define('igeChatJoinRoom', this._onJoinedRoom)
				.network.define('igeChatLeaveRoom', this._onLeftRoom)
				.network.define('igeChatRoomList', this._onServerSentRoomList)
				.network.define('igeChatRoomUserList', this._onServerSentRoomUserList)
				.network.define('igeChatRoomCreated', this._onRoomCreated)
				.network.define('igeChatRoomRemoved', this._onRoomRemoved);
        }

		this.log('Chat component initiated!');
    }
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = IgeChatComponent; }
var IgeCocoonJsComponent = IgeEventingClass.extend({
	classId: 'IgeCocoonJsComponent',
	componentId: 'cocoonJs',

	init: function () {
		this.detected = typeof(ext) !== 'undefined' && typeof(ext.IDTK_APP) !== 'undefined';

		if (this.detected) {
			this.log('CocoonJS support enabled!');
		}
	},

	// TODO: Finish keyboard implementation
	showInputDialog: function(title, message, initialValue, type, cancelText, okText) {
		if (this.detected) {
			title = title || '';
			message = message || '';
			initialValue = initialValue || '';
			type = type || 'text';
			cancelText = cancelText || 'Cancel';
			okText = okText || 'OK';

			ext.IDTK_APP.makeCall(
				'showTextDialog',
				title,
				message,
				initialValue,
				type,
				cancelText,
				okText
			);
		} else {
			this.log('Cannot open CocoonJS input dialog! CocoonJS is not detected!', 'error');
		}
	},

	/**
	 * Asks the API to load the url and show the web view.
	 * @param url
	 */
	showWebView: function (url) {
		if (this.detected) {
			// Forward a JS call to the webview IDTK API
			ext.IDTK_APP.makeCall("forward", "ext.IDTK_APP.makeCall('loadPath', '" + url + "')");
			ext.IDTK_APP.makeCall("forward", "ext.IDTK_APP.makeCall('show');");
		}
	},

	/**
	 * Asks the API to hide the web view.
	 */
	hideWebView: function () {
		if (this.detected) {
			// Forward a JS call to the webview IDTK API
			ext.IDTK_APP.makeCall("forward", "ext.IDTK_APP.makeCall('hide');");
		}
	}
});
var IgeUiPositionExtension = {
	/**
	 * Gets / sets the entity's x position relative to the left of
	 * the canvas.
	 * @param {Number} px
	 * @param {Boolean=} noUpdate
	 * @return {Number}
	 */
	left: function (px, noUpdate) {
		if (px !== undefined) {
			if (px === null) {
				// Remove all data
				delete this._uiLeft;
				delete this._uiLeftPercent;
			} else {
				delete this._uiCenter;
				delete this._uiCenterPercent;
				
				if (typeof(px) === 'string') {
					// Store the percentage value
					this._uiLeftPercent = px;
					
					// Check if we are already mounted
					var parentWidth,
						val = parseInt(px, 10),
						newVal;
					
					if (this._parent) {
						// We have a parent, use it's geometry
						parentWidth = this._parent._bounds2d.x;
					} else {
						// We don't have a parent so use the main canvas
						// as a reference
						parentWidth = ige._bounds2d.x;
					}
						
					// Calculate real width from percentage
					newVal = (parentWidth / 100 * val) | 0;
	
					this._uiLeft = newVal;
				} else {
					// The value passed is not a percentage, directly assign it
					this._uiLeft = px;
					delete this._uiLeftPercent;
				}
			}
			
			if (!noUpdate) {
				this._updateUiPosition();
			}
			return this;
		}

		return this._uiLeft;
	},
	
	/**
	 * Gets / sets the entity's x position relative to the right of
	 * the canvas.
	 * @param {Number} px
	 * @param {Boolean=} noUpdate
	 * @return {Number}
	 */
	right: function (px, noUpdate) {
		if (px !== undefined) {
			if (px === null) {
				// Remove all data
				delete this._uiRight;
				delete this._uiRightPercent;
			} else {
				delete this._uiCenter;
				delete this._uiCenterPercent;
				
				if (typeof(px) === 'string') {
					// Store the percentage value
					this._uiRightPercent = px;
					
					// Check if we are already mounted
					var parentWidth,
						val = parseInt(px, 10),
						newVal;
					
					if (this._parent) {
						// We have a parent, use it's geometry
						parentWidth = this._parent._bounds2d.x;
					} else {
						// We don't have a parent so use the main canvas
						// as a reference
						parentWidth = ige._bounds2d.x;
					}
						
					// Calculate real width from percentage
					newVal = (parentWidth / 100 * val) | 0;
	
					this._uiRight = newVal;
				} else {
					// The value passed is not a percentage, directly assign it
					this._uiRight = px;
					delete this._uiRightPercent;
				}
			}
			
			if (!noUpdate) {
				this._updateUiPosition();
			}
			return this;
		}

		return this._uiRight;
	},

	/**
	 * Gets / sets the viewport's x position relative to the center of
	 * the entity parent.
	 * @param {Number} px
	 * @param {Boolean=} noUpdate
	 * @return {Number}
	 */
	center: function (px, noUpdate) {
		if (px !== undefined) {
			if (px === null) {
				// Remove all data
				delete this._uiCenter;
				delete this._uiCenterPercent;
			} else {
				delete this._uiLeft;
				delete this._uiLeftPercent;
				delete this._uiRight;
				delete this._uiRightPercent;
				
				if (typeof(px) === 'string') {
					// Store the percentage value
					this._uiCenterPercent = px;
					
					// Check if we are already mounted
					var parentWidth,
						val = parseInt(px, 10),
						newVal;
					
					if (this._parent) {
						// We have a parent, use it's geometry
						parentWidth = this._parent._bounds2d.x2;
					} else {
						// We don't have a parent so use the main canvas
						// as a reference
						parentWidth = ige._bounds2d.x2;
					}
						
					// Calculate real width from percentage
					newVal = (parentWidth / 100 * val) | 0;
	
					this._uiCenter = newVal;
				} else {
					// The value passed is not a percentage, directly assign it
					this._uiCenter = px;
					delete this._uiCenterPercent;
				}
			}
			
			if (!noUpdate) {
				this._updateUiPosition();
			}
			return this;
		}

		return this._uiCenter;
	},

	/**
	 * Gets / sets the entity's y position relative to the top of
	 * the canvas.
	 * @param {Number} px
	 * @param {Boolean=} noUpdate
	 * @return {Number}
	 */
	top: function (px, noUpdate) {
		if (px !== undefined) {
			if (px === null) {
				// Remove all data
				delete this._uiTop;
				delete this._uiTopPercent;
			} else {
				delete this._uiMiddle;
				delete this._uiMiddlePercent;
				
				if (typeof(px) === 'string') {
					// Store the percentage value
					this._uiTopPercent = px;
					
					// Check if we are already mounted
					var parentHeight,
						val = parseInt(px, 10),
						newVal;
					
					if (this._parent) {
						// We have a parent, use it's geometry
						parentHeight = this._parent._bounds2d.y;
					} else {
						// We don't have a parent so use the main canvas
						// as a reference
						parentHeight = ige._bounds2d.y;
					}
						
					// Calculate real width from percentage
					newVal = (parentHeight / 100 * val) | 0;
	
					this._uiTop = newVal;
				} else {
					// The value passed is not a percentage, directly assign it
					this._uiTop = px;
					delete this._uiTopPercent;
				}
			}
			
			if (!noUpdate) {
				this._updateUiPosition();
			}
			return this;
		}

		return this._uiTop;
	},

	/**
	 * Gets / sets the entity's y position relative to the bottom of
	 * the canvas.
	 * @param {Number} px
	 * @param {Boolean=} noUpdate
	 * @return {Number}
	 */
	bottom: function (px, noUpdate) {
		if (px !== undefined) {
			if (px === null) {
				// Remove all data
				delete this._uiBottom;
				delete this._uiBottomPercent;
			} else {
				delete this._uiMiddle;
				delete this._uiMiddlePercent;
				
				if (typeof(px) === 'string') {
					// Store the percentage value
					this._uiBottomPercent = px;
					
					// Check if we are already mounted
					var parentHeight,
						val = parseInt(px, 10),
						newVal;
					
					if (this._parent) {
						// We have a parent, use it's geometry
						parentHeight = this._parent._bounds2d.y;
					} else {
						// We don't have a parent so use the main canvas
						// as a reference
						parentHeight = ige._bounds2d.y;
					}
						
					// Calculate real width from percentage
					newVal = (parentHeight / 100 * val) | 0;
	
					this._uiBottom = newVal;
				} else {
					// The value passed is not a percentage, directly assign it
					this._uiBottom = px;
					delete this._uiBottomPercent;
				}
			}
			
			if (!noUpdate) {
				this._updateUiPosition();
			}
			return this;
		}

		return this._uiBottom;
	},
	
	/**
	 * Gets / sets the viewport's y position relative to the middle of
	 * the canvas.
	 * @param {Number} px
	 * @param {Boolean=} noUpdate
	 * @return {Number}
	 */
	middle: function (px, noUpdate) {
		if (px !== undefined) {
			if (px === null) {
				// Remove all data
				delete this._uiMiddle;
				delete this._uiMiddlePercent;
			} else {
				delete this._uiTop;
				delete this._uiTopPercent;
				delete this._uiBottom;
				delete this._uiBottomPercent;
				
				if (typeof(px) === 'string') {
					// Store the percentage value
					this._uiMiddlePercent = px;
					
					// Check if we are already mounted
					var parentWidth,
						val = parseInt(px, 10),
						newVal;
					
					if (this._parent) {
						// We have a parent, use it's geometry
						parentWidth = this._parent._bounds2d.y2;
					} else {
						// We don't have a parent so use the main canvas
						// as a reference
						parentWidth = ige._bounds2d.y2;
					}
						
					// Calculate real width from percentage
					newVal = (parentWidth / 100 * val) | 0;
	
					this._uiMiddle = newVal;
				} else {
					// The value passed is not a percentage, directly assign it
					this._uiMiddle = px;
					delete this._uiMiddlePercent;
				}
			}
			
			if (!noUpdate) {
				this._updateUiPosition();
			}
			return this;
		}

		return this._uiMiddle;
	},

	/**
	 * Gets / sets the geometry.x in pixels.
	 * @param {Number, String=} px Either the width in pixels or a percentage
	 * @param {Boolean=} lockAspect
	 * @param {Number=} modifier A value to add to the final width. Useful when
	 * you want to alter a percentage value by a certain number of pixels after
	 * it has been calculated.
	 * @param {Boolean=} noUpdate
	 * @return {*}
	 */
	width: function (px, lockAspect, modifier, noUpdate) {
		if (px !== undefined) {
			if (px === null) {
				// Remove all data
				delete this._uiWidth;
				this._bounds2d.x = 0;
				this._bounds2d.x2 = 0;
			} else {
				this._uiWidth = px;
				this._widthModifier = modifier !== undefined ? modifier : 0;
	
				if (typeof(px) === 'string') {
					if (this._parent) {
						// Percentage
						var parentWidth = this._parent._bounds2d.x,
							val = parseInt(px, 10),
							newVal,
							ratio;
	
						// Calculate real width from percentage
						newVal = (parentWidth / 100 * val) + this._widthModifier | 0;
	
						if (lockAspect) {
							// Calculate the height from the change in width
							ratio = newVal / this._bounds2d.x;
							this.height(this._bounds2d.y / ratio, false, 0, noUpdate);
						}
	
						this._bounds2d.x = newVal;
						this._bounds2d.x2 = Math.floor(this._bounds2d.x / 2);
					} else {
						// We don't have a parent so use the main canvas
						// as a reference
						var parentWidth = ige._bounds2d.x,
							val = parseInt(px, 10);
	
						// Calculate real height from percentage
						this._bounds2d.x = (parentWidth / 100 * val) + this._widthModifier | 0;
						this._bounds2d.x2 = Math.floor(this._bounds2d.x / 2);
					}
				} else {
					if (lockAspect) {
						// Calculate the height from the change in width
						var ratio = px / this._bounds2d.x;
						this.height(this._bounds2d.y * ratio, false, 0, noUpdate);
					}
	
					this._bounds2d.x = px;
					this._bounds2d.x2 = Math.floor(this._bounds2d.x / 2);
				}
			}

			if (!noUpdate) {
				this._updateUiPosition();
			}
			return this;
		}

		return this._bounds2d.x;
	},

	/**
	 * Gets / sets the geometry.y in pixels.
	 * @param {Number=} px
	 * @param {Boolean=} lockAspect
	 * @param {Number=} modifier A value to add to the final height. Useful when
	 * you want to alter a percentage value by a certain number of pixels after
	 * it has been calculated.
	 * @param {Boolean=} noUpdate
	 * @return {*}
	 */
	height: function (px, lockAspect, modifier, noUpdate) {
		if (px !== undefined) {
			if (px === null) {
				// Remove all data
				delete this._uiHeight;
				this._bounds2d.y = 0;
				this._bounds2d.y2 = 0;
			} else {
				this._uiHeight = px;
				this._heightModifier = modifier !== undefined ? modifier : 0;
	
				if (typeof(px) === 'string') {
					if (this._parent) {
						// Percentage
						var parentHeight = this._parent._bounds2d.y,
							val = parseInt(px, 10),
							newVal,
							ratio;
	
						// Calculate real height from percentage
						// Calculate real width from percentage
						newVal = (parentHeight / 100 * val) + this._heightModifier | 0;
	
						if (lockAspect) {
							// Calculate the height from the change in width
							ratio = newVal / this._bounds2d.y;
							this.width(this._bounds2d.x / ratio, false, 0, noUpdate);
						}
	
						this._bounds2d.y = newVal;
						this._bounds2d.y2 = Math.floor(this._bounds2d.y / 2);
					} else {
						// We don't have a parent so use the main canvas
						// as a reference
						var parentHeight = ige._bounds2d.y,
							val = parseInt(px, 10);
	
						// Calculate real height from percentage
						this._bounds2d.y = (parentHeight / 100 * val) + this._heightModifier | 0;
						this._bounds2d.y2 = Math.floor(this._bounds2d.y / 2);
					}
				} else {
					if (lockAspect) {
						// Calculate the height from the change in width
						var ratio = px / this._bounds2d.y;
						this.width(this._bounds2d.x * ratio, false, 0, noUpdate);
					}
	
					this._bounds2d.y = px;
					this._bounds2d.y2 = Math.floor(this._bounds2d.y / 2);
				}
			}
			
			if (!noUpdate) {
				this._updateUiPosition();
			}
			return this;
		}

		return this._bounds2d.y;
	},
	
	autoScaleX: function (val, lockAspect) {
		if (val !== undefined) {
			this._autoScaleX = val;
			this._autoScaleLockAspect = lockAspect;

			this._updateUiPosition();
			return this;
		}

		return this._autoScaleX;
	},

	autoScaleY: function (val, lockAspect) {
		if (val !== undefined) {
			this._autoScaleY = val;
			this._autoScaleLockAspect = lockAspect;

			this._updateUiPosition();
			return this;
		}

		return this._autoScaleY;
	},

	/**
	 * Updates the UI position of every child entity down the scenegraph
	 * for this UI entity.
	 * @return {*}
	 */
	updateUiChildren: function () {
		var arr = this._children,
			arrCount,
			arrItem;
		
		if (arr) {
			arrCount = arr.length;
			
			while (arrCount--) {
				arrItem = arr[arrCount];
				if (arrItem._updateUiPosition) {
					arrItem._updateUiPosition();
				}
				
				if (typeof(arrItem.updateUiChildren) === 'function') {
					arrItem.updateUiChildren();
				}
			}
		}
		
		return this;
	},

	/**
	 * Sets the correct translate x and y for the viewport's left, right
	 * top and bottom co-ordinates.
	 * @private
	 */
	_updateUiPosition: function () {
		if (this._parent) {
			var parentGeom = this._parent._bounds2d,
				geomScaled = this._bounds2d.multiplyPoint(this._scale),
				percent,
				newVal,
				ratio;
			
			/*if (this._ignoreCamera && ige._currentCamera) {
				// Handle cam ignore when calculating 
				parentGeom = parentGeom.dividePoint(ige._currentCamera._scale);
			}*/
			
			if (this._autoScaleX) {
				// Get the percentage as an integer
				percent = parseInt(this._autoScaleX, 10);
	
				// Calculate new width from percentage
				newVal = (parentGeom.x / 100 * percent);
	
				// Calculate scale ratio
				ratio = newVal / this._bounds2d.x;
	
				// Set the new scale
				this._scale.x = ratio;
				
				if (this._autoScaleLockAspect) {
					this._scale.y = ratio;
				}
			}

			if (this._autoScaleY) {
				// Get the percentage as an integer
				percent = parseInt(this._autoScaleY, 10);

				// Calculate new height from percentage
				newVal = (parentGeom.y / 100 * percent);

				// Calculate scale ratio
				ratio = newVal / this._bounds2d.y;

				// Set the new scale
				this._scale.y = ratio;

				if (this._autoScaleLockAspect) {
					this._scale.x = ratio;
				}
			}

			if (this._uiWidth) { this.width(this._uiWidth, false, this._widthModifier, true); }
			if (this._uiHeight) { this.height(this._uiHeight, false, this._heightModifier, true); }
			
			if (this._uiCenterPercent) { this.center(this._uiCenterPercent, true); }
			if (this._uiMiddlePercent) { this.middle(this._uiMiddlePercent, true); }
			if (this._uiLeftPercent) { this.left(this._uiLeftPercent, true); }
			if (this._uiRightPercent) { this.right(this._uiRightPercent, true); }
			if (this._uiTopPercent) { this.top(this._uiTopPercent, true); }
			if (this._uiBottomPercent) { this.bottom(this._uiBottomPercent, true); }
			
			if (this._uiCenter !== undefined) {
				// The element is center-aligned
				this._translate.x = Math.floor(this._uiCenter);
			} else {
				// The element is not center-aligned, process left and right
				if (this._uiLeft !== undefined && this._uiRight !== undefined) {
					// Both left and right values are set, position left and assign width to reach right
					this.width((parentGeom.x) - this._uiLeft - this._uiRight, false, 0, true);
							
					// Update translation
					this._translate.x = Math.floor(this._uiLeft + geomScaled.x2 - (parentGeom.x2));
				} else {
					if (this._uiLeft !== undefined) {
						// Position left aligned
						this._translate.x = Math.floor(this._uiLeft + geomScaled.x2 - (parentGeom.x2));
					}
					
					if (this._uiRight !== undefined) {
						// Position right aligned
						this._translate.x = Math.floor(parentGeom.x2 - geomScaled.x2 - this._uiRight);
					}
				}
			}
			
			if (this._uiMiddle !== undefined) {
				// The element is middle-aligned
				this._translate.y = Math.floor(this._uiMiddle);
			} else {
				// The element is not middle-aligned, process top and bottom
				if (this._uiTop !== undefined && this._uiBottom !== undefined) {
					// Both top and bottom values are set, position top and assign height to reach bottom
					this.height((parentGeom.y) - this._uiTop - this._uiBottom, false, 0, true);
							
					// Update translation
					this._translate.y = Math.floor(this._uiTop + geomScaled.y2 - (parentGeom.y2));
				} else {
					if (this._uiTop !== undefined) {
						// Position top aligned
						this._translate.y = Math.floor(this._uiTop + geomScaled.y2 - (parentGeom.y2));
					}
					
					if (this._uiBottom !== undefined) {
						// Position bottom aligned
						this._translate.y = Math.floor(parentGeom.y2 - geomScaled.y2 - this._uiBottom);
					}
				}
			}
			
			this.emit('uiUpdate');
			
			this.cacheDirty(true);
		}
	}
};

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = IgeUiPositionExtension; }
// TODO: Add "overflow" with automatic scroll-bars
var IgeUiStyleExtension = {
	/**
	 * Gets / sets the color to use as the font color.
	 * @param {CSSColor, CanvasGradient, CanvasPattern=} color
	 * @return {*} Returns this when setting the value or the current value if none is specified.
	 */
	color: function (color) {
		if (color !== undefined) {
			this._color = color;
			this.cacheDirty(true);
			return this;
		}

		return this._color;
	},
	
	/**
	 * Sets the current background texture and the repeatType
	 * to determine in which axis the image should be repeated.
	 * @param {IgeTexture=} texture
	 * @param {String=} repeatType Accepts "repeat", "repeat-x",
	 * "repeat-y" and "no-repeat".
	 * @return {*} Returns this if any parameter is specified or
	 * the current background image if no parameters are specified.
	 */
	backgroundImage: function (texture, repeatType) {
		if (texture && texture.image) {
			if (!repeatType) { repeatType = 'no-repeat'; }

			// Store the repeatType
			this._patternRepeat = repeatType;

			// Store the texture
			this._patternTexture = texture;

			// Resize the image if required
			if (this._backgroundSize) {
				texture.resize(this._backgroundSize.x, this._backgroundSize.y);
				this._patternWidth = this._backgroundSize.x;
				this._patternHeight = this._backgroundSize.y;
			} else {
				this._patternWidth = texture.image.width;
				this._patternHeight = texture.image.height;
			}

			if (this._cell > 1) {
				// We are using a cell sheet, render the cell to a
				// temporary canvas and set that as the pattern image
				var canvas = document.createElement('canvas'),
					ctx = canvas.getContext('2d'),
					cellData = texture._cells[this._cell];

				canvas.width = cellData[2];
				canvas.height = cellData[3];

				ctx.drawImage(
					texture.image,
					cellData[0],
					cellData[1],
					cellData[2],
					cellData[3],
					0,
					0,
					cellData[2],
					cellData[3]
				);

				// Create the pattern from the texture cell
				this._patternFill = ige._ctx.createPattern(canvas, repeatType);
			} else {
				// Create the pattern from the texture
				this._patternFill = ige._ctx.createPattern(texture.image, repeatType);
			}

			texture.restoreOriginal();
			this.cacheDirty(true);
			return this;
		}

		return this._patternFill;
	},

	backgroundSize: function (x, y) {
		if (x !== undefined && y !== undefined) {

			if (typeof(x) === 'string' && x !== 'auto') {
				// Work out the actual size in pixels
				// from the percentage
				x = this._bounds2d.x / 100 * parseInt(x, 10);
			}

			if (typeof(y) === 'string' && y !== 'auto') {
				// Work out the actual size in pixels
				// from the percentage
				y = this._bounds2d.y / 100 * parseInt(y, 10);
			}

			if (x === 'auto' && y === 'auto') {
				this.log('Cannot set background x and y both to auto!', 'error');
				return this;
			} else if(x === 'auto') {
				if(this._patternTexture && this._patternTexture.image) {
					// find out y change and apply it to the x
					x = this._patternTexture.image.width * (y / this._patternTexture.image.height);
				} else {
					x = this._bounds2d.x * (y / this._bounds2d.y);
				}
			} else if(y === 'auto') {
				if(this._patternTexture && this._patternTexture.image) {
					// find out x change and apply it to the y
					y = this._patternTexture.image.height * (x / this._patternTexture.image.width);
				} else {
					y = this._bounds2d.y * (x / this._bounds2d.x);
				}
			}

			if (x !== 0 && y !== 0) {
				this._backgroundSize = {x: x, y: y};
	
				// Reset the background image
				if (this._patternTexture && this._patternRepeat) {
					this.backgroundImage(this._patternTexture, this._patternRepeat);
				}
				this.cacheDirty(true);
			} else {
				this.log('Cannot set background to zero-sized x or y!', 'error');
			}
			return this;
		}

		return this._backgroundSize;
	},

	/**
	 * Gets / sets the color to use as a background when
	 * rendering the UI element.
	 * @param {CSSColor, CanvasGradient, CanvasPattern=} color
	 * @return {*} Returns this when setting the value or the current value if none is specified.
	 */
	backgroundColor: function (color) {
		if (color !== undefined) {
			this._backgroundColor = color;
			this.cacheDirty(true);
			return this;
		}

		return this._backgroundColor;
	},

	/**
	 * Gets / sets the position to start rendering the background image at.
	 * @param {Number=} x
	 * @param {Number=} y
	 * @return {*} Returns this when setting the value or the current value if none is specified.
	 */
	backgroundPosition: function (x, y) {
		if (x !== undefined && y !== undefined) {
			this._backgroundPosition = {x: x, y: y};
			this.cacheDirty(true);
			return this;
		}

		return this._backgroundPosition;
	},

	borderColor: function (color) {
		if (color !== undefined) {
			this._borderColor = color;
			this._borderLeftColor = color;
			this._borderTopColor = color;
			this._borderRightColor = color;
			this._borderBottomColor = color;
			this.cacheDirty(true);
			return this;
		}

		return this._borderColor;
	},

	borderLeftColor: function (color) {
		if (color !== undefined) {
			this._borderLeftColor = color;
			this.cacheDirty(true);
			return this;
		}

		return this._borderLeftColor;
	},

	borderTopColor: function (color) {
		if (color !== undefined) {
			this._borderTopColor = color;
			this.cacheDirty(true);
			return this;
		}

		return this._borderTopColor;
	},

	borderRightColor: function (color) {
		if (color !== undefined) {
			this._borderRightColor = color;
			this.cacheDirty(true);
			return this;
		}

		return this._borderRightColor;
	},

	borderBottomColor: function (color) {
		if (color !== undefined) {
			this._borderBottomColor = color;
			this.cacheDirty(true);
			return this;
		}

		return this._borderBottomColor;
	},

	borderWidth: function (px) {
		if (px !== undefined) {
			this._borderWidth = px;
			this._borderLeftWidth = px;
			this._borderTopWidth = px;
			this._borderRightWidth = px;
			this._borderBottomWidth = px;
			this.cacheDirty(true);
			return this;
		}

		return this._borderWidth;
	},

	borderLeftWidth: function (px) {
		if (px !== undefined) {
			this._borderLeftWidth = px;
			this.cacheDirty(true);
			return this;
		}

		return this._borderLeftWidth;
	},

	borderTopWidth: function (px) {
		if (px !== undefined) {
			this._borderTopWidth = px;
			this.cacheDirty(true);
			return this;
		}

		return this._borderTopWidth;
	},

	borderRightWidth: function (px) {
		if (px !== undefined) {
			this._borderRightWidth = px;

			this.cacheDirty(true);
			return this;
		}

		return this._borderRightWidth;
	},

	borderBottomWidth: function (px) {
		if (px !== undefined) {
			this._borderBottomWidth = px;

			this.cacheDirty(true);
			return this;
		}

		return this._borderBottomWidth;
	},

	borderRadius: function (px) {
		if (px !== undefined) {
			this._borderRadius = px;
			this._borderTopLeftRadius = px;
			this._borderTopRightRadius = px;
			this._borderBottomRightRadius = px;
			this._borderBottomLeftRadius = px;

			this.cacheDirty(true);
			return this;
		}

		return this._borderRadius;
	},

	padding: function (left, top, right, bottom) {
		this._paddingLeft = left;
		this._paddingTop = top;
		this._paddingRight = right;
		this._paddingBottom = bottom;

		this.cacheDirty(true);
		return this;
	},

	paddingLeft: function (px) {
		if (px !== undefined) {
			this._paddingLeft = px;

			this.cacheDirty(true);
			return this;
		}

		return this._paddingLeft;
	},

	paddingTop: function (px) {
		if (px !== undefined) {
			this._paddingTop = px;

			this.cacheDirty(true);
			return this;
		}

		return this._paddingTop;
	},

	paddingRight: function (px) {
		if (px !== undefined) {
			this._paddingRight = px;

			this.cacheDirty(true);
			return this;
		}

		return this._paddingRight;
	},

	paddingBottom: function (px) {
		if (px !== undefined) {
			this._paddingBottom = px;

			this.cacheDirty(true);
			return this;
		}

		return this._paddingBottom;
	}
};

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = IgeUiStyleExtension; }
/**
 * A simple finite state machine implementation.
 */
var IgeFSM = IgeClass.extend({
	classId: 'IgeFSM',

	init: function () {
		var self = this;
		
		this._states = {};
		this._transitions = {};

		// Track states by name.
		this._initialStateName = '';
		this._currentStateName = '';
		this._previousStateName = '';
		
		this._debug = false;
	},

	/**
	 * Returns the name of the initial state.
	 * @returns {string}
	 */
	initialStateName: function () {
		return this._currentStateName;
	},

	/**
	 * Returns the name of the previous state.
	 * @returns {string}
	 */
	previousStateName: function () {
		return this._currentStateName;
	},

	/**
	 * Returns the name of the current state.
	 * @returns {string}
	 */
	currentStateName: function () {
		return this._currentStateName;
	},

	/**
	 * Gets / sets the debug flag. If set to true will enable console logging
	 * of state changes / events.
	 * @param {Boolean=} val Set to true to enable.
	 * @returns {*}
	 */
	debug: function (val) {
		if (val !== undefined) {
			this._debug = val;
			return this;
		}
		
		return this._debug;
	},

	/**
	 * Defines a state with a name and a state definition.
	 * @param {String} name The name of the state to define.
	 * @param {Object} definition The state definition object.
	 * @example #Define a state
	 *     var fsm = new IgeFSM();
	 *     
	 *     // Define an "idle" state
	 *     fsm.defineState('idle', {
	 *         enter: function (data, completeCallback) {
	 *             console.log('entered idle state');
	 *             completeCallback();
	 *         },
	 *         exit: function (data, completeCallback) {
	 *             console.log('exited idle state');
	 *             completeCallback();
	 *         }
	 *     });
	 * @returns {IgeFSM}
	 */
	defineState: function (name, definition) {
		this._states[name] = definition;

		if (!this._initialStateName) {
			this._initialStateName = name;
		}
		
		return this;
	},

	/**
	 * Defines a transition between two states.
	 * @param {String} fromState The state name the transition is from.
	 * @param {String} toState The state name the transition is to.
	 * @param {Function} transitionCheck A method to call just before this transition
	 * between the two specified states is executed, that will call the callback method
	 * passed to it in the second parameter and include either true to allow the
	 * transition to continue, or false to cancel it in the first parameter.
	 * @example #Define a state transition
	 *     var fsm = new IgeFSM();
	 *     
	 *     // Define an "idle" state
	 *     fsm.defineState('idle', {
	 *         enter: function (data, completeCallback) {
	 *             console.log('entered idle state');
	 *             completeCallback();
	 *         },
	 *         exit: function (data, completeCallback) {
	 *             console.log('exited idle state');
	 *             completeCallback();
	 *         }
	 *     });
	 *     
	 *     // Define a "moving" state
	 *     fsm.defineState('moving', {
	 *         enter: function (data, completeCallback) {
	 *             console.log('entered moving state');
	 *             completeCallback();
	 *         },
	 *         exit: function (data, completeCallback) {
	 *             console.log('exited moving state');
	 *             completeCallback();
	 *         }
	 *     });
	 *     
	 *     // Define a transition between the two methods
	 *     fsm.defineTransition('idle', 'moving', function (data, callback) {
	 *         // Check some data we were passed
	 *         if (data === 'ok') {
	 *             // Callback the listener and tell them there was no error
	 *             // (first argument is an err flag, set to false for no error)
	 *             callback(false);
	 *         } else {
	 *             // Callback and say there was an error by passing anything other
	 *             // than false in the first argument
	 *             callback('Some error string, or true or any data');
	 *         }
	 *     });
	 *     
	 *     // Now change states and cause it to fail
	 *     fsm.enterState('moving', 'notOk', function (err, data) {
	 *         if (!err) {
	 *             // There was no error, the state changed successfully
	 *             console.log('State changed!', fsm.currentStateName());
	 *         } else {
	 *             // There was an error, the state did not change
	 *             console.log('State did NOT change!', fsm.currentStateName());
	 *         }
	 *     });
	 *     
	 *     // Now change states and pass "ok" in the data to make it proceed
	 *     fsm.enterState('moving', 'ok', function (err, data) {
	 *         if (!err) {
	 *             // There was no error, the state changed successfully
	 *             console.log('State changed!', fsm.currentStateName());
	 *         } else {
	 *             // There was an error, the state did not change
	 *             console.log('State did NOT change!', fsm.currentStateName());
	 *         }
	 *     });
	 * @returns {*}
	 */
	defineTransition: function (fromState, toState, transitionCheck) {
		if (fromState && toState && transitionCheck) {
			if (!this._states[fromState]) {
				this.log('fromState "' + fromState + '" specified is not defined as a state!', 'error');
			}
	
			if (!this._states[toState]) {
				this.log('toState "' + toState + '" specified is not defined as a state!', 'error');
			}
	
			this._transitions[fromState] = this._transitions[fromState] || {};
			this._transitions[fromState][toState] = transitionCheck;
			
			return this;
		}
		
		return false;
	},

	/**
	 * After defining your states, call this with the state name and the initial
	 * state of the FSM will be set.
	 * @param {String} stateName The state to set as the initial state.
	 * @param {*=} data Any data you wish to pass the state's "enter" method.
	 * @param {Function=} callback An optional callback method that will be called
	 * once the state has been entered successfully, or if there was an error.
	 */
	initialState: function (stateName, data, callback) {
		var newStateObj = this.getState(stateName);
		
		this._currentStateName = stateName;
		
		if (this._debug) { this.log('Entering initial state: ' + stateName); }
		
		if (newStateObj.enter) {
			newStateObj.enter.apply(newStateObj, [data, function (enterErr, enterData) {
				if (callback) { callback(enterErr, enterData); }
			}]);
		}
	},

	/**
	 * Gets the state definition object for the specified state name.
	 * @param {String} stateName The name of the state who's definition object should
	 * be looked up and returned.
	 * @returns {Object} The state definition object or undefined if no state exists
	 * with that name.
	 */
	getState: function (stateName) {
		return this._states[stateName];
	},

	/**
	 * Tell the FSM to enter the state specified.
	 * @param {String} newStateName The new state to enter.
	 * @param {*} data Any data to pass to the exit and enter methods.
	 * @param {Function=} callback The optional callback method to call on completion.
	 */
	enterState: function (newStateName, data, callback) {
		var self = this;
		
		if (self._transitions[self._currentStateName] && self._transitions[self._currentStateName][newStateName]) {
			// There is a transition check method, call it to see if we can change states
			self._transitions[self._currentStateName][newStateName](data, function (err) {
				if (!err) {
					// State change allowed
					self._transitionStates(self._currentStateName, newStateName, data, callback);
				} else {
					// State change not allowed or error
					if (callback ) { callback(err); }
					
					this.log('Cannot transition from "' + self._currentStateName + '" to "' + newStateName + '" states.', 'warning');
				}
			});
		} else {
			// No transition check method exists, continue to change states
			self._transitionStates(self._currentStateName, newStateName, data, callback);
		}
	},

	/**
	 * Tell the FSM to exit the current state and enter the previous state.
	 * @param {Function=} callback Optional callback method once exiting the state
	 * has been executed.
	 */
	exitState: function (callback) {
		this.enterState(this._previousStateName, null, callback);
	},

	/**
	 * Handles changing states from one to another by checking for transitions and
	 * handling callbacks.
	 * @param {String} oldStateName The name of the state we are transitioning from.
	 * @param {String} newStateName The name of the state we are transitioning to.
	 * @param {*=} data Optional data to pass to the exit and enter methods of each state.
	 * @param {Function=} callback Optional callback method to execute once the transition
	 * has been completed.
	 * @private
	 */
	_transitionStates: function (oldStateName, newStateName, data, callback) {
		var self = this,
			currentStateObj = self.getState(self._currentStateName),
			newStateObj = self.getState(newStateName);
		
		if (currentStateObj && newStateObj) {
			if (self._debug) { self.log('Exiting state: ' + self._currentStateName); }
			if (currentStateObj.exit) {
				currentStateObj.exit.apply(currentStateObj, [data, function (exitStateErr, exitStateData) {
					self._previousStateName = self._currentStateName;
					self._currentStateName = newStateName;
					
					if (self._debug) { self.log('Entering state: ' + newStateName); }
					if (newStateObj.enter) {
						newStateObj.enter.apply(newStateObj, [data, function (enterStateErr, enterStateData) {
							if (callback) { callback(enterStateErr, data); }
						}]);
					}
				}]);
			}
		} else {
			if (callback) { callback('Cannot change states from "' + self._currentStateName + '" to "' + newStateName + '" states.'); }
			self.log('Cannot change states from "' + self._currentStateName + '" to "' + newStateName + '" states.', 'warning');
		}
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = IgeFSM; }
var IgeSceneGraph = IgeClass.extend({
	classId: 'IgeSceneGraph',
	interfaceImplements: [
		'addGraph',
		'removeGraph'
	],
	
	/**
	 * Called when loading the graph data via ige.addGraph().
	 * @param {Object=} options The options that were passed with the call
	 * to ige.addGraph().
	 */
	addGraph: function (options) {
		
	},
	
	/**
	 * The method called when the graph items are to be removed from the
	 * active graph.
	 */
	removeGraph: function () {
		
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = IgeSceneGraph; }
/**
 * When loaded into memory using ige.addGraph('IgeBaseScene') will create
 * the scene "baseScene" and the viewport "vp1" that are used in almost all
 * examples and can be used as the base for your scenegraph as well.
 */
var IgeBaseScene = IgeSceneGraph.extend({
	classId: 'IgeBaseScene',
	
	init: function () {},

	/**
	 * Called when loading the graph data via ige.addGraph().
	 * @param options
	 */
	addGraph: function (options) {
		// Clear existing graph data
		if (ige.$('baseScene')) {
			this.destroyGraph();
		}
		
		// Create the scene
		var baseScene = new IgeScene2d()
			.id('baseScene');

		// Create the main viewport to look at "baseScene"
		new IgeViewport()
			.id('vp1')
			.autoSize(true)
			.scene(baseScene)
			.drawBounds(false)
			.mount(ige);
	},

	/**
	 * The method called when the graph items are to be removed from the
	 * active graph.
	 */
	removeGraph: function () {
		// Destroy the viewport
		ige.$('vp1').destroy();
		
		// Destroy the baseScene
		ige.$('baseScene').destroy();
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = IgeBaseScene; }
var nullMethod = function () {},
	IgeDummyCanvas = function () {
		this.dummy = true;
		this.width = 0;
		this.height = 0;
	};

IgeDummyCanvas.prototype.getContext = function () {
	return IgeDummyContext;
};

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = IgeDummyCanvas; }
var nullMethod = function () {},
	IgeDummyContext = {
		dummy: true,
		save: nullMethod,
		restore: nullMethod,
		translate: nullMethod,
		rotate: nullMethod,
		scale: nullMethod,
		drawImage: nullMethod,
		fillRect: nullMethod,
		strokeRect: nullMethod,
		stroke: nullMethod,
		fill: nullMethod,
		rect: nullMethod,
		moveTo: nullMethod,
		lineTo: nullMethod,
		arc: nullMethod,
		clearRect: nullMethod,
		beginPath: nullMethod,
		clip: nullMethod,
		transform: nullMethod,
		setTransform: nullMethod,
		fillText: nullMethod
	};

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = IgeDummyContext; }
/**
 * Creates a new path node for use with the IgePathFinder class.
 */
var IgePathNode = IgePoint3d.extend({
	classId: 'IgePathNode',

	/**
	 * @constructor
	 * @param {Number} x
	 * @param {Number} y
	 * @param {Number} g
	 * @param {Number} moveCost
	 * @param {Number} h
	 * @param {Object} parent
	 * @param {String} direction
	 */
	init: function(x, y, g, moveCost, h, parent, direction) {
		this.z = 0; // Compat with IgePoint3d
		
		this.x = x;
		this.y = y;
		this.g = g + moveCost; // Cost of moving from the start point along the path to this node (parentNode.g + moveCost)
		this.h = h; // Rough distance to target node
		this.moveCost = moveCost;
		this.f = g + h; // Result of g + h
		this.link = parent;
		this.hash = x + ',' + y;
		this.listType = 0;
		this.direction = direction;
		this.mode = 0;
	},

	/**
	 * Gets / sets the path node mode. The mode determines if the co-ordinates
	 * will be in tile or absolute co-ordinates.
	 * @param {Number=} val 0 = tile based, 1 = absolute based.
	 * @return {*}
	 */
	mode: function (val) {
		if (val !== undefined) {
			this.mode = val;
			return this;
		}
		
		return this.mode;
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = IgePathNode; }
/**
 * Creates a new path using the A* path-finding algorithm.
 */
var IgePathFinder = IgeEventingClass.extend({
	classId: 'IgePathFinder',

	init: function() {
		this._neighbourLimit = 1000;
		this._squareCost = 10;
		this._diagonalCost = 10;
	},

	/**
	 * Gets / sets the cost of movement over a square (left,
	 * right, up, down) adjacent tile.
	 * @param {Number=} val
	 * @return {*}
	 */
	squareCost: function (val) {
		if (val !== undefined) {
			this._squareCost = val;
			return this;
		}

		return this._squareCost;
	},

	/**
	 * Gets / sets the cost of movement over a diagonal (nw,
	 * ne, sw, se) adjacent tile.
	 * @param {Number=} val
	 * @return {*}
	 */
	diagonalCost: function (val) {
		if (val !== undefined) {
			this._diagonalCost = val;
			return this;
		}

		return this._diagonalCost;
	},

	/**
	 * Gets / sets the limit on the number of neighbour nodes
	 * that the path-finder will analyse before reaching it's
	 * target tile. On large maps this limit should be increased
	 * to allow pathing where many neighbours need to be
	 * considered.
	 * @param val
	 * @return {*}
	 */
	neighbourLimit: function (val) {
		if (val !== undefined) {
			this._neighbourLimit = val;
			return this;
		}

		return this._neighbourLimit;
	},
	
	aStar: function () {
		this.log('The "IgePathFinder.aStar" method has been renamed to "generate". Please update your code.', 'error');
	},

	/**
	 * Uses the A* algorithm to generate path data between two points.
	 * @param {IgeCollisionMap2d} tileMap The tile map to use when generating the path.
	 * @param {IgePoint3d} startPoint The point on the map to start path-finding from.
	 * @param {IgePoint3d} endPoint The point on the map to try to path-find to.
	 * @param {Function} comparisonCallback The callback function that will decide if each tile that is being considered for use in the path is allowed or not based on the tile map's data stored for that tile which is passed to this method as the first parameter. Must return a boolean value.
	 * @param {Boolean} allowSquare Whether to allow neighboring tiles along a square axis. Defaults to true if undefined.
	 * @param {Boolean} allowDiagonal Whether to allow neighboring tiles along a diagonal axis. Defaults to false if undefined.
	 * @param {Boolean=} allowInvalidDestination If the path finder cannot path to the destination tile, if this is true the closest path will be returned instead.
	 * @return {Array} An array of objects each containing an x, y co-ordinate that describes the path from the starting point to the end point in order.
	 */
	generate: function (tileMap, startPoint, endPoint, comparisonCallback, allowSquare, allowDiagonal, allowInvalidDestination) {
		var openList = [],
			closedList = [],
			listHash = {},
			startNode,
			lowestFScoringIndex,
			openCount,
			currentNode,
			pathPoint,
			finalPath,
			neighbourList,
			neighbourCount,
			neighbourNode,
			endPointCheckTile,
			tileMapData,
			existingNode,
			lowestHNode;

		// Set some defaults
		if (allowSquare === undefined) { allowSquare = true; }
		if (allowDiagonal === undefined) { allowDiagonal = false; }

		// Check that the end point on the map is actually allowed to be pathed to!
		tileMapData = tileMap.map._mapData;
		endPointCheckTile = tileMapData[endPoint.y] && tileMapData[endPoint.y][endPoint.x] ? tileMapData[endPoint.y][endPoint.x] : null;
		if (!allowInvalidDestination && !comparisonCallback(endPointCheckTile, endPoint.x, endPoint.y)) {
			// There is no path to the end point because the end point
			// is not allowed to be pathed to!
			this.emit('noPathFound');
			//this.log('Cannot path to destination because the destination tile is not pathable!');
			return [];
		}

		// Starting point to open list
		startNode = new IgePathNode(startPoint.x, startPoint.y, 0, 0, this._heuristic(startPoint.x, startPoint.y, endPoint.x, endPoint.y, 10));
		startNode.link = 1;
		openList.push(startNode);
		listHash[startNode.hash] = startNode;
		startNode.listType = 1;

		lowestHNode = startNode;

		// Loop as long as there are more points to process in our open list
		while (openList.length) {
			// Check for some major error
			if (openList.length > this._neighbourLimit) {
				//this.log('Path finder error, open list nodes exceeded ' + this._neighbourLimit + '!', 'warning');
				this.emit('exceededLimit');
				break;
			}

			// Grab the lowest f scoring node from the open list
			// to process next
			lowestFScoringIndex = 0;
			openCount = openList.length;

			while (openCount--) {
				if(openList[openCount].f < openList[lowestFScoringIndex].f) { lowestFScoringIndex = openCount; }
			}

			currentNode = openList[lowestFScoringIndex];

			// Check if the current node is the end point
			if (currentNode.x === endPoint.x && currentNode.y === endPoint.y) {
				// We have reached the end point
				pathPoint = currentNode;
				finalPath = [];

				while(pathPoint.link) {
					finalPath.push(pathPoint);
					pathPoint = pathPoint.link;
				}

				this.emit('pathFound', finalPath);

				return finalPath.reverse();
			} else {
				// Remove the current node from the open list
				openList.splice(lowestFScoringIndex, 1);

				// Add the current node to the closed list
				closedList.push(currentNode);
				currentNode.listType = -1;

				// Get the current node's neighbors
				neighbourList = this._getNeighbours(currentNode, endPoint, tileMap, comparisonCallback, allowSquare, allowDiagonal);
				neighbourCount = neighbourList.length;

				// Loop the neighbours and add each one to the open list
				while (neighbourCount--) {
					neighbourNode = neighbourList[neighbourCount];
					existingNode = listHash[neighbourNode.hash];

					// Check that the neighbour is not on the closed list
					if (!existingNode || existingNode.listType !== -1) {
						// The neighbour is not on the closed list so
						// check if it is already on the open list
						if (existingNode && existingNode.listType === 1) {
							// The neighbour is already on the open list
							// so check if our new path is a better score
							if (existingNode.g > neighbourNode.g) {
								// Pathing from the current node through this neighbour
								// costs less that any way we've calculated before
								existingNode.link = neighbourNode.link;
								existingNode.g = neighbourNode.g;
								existingNode.f = neighbourNode.f;
							}
						} else {
							// Add the neighbour to the open list
							openList.push(neighbourNode);
							listHash[neighbourNode.hash] = neighbourNode;
							neighbourNode.listType = 1;
							existingNode = neighbourNode;
						}
					}

					// Check if this neighbour node has the lowest
					// h value (distance from target) and store it
					if (!lowestHNode || existingNode.h < lowestHNode.h) {
						lowestHNode = existingNode;
					}
				}
			}

		}

		if (!allowInvalidDestination || (allowInvalidDestination && !lowestHNode)) {
			// Could not find a path, return an empty array!
			//this.log('Could not find a path to destination!');
			this.emit('noPathFound');
			return [];
		} else {
			// We couldn't path to the destination so return
			// the closest detected end point
			pathPoint = lowestHNode;
			finalPath = [];

			while(pathPoint.link) {
				finalPath.push(pathPoint);
				pathPoint = pathPoint.link;
			}

			// Reverse the final path so it is from
			// start to finish
			finalPath = finalPath.reverse();

			this.emit('pathFound', finalPath);
			return finalPath;
		}
	},

	/**
	 * Get all the neighbors of a node for the A* algorithm.
	 * @param {IgePathNode} currentNode The current node along the path to evaluate neighbors for.
	 * @param {IgePathNode} endPoint The end point of the path.
	 * @param {IgeCollisionMap2d} tileMap The tile map to use when evaluating neighbours.
	 * @param {Function} comparisonCallback The callback function that will decide if the tile data at the neighbouring node is to be used or not. Must return a boolean value.
	 * @param {Boolean} allowSquare Whether to allow neighboring tiles along a square axis.
	 * @param {Boolean} allowDiagonal Whether to allow neighboring tiles along a diagonal axis.
	 * @return {Array} An array containing nodes describing the neighbouring tiles of the current node.
	 * @private
	 */
	_getNeighbours: function (currentNode, endPoint, tileMap, comparisonCallback, allowSquare, allowDiagonal) {
		var list = [],
			x = currentNode.x,
			y = currentNode.y,
			newX = 0,
			newY = 0,
			newNode,
			mapData = tileMap.map._mapData,
			currentNodeData = mapData[y] && mapData[y][x] ? mapData[y][x] : undefined,
			tileData;

		if (allowSquare) {
			newX = x - 1; newY = y;
			tileData = mapData[newY] && mapData[newY][newX] ? mapData[newY][newX] : null;
			if (comparisonCallback(tileData, newX, newY, currentNodeData, x, y)) {
				newNode = new IgePathNode(newX, newY, currentNode.g, this._squareCost, this._heuristic(newX, newY, endPoint.x, endPoint.y, this._squareCost), currentNode, 'W');
				list.push(newNode);
			}

			newX = x + 1; newY = y;
			tileData = mapData[newY] && mapData[newY][newX] ? mapData[newY][newX] : null;
			if (comparisonCallback(tileData, newX, newY, currentNodeData, x, y)) {
				newNode = new IgePathNode(newX, newY, currentNode.g, this._squareCost, this._heuristic(newX, newY, endPoint.x, endPoint.y, this._squareCost), currentNode, 'E');
				list.push(newNode);
			}

			newX = x; newY = y - 1;
			tileData = mapData[newY] && mapData[newY][newX] ? mapData[newY][newX] : null;
			if (comparisonCallback(tileData, newX, newY, currentNodeData, x, y)) {
				newNode = new IgePathNode(newX, newY, currentNode.g, this._squareCost, this._heuristic(newX, newY, endPoint.x, endPoint.y, this._squareCost), currentNode, 'N');
				list.push(newNode);
			}

			newX = x; newY = y + 1;
			tileData = mapData[newY] && mapData[newY][newX] ? mapData[newY][newX] : null;
			if (comparisonCallback(tileData, newX, newY, currentNodeData, x, y)) {
				newNode = new IgePathNode(newX, newY, currentNode.g, this._squareCost, this._heuristic(newX, newY, endPoint.x, endPoint.y, this._squareCost), currentNode, 'S');
				list.push(newNode);
			}

		}

		if (allowDiagonal) {
			newX = x - 1; newY = y - 1;
			tileData = mapData[newY] && mapData[newY][newX] ? mapData[newY][newX] : null;
			if (comparisonCallback(tileData, newX, newY, currentNodeData, x, y)) {
				newNode = new IgePathNode(newX, newY, currentNode.g, this._diagonalCost, this._heuristic(newX, newY, endPoint.x, endPoint.y, this._diagonalCost), currentNode, 'NW');
				list.push(newNode);
			}

			newX = x + 1; newY = y - 1;
			tileData = mapData[newY] && mapData[newY][newX] ? mapData[newY][newX] : null;
			if (comparisonCallback(tileData, newX, newY, currentNodeData, x, y)) {
				newNode = new IgePathNode(newX, newY, currentNode.g, this._diagonalCost, this._heuristic(newX, newY, endPoint.x, endPoint.y, this._diagonalCost), currentNode, 'NE');
				list.push(newNode);
			}

			newX = x - 1; newY = y + 1;
			tileData = mapData[newY] && mapData[newY][newX] ? mapData[newY][newX] : null;
			if (comparisonCallback(tileData, newX, newY, currentNodeData, x, y)) {
				newNode = new IgePathNode(newX, newY, currentNode.g, this._diagonalCost, this._heuristic(newX, newY, endPoint.x, endPoint.y, this._diagonalCost), currentNode, 'SW');
				list.push(newNode);
			}

			newX = x + 1; newY = y + 1;
			tileData = mapData[newY] && mapData[newY][newX] ? mapData[newY][newX] : null;
			if (comparisonCallback(tileData, newX, newY, currentNodeData, x, y)) {
				newNode = new IgePathNode(newX, newY, currentNode.g, this._diagonalCost, this._heuristic(newX, newY, endPoint.x, endPoint.y, this._diagonalCost), currentNode, 'SE');
				list.push(newNode);
			}
		}

		return list;
	},

	/**
	 * The heuristic to calculate the rough cost of pathing from the
	 * x1, y1 to x2, y2.
	 * @param {Number} x1 The first x co-ordinate.
	 * @param {Number} y1 The first y co-ordinate.
	 * @param {Number} x2 The second x co-ordinate.
	 * @param {Number} y2 The second y co-ordinate.
	 * @param {Number} moveCost The cost multiplier to multiply by.
	 * @return {Number} Returns the heuristic cost between the co-ordinates specified.
	 * @private
	 */
	_heuristic: function (x1, y1, x2, y2, moveCost) {
		return moveCost * (Math.abs(x1 - x2) + Math.abs(y1 - y2));
	},

	as: function (map, fromNode, toNode) {
		var openList = [],
			closedList = [];

		// Add start point to open list
		openList.push(fromNode);


	},

	_as: function (openList, closedList, currentNode, toNode) {

	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = IgePathFinder; }
/**
 * Creates a new tween instance.
 */
var IgeTween = IgeClass.extend({
	classId: 'IgeTween',

	init: function (targetObj, propertyObj, durationMs, options) {
		// Create a new tween object and return it
		// so the user can decide when to start it
		this._targetObj = targetObj;
		this._steps = [];
		this._currentStep = -1;
		if (propertyObj !== undefined) {
			this.stepTo(propertyObj);
		}
		this._durationMs = durationMs !== undefined ? durationMs : 0;
		this._started = false;
		this._stepDirection = false;

		// Sort out the options
		if (options && options.easing) { this.easing(options.easing); } else { this.easing('none'); }
		if (options && options.startTime !== undefined) { this.startTime(options.startTime); }
		if (options && options.beforeTween !== undefined) { this.beforeTween(options.beforeTween); }
		if (options && options.afterTween !== undefined) { this.afterTween(options.afterTween); }
	},

	/**
	 * Sets the object in which the properties to tween exist.
	 * @param targetObj
	 * @return {*}
	 */
	targetObj: function (targetObj) {
		if (targetObj !== undefined) {
			this._targetObj = targetObj;
		}

		return this;
	},

	/**
	 * Sets the tween's target properties to tween to.
	 * @param propertyObj
	 * @return {*}
	 */
	properties: function (propertyObj) {
		if (propertyObj !== undefined) {
			// Reset any existing steps and add this new one
			this._steps = [];
			this._currentStep = -1;
			this.stepTo(propertyObj);
		}

		return this;
	},

	/**
	 * Gets / sets the repeat mode for the tween. If the mode
	 * is set to 1 the tween will repeat from the first step.
	 * If set to 2 the tween will reverse the order of the steps
	 * each time the repeat occurs. The count determines the
	 * number of times the tween will be repeated before stopping.
	 * Setting the count to -1 will make it repeat infinitely.
	 * @param val
	 * @param count
	 * @return {*}
	 */
	repeatMode: function (val, count) {
		if (val !== undefined) {
			this._repeatMode = val;
			this.repeatCount(count);
			return this;
		}

		return this._repeatMode;
	},

	/**
	 * Gets / sets the repeat count. The count determines the
	 * number of times the tween will be repeated before stopping.
	 * Setting the count to -1 will make it repeat infinitely.
	 * This setting is used in conjunction with the repeatMode()
	 * method. If you just set a repeat count and no mode then
	 * the tween will not repeat.
	 * @param val
	 * @return {*}
	 */
	repeatCount: function (val) {
		if (val !== undefined) {
			this._repeatCount = val;
			this._repeatedCount = 0;
			return this;
		}

		return this._repeatCount;
	},

	/**
	 * DEPRECIATED, Renamed to stepTo().
	 */
	step: function (propertyObj, durationMs, easing) {
		this.log('The step method has been renamed to stepTo(). Please update your code as the step() method will soon be removed.', 'warning');
		this.stepTo(propertyObj, durationMs, easing);
		return this;
	},

	/**
	 * Defines a step in a multi-stage tween. Uses the properties
	 * as destination value.
	 * @param {Object} propertyObj The properties to
	 * tween during this step.
	 * @param {Number=} durationMs The number of milliseconds
	 * to spend tweening this step, or if not provided uses
	 * the current tween durationMs setting.
	 * @param {String=} easing The name of the easing method
	 * to use during this step.
	 * @param {Boolean=} delta If true will set the step to use
	 * delta values instead of absolute values as the destination.
	 * @return {*}
	 */
	stepTo: function (propertyObj, durationMs, easing, delta) {
		if (propertyObj !== undefined) {
			// Check if we have already been given a standard
			// non-staged property
			this._steps.push({
				props: propertyObj,
				durationMs: durationMs,
				easing: easing,
				isDelta: delta
			});
		}

		return this;
	},
	
	/**
	 * Defines a step in a multi-stage tween. Uses the properties
	 * as deltas, not as destination values
	 * @param {Object} propertyObj The properties to
	 * tween during this step.
	 * @param {Number=} durationMs The number of milliseconds
	 * to spend tweening this step, or if not provided uses
	 * the current tween durationMs setting.
	 * @param {String=} easing The name of the easing method
	 * to use during this step.
	 * @return {*}
	 */
	stepBy: function (propertyObj, durationMs, easing) {
		this.stepTo(
			propertyObj,
			durationMs,
			easing,
			true
		);
		
		return this;
	},

	/**
	 * Sets the duration of the tween in milliseconds.
	 * @param durationMs
	 * @return {*}
	 */
	duration: function (durationMs) {
		if (durationMs !== undefined) {
			this._durationMs = durationMs;
		}

		return this;
	},

	/**
	 * Sets the method to be called just before the tween has started.
	 * @param callback
	 * @return {*}
	 */
	beforeTween: function (callback) {
		if (callback !== undefined) {
			this._beforeTween = callback;
		}

		return this;
	},

	/**
	 * Sets the method to be called just after the tween has ended.
	 * @param callback
	 * @return {*}
	 */
	afterTween: function (callback) {
		if (callback !== undefined) {
			this._afterTween = callback;
		}

		return this;
	},

	/**
	 * Sets the method to be called just before a tween step has
	 * started.
	 * @param callback
	 * @return {*}
	 */
	beforeStep: function (callback) {
		if (callback !== undefined) {
			this._beforeStep = callback;
		}

		return this;
	},

	/**
	 * Sets the method to be called just after a tween step has
	 * ended.
	 * @param callback
	 * @return {*}
	 */
	afterStep: function (callback) {
		if (callback !== undefined) {
			this._afterStep = callback;
		}

		return this;
	},

	/**
	 * Sets the method to be called just after a tween has changed
	 * the values of the target object every update tick.
	 * @param callback
	 * @return {*}
	 */
	afterChange: function (callback) {
		if (callback !== undefined) {
			this._afterChange = callback;
		}

		return this;
	},

	/**
	 * Returns the object that this tween is modifying.
	 * @return {*}
	 */
	targetObject: function () {
		return this._targetObj;
	},

	/**
	 * Sets the name of the easing method to use with the tween.
	 * @param methodName
	 * @return {*}
	 */
	easing: function (methodName) {
		if (methodName !== undefined) {
			if (ige.tween.easing[methodName]) {
				this._easing = methodName;
			} else {
				this.log('The easing method you have selected does not exist, please use a valid easing method. For a list of easing methods please inspect ige.tween.easing from your console.', 'error', ige.tween.easing);
			}
		}

		return this;
	},

	/**
	 * Sets the timestamp at which the tween should start.
	 * @param timeMs
	 * @return {*}
	 */
	startTime: function (timeMs) {
		if (timeMs !== undefined) {
			this._startTime = timeMs;
		}

		return this;
	},

	/**
	 * Starts the tweening operation.
	 * @param {Number=} timeMs If set, the tween will start this
	 * many milliseconds in the future.
	 */
	start: function (timeMs) {
		if (timeMs !== undefined) {
			this.startTime(timeMs + ige._currentTime);
		}
		
		ige.tween.start(this);

		// Add the tween to the target object's tween array
		this._targetObj._tweenArr = this._targetObj._tweenArr || [];
		this._targetObj._tweenArr.push(this);

		return this;
	},

	/**
	 * Stops the tweening operation.
	 */
	stop: function () {
		ige.tween.stop(this);
		if (this._targetObj._tweenArr) {
			this._targetObj._tweenArr.pull(this);
		}

		return this;
	},

	/**
	 * Starts all tweens registered to an object.
	 * @private
	 */
	startAll: function () {
		if (this._targetObj._tweenArr) {
			this._targetObj._tweenArr.eachReverse(function (tweenItem) {
				tweenItem.start();
			});
		}

		return this;
	},

	/**
	 * Stops all tweens registered to an object.
	 * @private
	 */
	stopAll: function () {
		if (this._targetObj._tweenArr) {
			this._targetObj._tweenArr.eachReverse(function (tweenItem) {
				tweenItem.stop();
			});
		}

		return this;
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = IgeTween; }
/**
 * Creates a new texture.
 */
var IgeTexture = IgeEventingClass.extend({
	classId: 'IgeTexture',
	IgeTexture: true,

	/**
	 * Constructor for a new IgeTexture.
	 * @param {String, Object} urlOrObject Either a string URL that
	 * points to the path of the image or script you wish to use as
	 * the texture image, or an object containing a smart texture.
	 * @return {*}
	 */
	init: function (urlOrObject) {
		this._loaded = false;
		
		/* CEXCLUDE */
		// If on a server, error
		if (ige.isServer) {
			this.log('Cannot create a texture on the server. Textures are only client-side objects. Please alter your code so that you don\'t try to load a texture on the server-side using something like an if statement around your texture laoding such as "if (ige.isClient) {}".', 'error');
			return this;
		}
		/* CEXCLUDE */

		// Create an array that is used to store cell dimensions
		this._cells = [];
		this._smoothing = ige._globalSmoothing;
		
		// Instantiate filter lists for filter combinations
		this._applyFilters = [];
		this._applyFiltersData = [];
		this._preFilters = [];
		this._preFiltersData = [];

		var type = typeof(urlOrObject);

		if (type === 'string') {
			// Load the texture URL
			if (urlOrObject) {
				this.url(urlOrObject);
			}
		}

		if (type === 'object') {
			// Assign the texture script object
			this.assignSmartTextureImage(urlOrObject);
		}
	},

	/**
	 * Gets / sets the current object id. If no id is currently assigned and no
	 * id is passed to the method, it will automatically generate and assign a
	 * new id as a 16 character hexadecimal value typed as a string.
	 * @param {String=} id
	 * @return {*} Returns this when setting the value or the current value if none is specified.
	 */
	id: function (id) {
		if (id !== undefined) {
			// Check if this ID already exists in the object register
			if (ige._register[id]) {
				if (ige._register[id] === this) {
					// We are already registered as this id
					return this;
				}
				
				// Already an object with this ID!
				this.log('Cannot set ID of object to "' + id + '" because that ID is already in use by another object!', 'error');
			} else {
				// Check if we already have an id assigned
				if (this._id && ige._register[this._id]) {
					// Unregister the old ID before setting this new one
					ige.unRegister(this);
				}

				this._id = id;

				// Now register this object with the object register
				ige.register(this);

				return this;
			}
		}

		if (!this._id) {
			// The item has no id so generate one automatically
			if (this._url) {
				// Generate an ID from the URL string of the image
				// this texture is using. Useful for always reproducing
				// the same ID for the same texture :)
				this._id = ige.newIdFromString(this._url);
			} else {
				// We don't have a URL so generate a random ID
				this._id = ige.newIdHex();
			}
			ige.register(this);
		}

		return this._id;
	},

	/**
	 * Gets / sets the source file for this texture.
	 * @param {String=} url "The url used to load the file for this texture.
	 * @return {*}
	 */
	url: function (url) {
		if (url !== undefined) {
			this._url = url;

			if (url.substr(url.length - 2, 2) === 'js') {
				// This is a script-based texture, load the script
				this._loadScript(url);
			} else {
				// This is an image-based texture, load the image
				this._loadImage(url);
			}

			return this;
		}

		return this._url;
	},

	/**
	 * Loads an image into an img tag and sets an onload event
	 * to capture when the image has finished loading.
	 * @param {String} imageUrl The image url used to load the
	 * image data.
	 * @private
	 */
	_loadImage: function (imageUrl) {
		var image,
			self = this;

		if (ige.isClient) {
			// Increment the texture load count
			ige.textureLoadStart(imageUrl, this);

			// Check if the image url already exists in the image cache
			if (!ige._textureImageStore[imageUrl]) {
				// Image not in cache, create the image object
				image = ige._textureImageStore[imageUrl] = this.image = this._originalImage = new Image();
				image._igeTextures = image._igeTextures || [];

				// Add this texture to the textures that are using this image
				image._igeTextures.push(this);

				image.onload = function () {
					// Mark the image as loaded
					image._loaded = true;

					// Log success
					ige.log('Texture image (' + imageUrl + ') loaded successfully');

					/*if (image.width % 2) {
						self.log('The texture ' + imageUrl + ' width (' + image.width + ') is not divisible by 2 to a whole number! This can cause rendering artifacts. It can also cause performance issues on some GPUs. Please make sure your texture width is divisible by 2!', 'warning');
					}

					if (image.height % 2) {
						self.log('The texture ' + imageUrl + ' height (' + image.height + ') is not divisible by 2 to a whole number! This can cause rendering artifacts. It can also cause performance issues on some GPUs. Please make sure your texture height is divisible by 2!', 'warning');
					}*/

					// Loop textures that are using this image
					var arr = image._igeTextures,
						arrCount = arr.length, i,
						item;

					for (i = 0; i < arrCount; i++) {
						item = arr[i];

						item._mode = 0;

						item.sizeX(image.width);
						item.sizeY(image.height);

						item._cells[1] = [0, 0, item._sizeX, item._sizeY];
						
						// Mark texture as loaded
						item._textureLoaded();
					}
				};

				// Start the image loading by setting the source url
				image.src = imageUrl;
			} else {
				// Grab the cached image object
				image = this.image = this._originalImage = ige._textureImageStore[imageUrl];

				// Add this texture to the textures that are using this image
				image._igeTextures.push(this);

				if (image._loaded) {
					// The cached image object is already loaded so
					// fire off the relevant events
					self._mode = 0;

					self.sizeX(image.width);
					self.sizeY(image.height);

					if (image.width % 2) {
						this.log('This texture\'s width is not divisible by 2 which will cause the texture to use sub-pixel rendering resulting in a blurred image. This may also slow down the renderer on some browsers. Image file: ' + this._url, 'warning');
					}

					if (image.height % 2) {
						this.log('This texture\'s height is not divisible by 2 which will cause the texture to use sub-pixel rendering resulting in a blurred image. This may also slow down the renderer on some browsers. Image file: ' + this._url, 'warning');
					}

					self._cells[1] = [0, 0, self._sizeX, self._sizeY];
					
					// Mark texture as loaded
					self._textureLoaded();
				}
			}
		}
	},
	
	_textureLoaded: function () {
		var self = this;
		
		// Set a timeout here so that when this event is emitted,
		// the code creating the texture is given a chance to
		// set a listener first, otherwise this will be emitted
		// but nothing will have time to register a listener!
		setTimeout(function () {
			self._loaded = true;
			self.emit('loaded');

			// Inform the engine that this image has loaded
			ige.textureLoadEnd(self.image.src, self);
		}, 5);
	},

	/**
	 * Loads a render script into a script tag and sets an onload
	 * event to capture when the script has finished loading.
	 * @param {String} scriptUrl The script url used to load the
	 * script data.
	 * @private
	 */
	_loadScript: function (scriptUrl) {
		var textures = ige.textures,
			rs_sandboxContext,
			self = this,
			scriptElem;

		ige.textureLoadStart(scriptUrl, this);

		if (ige.isClient) {
			scriptElem = document.createElement('script');
			scriptElem.onload = function(data) {
				self.log('Texture script "' + scriptUrl + '" loaded successfully');
				// Parse the JS with evil eval and store the result in the asset
				eval(data);

				// Store the eval data (the "image" variable is declared
				// by the texture script and becomes available in this scope
				// because we evaluated it above)
				self._mode = 1;
				self.script = image;

				// Run the asset script init method
				if (typeof(image.init) === 'function') {
					image.init.apply(image, [self]);
				}

				//self.sizeX(image.width);
				//self.sizeY(image.height);

				self._loaded = true;
				self.emit('loaded');
				ige.textureLoadEnd(scriptUrl, self);
			};

			scriptElem.addEventListener('error', function () {
				self.log('Error loading smart texture script file: ' + scriptUrl, 'error');
			}, true);

			scriptElem.src = scriptUrl;
			document.getElementsByTagName('head')[0].appendChild(scriptElem);
		}
	},

	/**
	 * Assigns a render script to the smart texture.
	 * @param {String} scriptObj The script object.
	 * @private
	 */
	assignSmartTextureImage: function (scriptObj) {
		var textures = ige.textures,
			rs_sandboxContext,
			self = this,
			scriptElem;
		
		// Check the object has a render method
		if (typeof(scriptObj.render) === 'function') {
			//ige.textureLoadStart(scriptUrl, this);
	
			// Store the script data
			self._mode = 1;
			self.script = scriptObj;
	
			// Run the asset script init method
			if (typeof(scriptObj.init) === 'function') {
				scriptObj.init.apply(scriptObj, [self]);
			}
	
			//self.sizeX(image.width);
			//self.sizeY(image.height);
	
			self._loaded = true;
			self.emit('loaded');
			//ige.textureLoadEnd(scriptUrl, self);
		} else {
			this.log('Cannot assign smart texture because it doesn\'t have a render() method!', 'error');
		}
	},

	/**
	 * Sets the image element that the IgeTexture will use when
	 * rendering. This is a special method not designed to be called
	 * directly by any game code and is used specifically when
	 * assigning an existing canvas element to an IgeTexture.
	 * @param {Image} imageElement The canvas / image to use as
	 * the image data for the IgeTexture.
	 * @private
	 */
	_setImage: function (imageElement) {
		var image,
			self = this;

		if (ige.isClient) {
			// Create the image object
			image = this.image = this._originalImage = imageElement;
			image._igeTextures = image._igeTextures || [];

			// Mark the image as loaded
			image._loaded = true;

			this._mode = 0;

			this.sizeX(image.width);
			this.sizeY(image.height);

			this._cells[1] = [0, 0, this._sizeX, this._sizeY];
		}
	},

	/**
	 * Creates a new texture from a cell in the existing texture
	 * and returns the new texture.
	 * @param {Number, String} indexOrId The cell index or id to use.
	 * @return {*}
	 */
	textureFromCell: function (indexOrId) {
		var tex = new IgeTexture(),
			self = this;

		if (this._loaded) {
			this._textureFromCell(tex, indexOrId);
		} else {
			// The texture has not yet loaded, return the new texture and set a listener to handle
			// when this texture has loaded so we can assign the texture's image properly
			this.on('loaded', function () {
				self._textureFromCell(tex, indexOrId);
			})
		}

		return tex;
	},

	/**
	 * Called by textureFromCell() when the texture is ready
	 * to be processed. See textureFromCell() for description.
	 * @param {IgeTexture} tex The new texture to paint to.
	 * @param {Number, String} indexOrId The cell index or id
	 * to use.
	 * @private
	 */
	_textureFromCell: function (tex, indexOrId) {
		var index,
			cell,
			canvas,
			ctx;

		if (typeof(indexOrId) === 'string') {
			index = this.cellIdToIndex(indexOrId);
		} else {
			index = indexOrId;
		}

		if (this._cells[index]) {
			// Create a new IgeTexture, then draw the existing cell
			// to it's internal canvas
			cell = this._cells[index];
			canvas = document.createElement('canvas');
			ctx = canvas.getContext('2d');

			// Set smoothing mode
			// TODO: Does this cause a costly context change? If so maybe we set a global value to keep
			// TODO: track of the value and evaluate first before changing?
			if (!this._smoothing) {
				ctx.imageSmoothingEnabled = false;
				ctx.imageSmoothingEnabled = false;
			} else {
				ctx.imageSmoothingEnabled = true;
				ctx.imageSmoothingEnabled = true;
			}

			canvas.width = cell[2];
			canvas.height = cell[3];

			// Draw the cell to the canvas
			ctx.drawImage(
				this._originalImage,
				cell[0],
				cell[1],
				cell[2],
				cell[3],
				0,
				0,
				cell[2],
				cell[3]
			);

			// Set the new texture's image to the canvas
			tex._setImage(canvas);
			tex._loaded = true;

			// Fire the loaded event
			setTimeout(function () {
				tex.emit('loaded');
			}, 1);
		} else {
			this.log('Unable to create new texture from passed cell index (' + indexOrId + ') because the cell does not exist!', 'warning');
		}
	},

	/**
	 * Sets the _sizeX property.
	 * @param {Number} val
	 */
	sizeX: function (val) {
		this._sizeX = val;
	},

	/**
	 * Sets the _sizeY property.
	 * @param {Number} val
	 */
	sizeY: function (val) {
		this._sizeY = val;
	},

	/**
	 * Resizes the original texture image to a new size. This alters
	 * the image that the texture renders so all entities that use
	 * this texture will output the newly resized version of the image.
	 * @param {Number} x The new width.
	 * @param {Number} y The new height.
	 * @param {Boolean=} dontDraw If true the resized image will not be
	 * drawn to the texture canvas. Useful for just resizing the texture
	 * canvas and not the output image. Use in conjunction with the
	 * applyFilter() and preFilter() methods.
	 */
	resize: function (x, y, dontDraw) {
		if (this._originalImage) {
			if (this._loaded) {
				if (!this._textureCtx) {
					// Create a new canvas
					this._textureCanvas = document.createElement('canvas');
				}

				this._textureCanvas.width = x;
				this._textureCanvas.height = y;
				this._textureCtx = this._textureCanvas.getContext('2d');

				// Set smoothing mode
				if (!this._smoothing) {
					this._textureCtx.imageSmoothingEnabled = false;
					this._textureCtx.imageSmoothingEnabled = false;
				} else {
					this._textureCtx.imageSmoothingEnabled = true;
					this._textureCtx.imageSmoothingEnabled = true;
				}

				if (!dontDraw) {
					// Draw the original image to the new canvas
					// scaled as required
					this._textureCtx.drawImage(
						this._originalImage,
						0,
						0,
						this._originalImage.width,
						this._originalImage.height,
						0,
						0,
						x,
						y
					);
				}

				// Swap the current image for this new canvas
				this.image = this._textureCanvas;
			} else {
				this.log('Cannot resize texture because the texture image (' + this._url + ') has not loaded into memory yet!', 'error');
			}
		}
	},

	/**
	 * Resizes the original texture image to a new size based on percentage.
	 * This alters the image that the texture renders so all entities that use
	 * this texture will output the newly resized version of the image.
	 * @param {Number} x The new width.
	 * @param {Number} y The new height.
	 * @param {Boolean=} dontDraw If true the resized image will not be
	 * drawn to the texture canvas. Useful for just resizing the texture
	 * canvas and not the output image. Use in conjunction with the
	 * applyFilter() and preFilter() methods.
	 */
	resizeByPercent: function (x, y, dontDraw) {
		if (this._originalImage) {
			if (this._loaded) {
				// Calc final x/y values
				x = Math.floor((this.image.width / 100) * x);
				y = Math.floor((this.image.height / 100) * y);

				if (!this._textureCtx) {
					// Create a new canvas
					this._textureCanvas = document.createElement('canvas');
				}

				this._textureCanvas.width = x;
				this._textureCanvas.height = y;
				this._textureCtx = this._textureCanvas.getContext('2d');

				// Set smoothing mode
				if (!this._smoothing) {
					this._textureCtx.imageSmoothingEnabled = false;
					this._textureCtx.imageSmoothingEnabled = false;
				} else {
					this._textureCtx.imageSmoothingEnabled = true;
					this._textureCtx.imageSmoothingEnabled = true;
				}

				if (!dontDraw) {
					// Draw the original image to the new canvas
					// scaled as required
					this._textureCtx.drawImage(
						this._originalImage,
						0,
						0,
						this._originalImage.width,
						this._originalImage.height,
						0,
						0,
						x,
						y
					);
				}

				// Swap the current image for this new canvas
				this.image = this._textureCanvas;
			} else {
				this.log('Cannot resize texture because the texture image (' + this._url + ') has not loaded into memory yet!', 'error');
			}
		}
	},

	/**
	 * Sets the texture image back to the original image that the
	 * texture first loaded. Useful if you have applied filters
	 * or resized the image and now want to revert back to the
	 * original.
	 */
	restoreOriginal: function () {
		this.image = this._originalImage;
		delete this._textureCtx;
		delete this._textureCanvas;
		
		this.removeFilters();
	},

	smoothing: function (val) {
		if (val !== undefined) {
			this._smoothing = val;
			return this;
		}

		return this._smoothing;
	},

	/**
	 * Renders the texture image to the passed canvas context.
	 * @param {CanvasRenderingContext2d} ctx The canvas context to draw to.
	 * @param {IgeEntity} entity The entity that this texture is
	 * being drawn for.
	 */
	render: function (ctx, entity) {
		// Check that the cell is not set to null. If it is then
		// we don't render anything which effectively makes the
		// entity "blank"
		if (entity._cell !== null) {
			// TODO: Does this cause a costly context change? If so maybe we set a global value to keep
			// TODO: track of the value and evaluate first before changing?
			if (!this._smoothing) {
				ige._ctx.imageSmoothingEnabled = false;
				ige._ctx.imageSmoothingEnabled = false;
			} else {
				ige._ctx.imageSmoothingEnabled = true;
				ige._ctx.imageSmoothingEnabled = true;
			}

			if (this._mode === 0) {
				// This texture is image-based
				var cell = this._cells[entity._cell],
					geom = entity._bounds2d,
					poly = entity._renderPos; // Render pos is calculated in the IgeEntity.aabb() method

				if (cell) {
					if (this._preFilters.length > 0 && this._textureCtx) {
						// Call the drawing of the original image
						this._textureCtx.clearRect(0, 0, this._textureCanvas.width, this._textureCanvas.height);
						this._textureCtx.drawImage(this._originalImage, 0, 0);
						
						var self = this;
						// Call the applyFilter and preFilter methods one by one
						this._applyFilters.forEach(function(method, index) {
							self._textureCtx.save();
							method(self._textureCanvas, self._textureCtx, self._originalImage, self, self._applyFiltersData[index]);
							self._textureCtx.restore();
						});
						this._preFilters.forEach(function(method, index) {
							self._textureCtx.save();
							method(self._textureCanvas, self._textureCtx, self._originalImage, self, self._preFiltersData[index]);
							self._textureCtx.restore();
						});
					}

					ctx.drawImage(
						this.image,
						cell[0], // texture x
						cell[1], // texture y
						cell[2], // texture width
						cell[3], // texture height
						poly.x, // render x
						poly.y, // render y
						geom.x, // render width
						geom.y // render height
					);

					ige._drawCount++;
				} else {
					this.log('Cannot render texture using cell ' + entity._cell + ' because the cell does not exist in the assigned texture!', 'error');
				}
			}

			if (this._mode === 1) {
				// This texture is script-based (a "smart texture")
				ctx.save();
					this.script.render(ctx, entity, this);
				ctx.restore();

				ige._drawCount++;
			}
		}
	},
	
	/**
	 * Removes a certain filter from the texture
	 * Useful if you want to keep resizings, etc. 
	 */
	removeFilter: function(method) {
		var i;
		while ((i = this._preFilters.indexOf(method)) > -1) {
			this._preFilters[i] = undefined;
			this._preFiltersData[i] = undefined;
		}
		while ((i = this._applyFilters.indexOf(method)) > -1) {
			this._applyFilters[i] = undefined;
			this._applyFiltersData[i] = undefined;
		}
		this._preFilters = this._preFilters.clean();
		this._preFiltersData = this._preFiltersData.clean();
		this._applyFilters = this._applyFilters.clean();
		this._applyFiltersData = this._applyFiltersData.clean();
		
		this._rerenderFilters();
	},
	
	/**
	 * Removes all filters on the texture
	 * Useful if you want to keep resizings, etc. 
	 */
	removeFilters: function() {
		this._applyFilters = [];
		this._applyFiltersData = [];
		this._preFilters = [];
		this._preFiltersData = [];
		
		this._rerenderFilters();
	},
	
	/**
	 * Rerenders image with filter list. Keeps sizings.
	 * Useful if you have no preFilters
	 */
	_rerenderFilters: function() {
		if (!this._textureCanvas) return;
		// Rerender applyFilters from scratch:
		// Draw the basic image
		// resize it to the old boundaries
		this.resize(this._textureCanvas.width, this._textureCanvas.height, false);
		// Draw applyFilter layers upon it
		var self = this;
		this._applyFilters.forEach(function(method, index) {
			self._textureCtx.save();
			method(self._textureCanvas, self._textureCtx, self._originalImage, self, self._applyFiltersData[index]);
			self._textureCtx.restore();
		});
	},

	/**
	 * Gets / sets the pre-filter method that will be called before
	 * the texture is rendered and will allow you to modify the texture
	 * image before rendering each tick.
	 * @param method
	 * @return {*}
	 */
	preFilter: function (method, data) {
		if (method !== undefined) {
			if (this._originalImage) {
				if (!this._textureCtx) {
					// Create a new canvas
					this._textureCanvas = document.createElement('canvas');

					this._textureCanvas.width = this._originalImage.width;
					this._textureCanvas.height = this._originalImage.height;
					this._textureCtx = this._textureCanvas.getContext('2d');

					// Set smoothing mode
					if (!this._smoothing) {
						this._textureCtx.imageSmoothingEnabled = false;
						this._textureCtx.imageSmoothingEnabled = false;
					} else {
						this._textureCtx.imageSmoothingEnabled = true;
						this._textureCtx.imageSmoothingEnabled = true;
					}
				}

				// Swap the current image for this new canvas
				this.image = this._textureCanvas;

				// Save filter in active preFilter list
				this._preFilters[this._preFilters.length] = method;
				this._preFiltersData[this._preFiltersData.length] = !data ? {} : data;
			}
			return this;
		} else {
			this.log('Cannot use pre-filter, no filter method was passed!', 'warning');
		}

		return this._preFilters[this._preFilters.length - 1];
	},

	/**
	 * Applies a filter to the texture. The filter is a method that will
	 * take the canvas, context and originalImage parameters and then
	 * use context calls to alter / paint the context with the texture
	 * and any filter / adjustments that you want to apply.
	 * @param {Function} method
	 * @param {Object=} data
	 * @return {*}
	 */
	applyFilter: function (method, data) {
		if (this._loaded) {
			if (method !== undefined) {
				if (this._originalImage) {
					if (!this._textureCtx) {
						// Create a new canvas
						this._textureCanvas = document.createElement('canvas');
	
						this._textureCanvas.width = this._originalImage.width;
						this._textureCanvas.height = this._originalImage.height;
						this._textureCtx = this._textureCanvas.getContext('2d');
						
						// Draw the basic image
						this._textureCtx.clearRect(0, 0, this._textureCanvas.width, this._textureCanvas.height);
						this._textureCtx.drawImage(this._originalImage, 0, 0);
	
						// Set smoothing mode
						if (!this._smoothing) {
							this._textureCtx.imageSmoothingEnabled = false;
							this._textureCtx.imageSmoothingEnabled = false;
						} else {
							this._textureCtx.imageSmoothingEnabled = true;
							this._textureCtx.imageSmoothingEnabled = true;
						}
					}
	
					// Swap the current image for this new canvas
					this.image = this._textureCanvas;
	
					// Call the passed method
					if (this._preFilters.length <= 0) {
						this._textureCtx.save();
						method(this._textureCanvas, this._textureCtx, this._originalImage, this, data);
						this._textureCtx.restore();
					}
					
					// Save filter in active applyFiler list
					this._applyFilters[this._applyFilters.length] = method;
					this._applyFiltersData[this._applyFiltersData.length] = !data ? {} : data;
				}
			} else {
				this.log('Cannot apply filter, no filter method was passed!', 'warning');
			}
		} else {
			this.log('Cannot apply filter, the texture you are trying to apply the filter to has not yet loaded!', 'error');
		}

		return this;
	},
	
	/**
	 * Retrieves pixel data from x,y texture coordinate (starts from top-left).
	 * Important: If the texture has a cross-domain url, the image host must allow
	 * cross-origin resource sharing or a security error will be thrown.
	 * Reference: http://blog.chromium.org/2011/07/using-cross-domain-images-in-webgl-and.html
	 * @param  {Number} x
	 * @param  {Number} y
	 * @return {Array} [r,g,b,a] Pixel data.
	 */
	pixelData: function (x, y) {
		if (this._loaded) {
			if (this.image) {
				// Check if the texture is already using a canvas
				if (!this._textureCtx) {
					// Create a new canvas
					this._textureCanvas = document.createElement('canvas');

					this._textureCanvas.width = this.image.width;
					this._textureCanvas.height = this.image.height;
					this._textureCtx = this._textureCanvas.getContext('2d');

					// Set smoothing mode
					if (!this._smoothing) {
						this._textureCtx.imageSmoothingEnabled = false;
						this._textureCtx.imageSmoothingEnabled = false;
					} else {
						this._textureCtx.imageSmoothingEnabled = true;
						this._textureCtx.imageSmoothingEnabled = true;
					}
					
					// Draw the image to the canvas
					this._textureCtx.drawImage(this.image, 0, 0);
				} else {
					this._textureCtx = this._textureCtx;
				}

				return this._textureCtx.getImageData(x, y, 1, 1).data;
			}
		} else {
			this.log('Cannot read pixel data, the texture you are trying to read data from has not yet loaded!', 'error');
		}

		return this;
	},

	/**
	 * Creates a clone of the texture.
	 * @return {IgeTexture} A new, distinct texture with the same attributes
	 * as the one being cloned.
	 */
	clone: function () {
		return this.textureFromCell(1);
	},

	/**
	 * Returns a string containing a code fragment that when
	 * evaluated will reproduce this object.
	 * @return {String}
	 */
	stringify: function () {
		var str = "new " + this.classId() + "('" + this._url + "')";

		// Every object has an ID, assign that first
		// We've commented this because ids for textures are actually generated
		// from their asset so will ALWAYS produce the same ID as long as the asset
		// is the same path.
		//str += ".id('" + this.id() + "')";

		// Now get all other properties
		str += this._stringify();

		return str;
	},
	
	_stringify: function () {
		return '';
	},

	/**
	 * Destroys the item.
	 */
	destroy: function () {
		delete this._eventListeners;

		// Remove us from the image store reference array
		if (this.image && this.image._igeTextures) {
			this.image._igeTextures.pull(this);
		}

		// Remove the texture from the texture store
		ige._textureStore.pull(this);

		delete this.image;
		delete this.script;
		delete this._textureCanvas;
		delete this._textureCtx;

		this._destroyed = true;
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = IgeTexture; }
/**
 * Creates a new cell sheet. Cell sheets are textures that are
 * automatically split up into individual cells based on a cell
 * width and height.
 */
var IgeCellSheet = IgeTexture.extend({
	classId: 'IgeCellSheet',
	IgeSpriteSheet: true,

	init: function (url, horizontalCells, verticalCells) {
		var self = this;

		self.horizontalCells(horizontalCells || 1);
		self.verticalCells(verticalCells || 1);

		IgeTexture.prototype.init.call(this, url);
	},
	
	_textureLoaded: function () {
		if (this.image) {
			// Store the cell sheet image
			this._sheetImage = this.image;
			this._applyCells();
		} else {
			// Unable to create cells from non-image texture
			// TODO: Low-priority - Support cell sheets from smart-textures
			this.log('Cannot create cell-sheet because texture has not loaded an image!', 'error');
		}
		
		IgeTexture.prototype._textureLoaded.call(this);
	},

	/**
	 * Returns the total number of cells in the cell sheet.
	 * @return {Number}
	 */
	cellCount: function () {
		return this.horizontalCells() * this.verticalCells();
	},

	/**
	 * Gets / sets the number of horizontal cells in the cell sheet.
	 * @param {Number=} val The integer count of the number of horizontal cells in the cell sheet.
	 */
	horizontalCells: function (val) {
		if (val !== undefined) {
			this._cellColumns = val;
			return this;
		}

		return this._cellColumns;
	},

	/**
	 * Gets / sets the number of vertical cells in the cell sheet.
	 * @param {Number=} val The integer count of the number of vertical cells in the cell sheet.
	 */
	verticalCells: function (val) {
		if (val !== undefined) {
			this._cellRows = val;
			return this;
		}

		return this._cellRows;
	},

	/**
	 * Sets the x, y, width and height of each sheet cell and stores
	 * that information in the this._cells array.
	 * @private
	 */
	_applyCells: function () {
		var imgWidth, imgHeight,
			rows, columns,
			cellWidth, cellHeight,
			cellIndex,
			xPos, yPos;

		// Do we have an image to use?
		if (this.image) {
			// Check we have the correct data for a uniform cell layout
			if (this._cellRows && this._cellColumns) {
				imgWidth = this._sizeX;
				imgHeight = this._sizeY;
				rows = this._cellRows;
				columns = this._cellColumns;

				// Store the width and height of a single cell
				cellWidth = this._cellWidth = imgWidth / columns;
				cellHeight = this._cellHeight = imgHeight / rows;

				// Check if the cell width and height are non-floating-point
				if (cellWidth !== parseInt(cellWidth, 10)) {
					this.log('Cell width is a floating-point number! (Image Width ' + imgWidth + ' / Number of Columns ' + columns + ' = ' + cellWidth + ') in file: ' + this._url, 'warning');
				}

				if (cellHeight !== parseInt(cellHeight, 10)) {
					this.log('Cell height is a floating-point number! (Image Height ' + imgHeight + ' / Number of Rows ' + rows + ' = ' + cellHeight + ')  in file: ' + this._url, 'warning');
				}

				// Check if we need to calculate individual cell data
				if (rows > 1 || columns > 1) {
					for (cellIndex = 1; cellIndex <= (rows * columns); cellIndex++) {
						yPos = (Math.ceil(cellIndex / columns) - 1);
						xPos = ((cellIndex - (columns * yPos)) - 1);

						// Store the xy in the sheet frames variable
						this._cells[cellIndex] = [(xPos * cellWidth), (yPos * cellHeight), cellWidth, cellHeight];
					}
				} else {
					// The cell data shows only one cell so just store the whole image data
					this._cells[1] = [0, 0, this._sizeX, this._sizeY];
				}
			}
		}
	},

	/**
	 * Returns a string containing a code fragment that when
	 * evaluated will reproduce this object.
	 * @return {String}
	 */
	stringify: function () {
		var str = "new " + this.classId() + "('" + this.url() + "', " + this.horizontalCells() + ", " + this.verticalCells() + ")";

		// Every object has an ID, assign that first
		// IDs are automatically generated from texture urls
		//str += ".id('" + this.id() + "');";

		return str;
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = IgeTexture; }
/**
 * Creates a new sprite sheet that cuts an image up into
 * arbitrary sections.
 */
var IgeSpriteSheet = IgeTexture.extend({
	classId: 'IgeSpriteSheet',
	IgeSpriteSheet: true,

	init: function (url, cells) {
		this._spriteCells = cells;

		IgeTexture.prototype.init.call(this, url);
	},
	
	_textureLoaded: function () {
		if (this.image) {
			// Store the cell sheet image
			this._sheetImage = this.image;
			var i, cells = this._spriteCells;

			if (!cells) {
				// Try to automatically determine cells
				this.log('No cell data provided for sprite sheet, attempting to automatically detect sprite bounds...');
				cells = this.detectCells(this._sheetImage);
			}

			// Cells in the sheets always start at index
			// 1 so move all the cells one forward
			for (i = 0; i < cells.length; i++) {
				this._cells[i + 1] = cells[i];

				if (this._checkModulus) {
					// Check cell for division by 2 modulus warnings
					if (cells[i][2] % 2) {
						this.log('This texture\'s cell definition defines a cell width is not divisible by 2 which can cause the texture to use sub-pixel rendering resulting in a blurred image. This may also slow down the renderer on some browsers. Image file: ' + this._url, 'warning', cells[i]);
					}

					if (cells[i][3] % 2) {
						this.log('This texture\'s cell definition defines a cell height is not divisible by 2 which can cause the texture to use sub-pixel rendering resulting in a blurred image. This may also slow down the renderer on some browsers. Image file: ' + this._url, 'warning', cells[i]);
					}
				}
			}
		} else {
			// Unable to create cells from non-image texture
			// TODO: Low-priority - Support cell sheets from smart-textures
			this.log('Cannot create cell-sheet because texture has not loaded an image!', 'error');
		}
		
		IgeTexture.prototype._textureLoaded.call(this);
	},

	/**
	 * Uses the sprite sheet image pixel data to detect distinct sprite
	 * bounds.
	 * @param img
	 * @return {Array} An array of cell bounds.
	 */
	detectCells: function (img) {
		// Create a temp canvas
		var canvas = document.createElement('canvas'),
			ctx = canvas.getContext('2d'),
			pixels,
			x, y,
			newRect,
			spriteRects = [];

		canvas.width = img.width;
		canvas.height = img.height;

		// Draw the sheet to the canvas
		ctx.drawImage(img, 0, 0);

		// Read the pixel data
		pixels = ctx.getImageData(0, 0, canvas.width, canvas.height);

		// Loop the pixels and find non-transparent one
		for (y = 0; y < canvas.height; y++) {
			for (x = 0; x < canvas.width; x++) {
				// Check if the pixel is not transparent
				if (!pixels.isTransparent(x, y)) {
					// We found a non-transparent pixel so
					// is it in a rect we have already defined?
					if (!this._pixelInRects(spriteRects, x, y)) {
						// The pixel is not already in a rect,
						// so determine the bounding rect for
						// the new sprite whose pixel we've found
						newRect = this._determineRect(pixels, x, y);

						if (newRect) {
							spriteRects.push(newRect);
						} else {
							this.log('Cannot automatically determine sprite bounds!', 'warning');
							return [];
						}
					}
				}
			}
		}

		return spriteRects;
	},

	_pixelInRects: function (rects, x, y) {
		var rectIndex,
			rectCount = rects.length,
			rect;

		for (rectIndex = 0; rectIndex < rectCount; rectIndex++) {
			rect = rects[rectIndex];

			// Check if the x, y is inside this rect
			if (x >= rect.x && x <= rect.x + rect.width && y >= rect.y && y <= rect.y + rect.height) {
				// The x, y is inside this rect
				return true;
			}
		}

		return false;
	},

	_determineRect: function (pixels, x, y) {
		var pixArr = [{x: x, y: y}],
			rect = {x: x, y: y, width: 1, height: 1},
			currentPixel;

		while (pixArr.length) {
			// De-queue front item
			currentPixel = pixArr.shift();

			// Expand rect to include pixel position
			if (currentPixel.x > rect.x + rect.width) {
				rect.width = currentPixel.x - rect.x + 1;
			}

			if (currentPixel.y > rect.y + rect.height) {
				rect.height = currentPixel.y - rect.y + 1;
			}

			if (currentPixel.x < rect.x) {
				rect.width += rect.x - currentPixel.x;
				rect.x = currentPixel.x;
			}

			if (currentPixel.y < rect.y) {
				rect.height += rect.y - currentPixel.y;
				rect.y = currentPixel.y;
			}

			// Check surrounding pixels
			if (!pixels.isTransparent(currentPixel.x - 1, currentPixel.y - 1)) {
				// Mark pixel so we dont use it again
				pixels.makeTransparent(currentPixel.x - 1, currentPixel.y - 1);

				// Add pixel position to queue
				pixArr.push({x: currentPixel.x - 1, y: currentPixel.y - 1})
			}

			if (!pixels.isTransparent(currentPixel.x, currentPixel.y - 1)) {
				// Mark pixel so we dont use it again
				pixels.makeTransparent(currentPixel.x, currentPixel.y - 1);

				// Add pixel position to queue
				pixArr.push({x: currentPixel.x, y: currentPixel.y - 1})
			}

			if (!pixels.isTransparent(currentPixel.x + 1, currentPixel.y - 1)) {
				// Mark pixel so we dont use it again
				pixels.makeTransparent(currentPixel.x + 1, currentPixel.y - 1);

				// Add pixel position to queue
				pixArr.push({x: currentPixel.x + 1, y: currentPixel.y - 1})
			}

			if (!pixels.isTransparent(currentPixel.x - 1, currentPixel.y)) {
				// Mark pixel so we dont use it again
				pixels.makeTransparent(currentPixel.x - 1, currentPixel.y);

				// Add pixel position to queue
				pixArr.push({x: currentPixel.x - 1, y: currentPixel.y})
			}

			if (!pixels.isTransparent(currentPixel.x + 1, currentPixel.y)) {
				// Mark pixel so we dont use it again
				pixels.makeTransparent(currentPixel.x + 1, currentPixel.y);

				// Add pixel position to queue
				pixArr.push({x: currentPixel.x + 1, y: currentPixel.y})
			}

			if (!pixels.isTransparent(currentPixel.x - 1, currentPixel.y + 1)) {
				// Mark pixel so we dont use it again
				pixels.makeTransparent(currentPixel.x - 1, currentPixel.y + 1);

				// Add pixel position to queue
				pixArr.push({x: currentPixel.x - 1, y: currentPixel.y + 1})
			}

			if (!pixels.isTransparent(currentPixel.x, currentPixel.y + 1)) {
				// Mark pixel so we dont use it again
				pixels.makeTransparent(currentPixel.x, currentPixel.y + 1);

				// Add pixel position to queue
				pixArr.push({x: currentPixel.x, y: currentPixel.y + 1})
			}

			if (!pixels.isTransparent(currentPixel.x + 1, currentPixel.y + 1)) {
				// Mark pixel so we dont use it again
				pixels.makeTransparent(currentPixel.x + 1, currentPixel.y + 1);

				// Add pixel position to queue
				pixArr.push({x: currentPixel.x + 1, y: currentPixel.y + 1})
			}
		}

		return [rect.x, rect.y, rect.width, rect.height];
	},

	/**
	 * Returns the total number of cells in the cell sheet.
	 * @return {Number}
	 */
	cellCount: function () {
		return this._cells.length;
	},

	/**
	 * Returns the cell index that the passed cell id corresponds
	 * to.
	 * @param {String} id
	 * @return {Number} The cell index that the cell id corresponds
	 * to or -1 if a corresponding index could not be found.
	 */
	cellIdToIndex: function (id) {
		var cells = this._cells,
			i;
		for (i = 1; i < cells.length; i++) {
			if (cells[i][4] === id) {
				// Found the cell id so return the index
				return i;
			}
		}

		return -1;
	},

	/**
	 * Returns a string containing a code fragment that when
	 * evaluated will reproduce this object.
	 * @return {String}
	 */
	stringify: function () {
		var str = "new " + this.classId() + "('" + this.url() + "', " + this._cells.toString() + ")";

		// Every object has an ID, assign that first
		// IDs are automatically generated from texture urls
		//str += ".id('" + this.id() + "');";

		return str;
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = IgeSpriteSheet; }
/* TODO: URGENT - Make this alignment stuff work inside the bounds of the entity it is attached to
 * so that bottom-right aligns to the lower-right point of the bounding box of the entity
 * whilst maintaining the current text-alignment as well
* */

/**
 * Creates a new font sheet. A font sheet is an image that contains
 * letters and numbers rendered to specifications. It allows you to
 * use and render text fonts without the font actually existing on
 * the target system that the engine is running in.
 */
var IgeFontSheet = IgeTexture.extend({
	classId: 'IgeFontSheet',

	init: function (url) {
		IgeTexture.prototype.init.call(this, url);

		if (arguments[1]) {
			this.log('Font sheets no longer accept a caching limit value. All font output is now cached by default via the actual font entity - fontEntity.cache(true);', 'warning');
		}

		// Set the _noDimensions flag which tells any entity
		// that assigns this texture that the texture has an
		// unknown width/height so it should not get it's
		// dimension data from the texture
		this._noDimensions = true;

		// Set a listener for when the texture loads
		this.on('loaded', function () {
			if (this.image) {
				// Store the cell sheet image
				this._sheetImage = this.image;

				// Get the font sheet data header
				this._fontData = this.decodeHeader();

				// Cache access to looped data
				this._charCodeMap = this._fontData.characters.charCodes;
				this._charPosMap = this._fontData.characters.charPosition;
				this._measuredWidthMap = this._fontData.characters.measuredWidth;
				this._pixelWidthMap = this._fontData.characters.pixelWidth;

				if (this._fontData) {
					var header = this._fontData.font;
					this.log('Loaded font sheet for font: ' + header.fontName + ' @ ' + header.fontSize + header.fontSizeUnit + ' in ' + header.fontColor);
				} else {
					this.log('Could not load data header for font sheet: ' + this.image.src, 'error');
				}
			}
		});
	},

	decodeHeader: function () {
		// Create a temporary canvas
		var canvas = document.createElement('canvas'),
			ctx = canvas.getContext('2d');

		// Set canvas width to match font sheet image and
		// height to 1 as we have 1 line of header data
		canvas.width = this.image.width;
		canvas.height = 1;

		// Draw the font sheet to the canvas
		ctx.drawImage(this.image, 0, 0);

		// Decode the font sheet pixel-encoded data
		return this._decode(canvas, 0, 0, this.image.width);
	},

	_decode: function (canvas, x, y, maxX) {
		"use strict";
		var ctx = canvas.getContext('2d'),
			imageData = ctx.getImageData(x, y, maxX, canvas.height).data,
			run = true,
			quadCode,
			i = 0,
			jsonString = '';

		while (run) {
			quadCode = String(imageData[i]) + ' ' + String(imageData[i + 1]) + ' ' + String(imageData[i + 2]);
			if (quadCode === '3 2 1') {
				// We have scanned the terminal code
				// so exit the loop
				run = false;
				return JSON.parse(jsonString);
			} else {
				jsonString += String.fromCharCode(imageData[i]) + String.fromCharCode(imageData[i + 1]) + String.fromCharCode(imageData[i + 2]);
			}
			i += 4;

			if (i > imageData.length) {
				run = false;
				console.log('Image JSON Decode Error!');
			}
		}
	},

	lineHeightModifier: function (val) {
		if (typeof(val) !== 'undefined') {
			this._lineHeightModifier = val;
		}
	},

	/**
	 * Returns the width in pixels of the text passed in the
	 * argument.
	 * @param {String} text The text to measure.
	 * @returns {number}
	 */
	measureTextWidth: function (text) {
		if (this._loaded) {
			var characterIndex,
				charCodeMap = this._charCodeMap,
				measuredWidthMap = this._measuredWidthMap,
				charIndex,
				lineArr = [],
				lineIndex,
				measuredWidth,
				maxWidth = 0;
			
			// Handle multi-line text
			if (text.indexOf('\n') > -1) {
				// Split each line into an array item
				lineArr = text.split('\n');
			} else {
				// Store the text as a single line
				lineArr.push(text);
			}

			for (lineIndex = 0; lineIndex < lineArr.length; lineIndex++) {
				// Calculate the total width of the line of text
				measuredWidth = 0;
				for (characterIndex = 0; characterIndex < lineArr[lineIndex].length; characterIndex++) {
					charIndex = charCodeMap[lineArr[lineIndex].charCodeAt(characterIndex)];
					measuredWidth += measuredWidthMap[charIndex] || 0;
				}
				
				if (measuredWidth > maxWidth) {
					maxWidth = measuredWidth;
				}
			}

			// Store the width of this line so we can align it correctly
			return measuredWidth;
		}
		
		return -1;
	},

	render: function (ctx, entity) {
		if (entity._renderText && this._loaded) {
			var _ctx = ctx,
				text = entity._renderText,
				lineText,
				lineArr = [],
				lineIndex,
				characterIndex,
				charCodeMap = this._charCodeMap,
				charPosMap = this._charPosMap,
				measuredWidthMap = this._measuredWidthMap,
				pixelWidthMap = this._pixelWidthMap,
				renderX = 0,
				renderY = 0,
				renderStartX = 0,
				renderStartY = 0,
				masterX = 0,
				masterY = 0,
				lineWidth = [],
				lineHeight = (this._sizeY - 2),
				singleLineWidth = 0,
				totalWidth = 0,
				totalHeight,
				charIndex;

			// Handle multi-line text
			if (text.indexOf('\n') > -1) {
				// Split each line into an array item
				lineArr = text.split('\n');
			} else {
				// Store the text as a single line
				lineArr.push(text);
			}

			totalHeight = (lineHeight * lineArr.length);

			// TODO: Y-based alignment doesn't work at the moment. Fix it!
			// Handle text alignment y
			switch (entity._textAlignY) {
				case 0: // Align top
					renderStartY = -((lineHeight * (lineArr.length)) / 2) - (entity._textLineSpacing * ((lineArr.length - 1) / 2));//0;
				break;

				case 1: // Align middle
					renderStartY = -((lineHeight * (lineArr.length)) / 2) - (entity._textLineSpacing * ((lineArr.length - 1) / 2));
				break;

				case 2: // Align bottom
					renderStartY = -((lineHeight * (lineArr.length)) / 2) - (entity._textLineSpacing * ((lineArr.length - 1) / 2));//-((lineHeight) * (lineArr.length)) - (entity._textLineSpacing * (lineArr.length - 1));
				break;
			}

			// Calculate the total text width of each line
			for (lineIndex = 0; lineIndex < lineArr.length; lineIndex++) {
				lineText = lineArr[lineIndex];
				for (characterIndex = 0; characterIndex < lineText.length; characterIndex++) {
					charIndex = charCodeMap[lineText.charCodeAt(characterIndex)];
					singleLineWidth += measuredWidthMap[charIndex] || 0;
				}

				// Store the width of this line so we can align it correctly
				lineWidth[lineIndex] = singleLineWidth;

				if (singleLineWidth > totalWidth) {
					totalWidth = singleLineWidth;
				}

				singleLineWidth = 0;
			}

			// Handle text cached alignment x
			switch (entity._textAlignX) {
				case 0: // Align left
					renderStartX = -entity._bounds2d.x2;
					break;

				case 1: // Align center
					renderStartX = -totalWidth / 2;
					break;

				case 2: // Align right
					renderStartX = entity._bounds2d.x2 -totalWidth;
					break;
			}

			/*_ctx.strokeStyle = '#ff0000';
			_ctx.strokeRect(renderStartX, renderStartY, totalWidth, totalHeight);*/

			for (lineIndex = 0; lineIndex < lineArr.length; lineIndex++) {
				lineText = lineArr[lineIndex];
				renderY = (lineHeight * lineIndex) + (entity._textLineSpacing * (lineIndex));

				// Handle text alignment x
				switch (entity._textAlignX) {
					case 0: // Align left
						renderX = -entity._bounds2d.x2;
					break;

					case 1: // Align center
						renderX = -lineWidth[lineIndex] / 2;
					break;

					case 2: // Align right
						renderX = entity._bounds2d.x2 -lineWidth[lineIndex];
					break;
				}

				for (characterIndex = 0; characterIndex < lineText.length; characterIndex++) {
					charIndex = charCodeMap[lineText.charCodeAt(characterIndex)];

					_ctx.drawImage(
						this.image,
						charPosMap[charIndex], // texture x
						2, // texture y
						pixelWidthMap[charIndex], // texture width
						this._sizeY - 2, // texture height
						Math.floor(masterX + renderX), // render x TODO: Performance - Cache these?
						Math.floor(masterY + renderStartY + renderY), // render y
						pixelWidthMap[charIndex], // render width
						(this._sizeY - 2) // render height
					);

					// Check if we should overlay with a colour
					if (entity._colorOverlay) {
						_ctx.save();
						// Set the composite operation and draw the colour over the top
						_ctx.globalCompositeOperation = 'source-atop';

						_ctx.fillStyle = entity._colorOverlay;
						_ctx.fillRect(
							Math.floor(masterX + renderX), // render x TODO: Performance - Cache these?
							Math.floor(masterY + renderStartY + renderY), // render y
							pixelWidthMap[charIndex], // render width
							(this._sizeY - 2) // render height
						);
						_ctx.restore();
					}

					renderX += measuredWidthMap[charIndex] || 0;

					ige._drawCount++;
				}

				renderX = 0;
			}
		}
	},

	destroy: function () {
		this.image = null;
		this.script = null;
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = IgeFontSheet; }
/**
 * Provides native canvas font rendering supporting multi-line
 * text and alignment options.
 */
var IgeFontSmartTexture = {
	measureTextWidth: function (text, entity) {
		if (entity._nativeFont) {
			var lineArr = [],
				lineIndex,
				measuredWidth,
				maxWidth = 0,
				canvas = document.createElement('canvas'),
				ctx = canvas.getContext('2d');
			
			// Handle multi-line text
			if (text.indexOf('\n') > -1) {
				// Split each line into an array item
				lineArr = text.split('\n');
			} else {
				// Store the text as a single line
				lineArr.push(text);
			}

			ctx.font = entity._nativeFont;
			ctx.textBaseline = 'middle';

			if (entity._nativeStroke) {
				ctx.lineWidth = entity._nativeStroke;

				if (entity._nativeStrokeColor) {
					ctx.strokeStyle = entity._nativeStrokeColor;
				} else {
					ctx.strokeStyle = entity._colorOverlay;
				}
			}
			
			for (lineIndex = 0; lineIndex < lineArr.length; lineIndex++) {
				// Measure text
				measuredWidth = ctx.measureText(lineArr[lineIndex]).width;
				
				if (measuredWidth > maxWidth) {
					maxWidth = measuredWidth;
				}
			}
			
			return maxWidth;
		}
		
		return -1;
	},
	
	render: function (ctx, entity) {
		if (entity._nativeFont && entity._renderText) {
			var text = entity._renderText,
				lineArr = [],
				textSize,
				renderStartY,
				renderY,
				lineHeight,
				i;

			ctx.font = entity._nativeFont;

			if (entity._colorOverlay) {
				ctx.fillStyle = entity._colorOverlay;
			}

			// Text alignment
			if (entity._textAlignX === 0) {
				ctx.textAlign = 'left';
				ctx.translate(-entity._bounds2d.x2, 0);
			}

			if (entity._textAlignX === 1) {
				ctx.textAlign = 'center';
				//ctx.translate(-entity._bounds2d.x2, 0);
			}

			if (entity._textAlignX === 2) {
				ctx.textAlign = 'right';
				ctx.translate(entity._bounds2d.x2, 0);
			}

			if (entity._nativeStroke) {
				ctx.lineWidth = entity._nativeStroke;

				if (entity._nativeStrokeColor) {
					ctx.strokeStyle = entity._nativeStrokeColor;
				} else {
					ctx.strokeStyle = entity._colorOverlay;
				}
			}

			// Handle multi-line text
			if (text.indexOf('\n') > -1) {
				// Split each line into an array item
				lineArr = text.split('\n');
			} else {
				// Store the text as a single line
				lineArr.push(text);
			}

			// vertical text alignment
			if (entity._textAlignY === 0) {
				ctx.textBaseline = 'top';
				renderStartY = -(entity._bounds2d.y / 2);
			}
			if (entity._textAlignY === 1) {
				ctx.textBaseline = 'middle';
				renderStartY = -(entity._textLineSpacing / 2) * (lineArr.length - 1);
			}
			if (entity._textAlignY === 2) {
				ctx.textBaseline = 'bottom';
				renderStartY = entity._bounds2d.y / 2 - entity._textLineSpacing * (lineArr.length - 1);
			}
			// Justified - lines spaced out evenly according to height
			if (entity._textAlignY === 3) {
				ctx.textBaseline = 'middle';
				lineHeight = Math.floor(entity._bounds2d.y / lineArr.length);
				renderStartY = -((lineHeight + (entity._textLineSpacing)) / 2) * (lineArr.length - 1);
			}

			for (i = 0; i < lineArr.length; i++) {
				if (entity._textAlignY === 3) {
					renderY = renderStartY + (lineHeight * i) + (entity._textLineSpacing * (i));
				} else {
					renderY = renderStartY + entity._textLineSpacing * i;
				}

				// Measure text
				textSize = ctx.measureText(lineArr[i]);

				// Check if we should stroke the text too
				if (entity._nativeStroke) {
					ctx.strokeText(lineArr[i], 0, renderY);
				}

				// Draw text
				ctx.fillText(lineArr[i], 0, renderY);
			}
		}
	}
};
/**
 * Creates a new object.
 */
var IgeObject = IgeEventingClass.extend({
	classId: 'IgeObject',

	init: function () {
		this._newBorn = true;
		this._alive = true;
		this._mode = 0;
		this._mountMode = 0;
		this._parent = null;
		this._children = [];
		this._layer = 0;
		this._depth = 0;
		this._depthSortMode = 0;
		this._timeStream = [];
		this._inView = true;
		this._managed = 1;
		
		this._specialProp = [
			'_id',
			'_parent',
			'_children'
		];
	},

	/**
	 * Determines if the object is alive or not. The alive
	 * value is automatically set to false when the object's
	 * destroy() method is called. Useful for checking if
	 * an object that you are holding a reference to has been
	 * destroyed.
	 * @param {Boolean=} val The value to set the alive flag
	 * to.
	 * @example #Get the alive flag value
	 *     var entity = new IgeEntity();
	 *     console.log(entity.alive());
	 * @example #Set the alive flag value
	 *     var entity = new IgeEntity();
	 *     entity.alive(true);
	 * @return {*}
	 */
	alive: function (val) {
		if (val !== undefined) {
			this._alive = val;
			return this;
		}

		return this._alive;
	},

	/**
	 * Gets / set the managed mode from 0 to 2. 0 = off, 1 = static, 2 = dynamic.
	 * 
	 * @param {Number=} val Set to 0 to switch off managed mode, 1 to set to static
	 * managed mode or 2 to dynamic managed mode. When in a managed mode and when
	 * the parent of this entity has an entity manager component enabled, the entity
	 * will be checked to see if it is inside the visible area of a viewport. If it
	 * is deemed not to be in a visible area (via it's AABB non-intersection with
	 * viewport view area) then it will either be un-mounted from the parent (mode 1)
	 * or marked as no longer in view (mode 2). Mode 2 in view = false will cause the
	 * entity to no longer be depth-sorted or rendered but will still have it's
	 * update() method called each frame allowing logic processing to occur as normal.
	 * The default managed mode is 1.
	 * @returns {*}
	 */
	managed: function (val) {
		if (val !== undefined) {
			this._managed = val;
			return this;
		}
		
		return this._managed;
	},

	/**
	 * Gets / sets the current object id. If no id is currently assigned and no
	 * id is passed to the method, it will automatically generate and assign a
	 * new id as a 16 character hexadecimal value typed as a string.
	 * @param {String=} id
	 * @example #Get the id of an entity
	 *     var entity = new IgeEntity();
	 *     console.log(entity.id());
	 * @example #Set the id of an entity
	 *     var entity = new IgeEntity();
	 *     entity.id('myNewId');
	 * @example #Set the id of an entity via chaining
	 *     var entity = new IgeEntity()
	 *         .id('myNewId');
	 * @return {*} Returns this when setting the value or the current value if none is specified.
	 */
	id: function (id) {
		if (id !== undefined) {
			// Check if we're changing the id
			if (id !== this._id) {
				// Check if this ID already exists in the object register
				if (ige._register[id]) {
					// Already an object with this ID!
					if (ige._register[id] !== this) {
						this.log('Cannot set ID of object to "' + id + '" because that ID is already in use by another object!', 'error');
					}
				} else {
					// Check if we already have an id assigned
					if (this._id && ige._register[this._id]) {
						// Unregister the old ID before setting this new one
						ige.unRegister(this);
					}

					this._id = id;

					// Now register this object with the object register
					ige.register(this);

					return this;
				}
			} else {
				// The same ID we already have is being applied,
				// ignore the request and return
				return this;
			}
		}

		if (!this._id) {
			// The item has no id so generate one automatically
			this._id = ige.newIdHex();
			ige.register(this);
		}

		return this._id;
	},

	/**
	 * Gets / sets the arbitrary category name that the object belongs to.
	 * @param {String=} val
	 * @example #Get the category of an entity
	 *     var entity = new IgeEntity();
	 *     console.log(entity.category());
	 * @example #Set the category of an entity
	 *     var entity = new IgeEntity();
	 *     entity.category('myNewCategory');
	 * @example #Set the category of an entity via chaining
	 *     var entity = new IgeEntity()
	 *         .category('myNewCategory');
	 * @example #Get all the entities belonging to a category
	 *     var entityArray = ige.$$('categoryName');
	 * @example #Remove the category of an entity
	 *     // Set category to some name
	 *     var entity = new IgeEntity()
	 *         .category('myCategory');
	 *         
	 *     // Will output "myCategory"
	 *     console.log(entity.category());
	 *     
	 *     // Now remove the category
	 *     entity.category('');
	 *     
	 *     // Will return ""
	 *     console.log(entity.category());
	 * @return {*}
	 */
	category: function (val) {
		if (val !== undefined) {
			// Check if we already have a category
			if (this._category) {
				// Check if the category being assigned is different from
				// the current one
				if (this._category !== val) {
					// The category is different so remove this object
					// from the current category association
					ige.categoryUnRegister(this);
				}
			}
			
			this._category = val;

			// Check the category is not a blank string
			if (val) {
				// Now register this object with the category it has been assigned
				ige.categoryRegister(this);
			}
			return this;
		}

		return this._category;
	},

	/**
	 * DEPRECIATED - Use category() instead. A warning method to
	 * help developers move to the new groups system.
	 */
	group: function () {
		this.log('The group() method has been renamed to category(). Please update your code.', 'error');
	},

	/**
	 * Adds this entity to a group or groups passed as
	 * arguments.
	 * @param {*} groupName A group or array of group names
	 * to add the entity to.
	 * @example #Add entity to a single group
	 *     var entity = new IgeEntity();
	 *     entity.addGroup('g1');
	 * @example #Add entity to multiple groups
	 *     var entity = new IgeEntity();
	 *     entity.addGroup('g1', 'g2', 'g3');
	 * @example #Add entity to multiple groups via an array
	 *     var entity = new IgeEntity();
	 *     entity.addGroup(['g1', 'g2', 'g3']);
	 * @example #Add entity to multiple groups via multiple arrays
	 *     var entity = new IgeEntity();
	 *     entity.addGroup(['g1', 'g2', 'g3'], ['g4', 'g5']);
	 * @return {*}
	 */
	addGroup: function () {
		var arrCount = arguments.length,
			groupName,
			groupItemCount;

		while (arrCount--) {
			groupName = arguments[arrCount];
			
			// Check if the argument is an array
			if (groupName instanceof Array) {
				groupItemCount = groupName.length;
				
				// Add each group of the array to the entity
				while (groupItemCount--) {
					if (!this._groups || this._groups.indexOf(groupName[groupItemCount]) === -1) {
						this._groups = this._groups || [];
						this._groups.push(groupName[groupItemCount]);

						// Now register this object with the group it has been assigned
						ige.groupRegister(this, groupName[groupItemCount]);
					}
				}
			} else {
				if (!this._groups || this._groups.indexOf(groupName) === -1) {
					this._groups = this._groups || [];
					this._groups.push(groupName);
	
					// Now register this object with the group it has been assigned
					ige.groupRegister(this, groupName);
				}
			}
		}

		return this;
	},

	/**
	 * Checks if the entity is in the group or array of group
	 * names passed.
	 * @param {*} groupName A group name or array of names.
	 * @param {Boolean=} matchAllGroups If set to true, will cause
	 * the method to check if the entity is in ALL the groups,
	 * otherwise the method will check if the entity is in ANY group.
	 * @example #Check if the entity is in a group
	 *     var entity = new IgeEntity();
	 *     entity.addGroup('g1', 'g2');
	 *	
	 *     // Will output true since entity is part of g1 group
	 *     console.log(entity.inGroup('g1', false);
	 *	
	 *     // Will output false since entity is not part of g3 group
	 *     console.log(entity.inGroup('g3', false);
	 * @example #Check if the entity is in an array of groups using ANY and ALL options
	 *     var entity = new IgeEntity();
	 *     entity.addGroup('g1', 'g2');
	 *     
	 *     // Will output true since entity is part of g1 group
	 *     console.log(entity.inGroup(['g1, 'g3'], false);
	 *     
	 *     // Will output false since entity is not part of g3 group
	 *     console.log(entity.inGroup(['g1, 'g3'], true);
	 * @return {Boolean}
	 */
	inGroup: function (groupName, matchAllGroups) {
		if (groupName) {
			if (matchAllGroups) {
				return this.inAllGroups(groupName);
			} else {
				return this.inAnyGroup(groupName);
			}
		}
		
		return false;
	},

	/**
	 * Checks if the entity is in the specified group or
	 * array of groups. If multiple group names are passed,
	 * as an array the method will only return true if the
	 * entity is in ALL the passed groups.
	 * @param {*} groupName The name of the group or array
	 * if group names to check if this entity is a member of.
	 * @example #Check if entity belongs to all of the passed groups
	 *     // Add a couple of groups
	 *     var entity = new IgeEntity();
	 *     entity.addGroup(['g1', 'g2']);
	 *	
	 *     // This will output "false" (entity is not part of g3)
	 *     console.log(entity.inAllGroups(['g1', 'g3']));
	 *	
	 *     // This will output "true"
	 *     console.log(entity.inAllGroups('g1'));
	 *	
	 *     // This will output "true"
	 *     console.log(entity.inAllGroups(['g1', 'g2']));
	 * @return {Boolean}
	 */
	inAllGroups: function (groupName) {
		var arrItem, arrCount;
		
		if (groupName instanceof Array) {
			arrCount = groupName.length;
			
			while (arrCount--) {
				arrItem = groupName[arrCount];
			
				if (arrItem) {
					if (!this._groups || this._groups.indexOf(arrItem) === -1) {
						return false;
					}
				}
			}
		} else {
			return !(!this._groups || this._groups.indexOf(groupName) === -1);
		}

		return true;
	},

	/**
	 * Checks if the entity is in the specified group or
	 * array of group names. If multiple group names are passed
	 * as an array, the method will return true if the entity
	 * is in ANY of the the passed groups.
	 * @param {*} groupName The name of the group or array of
	 * group names to check if this entity is a member of.
	 * @example #Check if entity belongs to any of the passed groups
	 *     // Add a couple of groups
	 *     var entity = new IgeEntity();
	 *     entity.addGroup('g1', 'g2');
	 *	
	 *     // This will output "false"
	 *     console.log(entity.inAnyGroup('g3'));
	 *	
	 *     // This will output "true"
	 *     console.log(entity.inAnyGroup(['g3', 'g1']));
	 * @return {Boolean}
	 */
	inAnyGroup: function (groupName) {
		var arrItem, arrCount;

		if (groupName instanceof Array) {
			arrCount = groupName.length;

			while (arrCount--) {
				arrItem = groupName[arrCount];

				if (arrItem) {
					if (this._groups && this._groups.indexOf(arrItem) > -1) {
						return true;
					}
				}
			}
		} else {
			return (this._groups && this._groups.indexOf(groupName) > -1);
		}

		return false;
	},

	/**
	 * Gets an array of all groups this entity belongs to.
	 * @example #Get array of groups entity belongs to
	 *     var entity = new IgeEntity();
	 *     entity.addGroup('g1', 'g2');
	 *	
	 *     // This will output "['g1', 'g2']"
	 *     console.log(entity.groups());
	 * @return {*}
	 */
	groups: function () {
		return this._groups || [];
	},

	/**
	 * Gets the number of groups this entity belongs to.
	 * @example #Get number of groups entity belongs to
	 *     var entity = new IgeEntity();
	 *     entity.addGroup('g1', 'g2');
	 *	
	 *     // This will output "2"
	 *     console.log(entity.groupCount());
	 * @return {Number}
	 */
	groupCount: function () {
		return this._groups ? this._groups.length : 0;
	},

	/**
	 * Removes the entity from the group or groups passed. This
	 * method accepts multiple arguments and will remove the entity
	 * from all groups passed as arguments.
	 * @param {*} groupName The name of the group or array of group
	 * names to remove this entity as a member of.
	 * @example #Remove entity from single group
	 *     var entity = new IgeEntity();
	 *     entity.addGroup('g1', 'g2');
	 *	
	 *     // This will output "['g1', 'g2']"
	 *     console.log(entity.groups());
	 *	
	 *     // Remove entity from a single group
	 *     entity.removeGroup('g1');
	 *	
	 *     // This will output "['g2']"
	 *     console.log(entity.groups());
	 * @example #Remove entity from multiple groups
	 *     var entity = new IgeEntity();
	 *     entity.addGroup('g1', 'g3', 'g2');
	 *	
	 *     // This will output "['g1', 'g3', 'g2']"
	 *     console.log(entity.groups());
	 *	
	 *     // Remove entity from multiple groups
	 *     entity.removeGroup('g1', 'g3');
	 *	
	 *     // This will output "['g2']"
	 *     console.log(entity.groups());
	 * @example #Remove entity from multiple groups via an array
	 *     var entity = new IgeEntity();
	 *     entity.addGroup('g1', 'g3', 'g2');
	 *	
	 *     // This will output "['g1', 'g3', 'g2']"
	 *     console.log(entity.groups());
	 *	
	 *     // Remove entity from multiple groups
	 *     entity.removeGroup(['g1', 'g3']);
	 *	
	 *     // This will output "['g2']"
	 *     console.log(entity.groups());
	 * @example #Remove entity from multiple groups via multiple arrays
	 *     var entity = new IgeEntity();
	 *     entity.addGroup('g1', 'g2', 'g3', 'g4', 'g5', 'g6', 'g7');
	 *	
	 *     // This will output "['g1', 'g2', 'g3', 'g4', 'g5', 'g6', 'g7']"
	 *     console.log(entity.groups());
	 *	
	 *     // Remove entity from multiple groups
	 *     entity.removeGroup(['g1', 'g3'], ['g5', 'g6', 'g7']);
	 *	
	 *     // This will output "['g2', 'g4']"
	 *     console.log(entity.groups());
	 * @return {*}
	 */
	removeGroup: function () {
		if (this._groups) {
			var arrCount = arguments.length,
				groupName,
				groupNameCount;

			while (arrCount--) {
				groupName = arguments[arrCount];
				
				if (groupName instanceof Array) {
					groupNameCount = groupName.length;
					
					while (groupNameCount--) {
						this._groups.pull(groupName[groupNameCount]);

						// Now un-register this object with the group it has been assigned
						ige.groupUnRegister(this, groupName[groupNameCount]);
					}
				} else {
					this._groups.pull(groupName);
	
					// Now un-register this object with the group it has been assigned
					ige.groupUnRegister(this, groupName);
				}
			}
		}

		return this;
	},

	/**
	 * Removes the entity from all groups it is a member of.
	 * @example #Remove entity from all groups
	 *     var entity = new IgeEntity();
	 *     entity.addGroup('g1', 'g3', 'g2');
	 *	
	 *     // This will output "['g1', 'g3', 'g2']"
	 *     console.log(entity.groups());
	 *	
	 *     // Remove all the groups
	 *     entity.removeAllGroups();
	 *	
	 *     // This will output "[]"
	 *     console.log(entity.groups());
	 * @return {*}
	 */
	removeAllGroups: function () {
		if (this._groups) {
			// Loop through all groups and un-register one at a time
			var arr = this._groups,
				arrCount = arr.length;

			while (arrCount--) {
				ige.groupUnRegister(this, arr[arrCount]);
			}

			delete this._groups;
		}
		return this;
	},

	/**
	 * Adds a behaviour to the object's active behaviour list.
	 * @param {String} id
	 * @param {Function} behaviour
	 * @param {Boolean=} duringTick If true, will execute the behaviour
	 * during the tick() method instead of the update() method.
	 * @example #Add a behaviour with the id "myBehaviour"
	 *     var entity = new IgeEntity();
	 *     entity.addBehaviour('myBehaviour', function () {
	 *         // Code here will execute during each engine update for
	 *         // this entity. I can access the entity via the "this"
	 *         // keyword such as:
	 *         this._somePropertyOfTheEntity = 'moo';
	 *     });
	 *     
	 *     // Now since each update we are setting _somePropertyOfTheEntity
	 *     // to equal "moo" we can console log the property and get
	 *     // the value as "moo"
	 *     console.log(entity._somePropertyOfTheEntity);
	 * @return {*} Returns this on success or false on failure.
	 */
	addBehaviour: function (id, behaviour, duringTick) {
		if (typeof(id) === 'string') {
			if (typeof(behaviour) === 'function') {
				if (duringTick) {
					this._tickBehaviours = this._tickBehaviours || [];
					this._tickBehaviours.push({
						id:id,
						method: behaviour
					});
				} else {
					this._updateBehaviours = this._updateBehaviours || [];
					this._updateBehaviours.push({
						id:id,
						method: behaviour
					});	
				}

				return this;
			} else {
				this.log('The behaviour you passed is not a function! The second parameter of the call must be a function!', 'error');
			}
		} else {
			this.log('Cannot add behaviour to object because the specified behaviour id is not a string. You must provide two parameters with the addBehaviour() call, an id:String and a behaviour:Function. Adding a behaviour with an id allows you to remove it by it\'s id at a later stage!', 'error');
		}

		return false;
	},

	/**
	 * Removes a behaviour to the object's active behaviour list by it's id.
	 * @param {String} id
	 * @param {Boolean=} duringTick If true will look to remove the behaviour
	 * from the tick method rather than the update method.
	 * @example #Remove a behaviour with the id "myBehaviour"
	 *     var entity = new IgeEntity();
	 *     entity.addBehaviour('myBehaviour', function () {
	 *         // Code here will execute during each engine update for
	 *         // this entity. I can access the entity via the "this"
	 *         // keyword such as:
	 *         this._somePropertyOfTheEntity = 'moo';
	 *     });
	 *     
	 *     // Now remove the "myBehaviour" behaviour
	 *     entity.removeBehaviour('myBehaviour');
	 * @return {*} Returns this on success or false on failure.
	 */
	removeBehaviour: function (id, duringTick) {
		if (id !== undefined) {
			var arr,
				arrCount;
			
			if (duringTick) {
				arr = this._tickBehaviours;
			} else {
				arr = this._updateBehaviours;
			}

			// Find the behaviour
			if (arr) {
				arrCount = arr.length;

				while (arrCount--) {
					if (arr[arrCount].id === id) {
						// Remove the item from the array
						arr.splice(arrCount, 1);
						return this;
					}
				}
			}
		}

		return false;
	},

	/**
	 * Checks if the object has the specified behaviour already added to it.
	 * @param {String} id
	 * @param {Boolean=} duringTick If true will look to remove the behaviour
	 * from the tick method rather than the update method.
	 * @example #Check for a behaviour with the id "myBehaviour"
	 *     var entity = new IgeEntity();
	 *     entity.addBehaviour('myBehaviour', function () {
	 *         // Code here will execute during each engine update for
	 *         // this entity. I can access the entity via the "this"
	 *         // keyword such as:
	 *         this._somePropertyOfTheEntity = 'moo';
	 *     });
	 *     
	 *     // Now check for the "myBehaviour" behaviour
	 *     console.log(entity.hasBehaviour('myBehaviour')); // Will log "true"
	 * @return {*} Returns this on success or false on failure.
	 */
	hasBehaviour: function (id, duringTick) {
		if (id !== undefined) {
			var arr,
				arrCount;
			
			if (duringTick) {
				arr = this._tickBehaviours;
			} else {
				arr = this._updateBehaviours;
			}

			// Find the behaviour
			if (arr) {
				arrCount = arr.length;

				while (arrCount--) {
					if (arr[arrCount].id === id) {
						return true;
					}
				}
			}
		}

		return false;
	},
	
	/**
	 * Gets / sets the boolean flag determining if this object should have
	 * it's bounds drawn when the bounds for all objects are being drawn.
	 * In order for bounds to be drawn the viewport the object is being drawn
	 * to must also have draw bounds enabled.
	 * @param {Boolean} val
	 * @example #Enable draw bounds
	 *     var entity = new IgeEntity();
	 *     entity.drawBounds(true);
	 * @example #Disable draw bounds
	 *     var entity = new IgeEntity();
	 *     entity.drawBounds(false);
	 * @example #Get the current flag value
	 *     console.log(entity.drawBounds());
	 * @return {*}
	 */
	drawBounds: function (val) {
		if (val !== undefined) {
			this._drawBounds = val;
			return this;
		}

		return this._drawBounds;
	},

	/**
	 * Gets / sets the boolean flag determining if this object should have
	 * it's bounds data drawn when the bounds for all objects are being drawn.
	 * Bounds data includes the object ID and it's current depth etc.
	 * @param {Boolean} val
	 * @example #Enable draw bounds data
	 *     var entity = new IgeEntity();
	 *     entity.drawBoundsData(true);
	 * @example #Disable draw bounds data
	 *     var entity = new IgeEntity();
	 *     entity.drawBoundsData(false);
	 * @example #Get the current flag value
	 *     console.log(entity.drawBoundsData());
	 * @return {*}
	 */
	drawBoundsData: function (val) {
		if (val !== undefined) {
			this._drawBoundsData = val;
			return this;
		}

		return this._drawBoundsData;
	},

	/**
	 * Gets / sets the boolean flag determining if this object should have
	 * it's mouse position drawn, usually for debug purposes.
	 * @param {Boolean=} val
	 * @example #Enable draw mouse position data
	 *     var entity = new IgeEntity();
	 *     entity.drawMouse(true);
	 * @example #Disable draw mouse position data
	 *     var entity = new IgeEntity();
	 *     entity.drawMouse(false);
	 * @example #Get the current flag value
	 *     console.log(entity.drawMouse());
	 * @return {*}
	 */
	drawMouse: function (val) {
		if (val !== undefined) {
			this._drawMouse = val;
			return this;
		}

		return this._drawMouse;
	},
	
	/**
	 * Gets / sets the boolean flag determining if this object should have
	 * it's extra mouse data drawn for debug purposes. For instance, on tilemaps
	 * (IgeTileMap2d) instances, when enabled you will see the tile x and y
	 * co-ordinates currently being hoverered over by the mouse.
	 * @param {Boolean=} val
	 * @example #Enable draw mouse data
	 *     var entity = new IgeEntity();
	 *     entity.drawMouseData(true);
	 * @example #Disable draw mouse data
	 *     var entity = new IgeEntity();
	 *     entity.drawMouseData(false);
	 * @example #Get the current flag value
	 *     console.log(entity.drawMouseData());
	 * @return {*}
	 */
	drawMouseData: function (val) {
		if (val !== undefined) {
			this._drawMouseData = val;
			return this;
		}

		return this._drawMouseData;
	},

	/**
	 * Finds a child entity that matches the id mounted to this
	 * or any other child entity down the scenegraph chain. Will
	 * only return an object if the entity found has this entity
	 * as an ancestor (parent or parent of parent etc).
	 * @param {String} id The id of the entity to find.
	 * @returns {*} The entity or undefined.
	 */
	$: function (id) {
		var obj = ige.$(id);
		
		if (obj._parent === this) {
			// We found a child and it's parent is this object so return it
			return obj;
		} else {
			// Scan up the object's parent chain to see if this object is
			// an ancestor at some point
			var ancestor = obj.parent(this.id());
			
			if (ancestor) {
				return obj;
			} else {
				return undefined;
			}
		}
	},

	/**
	 * Finds all child entities of this or any child of this entity
	 * down the scenegraph who's category matches the category name
	 * passed.
	 * @param {String} categoryName The category name to scan for.
	 * @returns {Array}
	 */
	$$: function (categoryName) {
		var objArr = ige.$$(categoryName),
			arrCount = objArr.length,
			obj,
			finalArr = [],
			thisId = this.id();
			
		// Scan all objects that have the specified category
		// and see if we are it's parent or an ancestor
		while (arrCount--) {
			obj = objArr[arrCount];
			if (obj._parent === this || obj.parent(thisId)) {
				finalArr.push(obj);
			}
		}
		
		return finalArr;
	},

	/**
	 * Returns the object's parent object (the object that
	 * it is mounted to).
	 * @param {String=} id Optional, if present will scan up
	 * the parent chain until a parent with the matching id is
	 * found. If none is found, returns undefined.
	 * @example #Get the object parent
	 *     // Create a couple of entities and give them ids
	 *     var entity1 = new IgeEntity().id('entity1'),
	 *         entity2 = new IgeEntity().id('entity2');
	 *     
	 *     // Mount entity2 to entity1
	 *     entity2.mount(entity1);
	 *     
	 *     // Get the parent of entity2 (which is entity1)
	 *     var parent = entity2.parent();
	 *     
	 *     // Log the parent's id (will output "entity1")
	 *     console.log(parent.id());
	 * @return {*}
	 */
	parent: function (id) {
		if (!id) {
			return this._parent;
		}
		
		if (this._parent) {
			if (this._parent.id() === id) {
				return this._parent;
			} else {
				return this._parent.parent(id);
			}
		}
		
		return undefined;
	},

	/**
	 * Returns the object's children as an array of objects.
	 * @example #Get the child objects array
	 *     // Create a couple of entities and give them ids
	 *     var entity1 = new IgeEntity().id('entity1'),
	 *         entity2 = new IgeEntity().id('entity2');
	 *	
	 *     // Mount entity2 to entity1
	 *     entity2.mount(entity1);
	 *	
	 *     // Get the chilren array entity1
	 *     var childArray = entity1.children();
	 *	
	 *     // Log the child array contents (will contain entity2)
	 *     console.log(childArray);
	 * @return {Array} The array of child objects.
	 */
	children: function () {
		return this._children;
	},

	/**
	 * Mounts this object to the passed object in the scenegraph.
	 * @param {IgeObject} obj
	 * @example #Mount an entity to another entity
	 *     // Create a couple of entities and give them ids
	 *     var entity1 = new IgeEntity().id('entity1'),
	 *         entity2 = new IgeEntity().id('entity2');
	 *	
	 *     // Mount entity2 to entity1
	 *     entity2.mount(entity1);
	 * @return {*} Returns this on success or false on failure.
	 */
	mount: function (obj) {
		if (obj) {
			if (obj === this) {
				this.log('Cannot mount an object to itself!', 'error');
				return this;
			}
			
			if (obj._children) {
				// Check that the engine will allow us to register this object
				this.id(); // Generates a new id if none is currently set, and registers it on the object register!

				if (this._parent) {
					if (this._parent === obj) {
						// We are already mounted to the parent!
						return this;
					} else {
						// We are already mounted to a different parent
						this.unMount();
					}
				}

				this._parent = obj;
				
				// Check if we need to set the ignore camera flag
				if (!this._ignoreCamera && this._parent._ignoreCamera) {
					this._ignoreCamera = this._parent._ignoreCamera;
					
					/*if (this.ignoreCameraComposite) {
						this.ignoreCameraComposite(this._parent._ignoreCamera);
					}*/
				}
				
				// Make sure we keep the child's room id in sync with it's parent
				if (this._parent._streamRoomId) {
					this._streamRoomId = this._parent._streamRoomId;
				}
				
				obj._children.push(this);
				this._parent._childMounted(this);

				if (obj.updateTransform) {
					obj.updateTransform();
					obj.aabb(true);
				}
				
				if (obj._compositeCache) {
					this._compositeParent = true;
				} else {
					delete this._compositeParent;
				}
				
				this._mounted(this._parent);

				this.emit('mounted', this._parent);

				return this;
			} else {
				// The object has no _children array!
				this.log('Cannot mount object because it has no _children array! If you are mounting to a custom class, ensure that you have called the prototype.init() method of your super-class during the init of your custom class.', 'warning');
				return false;
			}
		} else {
			this.log('Cannot mount non-existent object!', 'error');
		}
	},

	/**
	 * Unmounts this object from it's parent object in the scenegraph.
	 * @example #Unmount an entity from another entity
	 *     // Create a couple of entities and give them ids
	 *     var entity1 = new IgeEntity().id('entity1'),
	 *         entity2 = new IgeEntity().id('entity2');
	 *	
	 *     // Mount entity2 to entity1
	 *     entity2.mount(entity1);
	 *     
	 *     // Now unmount entity2 from entity1
	 *     entity2.unMount();
	 * @return {*} Returns this on success or false on failure.
	 */
	unMount: function () {
		if (this._parent) {
			var childArr = this._parent._children,
				index = childArr.indexOf(this),
				oldParent = this._parent;

			if (index > -1) {
				// Found this in the parent._children array so remove it
				childArr.splice(index, 1);

				this._parent._childUnMounted(this);
				this._parent = null;
				
				this._unMounted(oldParent);

				return this;
			} else {
				// Cannot find this in the parent._children array
				return false;
			}
		} else {
			return false;
		}
	},
	
	/**
	 * Determines if the object has a parent up the scenegraph whose
	 * id matches the one passed. Will traverse each parent object
	 * checking if the id matches. This information will be cached when
	 * first called and can be refreshed by setting the "fresh" parameter
	 * to true.
	 * @param {String} parentId The id of the parent to check for.
	 * @param {Boolean=} fresh If true will force a full check instead of
	 * using the cached value from an earlier check.
	 */
	hasParent: function (parentId, fresh) {
		var bool = false;
		
		// Check for a cached value
		if (!fresh && this._hasParent && this._hasParent[parentId] !== undefined) {
			return this._hasParent[parentId];
		}
		
		if (this._parent) {
			if (this._parent.id() === parentId) {
				bool = true;
			} else {
				bool = this._parent.hasParent(parentId, fresh);
			}
		}
		
		this._hasParent = this._hasParent || {};
		this._hasParent[parentId] = bool;
		
		return bool;
	},

	/**
	 * Clones the object and all it's children and returns a new object.
	 */
	clone: function (options) {
		// Make sure we have an options object
		if (options === undefined) { options = {}; }
		
		// Set some default option values
		if (options.id === undefined) { options.id = false; }
		if (options.mount === undefined) { options.mount = false; }
		if (options.transform === undefined) { options.transform = true; }
		
		// Loop all children and clone them, then return cloned version of ourselves
		var newObject = eval(this.stringify(options));
		
		return newObject;
	},

	/**
	 * Gets / sets the positioning mode of the entity.
	 * @param {Number=} val 0 = 2d, 1 = isometric
	 * @example #Set the positioning mode to 2d
	 *     var entity = new IgeEntity()
	 *         .mode(0);
	 * @example #Set the positioning mode to isometric
	 *     var entity = new IgeEntity()
	 *         .mode(1);
	 * @return {*}
	 */
	mode: function (val) {
		if (val !== undefined) {
			this._mode = val;
			return this;
		}

		return this._mode;
	},

	/**
	 * Gets / sets if this object should be positioned isometrically
	 * or in 2d.
	 * @param {Boolean} val Set to true to position this object in
	 * isometric space or false to position it in 2d space.
	 * @example #Set the positioning mode to isometric
	 *     var entity = new IgeEntity()
	 *         .isometric(true);
	 * @example #Set the positioning mode to 2d
	 *     var entity = new IgeEntity()
	 *         .isometric(false);
	 * @return {*}
	 */
	isometric: function (val) {
		if (val === true) {
			this._mode = 1;
			return this;
		}

		if (val === false) {
			this._mode = 0;
			return this;
		}

		return this._mode === 1;
	},

	/**
	 * Gets / sets if objects mounted to this object should be positioned
	 * and depth-sorted in an isometric fashion or a 2d fashion.
	 * @param {Boolean=} val Set to true to enabled isometric positioning
	 * and depth sorting of objects mounted to this object, or false to
	 * enable 2d positioning and depth-sorting of objects mounted to this
	 * object.
	 * @example #Set children to be positioned and depth sorted in 2d
	 *     var entity = new IgeEntity()
	 *         .isometricMounts(false);
	 * @example #Set children to be positioned and depth sorted in isometric
	 *     var entity = new IgeEntity()
	 *         .isometricMounts(true);
	 * @return {*}
	 */
	isometricMounts: function (val) {
		if (val === true) {
			this._mountMode = 1;
			return this;
		}

		if (val === false) {
			this._mountMode = 0;
			return this;
		}

		return this._mountMode === 1;
	},

	/**
	 * Gets / sets the indestructible flag. If set to true, the object will
	 * not be destroyed even if a call to the destroy() method is made.
	 * @param {Number=} val
	 * @example #Set an entity to indestructible
	 *     var entity = new IgeEntity()
	 *         .indestructible(true);
	 * @example #Set an entity to destructible
	 *     var entity = new IgeEntity()
	 *         .indestructible(false);
	 * @example #Get an entity's indestructible flag value
	 *     var entity = new IgeEntity()
	 *     console.log(entity.indestructible());
	 * @return {*} Returns this when setting the value or the current value if none is specified.
	 */
	indestructible: function (val) {
		if (typeof(val) !== 'undefined') {
			this._indestructible = val;
			return this;
		}

		return this._indestructible;
	},

	/**
	 * Gets / sets the current entity layer. This affects how the entity is depth-sorted
	 * against other entities of the same parent. Please note that entities are first sorted
	 * by their layer and then by their depth, and only entities of the same layer will be
	 * sorted against each other by their depth values.
	 * @param {Number=} val
	 * @example #Set an entity's layer to 22
	 *     var entity = new IgeEntity()
	 *         .layer(22);
	 * @example #Get an entity's layer value
	 *     var entity = new IgeEntity()
	 *     console.log(entity.layer());
	 * @example #How layers and depths are handled together
	 *     var entity1 = new IgeEntity(),
	 *         entity2 = new IgeEntity(),
	 *         entity3 = new IgeEntity();
	 *         
	 *     // Set entity1 to at layer zero and depth 100
	 *     entity1.layer(0)
	 *         .depth(100);
	 *     
	 *     // Set entity2 and 3 to be at layer 1
	 *     entity2.layer(1);
	 *     entity3.layer(1);
	 *	
	 *     // Set entity3 to have a higher depth than entity2
	 *     entity2.depth(0);
	 *     entity3.depth(1);
	 *     
	 *     // The engine sorts first based on layer from lowest to highest
	 *     // and then within each layer, by depth from lowest to highest.
	 *     // This means that entity1 will be drawn before entity 2 and 3
	 *     // because even though it's depth is higher, it is not on the same
	 *     // layer as entity 2 and 3.
	 *     
	 *     // Based on the layers and depths we have assigned, here
	 *     // is how the engine will sort the draw order of the entities
	 *     // entity1
	 *     // entity2
	 *     // entity3
	 * @return {*} Returns this when setting the value or the current value if none is specified.
	 */
	layer: function (val) {
		if (val !== undefined) {
			this._layer = val;
			return this;
		}

		return this._layer;
	},

	/**
	 * Gets / sets the current render depth of the object (higher depths
	 * are drawn over lower depths). Please note that entities are first sorted
	 * by their layer and then by their depth, and only entities of the same layer will be
	 * sorted against each other by their depth values.
	 * @param {Number=} val
	 * @example #Set an entity's depth to 1
	 *     var entity = new IgeEntity()
	 *         .depth(1);
	 * @example #Get an entity's depth value
	 *     var entity = new IgeEntity()
	 *     console.log(entity.depth());
	 * @example #How layers and depths are handled together
	 *     var entity1 = new IgeEntity(),
	 *         entity2 = new IgeEntity(),
	 *         entity3 = new IgeEntity();
	 *
	 *     // Set entity1 to at layer zero and depth 100
	 *     entity1.layer(0)
	 *         .depth(100);
	 *
	 *     // Set entity2 and 3 to be at layer 1
	 *     entity2.layer(1);
	 *     entity3.layer(1);
	 *
	 *     // Set entity3 to have a higher depth than entity2
	 *     entity2.depth(0);
	 *     entity3.depth(1);
	 *
	 *     // The engine sorts first based on layer from lowest to highest
	 *     // and then within each layer, by depth from lowest to highest.
	 *     // This means that entity1 will be drawn before entity 2 and 3
	 *     // because even though it's depth is higher, it is not on the same
	 *     // layer as entity 2 and 3.
	 *
	 *     // Based on the layers and depths we have assigned, here
	 *     // is how the engine will sort the draw order of the entities
	 *     // entity1
	 *     // entity2
	 *     // entity3
	 * @return {*} Returns this when setting the value or the current value if none is specified.
	 */
	depth: function (val) {
		if (val !== undefined) {
			this._depth = val;
			return this;
		}

		return this._depth;
	},

	/**
	 * Loops through all child objects of this object and destroys them
	 * by calling each child's destroy() method then clears the object's
	 * internal _children array.
	 */
	destroyChildren: function () {
		var arr = this._children,
			arrCount;

		if (arr) {
			arrCount = arr.length;

			while (arrCount--) {
				arr[arrCount].destroy();
			}
		}

		this._children = [];

		return this;
	},

	/**
	 * Removes all references to any behaviour methods that were added to
	 * this object.
	 */
	destroyBehaviours: function () {
		delete this._updateBehaviours;
		delete this._tickBehaviours;
	},

	/**
	 * Loops through all components added to this object and calls their
	 * destroy() method, then removes any references to the components.
	 * @return {*}
	 */
	destroyComponents: function () {
		var arr = this._components,
			arrCount;

		if (arr) {
			arrCount = arr.length;

			while (arrCount--) {
				if (arr[arrCount].destroy) {
					arr[arrCount].destroy();
				}
			}
		}

		delete this._components;

		return this;
	},

	/**
	 * Gets / sets the depth sort mode that is used when
	 * depth sorting this object's children against each other. This
	 * mode only applies if this object's mount mode is isometric,
	 * as set by calling isometricMounts(true). If the mount mode is
	 * 2d, the depth sorter will use a very fast 2d depth sort that
	 * does not use 3d bounds at all.
	 * @param {Number=} val The mode to use when depth sorting
	 * this object's children, given as an integer value.
	 * @example #Turn off all depth sorting for this object's children
	 *     entity.depthSortMode(-1);
	 * @example #Use 3d bounds when sorting this object's children
	 *     entity.depthSortMode(0);
	 * @example #Use 3d bounds optimised for mostly cube-shaped bounds when sorting this object's children
	 *     entity.depthSortMode(1);
	 * @example #Use 3d bounds optimised for all cube-shaped bounds when sorting this object's children
	 *     entity.depthSortMode(2);
	 * @return {*}
	 */
	depthSortMode: function (val) {
		if (val !== undefined) {
			this._depthSortMode = val;
			return this;
		}

		return this._depthSortMode;
	},

	/**
	 * Sorts the _children array by the layer and then depth of each object.
	 */
	depthSortChildren: function () {
		if (this._depthSortMode !== -1) {
			// TODO: Optimise this method, it is not especially efficient at the moment!
			var arr = this._children,
				arrCount,
				sortObj,
				i, j;

			if (arr) {
				arrCount = arr.length;

				// See if we can bug-out early
				if (arrCount > 1) {
					// Check if the mount mode is isometric
					if (this._mountMode === 1) {
						// Check the depth sort mode
						if (this._depthSortMode === 0) { // Slowest, uses 3d bounds
							// Calculate depths from 3d bounds
							sortObj = {
								adj: [],
								c: [],
								p: [],
								order: [],
								order_ind: arrCount - 1
							};

							for (i = 0; i < arrCount; ++i) {
								sortObj.c[i] = 0;
								sortObj.p[i] = -1;

								for (j = i + 1; j < arrCount; ++j) {
									sortObj.adj[i] = sortObj.adj[i] || [];
									sortObj.adj[j] = sortObj.adj[j] || [];

									if (arr[i]._inView && arr[j]._inView && arr[i]._projectionOverlap && arr[j]._projectionOverlap) {
										if (arr[i]._projectionOverlap(arr[j])) {
											if (arr[i].isBehind(arr[j])) {
												sortObj.adj[j].push(i);
											} else {
												sortObj.adj[i].push(j);
											}
										}
									}
								}
							}

							for (i = 0; i < arrCount; ++i) {
								if (sortObj.c[i] === 0) {
									this._depthSortVisit(i, sortObj);
								}
							}

							for (i = 0; i < sortObj.order.length; i++) {
								arr[sortObj.order[i]].depth(i);
							}

							this._children.sort(function (a, b) {
								var layerIndex = b._layer - a._layer;

								if (layerIndex === 0) {
									// On same layer so sort by depth
									return b._depth - a._depth;
								} else {
									// Not on same layer so sort by layer
									return layerIndex;
								}
							});
						}

						if (this._depthSortMode === 1) { // Medium speed, optimised for almost-cube shaped 3d bounds
							// Now sort the entities by depth
							this._children.sort(function (a, b) {
								var layerIndex = b._layer - a._layer;

								if (layerIndex === 0) {
									// On same layer so sort by depth
									//if (a._projectionOverlap(b)) {
										if (a.isBehind(b)) {
											return -1;
										} else {
											return 1;
										}
									//}
								} else {
									// Not on same layer so sort by layer
									return layerIndex;
								}
							});
						}

						if (this._depthSortMode === 2) { // Fastest, optimised for cube-shaped 3d bounds
							while (arrCount--) {
								sortObj = arr[arrCount];
								j = sortObj._translate;

								if (j) {
									sortObj._depth = j.x + j.y + j.z;
								}
							}

							// Now sort the entities by depth
							this._children.sort(function (a, b) {
								var layerIndex = b._layer - a._layer;

								if (layerIndex === 0) {
									// On same layer so sort by depth
									return b._depth - a._depth;
								} else {
									// Not on same layer so sort by layer
									return layerIndex;
								}
							});
						}
					} else { // 2d mode
						// Now sort the entities by depth
						this._children.sort(function (a, b) {
							var layerIndex = b._layer - a._layer;

							if (layerIndex === 0) {
								// On same layer so sort by depth
								return b._depth - a._depth;
							} else {
								// Not on same layer so sort by layer
								return layerIndex;
							}
						});
					}
				}
			}
		}
	},

	/**
	 * Gets / sets the view checking flag that if set to true
	 * will ask the engine to check during each tick if this
	 * object is actually "on screen" or not, and bypass it
	 * if it is not. The default is this flag set to false.
	 * @param {Boolean=} val The boolean flag value.
	 * @return {*}
	 */
	viewChecking: function (val) {
		if (val !== undefined) {
			this._viewChecking = val;
			return this;
		}

		return this._viewChecking;
	},

	/**
	 * ALPHA CODE DO NOT USE YET.
	 * When view checking is enabled, this method is called to
	 * determine if this object is within the bounds of an active
	 * viewport, essentially determining if the object is
	 * "on screen" or not.
	 */
	viewCheckChildren: function () {
		if (ige._currentViewport) {
			var arr = this._children,
				arrCount = arr.length,
				vpViewArea = ige._currentViewport.viewArea(),
				item;
	
			while (arrCount--) {
				item = arr[arrCount];
	
				if (item._alwaysInView) {
					item._inView = true;
				} else {
					if (item.aabb) {
						// Check the entity to see if its bounds are "inside" the
						// viewport's visible area
						if (vpViewArea.intersects(item.aabb(true))) {
							// The entity is inside the viewport visible area
							item._inView = true;
						} else {
							item._inView = false;
						}
					} else {
						item._inView = false;
					}
				}
			}
		}
		
		return this;
	},
	
	update: function (ctx, tickDelta) {
		// Check that we are alive before processing further
		if (this._alive) {
			if (this._newBorn) { this._newBorn = false; }
			var arr = this._children,
				arrCount,
				ts, td;

			if (arr) {
				arrCount = arr.length;
				
				// Depth sort all child objects
				if (arrCount && !ige._headless) {
					if (igeConfig.debug._timing) {
						if (!ige._timeSpentLastTick[this.id()]) {
							ige._timeSpentLastTick[this.id()] = {};
						}

						ts = new Date().getTime();
						this.depthSortChildren();
						td = new Date().getTime() - ts;
						ige._timeSpentLastTick[this.id()].depthSortChildren = td;
					} else {
						this.depthSortChildren();
					}
				}

				// Loop our children and call their update methods
				if (igeConfig.debug._timing) {
					while (arrCount--) {
						ts = new Date().getTime();
						arr[arrCount].update(ctx, tickDelta);
						td = new Date().getTime() - ts;
						if (arr[arrCount]) {
							if (!ige._timeSpentInTick[arr[arrCount].id()]) {
								ige._timeSpentInTick[arr[arrCount].id()] = 0;
							}

							if (!ige._timeSpentLastTick[arr[arrCount].id()]) {
								ige._timeSpentLastTick[arr[arrCount].id()] = {};
							}

							ige._timeSpentInTick[arr[arrCount].id()] += td;
							ige._timeSpentLastTick[arr[arrCount].id()].tick = td;
						}
					}
				} else {
					while (arrCount--) {
						arr[arrCount].update(ctx, tickDelta);
					}
				}
			}
		}
	},

	/**
	 * Processes the actions required each render frame.
	 */
	tick: function (ctx) {
		// Check that we are alive before processing further
		if (this._alive) {
			var arr = this._children,
				arrCount,
				ts, td;
	
			if (this._viewChecking) {
				// Set the in-scene flag for each child based on
				// the current viewport
				this.viewCheckChildren();
			}
	
			// Loop the child objects of this object
			if (arr) {
				arrCount = arr.length;
				
				// Loop our children and call their tick methods
				if (igeConfig.debug._timing) {
					while (arrCount--) {
						if (!arr[arrCount]) {
							this.log('Object _children is undefined for index ' + arrCount + ' and _id: ' + this._id, 'error');
							continue;
						}
						
						if (!arr[arrCount]._newBorn) {
							ctx.save();
							ts = new Date().getTime();
							arr[arrCount].tick(ctx);
							td = new Date().getTime() - ts;
							if (arr[arrCount]) {
								if (!ige._timeSpentInTick[arr[arrCount].id()]) {
									ige._timeSpentInTick[arr[arrCount].id()] = 0;
								}
		
								if (!ige._timeSpentLastTick[arr[arrCount].id()]) {
									ige._timeSpentLastTick[arr[arrCount].id()] = {};
								}
		
								ige._timeSpentInTick[arr[arrCount].id()] += td;
								ige._timeSpentLastTick[arr[arrCount].id()].tick = td;
							}
							ctx.restore();
						}
					}
				} else {
					while (arrCount--) {
						if (!arr[arrCount]) {
							this.log('Object _children is undefined for index ' + arrCount + ' and _id: ' + this._id, 'error');
							continue;
						}
						
						if (!arr[arrCount]._newBorn) {
							ctx.save();
							arr[arrCount].tick(ctx);
							ctx.restore();
						}
					}
				}
			}
		}
	},

	_depthSortVisit: function (u, sortObj) {
		var arr = sortObj.adj[u],
			arrCount = arr.length,
			i, v;

		sortObj.c[u] = 1;

		for (i = 0; i < arrCount; ++i) {
			v = arr[i];

			if (sortObj.c[v] === 0) {
				sortObj.p[v] = u;
				this._depthSortVisit(v, sortObj);
			}
		}

		sortObj.c[u] = 2;
		sortObj.order[sortObj.order_ind] = u;
		--sortObj.order_ind;
	},

	/**
	 * Handles screen resize events. Calls the _resizeEvent method of
	 * every child object mounted to this object.
	 * @param event
	 * @private
	 */
	_resizeEvent: function (event) {
		var arr = this._children,
			arrCount;

		if (arr) {
			arrCount = arr.length;

			while (arrCount--) {
				arr[arrCount]._resizeEvent(event);
			}
		}


	},

	/**
	 * Calls each behaviour method for the object.
	 * @private
	 */
	_processUpdateBehaviours: function (ctx, tickDelta) {
		var arr = this._updateBehaviours,
			arrCount;

		if (arr) {
			arrCount = arr.length;
			while (arrCount--) {
				arr[arrCount].method.apply(this, arguments);
			}
		}
	},

	/**
	 * Calls each behaviour method for the object.
	 * @private
	 */
	_processTickBehaviours: function (ctx) {
		var arr = this._tickBehaviours,
			arrCount;

		if (arr) {
			arrCount = arr.length;
			while (arrCount--) {
				arr[arrCount].method.apply(this, arguments);
			}
		}
	},
	
	/**
	 * Called when a child object is mounted to this object.
	 * @param obj
	 * @private
	 */
	_childMounted: function (obj) {
		this._resizeEvent(null);
	},

	/**
	 * Called when a child object is un-mounted to this object.
	 * @param obj
	 * @private
	 */
	_childUnMounted: function (obj) {},
	
	/**
	 * Called when this object is mounted to another object.
	 * @param obj
	 * @private
	 */
	_mounted: function (obj) {
		
	},
	
	/**
	 * Called when this object is un-mounted from it's parent.
	 * @param obj
	 * @private
	 */
	_unMounted: function (obj) {
		
	},

	/**
	 * Destroys the object and all it's child objects, removing them from the
	 * scenegraph and from memory.
	 */
	destroy: function () {
		// Remove ourselves from any parent
		this.unMount();

		// Remove any children
		if (this._children) {
			this.destroyChildren();
		}

		// Remove any components
		this.destroyComponents();

		// Remove any behaviours
		this.destroyBehaviours();

		// Remove the object from the lookup system
		ige.unRegister(this);
		ige.categoryUnRegister(this);
		ige.groupUnRegister(this);

		// Set a flag in case a reference to this object
		// has been held somewhere, shows that the object
		// should no longer be interacted with
		this._alive = false;

		// Remove the event listeners array in case any
		// object references still exist there
		delete this._eventListeners;

		return this;
	},
	
	objSave: function () {
		return {igeClass: this.classId(), data: this._objSaveReassign(this, [])};
	},
	
	objLoad: function (obj) {
		this._objLoadReassign(this, obj.data);
	},
	
	saveSpecialProp: function (obj, i) {
		switch (i) {
			case '_id':
				if (obj._id) {
					return {_id: obj._id};
				}
				break;
			
			case '_parent':
				if (obj._parent) {
					return {_parent: obj._parent.id()};
				}
				break;
			
			case '_children':
				if (obj._children.length) {
					var childIndex,
						child,
						arr = [];
					
					for (childIndex = 0; childIndex < obj._children.length; childIndex++) {
						child = obj._children[childIndex];
						arr.push(child.objSave());
					}
					
					return {_children: arr};
				}
				break;
		}
		
		return undefined;
	},
	
	loadSpecialProp: function (obj, i) {
		switch (i) {
			case '_id':
				return {_id: obj[i]};
				break;
			
			case '_parent':
				return {_parent: obj[i]};
				break;
			
			case '_children':
				return {_children: obj[i]};
				break;
		}
		return undefined;
	},
	
	loadGraph: function (obj) {
		if (obj.igeClass && obj.data) {
			// Create a new class instance
			var classInstance = ige.newClassInstance(obj.igeClass),
				newId,
				childArr,
				childIndex,
				parentId;
			
			classInstance.objLoad(obj);
			
			if (classInstance._parent) {
				// Record the id and delete it
				parentId = classInstance._parent;
				delete classInstance._parent;
			}
			
			// Process item id
			if (classInstance._id) {
				newId = classInstance._id;
				delete classInstance._id;
				
				classInstance.id(newId);
			}
			
			// Check for children and process them if exists
			if (classInstance._children && classInstance._children.length) {
				childArr = classInstance._children;
				classInstance._children = [];
				
				for (childIndex = 0; childIndex < childArr.length; childIndex++) {
					classInstance.loadGraph(childArr[childIndex]);
				}
			}
			
			// Now mount the instance if it has a parent
			classInstance.mount(this);
		}
	},
	
	_objSaveReassign: function (obj, ref) {
		var copyObj,
			specialKeys = this._specialProp,
			refIndex,
			specProp,
			specPropKey,
			i;
		
		if (typeof(obj) === 'object' && !(obj instanceof Array)) {
			copyObj = {};
			
			for (i in obj) {
				if (obj.hasOwnProperty(i)) {
					if (typeof(obj[i]) === 'object') {
						if (specialKeys.indexOf(i) === -1) {
							// Check if the ref already exists
							refIndex = ref.indexOf(obj[i]);
							
							if (refIndex > -1) {
								copyObj[i] = '{ref:' + refIndex + '}';
								this.log('Possible circular reference for property ' + i);
							} else {
								ref.push(obj[i]);
								copyObj[i] = this._objSaveReassign(obj[i], ref);
							}
						} else {
							// This is a special property that needs handling via
							// it's own method to return an appropriate data value
							// so check if there is a method for it
							specProp = this.saveSpecialProp(obj, i);
							
							if (specProp) {
								if (typeof(specProp) === 'object' && !(specProp instanceof Array)) {
									// Process the returned object properties
									for (specPropKey in specProp) {
										if (specProp.hasOwnProperty(specPropKey)) {
											// Copy the special property data to the key in
											// our return object
											copyObj[specPropKey] = specProp[specPropKey];
										}
									}
								} else {
									copyObj[i] = specProp;
								}
							}
						}
					} else {
						copyObj[i] = obj[i];
					}
				}
			}
			
			return copyObj;
		} else {
			return obj;
		}
	},
	
	_objLoadReassign: function (obj, newProps) {
		var specialKeys = this._specialProp,
			specProp,
			specPropKey,
			i;
		
		for (i in newProps) {
			if (newProps.hasOwnProperty(i)) {
				if (specialKeys.indexOf(i) === -1) {
					if (typeof(newProps[i]) === 'object' && obj[i]) {
						this._objLoadReassign(obj[i], newProps[i]);
					} else {
						// Assign the property value directly
						obj[i] = newProps[i];
					}
				} else {
					// This is a special property that needs handling via
					// it's own method to return an appropriate data value
					// so check if there is a method for it
					specProp = this.loadSpecialProp(newProps, i);
					
					if (specProp) {
						if (typeof(specProp) === 'object' && !(specProp instanceof Array)) {
							// Process the returned object properties
							for (specPropKey in specProp) {
								if (specProp.hasOwnProperty(specPropKey)) {
									// Copy the special property data to the key in
									// our return object
									obj[specPropKey] = specProp[specPropKey];
								}
							}
						} else {
							obj[i] = specProp;
						}
					}
				}
			}
		}
	},

	/**
	 * Returns a string containing a code fragment that when
	 * evaluated will reproduce this object.
	 * @return {String}
	 */
	stringify: function (options) {
		// Make sure we have an options object
		if (options === undefined) { options = {}; }
		
		var str = "new " + this.classId() + "()";

		// Every object has an ID, assign that first
		if (options.id !== false) {
			str += ".id('" + this.id() + "')";
		}

		// Now check if there is a parent and mount that
		if (options.mount !== false && this.parent()) {
			str += ".mount(ige.$('" + this.parent().id() + "'))";
		}

		// Now get all other properties
		str += this._stringify(options);

		return str;
	},

	/**
	 * Returns a string containing a code fragment that when
	 * evaluated will reproduce this object's properties via
	 * chained commands. This method will only check for
	 * properties that are directly related to this class.
	 * Other properties are handled by their own class method.
	 * @return {String}
	 */
	_stringify: function (options) {
		// Make sure we have an options object
		if (options === undefined) { options = {}; }
		
		var str = '', i;

		// Loop properties and add property assignment code to string
		for (i in this) {
			if (this.hasOwnProperty(i) && this[i] !== undefined) {
				switch (i) {
					case '_category':
						str += ".category(" + this.category() + ")";
						break;
					case '_drawBounds':
						str += ".drawBounds(" + this.drawBounds() + ")";
						break;
					case '_drawBoundsData':
						str += ".drawBoundsData(" + this.drawBoundsData() + ")";
						break;
					case '_drawMouse':
						str += ".drawMouse(" + this.drawMouse() + ")";
						break;
					case '_mode':
						str += ".mode(" + this.mode() + ")";
						break;
					case '_isometricMounts':
						str += ".isometricMounts(" + this.isometricMounts() + ")";
						break;
					case '_indestructible':
						str += ".indestructible(" + this.indestructible() + ")";
						break;
					case '_layer':
						str += ".layer(" + this.layer() + ")";
						break;
					case '_depth':
						str += ".depth(" + this.depth() + ")";
						break;
				}
			}
		}

		return str;
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = IgeObject; }

/**
 * Creates an entity and handles the entity's life cycle and
 * all related entity actions / methods.
 */
var IgeEntity = IgeObject.extend({
	classId: 'IgeEntity',

	init: function () {
		IgeObject.prototype.init.call(this);
		
		// Register the IgeEntity special properties handler for 
		// serialise and de-serialise support
		this._specialProp.push('_texture');
		this._specialProp.push('_eventListeners');
		this._specialProp.push('_aabb');

		this._anchor = new IgePoint2d(0, 0);
		this._renderPos = {x: 0, y: 0};

		this._computedOpacity = 1;
		this._opacity = 1;
		this._cell = 1;

		this._deathTime = undefined;
		this._bornTime = ige._currentTime;

		this._translate = new IgePoint3d(0, 0, 0);
		this._oldTranslate = new IgePoint3d(0, 0, 0);
		this._rotate = new IgePoint3d(0, 0, 0);
		this._scale = new IgePoint3d(1, 1, 1);
		this._origin = new IgePoint3d(0.5, 0.5, 0.5);

		this._bounds2d = new IgePoint2d(40, 40);
		this._bounds3d = new IgePoint3d(0, 0, 0);
		
		this._oldBounds2d = new IgePoint2d(40, 40);
		this._oldBounds3d = new IgePoint3d(0, 0, 0);

		this._highlight = false;
		this._mouseEventsActive = false;
		
		this._velocity = new IgePoint3d(0, 0, 0);

        this._localMatrix = new IgeMatrix2d();
        this._worldMatrix = new IgeMatrix2d();
		this._oldWorldMatrix = new IgeMatrix2d();

		this._inView = true;
		this._hidden = false;
		
		//this._mouseEventTrigger = 0;

		/* CEXCLUDE */
		if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') {
			// Set the stream floating point precision to 2 as default
			this.streamFloatPrecision(2);
		}
		/* CEXCLUDE */

		// Set the default stream sections as just the transform data
		this.streamSections(['transform']);
	},

	/**
	 * Sets the entity as visible and able to be interacted with.
	 * @example #Show a hidden entity
	 *     entity.show();
	 * @return {*} The object this method was called from to allow
	 * method chaining.
	 */
	show: function () {
		this._hidden = false;
		return this;
	},

	/**
	 * Sets the entity as hidden and cannot be interacted with.
	 * @example #Hide a visible entity
	 *     entity.hide();
	 * @return {*} The object this method was called from to allow
	 * method chaining.
	 */
	hide: function () {
		this._hidden = true;
		return this;
	},

	/**
	 * Checks if the entity is visible.
	 * @returns {boolean} True if the entity is visible.
	 */
	isVisible: function () {
		return this._hidden === false;
	},
	
	/**
	 * Checks if the entity is hidden.
	 * @returns {boolean} True if the entity is hidden.
	 */
	isHidden: function () {
		return this._hidden === true;
	},

	/**
	 * Gets / sets the cache flag that determines if the entity's
	 * texture rendering output should be stored on an off-screen
	 * canvas instead of calling the texture.render() method each
	 * tick. Useful for expensive texture calls such as rendering
	 * fonts etc. If enabled, this will automatically disable advanced
	 * composite caching on this entity with a call to
	 * compositeCache(false).
	 * @param {Boolean=} val True to enable caching, false to
	 * disable caching.
	 * @example #Enable entity caching
	 *     entity.cache(true);
	 * @example #Disable entity caching
	 *     entity.cache(false);
	 * @example #Get caching flag value
	 *     var val = entity.cache();
	 * @return {*}
	 */
	cache: function (val) {
		if (val !== undefined) {
			this._cache = val;
			
			if (val) {
				// Create the off-screen canvas
				if (ige.isClient) {
					// Use a real canvas
					this._cacheCanvas = document.createElement('canvas');
				} else {
					// Use dummy objects for canvas and context
					this._cacheCanvas = new IgeDummyCanvas();
				}
				
				this._cacheCtx = this._cacheCanvas.getContext('2d');
				this._cacheDirty = true;
				
				// Set smoothing mode
				var smoothing = this._cacheSmoothing !== undefined ? this._cacheSmoothing : ige._globalSmoothing;
				if (!smoothing) {
					this._cacheCtx.imageSmoothingEnabled = false;
				} else {
					this._cacheCtx.imageSmoothingEnabled = true;
				}

				// Switch off composite caching
				if (this.compositeCache()) {
					this.compositeCache(false);
				}
			} else {
				// Remove the off-screen canvas
				delete this._cacheCanvas;
			}

			return this;
		}

		return this._cache;
	},

	/**
	 * When using the caching system, this boolean determines if the
	 * cache canvas should have image smoothing enabled or not. If
	 * not set, the ige global smoothing setting will be used instead.
	 * @param {Boolean=} val True to enable smoothing, false to disable.
	 * @returns {*}
	 */
	cacheSmoothing: function (val) {
		if (val !== undefined) {
			this._cacheSmoothing = val;
			return this;
		}
		
		return this._cacheSmoothing;
	},

	/**
	 * Gets / sets composite caching. Composite caching draws this entity
	 * and all of it's children (and their children etc) to a single off
	 * screen canvas so that the entity does not need to be redrawn with
	 * all it's children every tick. For composite entities where little
	 * change occurs this will massively increase rendering performance.
	 * If enabled, this will automatically disable simple caching on this
	 * entity with a call to cache(false).
	 * @param {Boolean=} val
	 * @example #Enable entity composite caching
	 *     entity.compositeCache(true);
	 * @example #Disable entity composite caching
	 *     entity.compositeCache(false);
	 * @example #Get composite caching flag value
	 *     var val = entity.cache();
	 * @return {*}
	 */
	compositeCache: function (val) {
		if (ige.isClient) {
			if (val !== undefined) {
				if (val) {
					// Switch off normal caching
					this.cache(false);
					
					// Create the off-screen canvas
					this._cacheCanvas = document.createElement('canvas');
					this._cacheCtx = this._cacheCanvas.getContext('2d');
					this._cacheDirty = true;
					
					// Set smoothing mode
					var smoothing = this._cacheSmoothing !== undefined ? this._cacheSmoothing : ige._globalSmoothing;
					if (!smoothing) {
						this._cacheCtx.imageSmoothingEnabled = false;
						this._cacheCtx.imageSmoothingEnabled = false;
					} else {
						this._cacheCtx.imageSmoothingEnabled = true;
						this._cacheCtx.imageSmoothingEnabled = true;
					}
				}
				
				// Loop children and set _compositeParent to the correct value
				this._children.each(function () {
					if (val) {
						this._compositeParent = true;
					} else {
						delete this._compositeParent;
					}
				});
				
				this._compositeCache = val;
				return this;
			}
			
			return this._compositeCache;
		} else {
			return this;
		}
	},

	/**
	 * Gets / sets the cache dirty flag. If set to true this will
	 * instruct the entity to re-draw it's cached image from the
	 * assigned texture. Once that occurs the flag will automatically
	 * be set back to false. This works in either standard cache mode
	 * or composite cache mode.
	 * @param {Boolean=} val True to force a cache update.
	 * @example #Get cache dirty flag value
	 *     var val = entity.cacheDirty();
	 * @example #Set cache dirty flag value
	 *     entity.cacheDirty(true);
	 * @return {*}
	 */
	cacheDirty: function (val) {
		if (val !== undefined) {
			this._cacheDirty = val;
			
			// Check if the entity is a child of a composite or composite
			// entity chain and propagate the dirty cache up the chain
			if (val && this._compositeParent && this._parent) {
				this._parent.cacheDirty(val);
				
				if (!this._cache && !this._compositeCache) {
					// Set clean immediately as no caching is enabled on this child
					this._cacheDirty = false;
				}
			}
			
			return this;
		}

		return this._cacheDirty;
	},

	/**
	 * Gets the position of the mouse relative to this entity's
	 * center point.
	 * @param {IgeViewport=} viewport The viewport to use as the
	 * base from which the mouse position is determined. If no
	 * viewport is specified then the current viewport the engine
	 * is rendering to is used instead.
	 * @example #Get the mouse position relative to the entity
	 *     // The returned value is an object with properties x, y, z
	 *     var mousePos = entity.mousePos();
	 * @return {IgePoint3d} The mouse point relative to the entity
	 * center.
	 */
	mousePos: function (viewport) {
		viewport = viewport || ige._currentViewport;
		if (viewport) {
			var mp = viewport._mousePos.clone(),
				cam;

			if (this._ignoreCamera) {
				/*cam = ige._currentCamera;
				mp.thisMultiply(1 / cam._scale.x, 1 / cam._scale.y, 1 / cam._scale.z);
				//mp.thisRotate(-cam._rotate.z);
				mp.thisAddPoint(cam._translate);*/
			}
			
			mp.x += viewport._translate.x;
			mp.y += viewport._translate.y;
			this._transformPoint(mp);
			return mp;
		} else {
			return new IgePoint3d(0, 0, 0);
		}
	},

	/**
	 * Gets the position of the mouse relative to this entity not
	 * taking into account viewport translation.
	 * @param {IgeViewport=} viewport The viewport to use as the
	 * base from which the mouse position is determined. If no
	 * viewport is specified then the current viewport the engine
	 * is rendering to is used instead.
	 * @example #Get absolute mouse position
	 *     var mousePosAbs = entity.mousePosAbsolute();
	 * @return {IgePoint3d} The mouse point relative to the entity
	 * center.
	 */
	mousePosAbsolute: function (viewport) {
		viewport = viewport || ige._currentViewport;
		if (viewport) {
			var mp = viewport._mousePos.clone();
			this._transformPoint(mp);
			return mp;
		}

		return new IgePoint3d(0, 0, 0);
	},

	/**
	 * Gets the position of the mouse in world co-ordinates.
	 * @param {IgeViewport=} viewport The viewport to use as the
	 * base from which the mouse position is determined. If no
	 * viewport is specified then the current viewport the engine
	 * is rendering to is used instead.
	 * @example #Get mouse position in world co-ordinates
	 *     var mousePosWorld = entity.mousePosWorld();
	 * @return {IgePoint3d} The mouse point relative to the world
	 * center.
	 */
	mousePosWorld: function (viewport) {
		viewport = viewport || ige._currentViewport;
		var mp = this.mousePos(viewport);
		this.localToWorldPoint(mp, viewport);

		if (this._ignoreCamera) {
			//viewport.camera._worldMatrix.getInverse().transform([mp]);
		}

		return mp;
	},

	/**
	 * Rotates the entity to point at the target point around the z axis.
	 * @param {IgePoint3d} point The point in world co-ordinates to
	 * point the entity at.
	 * @example #Point the entity at another entity
	 *     entity.rotateToPoint(otherEntity.worldPosition());
	 * @example #Point the entity at mouse
	 *     entity.rotateToPoint(ige._currentViewport.mousePos());
	 * @example #Point the entity at an arbitrary point x, y
	 *     entity.rotateToPoint(new IgePoint3d(x, y, 0));
	 * @return {*}
	 */
	rotateToPoint: function (point) {
		var worldPos = this.worldPosition();
		this.rotateTo(
			this._rotate.x,
			this._rotate.y,
			(Math.atan2(worldPos.y - point.y, worldPos.x - point.x) - this._parent._rotate.z) + Math.radians(270)
		);

		return this;
	},

	/**
	 * Gets / sets the texture to use as the background
	 * pattern for this entity.
	 * @param {IgeTexture} texture The texture to use as
	 * the background.
	 * @param {String=} repeat The type of repeat mode either: "repeat",
	 * "repeat-x", "repeat-y" or "none".
	 * @param {Boolean=} trackCamera If set to true, will track the camera
	 * translation and "move" the background with the camera.
	 * @param {Boolean=} isoTile If true the tiles of the background will
	 * be treated as isometric and will therefore be drawn so that they are
	 * layered seamlessly in isometric view.
	 * @example #Set a background pattern for this entity with 2d tiling
	 *     var texture = new IgeTexture('path/to/my/texture.png');
	 *     entity.backgroundPattern(texture, 'repeat', true, false);
	 * @example #Set a background pattern for this entity with isometric tiling
	 *     var texture = new IgeTexture('path/to/my/texture.png');
	 *     entity.backgroundPattern(texture, 'repeat', true, true);
	 * @return {*}
	 */
	backgroundPattern: function (texture, repeat, trackCamera, isoTile) {
		if (texture !== undefined) {
			this._backgroundPattern = texture;
			this._backgroundPatternRepeat = repeat || 'repeat';
			this._backgroundPatternTrackCamera = trackCamera;
			this._backgroundPatternIsoTile = isoTile;
			this._backgroundPatternFill = null;
			return this;
		}

		return this._backgroundPattern;
	},

	/**
	 * Set the object's width to the number of tile width's specified.
	 * @param {Number} val Number of tiles.
	 * @param {Boolean=} lockAspect If true, sets the height according
	 * to the texture aspect ratio and the new width.
	 * @example #Set the width of the entity based on the tile width of the map the entity is mounted to
	 *     // Set the entity width to the size of 1 tile with
	 *     // lock aspect enabled which will automatically size
	 *     // the height as well so as to maintain the aspect
	 *     // ratio of the entity
	 *     entity.widthByTile(1, true);
	 * @return {*} The object this method was called from to allow
	 * method chaining.
	 */
	widthByTile: function (val, lockAspect) {
		if (this._parent && this._parent._tileWidth !== undefined && this._parent._tileHeight !== undefined) {
			var tileSize = this._mode === 0 ? this._parent._tileWidth : this._parent._tileWidth * 2,
				ratio;

			this.width(val * tileSize);

			if (lockAspect) {
				if (this._texture) {
					// Calculate the height based on the new width
					ratio = this._texture._sizeX / this._bounds2d.x;
					this.height(this._texture._sizeY / ratio);
				} else {
					this.log('Cannot set height based on texture aspect ratio and new width because no texture is currently assigned to the entity!', 'error');
				}
			}
		} else {
			this.log('Cannot set width by tile because the entity is not currently mounted to a tile map or the tile map has no tileWidth or tileHeight values.', 'warning');
		}

		return this;
	},

	/**
	 * Set the object's height to the number of tile height's specified.
	 * @param {Number} val Number of tiles.
	 * @param {Boolean=} lockAspect If true, sets the width according
	 * to the texture aspect ratio and the new height.
	 * @example #Set the height of the entity based on the tile height of the map the entity is mounted to
	 *     // Set the entity height to the size of 1 tile with
	 *     // lock aspect enabled which will automatically size
	 *     // the width as well so as to maintain the aspect
	 *     // ratio of the entity
	 *     entity.heightByTile(1, true);
	 * @return {*} The object this method was called from to allow
	 * method chaining.
	 */
	heightByTile: function (val, lockAspect) {
		if (this._parent && this._parent._tileWidth !== undefined && this._parent._tileHeight !== undefined) {
			var tileSize = this._mode === 0 ? this._parent._tileHeight : this._parent._tileHeight * 2,
				ratio;

			this.height(val * tileSize);

			if (lockAspect) {
				if (this._texture) {
					// Calculate the width based on the new height
					ratio = this._texture._sizeY / this._bounds2d.y;
					this.width(this._texture._sizeX / ratio);
				} else {
					this.log('Cannot set width based on texture aspect ratio and new height because no texture is currently assigned to the entity!', 'error');
				}
			}
		} else {
			this.log('Cannot set height by tile because the entity is not currently mounted to a tile map or the tile map has no tileWidth or tileHeight values.', 'warning');
		}

		return this;
	},
	
	/**
	 * Adds the object to the tile map at the passed tile co-ordinates. If
	 * no tile co-ordinates are passed, will use the current tile position
	 * and the tileWidth() and tileHeight() values.
	 * @param {Number=} x X co-ordinate of the tile to occupy.
	 * @param {Number=} y Y co-ordinate of the tile to occupy.
	 * @param {Number=} width Number of tiles along the x-axis to occupy.
	 * @param {Number=} height Number of tiles along the y-axis to occupy.
	 */
	occupyTile: function (x, y, width, height) {
		// Check that the entity is mounted to a tile map
		if (this._parent && this._parent.IgeTileMap2d) {
			if (x !== undefined && y !== undefined) {
				this._parent.occupyTile(x, y, width, height, this);
			} else {
				// Occupy tiles based upon tile point and tile width/height
				var trPoint = new IgePoint3d(this._translate.x - (((this._tileWidth / 2) - 0.5) * this._parent._tileWidth), this._translate.y - (((this._tileHeight / 2) - 0.5) * this._parent._tileHeight), 0),
					tilePoint = this._parent.pointToTile(trPoint);
	
				if (this._parent._mountMode === 1) {
					tilePoint.thisToIso();
				}
	
				this._parent.occupyTile(tilePoint.x, tilePoint.y, this._tileWidth, this._tileHeight, this);
			}
		}
		return this;
	},
	
	/**
	 * Removes the object from the tile map at the passed tile co-ordinates.
	 * If no tile co-ordinates are passed, will use the current tile position
	 * and the tileWidth() and tileHeight() values.
	 * @param {Number=} x X co-ordinate of the tile to un-occupy.
	 * @param {Number=} y Y co-ordinate of the tile to un-occupy.
	 * @param {Number=} width Number of tiles along the x-axis to un-occupy.
	 * @param {Number=} height Number of tiles along the y-axis to un-occupy.
	 * @private
	 */
	unOccupyTile: function (x, y, width, height) {
		// Check that the entity is mounted to a tile map
		if (this._parent && this._parent.IgeTileMap2d) {
			if (x !== undefined && y !== undefined) {
				this._parent.unOccupyTile(x, y, width, height);
			} else {
				// Un-occupy tiles based upon tile point and tile width/height
				var trPoint = new IgePoint3d(this._translate.x - (((this._tileWidth / 2) - 0.5) * this._parent._tileWidth), this._translate.y - (((this._tileHeight / 2) - 0.5) * this._parent._tileHeight), 0),
					tilePoint = this._parent.pointToTile(trPoint);
	
				if (this._parent._mountMode === 1) {
					tilePoint.thisToIso();
				}
	
				this._parent.unOccupyTile(tilePoint.x, tilePoint.y, this._tileWidth, this._tileHeight);
			}
		}
		return this;
	},
	
	/**
	 * Returns an array of tile co-ordinates that the object is currently
	 * over, calculated using the current world co-ordinates of the object
	 * as well as it's 3d geometry.
	 * @private
	 * @return {Array} The array of tile co-ordinates as IgePoint3d instances.
	 */
	overTiles: function () {
		// Check that the entity is mounted to a tile map
		if (this._parent && this._parent.IgeTileMap2d) {
			var x,
				y,
				tileWidth = this._tileWidth || 1,
				tileHeight = this._tileHeight || 1,
				tile = this._parent.pointToTile(this._translate),
				tileArr = [];
	
			for (x = 0; x < tileWidth; x++) {
				for (y = 0; y < tileHeight; y++) {
					tileArr.push(new IgePoint3d(tile.x + x, tile.y + y, 0));
				}
			}
	
			return tileArr;
		}
	},

	/**
	 * Gets / sets the anchor position that this entity's texture
	 * will be adjusted by.
	 * @param {Number=} x The x anchor value.
	 * @param {Number=} y The y anchor value.
	 * @return {*} "this" when arguments are passed to allow method
	 * chaining or the current value if no arguments are specified.
	 */
	anchor: function (x, y) {
		if (x !== undefined && y !== undefined) {
			this._anchor = new IgePoint2d(x, y);
			return this;
		}

		return this._anchor;
	},

	/**
	 * Gets / sets the geometry x value.
	 * @param {Number=} px The new x value in pixels.
	 * @example #Set the width of the entity
	 *     entity.width(40);
	 * @return {*} "this" when arguments are passed to allow method
	 * chaining or the current value if no arguments are specified.
	 */
	width: function (px, lockAspect) {
		if (px !== undefined) {
			if (lockAspect) {
				// Calculate the height from the change in width
				var ratio = px / this._bounds2d.x;
				this.height(this._bounds2d.y * ratio);
			}

			this._bounds2d.x = px;
			this._bounds2d.x2 = (px / 2);
			return this;
		}

		return this._bounds2d.x;
	},

	/**
	 * Gets / sets the geometry y value.
	 * @param {Number=} px The new y value in pixels.
	 * @example #Set the height of the entity
	 *     entity.height(40);
	 * @return {*} "this" when arguments are passed to allow method
	 * chaining or the current value if no arguments are specified.
	 */
	height: function (px, lockAspect) {
		if (px !== undefined) {
			if (lockAspect) {
				// Calculate the width from the change in height
				var ratio = px / this._bounds2d.y;
				this.width(this._bounds2d.x * ratio);
			}

			this._bounds2d.y = px;
			this._bounds2d.y2 = (px / 2);
			return this;
		}

		return this._bounds2d.y;
	},
	
	/**
	 * Gets / sets the 2d geometry of the entity. The x and y values are
	 * relative to the center of the entity. This geometry is used when
	 * rendering textures for the entity and positioning in world space as
	 * well as UI positioning calculations. It holds no bearing on isometric
	 * positioning.
	 * @param {Number=} x The new x value in pixels.
	 * @param {Number=} y The new y value in pixels.
	 * @example #Set the dimensions of the entity (width and height)
	 *     entity.bounds2d(40, 40);
	 * @return {*} "this" when arguments are passed to allow method
	 * chaining or the current value if no arguments are specified.
	 */
	bounds2d: function (x, y) {
		if (x !== undefined && y !== undefined) {
			this._bounds2d = new IgePoint2d(x, y, 0);
			return this;
		}
		
		if (x !== undefined && y === undefined) {
			// x is considered an IgePoint2d instance
			this._bounds2d = new IgePoint2d(x.x, x.y);
		}

		return this._bounds2d;
	},

	/**
	 * Gets / sets the 3d geometry of the entity. The x and y values are
	 * relative to the center of the entity and the z value is wholly
	 * positive from the "floor". Used to define a 3d bounding cuboid for
	 * the entity used in isometric depth sorting and hit testing.
	 * @param {Number=} x The new x value in pixels.
	 * @param {Number=} y The new y value in pixels.
	 * @param {Number=} z The new z value in pixels.
	 * @example #Set the dimensions of the entity (width, height and length)
	 *     entity.bounds3d(40, 40, 20);
	 * @return {*} "this" when arguments are passed to allow method
	 * chaining or the current value if no arguments are specified.
	 */
	bounds3d: function (x, y, z) {
		if (x !== undefined && y !== undefined && z !== undefined) {
			this._bounds3d = new IgePoint3d(x, y, z);
			return this;
		}

		return this._bounds3d;
	},

	/**
	 * @deprecated Use bounds3d instead
	 * @param x
	 * @param y
	 * @param z
	 */
	size3d: function (x, y, z) {
		this.log('size3d has been renamed to bounds3d but is exactly the same so please search/replace your code to update calls.', 'warning');
	},

	/**
	 * Gets / sets the life span of the object in milliseconds. The life
	 * span is how long the object will exist for before being automatically
	 * destroyed.
	 * @param {Number=} milliseconds The number of milliseconds the entity
	 * will live for from the current time.
	 * @param {Function=} deathCallback Optional callback method to call when
	 * the entity is destroyed from end of lifespan.
	 * @example #Set the lifespan of the entity to 2 seconds after which it will automatically be destroyed
	 *     entity.lifeSpan(2000);
	 * @return {*} "this" when arguments are passed to allow method
	 * chaining or the current value if no arguments are specified.
	 */
	lifeSpan: function (milliseconds, deathCallback) {
		if (milliseconds !== undefined) {
			this.deathTime(ige._currentTime + milliseconds, deathCallback);
			return this;
		}

		return this.deathTime() - ige._currentTime;
	},

	/**
	 * Gets / sets the timestamp in milliseconds that denotes the time
	 * that the entity will be destroyed. The object checks it's own death
	 * time during each tick and if the current time is greater than the
	 * death time, the object will be destroyed.
	 * @param {Number=} val The death time timestamp. This is a time relative
	 * to the engine's start time of zero rather than the current time that
	 * would be retrieved from new Date().getTime(). It is usually easier
	 * to call lifeSpan() rather than setting the deathTime directly.
	 * @param {Function=} deathCallback Optional callback method to call when
	 * the entity is destroyed from end of lifespan.
	 * @example #Set the death time of the entity to 60 seconds after engine start
	 *     entity.deathTime(60000);
	 * @return {*} "this" when arguments are passed to allow method
	 * chaining or the current value if no arguments are specified.
	 */
	deathTime: function (val, deathCallback) {
		if (val !== undefined) {
			this._deathTime = val;
			
			if (deathCallback !== undefined) {
				this._deathCallBack = deathCallback;
			}
			return this;
		}

		return this._deathTime;
	},

	/**
	 * Gets / sets the entity opacity from 0.0 to 1.0.
	 * @param {Number=} val The opacity value.
	 * @example #Set the entity to half-visible
	 *     entity.opacity(0.5);
	 * @example #Set the entity to fully-visible
	 *     entity.opacity(1.0);
	 * @return {*} "this" when arguments are passed to allow method
	 * chaining or the current value if no arguments are specified.
	 */
	opacity: function (val) {
		if (val !== undefined) {
			this._opacity = val;
			return this;
		}

		return this._opacity;
	},

	/**
	 * Gets / sets the noAabb flag that determines if the entity's axis
	 * aligned bounding box should be calculated every tick or not. If
	 * you don't need the AABB data (for instance if you don't need to
	 * detect mouse events on this entity or you DO want the AABB to be
	 * updated but want to control it manually by calling aabb(true) 
	 * yourself as needed).
	 * @param {Boolean=} val If set to true will turn off AABB calculation.
	 * @returns {*}
	 */
	noAabb: function (val) {
		if (val !== undefined) {
			this._noAabb = val;
			return this;
		}

		return this._noAabb;
	},

	/**
	 * Gets / sets the texture to use when rendering the entity.
	 * @param {IgeTexture=} texture The texture object.
	 * @example #Set the entity texture (image)
	 *     var texture = new IgeTexture('path/to/some/texture.png');
	 *     entity.texture(texture);
	 * @return {*} "this" when arguments are passed to allow method
	 * chaining or the current value if no arguments are specified.
	 */
	texture: function (texture) {
		if (texture !== undefined) {
			this._texture = texture;
			return this;
		}

		return this._texture;
	},

	/**
	 * Gets / sets the current texture cell used when rendering the game
	 * object's texture. If the texture is not cell-based, this value is
	 * ignored.
	 * @param {Number=} val The cell index.
	 * @example #Set the entity texture as a 4x4 cell sheet and then set the cell to use
	 *     var texture = new IgeCellSheet('path/to/some/cellSheet.png', 4, 4);
	 *     entity.texture(texture)
	 *         .cell(3);
	 * @return {*} "this" when arguments are passed to allow method
	 * chaining or the current value if no arguments are specified.
	 */
	cell: function (val) {
		if (val > 0 || val === null) {
			this._cell = val;
			return this;
		}

		return this._cell;
	},

	/**
	 * Gets / sets the current texture cell used when rendering the game
	 * object's texture. If the texture is not cell-based, this value is
	 * ignored. This differs from cell() in that it accepts a string id
	 * as the cell
	 * @param {Number=} val The cell id.
	 * @example #Set the entity texture as a sprite sheet with cell ids and then set the cell to use
	 *     var texture = new IgeSpriteSheet('path/to/some/cellSheet.png', [
	 *         [0, 0, 40, 40, 'robotHead'],
	 *         [40, 0, 40, 40, 'humanHead'],
	 *     ]);
	 *     
	 *     // Assign the texture, set the cell to use and then
	 *     // set the entity to the size of the cell automatically!
	 *     entity.texture(texture)
	 *         .cellById('robotHead')
	 *         .dimensionsFromCell();
	 * @return {*} "this" when arguments are passed to allow method
	 * chaining or the current value if no arguments are specified.
	 */
	cellById: function (val) {
		if (val !== undefined) {
			if (this._texture) {
				// Find the cell index this id corresponds to
				var i,
					tex = this._texture,
					cells = tex._cells;

				for (i = 1; i < cells.length; i++) {
					if (cells[i][4] === val) {
						// Found the cell id so assign this cell index
						this.cell(i);
						return this;
					}
				}

				// We were unable to find the cell index from the cell
				// id so produce an error
				this.log('Could not find the cell id "' + val + '" in the assigned entity texture ' + tex.id() + ', please check your sprite sheet (texture) cell definition to ensure the cell id "' + val + '" has been assigned to a cell!', 'error');
			} else {
				this.log('Cannot assign cell index from cell ID until an IgeSpriteSheet has been set as the texture for this entity. Please set the texture before calling cellById().', 'error');
			}
		}

		return this._cell;
	},

	/**
	 * Sets the geometry of the entity to match the width and height
	 * of the assigned texture.
	 * @param {Number=} percent The percentage size to resize to.
	 * @example #Set the entity dimensions based on the assigned texture
	 *     var texture = new IgeTexture('path/to/some/texture.png');
	 *	
	 *     // Assign the texture, and then set the entity to the
	 *     // size of the texture automatically!
	 *     entity.texture(texture)
	 *         .dimensionsFromTexture();
	 * @return {*} The object this method was called from to allow
	 * method chaining.
	 */
	dimensionsFromTexture: function (percent) {
		if (this._texture) {
			if (percent === undefined) {
				this.width(this._texture._sizeX);
				this.height(this._texture._sizeY);
			} else {
				this.width(Math.floor(this._texture._sizeX / 100 * percent));
				this.height(Math.floor(this._texture._sizeY / 100 * percent));
			}

			// Recalculate localAabb
			this.localAabb(true);
		}

		return this;
	},

	/**
	 * Sets the geometry of the entity to match the width and height
	 * of the assigned texture cell. If the texture is not cell-based
	 * the entire texture width / height will be used.
	 * @param {Number=} percent The percentage size to resize to.
	 * @example #Set the entity dimensions based on the assigned texture and cell
	 *     var texture = new IgeSpriteSheet('path/to/some/cellSheet.png', [
	 *         [0, 0, 40, 40, 'robotHead'],
	 *         [40, 0, 40, 40, 'humanHead'],
	 *     ]);
	 *
	 *     // Assign the texture, set the cell to use and then
	 *     // set the entity to the size of the cell automatically!
	 *     entity.texture(texture)
	 *         .cellById('robotHead')
	 *         .dimensionsFromCell();
	 * @return {*} The object this method was called from to allow
	 * method chaining
	 */
	dimensionsFromCell: function (percent) {
		if (this._texture) {
			if (this._texture._cells && this._texture._cells.length) {
				if (percent === undefined) {
					this.width(this._texture._cells[this._cell][2]);
					this.height(this._texture._cells[this._cell][3]);
				} else {
					this.width(Math.floor(this._texture._cells[this._cell][2] / 100 * percent));
					this.height(Math.floor(this._texture._cells[this._cell][3] / 100 * percent));
				}
				
				// Recalculate localAabb
				this.localAabb(true);
			}
		}

		return this;
	},

	/**
	 * Gets / sets the highlight mode. True is on false is off.
	 * @param {Boolean} val The highlight mode true, false or optionally a string representing a globalCompositeOperation.
	 * https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Compositing
	 * @example #Set the entity to render highlighted
	 *     entity.highlight(true);
	 * @example #Set the entity to render highlighted using 'screen' globalCompositeOperation
	 *     entity.highlight('screen');
	 * @example #Get the current highlight state
	 *     var isHighlighted = entity.highlight();
	 * @return {*} "this" when arguments are passed to allow method
	 * chaining or the current value if no arguments are specified.
	 */
	highlight: function (val) {
		if (val !== undefined) {
			this._highlight = val;
			return this;
		}

		return this._highlight;
	},

	/**
	 * Returns the absolute world position of the entity as an
	 * IgePoint3d.
	 * @example #Get the world position of the entity
	 *     var wordPos = entity.worldPosition();
	 * @return {IgePoint3d} The absolute world position of the
	 * entity.
	 */
	worldPosition: function () {
		return new IgePoint3d(this._worldMatrix.matrix[2], this._worldMatrix.matrix[5], 0);
	},

	/**
	 * Returns the absolute world rotation z of the entity as a
	 * value in radians.
	 * @example #Get the world rotation of the entity's z axis
	 *     var wordRot = entity.worldRotationZ();
	 * @return {Number} The absolute world rotation z of the
	 * entity.
	 */
	worldRotationZ: function () {
		return this._worldMatrix.rotationRadians();
	},

	/**
	 * Converts an array of points from local space to this entity's
	 * world space using it's world transform matrix. This will alter
	 * the points passed in the array directly.
	 * @param {Array} points The array of IgePoints to convert.
	 */
	localToWorld: function (points, viewport, inverse) {
		viewport = viewport || ige._currentViewport;
		
		if (this._adjustmentMatrix) {
			// Apply the optional adjustment matrix
			this._worldMatrix.multiply(this._adjustmentMatrix);
		}
		
		if (!inverse) {
			this._worldMatrix.transform(points, this);
		} else {
			this._localMatrix.transform(points, this);
			//this._worldMatrix.getInverse().transform(points, this);
		}

		if (this._ignoreCamera) {
			//viewport.camera._worldMatrix.transform(points, this);
		}
	},

	/**
	 * Converts a point from local space to this entity's world space
	 * using it's world transform matrix. This will alter the point's
	 * data directly.
	 * @param {IgePoint3d} point The IgePoint3d to convert.
	 */
	localToWorldPoint: function (point, viewport) {
		viewport = viewport || ige._currentViewport;
		this._worldMatrix.transform([point], this);
	},
	
	/**
	 * Returns the screen position of the entity as an IgePoint3d where x is the
	 * "left" and y is the "top", useful for positioning HTML elements at the
	 * screen location of an IGE entity. This method assumes that the top-left
	 * of the main canvas element is at 0, 0. If not you can adjust the values
	 * yourself to allow for offset.
	 * @example #Get the screen position of the entity
	 *     var screenPos = entity.screenPosition();
	 * @return {IgePoint3d} The screen position of the entity.
	 */
	screenPosition: function () {
		return new IgePoint3d(
			Math.floor(((this._worldMatrix.matrix[2] - ige._currentCamera._translate.x) * ige._currentCamera._scale.x) + ige._bounds2d.x2),
			Math.floor(((this._worldMatrix.matrix[5] - ige._currentCamera._translate.y) * ige._currentCamera._scale.y) + ige._bounds2d.y2),
			0
		);
	},
	
	/**
	 * @deprecated Use bounds3dPolygon instead
	 */
	localIsoBoundsPoly: function () {},
	
	localBounds3dPolygon: function (recalculate) {
		if (this._bounds3dPolygonDirty || !this._localBounds3dPolygon || recalculate) {
			var geom = this._bounds3d,
				poly = new IgePoly2d(),
				// Bottom face
				bf2 = Math.toIso(+(geom.x2), -(geom.y2),  -(geom.z2)),
				bf3 = Math.toIso(+(geom.x2), +(geom.y2),  -(geom.z2)),
				bf4 = Math.toIso(-(geom.x2), +(geom.y2),  -(geom.z2)),
				// Top face
				tf1 = Math.toIso(-(geom.x2), -(geom.y2),  (geom.z2)),
				tf2 = Math.toIso(+(geom.x2), -(geom.y2),  (geom.z2)),
				tf4 = Math.toIso(-(geom.x2), +(geom.y2),  (geom.z2));
			
			poly.addPoint(tf1.x, tf1.y)
				.addPoint(tf2.x, tf2.y)
				.addPoint(bf2.x, bf2.y)
				.addPoint(bf3.x, bf3.y)
				.addPoint(bf4.x, bf4.y)
				.addPoint(tf4.x, tf4.y)
				.addPoint(tf1.x, tf1.y);
			
			this._localBounds3dPolygon = poly;
			this._bounds3dPolygonDirty = false;
		}
		
		return this._localBounds3dPolygon;
	},
	
	/**
	 * @deprecated Use bounds3dPolygon instead
	 */
	isoBoundsPoly: function () {},
	
	bounds3dPolygon: function (recalculate) {
		if (this._bounds3dPolygonDirty || !this._bounds3dPolygon || recalculate) {
			var poly = this.localBounds3dPolygon(recalculate).clone();
			
			// Convert local co-ordinates to world based on entities world matrix
			this.localToWorld(poly._poly);
			
			this._bounds3dPolygon = poly;
		}
		
		return this._bounds3dPolygon;
	},

	/**
	 * @deprecated Use mouseInBounds3d instead
	 */
	mouseInIsoBounds: function () {},
	
	mouseInBounds3d: function (recalculate) {
		var poly = this.localBounds3dPolygon(recalculate),
			mp = this.mousePos();
		
		return poly.pointInside(mp);
	},

	/**
	 * Calculates and returns the current axis-aligned bounding box in
	 * world co-ordinates.
	 * @param {Boolean=} recalculate If true this will force the
	 * recalculation of the AABB instead of returning a cached
	 * value.
	 * @example #Get the entity axis-aligned bounding box dimensions
	 *     var aabb = entity.aabb();
	 *     
	 *     console.log(aabb.x);
	 *     console.log(aabb.y);
	 *     console.log(aabb.width);
	 *     console.log(aabb.height);
	 * @example #Get the entity axis-aligned bounding box dimensions forcing the engine to update the values first
	 *     var aabb = entity.aabb(true); // Call with true to force update
	 *     
	 *     console.log(aabb.x);
	 *     console.log(aabb.y);
	 *     console.log(aabb.width);
	 *     console.log(aabb.height);
	 * @return {IgeRect} The axis-aligned bounding box in world co-ordinates.
	 */
	aabb: function (recalculate, inverse) {
		if (this._aabbDirty || !this._aabb || recalculate) { //  && this.newFrame()
			var poly = new IgePoly2d(),
				minX, minY,
				maxX, maxY,
				box,
				anc = this._anchor,
				ancX = anc.x,
				ancY = anc.y,
				geom,
				geomX2,
				geomY2,
				x, y;

			geom = this._bounds2d;
			geomX2 = geom.x2;
			geomY2 = geom.y2;
			
			x = geomX2;
			y = geomY2;

			poly.addPoint(-x + ancX, -y + ancY);
			poly.addPoint(x + ancX, -y + ancY);
			poly.addPoint(x + ancX, y + ancY);
			poly.addPoint(-x + ancX, y + ancY);

			this._renderPos = {x: -x + ancX, y: -y + ancY};

			// Convert the poly's points from local space to world space
			this.localToWorld(poly._poly, null, inverse);

			// Get the extents of the newly transformed poly
			minX = Math.min(
				poly._poly[0].x,
				poly._poly[1].x,
				poly._poly[2].x,
				poly._poly[3].x
			);

			minY = Math.min(
				poly._poly[0].y,
				poly._poly[1].y,
				poly._poly[2].y,
				poly._poly[3].y
			);

			maxX = Math.max(
				poly._poly[0].x,
				poly._poly[1].x,
				poly._poly[2].x,
				poly._poly[3].x
			);

			maxY = Math.max(
				poly._poly[0].y,
				poly._poly[1].y,
				poly._poly[2].y,
				poly._poly[3].y
			);

			box = new IgeRect(minX, minY, maxX - minX, maxY - minY);

			this._aabb = box;
			this._aabbDirty = false;
		}

		return this._aabb;
	},

	/**
	 * Calculates and returns the local axis-aligned bounding box
	 * for the entity. This is the AABB relative to the entity's
	 * center point.
	 * @param {Boolean=} recalculate If true this will force the
	 * recalculation of the local AABB instead of returning a cached
	 * value.
	 * @example #Get the entity local axis-aligned bounding box dimensions
	 *     var aabb = entity.localAabb();
	 *	
	 *     console.log(aabb.x);
	 *     console.log(aabb.y);
	 *     console.log(aabb.width);
	 *     console.log(aabb.height);
	 * @example #Get the entity local axis-aligned bounding box dimensions forcing the engine to update the values first
	 *     var aabb = entity.localAabb(true); // Call with true to force update
	 *	
	 *     console.log(aabb.x);
	 *     console.log(aabb.y);
	 *     console.log(aabb.width);
	 *     console.log(aabb.height);
	 * @return {IgeRect} The local AABB.
	 */
	localAabb: function (recalculate) {
		if (!this._localAabb || recalculate) {
			var aabb = this.aabb();
			this._localAabb = new IgeRect(-Math.floor(aabb.width / 2), -Math.floor(aabb.height / 2), Math.floor(aabb.width), Math.floor(aabb.height));
		}

		return this._localAabb;
	},

	/**
	 * Calculates the axis-aligned bounding box for this entity, including
	 * all child entity bounding boxes and returns the final composite
	 * bounds.
	 * @example #Get the composite AABB
	 *     var entity = new IgeEntity(),
	 *         aabb = entity.compositeAabb();
	 * @return {IgeRect}
	 */
	compositeAabb: function (inverse) {
		var arr = this._children,
			arrCount,
			rect;
	
		if (inverse) {
			rect = this.aabb(true, inverse).clone();
		} else {
			rect = this.aabb().clone();	
		}

		// Now loop all children and get the aabb for each of them
		// them add those bounds to the current rect
		if (arr) {
			arrCount = arr.length;

			while (arrCount--) {
				rect.thisCombineRect(arr[arrCount].compositeAabb(inverse));
			}
		}

		return rect;
	},

	/**
	 * Gets / sets the composite stream flag. If set to true, any objects
	 * mounted to this one will have their streamMode() set to the same
	 * value as this entity and will also have their compositeStream flag
	 * set to true. This allows you to easily automatically stream any
	 * objects mounted to a root object and stream them all.
	 * @param val
	 * @returns {*}
	 */
	compositeStream: function (val) {
		if (val !== undefined) {
			this._compositeStream = val;
			return this;
		}
		
		return this._compositeStream;
	},

	/**
	 * Override the _childMounted method and apply entity-based flags.
	 * @param {IgeEntity} child
	 * @private
	 */
	_childMounted: function (child) {
		// Check if we need to set the compositeStream and streamMode
		if (this.compositeStream()) {
			child.compositeStream(true);
			child.streamMode(this.streamMode());
			child.streamControl(this.streamControl());
		}
		
		IgeObject.prototype._childMounted.call(this, child);
				
		// Check if we are compositeCached and update the cache
		if (this.compositeCache()) {
			this.cacheDirty(true);
		}
	},
	
	/**
	 * Takes two values and returns them as an array where index [0]
	 * is the y argument and index[1] is the x argument. This method
	 * is used specifically in the 3d bounds intersection process to
	 * determine entity depth sorting.
	 * @param {Number} x The first value.
	 * @param {Number} y The second value.
	 * @return {Array} The swapped arguments.
	 * @private
	 */
	_swapVars: function (x, y) {
		return [y, x];
	},

	_internalsOverlap: function (x0, x1, y0, y1) {
		var tempSwap;

		if (x0 > x1) {
			tempSwap = this._swapVars(x0, x1);
			x0 = tempSwap[0];
			x1 = tempSwap[1];
		}

		if (y0 > y1) {
			tempSwap = this._swapVars(y0, y1);
			y0 = tempSwap[0];
			y1 = tempSwap[1];
		}

		if (x0 > y0) {
			tempSwap = this._swapVars(x0, y0);
			x0 = tempSwap[0];
			y0 = tempSwap[1];

			tempSwap = this._swapVars(x1, y1);
			x1 = tempSwap[0];
			y1 = tempSwap[1];
		}

		return y0 < x1;
	},

	_projectionOverlap: function (otherObject) {
		var thisG3d = this._bounds3d,
			thisMin = {
				x: this._translate.x - thisG3d.x / 2,
				y: this._translate.y - thisG3d.y / 2,
				z: this._translate.z - thisG3d.z
			},
			thisMax = {
				x: this._translate.x + thisG3d.x / 2,
				y: this._translate.y + thisG3d.y / 2,
				z: this._translate.z + thisG3d.z
			},
			otherG3d = otherObject._bounds3d,
			otherMin = {
				x: otherObject._translate.x - otherG3d.x / 2,
				y: otherObject._translate.y - otherG3d.y / 2,
				z: otherObject._translate.z - otherG3d.z
			},
			otherMax = {
				x: otherObject._translate.x + otherG3d.x / 2,
				y: otherObject._translate.y + otherG3d.y / 2,
				z: otherObject._translate.z + otherG3d.z
			};

		return this._internalsOverlap(
			thisMin.x - thisMax.y,
			thisMax.x - thisMin.y,
			otherMin.x - otherMax.y,
			otherMax.x - otherMin.y
		) && this._internalsOverlap(
			thisMin.x - thisMax.z,
			thisMax.x - thisMin.z,
			otherMin.x - otherMax.z,
			otherMax.x - otherMin.z
		) && this._internalsOverlap(
			thisMin.z - thisMax.y,
			thisMax.z - thisMin.y,
			otherMin.z - otherMax.y,
			otherMax.z - otherMin.y
		);
	},

	/**
	 * Compares the current entity's 3d bounds to the passed entity and
	 * determines if the current entity is "behind" the passed one. If an
	 * entity is behind another, it is drawn first during the scenegraph
	 * render phase.
	 * @param {IgeEntity} otherObject The other entity to check this
	 * entity's 3d bounds against.
	 * @example #Determine if this entity is "behind" another entity based on the current depth-sort 
	 *     var behind = entity.isBehind(otherEntity);
	 * @return {Boolean} If true this entity is "behind" the passed entity
	 * or false if not.
	 */
	isBehind: function (otherObject) {
		var thisG3d = this._bounds3d,
			otherG3d = otherObject._bounds3d,
			thisTranslate = this._translate.clone(),
			otherTranslate = otherObject._translate.clone();

		// thisTranslate.thisToIso();
		// otherTranslate.thisToIso();

		if(this._origin.x !== 0.5 || this._origin.y !== 0.5) {
			thisTranslate.x += this._bounds2d.x * (0.5 - this._origin.x)
			thisTranslate.y += this._bounds2d.y * (0.5 - this._origin.y)
		}
		if(otherObject._origin.x !== 0.5 || otherObject._origin.y !== 0.5) {
			otherTranslate.x += otherObject._bounds2d.x * (0.5 - otherObject._origin.x)
			otherTranslate.y += otherObject._bounds2d.y * (0.5 - otherObject._origin.y)
		}

		var
			thisX = thisTranslate.x,
			thisY = thisTranslate.y,
			otherX = otherTranslate.x,
			otherY = otherTranslate.y,
			thisMin = new IgePoint3d(
				thisX - thisG3d.x / 2,
				thisY - thisG3d.y / 2,
				this._translate.z
			),
			thisMax = new IgePoint3d(
				thisX + thisG3d.x / 2,
				thisY + thisG3d.y / 2,
				this._translate.z + thisG3d.z
			),		
			otherMin = new IgePoint3d(
				otherX - otherG3d.x / 2,
				otherY - otherG3d.y / 2,
				otherObject._translate.z
			),
			otherMax = new IgePoint3d(
				otherX + otherG3d.x / 2,
				otherY + otherG3d.y / 2,
				otherObject._translate.z + otherG3d.z
			);

		if (thisMax.x <= otherMin.x) {
			return false;
		}

		if (otherMax.x <= thisMin.x) {
			return true;
		}

		if (thisMax.y <= otherMin.y) {
			return false;
		}

		if (otherMax.y <= thisMin.y) {
			return true;
		}

		if (thisMax.z <= otherMin.z) {
			return false;
		}

		if (otherMax.z <= thisMin.z) {
			return true;
		}

		return (thisX + thisY + this._translate.z) > (otherX + otherY + otherObject._translate.z);
	},

	/**
	 * Get / set the flag determining if this entity will respond
	 * to mouse interaction or not. When you set a mouse* event e.g.
	 * mouseUp, mouseOver etc this flag will automatically be reset
	 * to true.
	 * @param {Boolean=} val The flag value true or false.
	 * @example #Set entity to ignore mouse events
	 *     entity.mouseEventsActive(false);
	 * @example #Set entity to receive mouse events
	 *     entity.mouseEventsActive(true);
	 * @example #Get current flag value
	 *     var val = entity.mouseEventsActive();
	 * @return {*} "this" when arguments are passed to allow method
	 * chaining or the current value if no arguments are specified.
	 */
	mouseEventsActive: function (val) {
		if (val !== undefined) {
			this._mouseEventsActive = val;
			return this;
		}

		return this._mouseEventsActive;
	},

	/**
	 * Sets the _ignoreCamera internal flag to the value passed for this
	 * and all child entities down the scenegraph.
	 * @param val
	 */
	ignoreCameraComposite: function (val) {
		var i,
			arr = this._children,
			arrCount = arr.length;
		
		this._ignoreCamera = val;
		
		for (i = 0; i < arrCount; i++) {
			if (arr[i].ignoreCameraComposite) {
				arr[i].ignoreCameraComposite(val);
			}
		}
	},

	/**
	 * Determines if the frame alternator value for this entity
	 * matches the engine's frame alternator value. The entity's
	 * frame alternator value will be set to match the engine's
	 * after each call to the entity.tick() method so the return
	 * value of this method can be used to determine if the tick()
	 * method has already been run for this entity.
	 *
	 * This is useful if you have multiple viewports which will
	 * cause the entity tick() method to fire once for each viewport
	 * but you only want to execute update code such as movement etc
	 * on the first time the tick() method is called.
	 * 
	 * @example #Determine if the entity has already had it's tick method called
	 *     var tickAlreadyCalled = entity.newFrame();
	 * @return {Boolean} If false, the entity's tick method has
	 * not yet been processed for this tick.
	 */
	newFrame: function () {
		return ige._frameAlternator !== this._frameAlternatorCurrent;
	},

	/**
	 * Sets the canvas context transform properties to match the the game
	 * object's current transform values.
	 * @param {CanvasRenderingContext2D} ctx The canvas context to apply
	 * the transformation matrix to.
	 * @example #Transform a canvas context to the entity's local matrix values
	 *     var canvas = document.createElement('canvas');
	 *     canvas.width = 800;
	 *     canvas.height = 600;
	 *
	 *     var ctx = canvas.getContext('2d');
	 *     entity._transformContext(ctx);
	 * @private
	 */
	_transformContext: function (ctx, inverse) {
		if (this._parent) {
			ctx.globalAlpha = this._computedOpacity = this._parent._computedOpacity * this._opacity;
		} else {
			ctx.globalAlpha = this._computedOpacity = this._opacity;
		}

		if (!inverse) {
			this._localMatrix.transformRenderingContext(ctx);
		} else {
			this._localMatrix.getInverse().transformRenderingContext(ctx);
		}
	},
	
	mouseAlwaysInside: function (val) {
		if (val !== undefined) {
			this._mouseAlwaysInside = val;
			return this;
		}
		
		return this._mouseAlwaysInside;
	},
	
	/**
	 * Processes the updates required each render frame. Any code in the update()
	 * method will be called ONCE for each render frame BEFORE the tick() method.
	 * This differs from the tick() method in that the tick method can be called
	 * multiple times during a render frame depending on how many viewports your
	 * simulation is being rendered to, whereas the update() method is only called
	 * once. It is therefore the perfect place to put code that will control your
	 * entity's motion, AI etc.
	 * @param {CanvasRenderingContext2D} ctx The canvas context to render to.
	 */
	update: function (ctx, tickDelta) {
		// Check if the entity should still exist
		if (this._deathTime !== undefined && this._deathTime <= ige._tickStart) {
			// Check if the deathCallBack was set
			if (this._deathCallBack) {
				this._deathCallBack.apply(this);
				delete this._deathCallback;
			}
			
			// The entity should be removed because it has died
			this.destroy();
		} else {
			// Check that the entity has been born
			if (this._bornTime === undefined || ige._currentTime >= this._bornTime) {
				// Remove the stream data cache
				delete this._streamDataCache;
	
				// Process any behaviours assigned to the entity
				this._processUpdateBehaviours(ctx, tickDelta);
				
				// Process velocity
				if (this._velocity.x || this._velocity.y) {
					this._translate.x += (this._velocity.x / 16) * tickDelta;
					this._translate.y += (this._velocity.y / 16) * tickDelta;
				}
	
				if (this._timeStream.length) {
					// Process any interpolation
					this._processInterpolate(ige._tickStart - ige.network.stream._renderLatency);
				}
	
				// Check for changes to the transform values
				// directly without calling the transform methods
				this.updateTransform();
	
				if (!this._noAabb && this._aabbDirty) {
					// Update the aabb
					this.aabb();
				}
	
				this._oldTranslate = this._translate.clone();
	
				// Update this object's current frame alternator value
				// which allows us to determine if we are still on the
				// same frame
				this._frameAlternatorCurrent = ige._frameAlternator;
			} else {
				// The entity is not yet born, unmount it and add to the spawn queue
				this._birthMount = this._parent.id();
				this.unMount();
				
				ige.spawnQueue(this);
			}
		}

		// Process super class
		IgeObject.prototype.update.call(this, ctx, tickDelta);
	},

	/**
	 * Processes the actions required each render frame.
	 * @param {CanvasRenderingContext2D} ctx The canvas context to render to.
	 * @param {Boolean} dontTransform If set to true, the tick method will
	 * not transform the context based on the entity's matrices. This is useful
	 * if you have extended the class and want to process down the inheritance
	 * chain but have already transformed the entity in a previous overloaded
	 * method.
	 */
	tick: function (ctx, dontTransform) {
		if (!this._hidden && this._inView && (!this._parent || (this._parent._inView)) && !this._streamJustCreated) {
			// Process any behaviours assigned to the entity
			this._processTickBehaviours(ctx);
			
			// Process any mouse events we need to do
			if (this._mouseEventsActive) {
				if (this._processTriggerHitTests()) {
					// Point is inside the trigger bounds
					ige.input.queueEvent(this, this._mouseInTrigger, null);
				} else {
					if (ige.input.mouseMove) {
						// There is a mouse move event but we are not inside the entity
						// so fire a mouse out event (_handleMouseOut will check if the
						// mouse WAS inside before firing an out event).
						this._handleMouseOut(ige.input.mouseMove);
					}
				}
			}

			if (!this._dontRender) {
				// Check for cached version
				if (this._cache || this._compositeCache) {
					// Caching is enabled
					if (this._cacheDirty) {
						// The cache is dirty, redraw it
						this._refreshCache(dontTransform);
					}
					
					// Now render the cached image data to the main canvas
					this._renderCache(ctx);
				} else {
					// Non-cached output
					// Transform the context by the current transform settings
					if (!dontTransform) {
						this._transformContext(ctx);
					}
					
					// Render the entity
					this._renderEntity(ctx, dontTransform);
				}
			}

			// Process any automatic-mode stream updating required
			if (this._streamMode === 1) {
				this.streamSync();
			}

			if (this._compositeCache) {
				if (this._cacheDirty) {
					// Process children
					IgeObject.prototype.tick.call(this, this._cacheCtx);
					this._renderCache(ctx);
					this._cacheDirty = false;
				}
			} else {
				// Process children
				IgeObject.prototype.tick.call(this, ctx);
			}
		}
	},
	
	_processTriggerHitTests: function () {
		var mp, mouseTriggerPoly;

		if (ige._currentViewport) {
			if (!this._mouseAlwaysInside) {
				mp = this.mousePosWorld();
	
				if (mp) {
					// Use the trigger polygon if defined
					if (this._triggerPolygon && this[this._triggerPolygon]) {
						mouseTriggerPoly = this[this._triggerPolygon](mp);
					} else {
						// Default to either aabb or bounds3dPolygon depending on entity parent mounting mode
						if (this._parent && this._parent._mountMode === 1) {
							// Use bounds3dPolygon
							mouseTriggerPoly = this.bounds3dPolygon();
						} else {
							// Use aabb
							mouseTriggerPoly = this.aabb();
						}
					}
					
					// Check if the current mouse position is inside this aabb
					return mouseTriggerPoly.xyInside(mp.x, mp.y);
				}
			} else {
				return true;
			}
		}
		
		return false;
	},
	
	_refreshCache: function (dontTransform) {
		// The cache is not clean so re-draw it
		// Render the entity to the cache
		var _canvas = this._cacheCanvas,
			_ctx = this._cacheCtx;

		if (this._compositeCache) {
			// Get the composite entity AABB and alter the internal canvas
			// to the composite size so we can render the entire entity
			var aabbC = this.compositeAabb(true);
			
			this._compositeAabbCache = aabbC;
			
			if (aabbC.width > 0 && aabbC.height > 0) {
				_canvas.width = Math.ceil(aabbC.width);
				_canvas.height = Math.ceil(aabbC.height);
			} else {
				// We cannot set a zero size for a canvas, it will
				// cause the browser to freak out
				_canvas.width = 2;
				_canvas.height = 2;
			}
			
			// Translate to the center of the canvas
			_ctx.translate(-aabbC.x, -aabbC.y);

			/**
			 * Fires when the entity's composite cache is ready.
			 * @event IgeEntity#compositeReady
			 */
			this.emit('compositeReady');
		} else {
			if (this._bounds2d.x > 0 && this._bounds2d.y > 0) {
				_canvas.width = this._bounds2d.x;
				_canvas.height = this._bounds2d.y;
			} else {
				// We cannot set a zero size for a canvas, it will
				// cause the browser to freak out
				_canvas.width = 1;
				_canvas.height = 1;
			}
			
			// Translate to the center of the canvas
			_ctx.translate(this._bounds2d.x2, this._bounds2d.y2);
			
			this._cacheDirty = false;
		}
		
		// Transform the context by the current transform settings
		if (!dontTransform) {
			this._transformContext(_ctx);
		}
		
		this._renderEntity(_ctx, dontTransform);
	},

	/**
	 * Handles calling the texture.render() method if a texture
	 * is applied to the entity. This part of the tick process has
	 * been abstracted to allow it to be overridden by an extending
	 * class.
	 * @param {CanvasRenderingContext2D} ctx The canvas context to render
	 * the entity to.
	 * @private
	 */
	_renderEntity: function (ctx) {
		if (this._opacity > 0) {
			// Check if the entity has a background pattern
			if (this._backgroundPattern) {
				if (!this._backgroundPatternFill) {
					// We have a pattern but no fill produced
					// from it. Check if we have a context to
					// generate a pattern from
					if (ctx) {
						// Produce the pattern fill
						this._backgroundPatternFill = ctx.createPattern(this._backgroundPattern.image, this._backgroundPatternRepeat);
					}
				}

				if (this._backgroundPatternFill) {
					// Draw the fill
					ctx.save();
					ctx.fillStyle = this._backgroundPatternFill;

					// TODO: When firefox has fixed their bug regarding negative rect co-ordinates, revert this change

					// This is the proper way to do this but firefox has a bug which I'm gonna report
					// so instead I have to use ANOTHER translate call instead. So crap!
					//ctx.rect(-this._bounds2d.x2, -this._bounds2d.y2, this._bounds2d.x, this._bounds2d.y);
					ctx.translate(-this._bounds2d.x2, -this._bounds2d.y2);
					ctx.rect(0, 0, this._bounds2d.x, this._bounds2d.y);
					if (this._backgroundPatternTrackCamera) {
						ctx.translate(-ige._currentCamera._translate.x, -ige._currentCamera._translate.y);
						ctx.scale(ige._currentCamera._scale.x, ige._currentCamera._scale.y);
					}
					ctx.fill();
					ige._drawCount++;

					if (this._backgroundPatternIsoTile) {
						ctx.translate(-Math.floor(this._backgroundPattern.image.width) / 2, -Math.floor(this._backgroundPattern.image.height / 2));
						ctx.fill();
						ige._drawCount++;
					}

					ctx.restore();
				}
			}

			var texture = this._texture;

			// Check if the entity is visible based upon its opacity
			if (texture && texture._loaded) {
				// Draw the entity image
				texture.render(ctx, this, ige._tickDelta);

				if (this._highlight) {
					ctx.globalCompositeOperation = this._highlightToGlobalCompositeOperation(this._highlight);
					texture.render(ctx, this);
				}
			}
			
			if (this._compositeCache && ige._currentViewport._drawCompositeBounds) {
				//console.log('moo');
				ctx.fillStyle = 'rgba(0, 0, 255, 0.3)';
				ctx.fillRect(-this._bounds2d.x2, -this._bounds2d.y2, this._bounds2d.x,	this._bounds2d.y);
				ctx.fillStyle = '#ffffff';
				ctx.fillText('Composite Entity', -this._bounds2d.x2, -this._bounds2d.y2 - 15);
				ctx.fillText(this.id(), -this._bounds2d.x2, -this._bounds2d.y2 - 5);
			}
		}
	},

	/**
	 * Draws the cached off-screen canvas image data to the passed canvas
	 * context.
	 * @param {CanvasRenderingContext2D} ctx The canvas context to render
	 * the entity to.
	 * @private
	 */
	_renderCache: function (ctx) {
		ctx.save();
		if (this._compositeCache) {
			var aabbC = this._compositeAabbCache;
			ctx.translate(this._bounds2d.x2 + aabbC.x, this._bounds2d.y2 + aabbC.y);
			
			if (this._parent && this._parent._ignoreCamera) {
				// Translate the entity back to negate the scene translate
				var cam = ige._currentCamera;
				//ctx.translate(-cam._translate.x, -cam._translate.y);
				/*this.scaleTo(1 / cam._scale.x, 1 / cam._scale.y, 1 / cam._scale.z);
				this.rotateTo(-cam._rotate.x, -cam._rotate.y, -cam._rotate.z);*/
			}
		}
		
		// We have a clean cached version so output that
		ctx.drawImage(
			this._cacheCanvas,
			-this._bounds2d.x2, -this._bounds2d.y2
		);
		
		if (ige._currentViewport._drawCompositeBounds) {
			ctx.fillStyle = 'rgba(0, 255, 0, 0.5)';
			ctx.fillRect(-this._bounds2d.x2, -this._bounds2d.y2, this._cacheCanvas.width,	this._cacheCanvas.height);
			ctx.fillStyle = '#ffffff';
			ctx.fillText('Composite Cache', -this._bounds2d.x2, -this._bounds2d.y2 - 15);
			ctx.fillText(this.id(), -this._bounds2d.x2, -this._bounds2d.y2 - 5);
		}

		ige._drawCount++;

		if (this._highlight) {
			ctx.globalCompositeOperation = this._highlightToGlobalCompositeOperation(this._highlight);
			ctx.drawImage(
				this._cacheCanvas,
				-this._bounds2d.x2, -this._bounds2d.y2
			);

			ige._drawCount++;
		}
		ctx.restore();
	},

	/**
	 * Transforms a point by the entity's parent world matrix and
	 * it's own local matrix transforming the point to this entity's
	 * world space.
	 * @param {IgePoint3d} point The point to transform.
	 * @example #Transform a point by the entity's world matrix values
	 *     var point = new IgePoint3d(0, 0, 0);
	 *     entity._transformPoint(point);
	 *     
	 *     console.log(point);
	 * @return {IgePoint3d} The transformed point.
	 * @private
	 */
	_transformPoint: function (point) {
		if (this._parent) {
			var tempMat = new IgeMatrix2d();
			// Copy the parent world matrix
			tempMat.copy(this._parent._worldMatrix);
			// Apply any local transforms
			tempMat.multiply(this._localMatrix);
			// Now transform the point
			tempMat.getInverse().transformCoord(point, this);
		} else {
			this._localMatrix.transformCoord(point, this);
		}

		return point;
	},
	
	/**
	 * Helper method to transform an array of points using _transformPoint.
	 * @param {Array} points The points array to transform.
	 * @private
	 */
	_transformPoints: function (points) {
		var point, pointCount = points.length;
		
		while (pointCount--) {
			point = points[pointCount];
			if (this._parent) {
				var tempMat = new IgeMatrix2d();
				// Copy the parent world matrix
				tempMat.copy(this._parent._worldMatrix);
				// Apply any local transforms
				tempMat.multiply(this._localMatrix);
				// Now transform the point
				tempMat.getInverse().transformCoord(point, this);
			} else {
				this._localMatrix.transformCoord(point, this);
			}
		}
	},

	/**
	 * Generates a string containing a code fragment that when
	 * evaluated will reproduce this object's properties via
	 * chained commands. This method will only check for
	 * properties that are directly related to this class.
	 * Other properties are handled by their own class method.
	 * @return {String} The string code fragment that will
	 * reproduce this entity when evaluated.
	 */
	_stringify: function (options) {
		// Make sure we have an options object
		if (options === undefined) { options = {}; }
		
		// Get the properties for all the super-classes
		var str = IgeObject.prototype._stringify.call(this, options), i;

		// Loop properties and add property assignment code to string
		for (i in this) {
			if (this.hasOwnProperty(i) && this[i] !== undefined) {
				switch (i) {
					case '_opacity':
						str += ".opacity(" + this.opacity() + ")";
						break;
					case '_texture':
						str += ".texture(ige.$('" + this.texture().id() + "'))";
						break;
					case '_cell':
						str += ".cell(" + this.cell() + ")";
						break;
					case '_translate':
						if (options.transform !== false && options.translate !== false) {
							str += ".translateTo(" + this._translate.x + ", " + this._translate.y + ", " + this._translate.z + ")";
						}
						break;
					case '_rotate':
						if (options.transform !== false && options.rotate !== false) {
							str += ".rotateTo(" + this._rotate.x + ", " + this._rotate.y + ", " + this._rotate.z + ")";
						}
						break;
					case '_scale':
						if (options.transform !== false && options.scale !== false) {
							str += ".scaleTo(" + this._scale.x + ", " + this._scale.y + ", " + this._scale.z + ")";
						}
						break;
					case '_origin':
						if (options.origin !== false) {
							str += ".originTo(" + this._origin.x + ", " + this._origin.y + ", " + this._origin.z + ")";
						}
						break;
					case '_anchor':
						if (options.anchor !== false) {
							str += ".anchor(" + this._anchor.x + ", " + this._anchor.y + ")";
						}
						break;
					case '_width':
						if (typeof(this.width()) === 'string') {
							str += ".width('" + this.width() + "')";
						} else {
							str += ".width(" + this.width() + ")";
						}
						break;
					case '_height':
						if (typeof(this.height()) === 'string') {
							str += ".height('" + this.height() + "')";
						} else {
							str += ".height(" + this.height() + ")";
						}
						break;
					case '_bounds3d':
						str += ".bounds3d(" + this._bounds3d.x + ", " + this._bounds3d.y + ", " + this._bounds3d.z + ")";
						break;
					case '_deathTime':
						if (options.deathTime !== false && options.lifeSpan !== false) {
							str += ".deathTime(" + this.deathTime() + ")";
						}
						break;
					case '_highlight':
						str += ".highlight(" + this.highlight() + ")";
						break;
				}
			}
		}

		return str;
	},

	/**
	 * Destroys the entity by removing it from the scenegraph,
	 * calling destroy() on any child entities and removing
	 * any active event listeners for the entity. Once an entity
	 * has been destroyed it's this._alive flag is also set to
	 * false.
	 * @example #Destroy the entity
	 *     entity.destroy();
	 */
	destroy: function () {
		this._alive = false;
		
		/* CEXCLUDE */
		// Check if the entity is streaming
		if (this._streamMode === 1) {
			delete this._streamDataCache;
			this.streamDestroy();
		}
		/* CEXCLUDE */
		
		/**
		 * Fires when the entity has been destroyed.
		 * @event IgeEntity#destroyed
		 * @param {IgeEntity} The entity that has been destroyed. 
		 */
		this.emit('destroyed', this);

		// Call IgeObject.destroy()
		IgeObject.prototype.destroy.call(this);
	},
	
	saveSpecialProp: function (obj, i) {
		switch (i) {
			case '_texture':
				if (obj._texture) {
					return {_texture: obj._texture.id()};
				}
				break;
			
			default:
				// Call super-class saveSpecialProp
				return IgeObject.prototype.saveSpecialProp.call(this, obj, i);
				break;
		}
		
		return undefined;
	},
	
	loadSpecialProp: function (obj, i) {
		switch (i) {
			case '_texture':
				return {_texture: ige.$(obj[i])};
				break;
			
			default:
				// Call super-class loadSpecialProp
				return IgeObject.prototype.loadSpecialProp.call(this, obj, i);
				break;
		}
		
		return undefined;
	},

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// INTERACTION
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	/**
	 * Gets / sets the callback that is fired when a mouse
	 * move event is triggered.
	 * @param {Function=} callback
	 * @example #Hook the mouse move event and stop it propagating further down the scenegraph
	 *     entity.mouseMove(function (event, control) {
	 *         // Mouse moved with button
	 *         console.log('Mouse move button: ' + event.button);
	 *         
	 *         // Stop the event propagating further down the scenegraph
	 *         control.stopPropagation();
	 *         
	 *         // You can ALSO stop propagation without the control object
	 *         // reference via the global reference:
	 *         ige.input.stopPropagation();
	 *     });
	 * @return {*}
	 */
	mouseMove: function (callback) {
		if (callback) {
			this._mouseMove = callback;
			this._mouseEventsActive = true;
			return this;
		}

		return this._mouseMove;
	},

	/**
	 * Gets / sets the callback that is fired when a mouse
	 * over event is triggered.
	 * @param {Function=} callback
	 * @example #Hook the mouse over event and stop it propagating further down the scenegraph
	 *     entity.mouseOver(function (event, control) {
	 *         // Mouse over with button
	 *         console.log('Mouse over button: ' + event.button);
	 *         
	 *         // Stop the event propagating further down the scenegraph
	 *         control.stopPropagation();
	 *         
	 *         // You can ALSO stop propagation without the control object
	 *         // reference via the global reference:
	 *         ige.input.stopPropagation();
	 *     });
	 * @return {*}
	 */
	mouseOver: function (callback) {
		if (callback) {
			this._mouseOver = callback;
			this._mouseEventsActive = true;
			return this;
		}

		return this._mouseOver;
	},

	/**
	 * Gets / sets the callback that is fired when a mouse
	 * out event is triggered.
	 * @param {Function=} callback
	 * @example #Hook the mouse out event and stop it propagating further down the scenegraph
	 *     entity.mouseOut(function (event, control) {
	 *         // Mouse out with button
	 *         console.log('Mouse out button: ' + event.button);
	 *         
	 *         // Stop the event propagating further down the scenegraph
	 *         control.stopPropagation();
	 *         
	 *         // You can ALSO stop propagation without the control object
	 *         // reference via the global reference:
	 *         ige.input.stopPropagation();
	 *     });
	 * @return {*}
	 */
	mouseOut: function (callback) {
		if (callback) {
			this._mouseOut = callback;
			this._mouseEventsActive = true;
			return this;
		}

		return this._mouseOut;
	},

	/**
	 * Gets / sets the callback that is fired when a mouse
	 * up event is triggered.
	 * @param {Function=} callback
	 * @example #Hook the mouse up event and stop it propagating further down the scenegraph
	 *     entity.mouseUp(function (event, control) {
	 *         // Mouse up with button
	 *         console.log('Mouse up button: ' + event.button);
	 *         
	 *         // Stop the event propagating further down the scenegraph
	 *         control.stopPropagation();
	 *         
	 *         // You can ALSO stop propagation without the control object
	 *         // reference via the global reference:
	 *         ige.input.stopPropagation();
	 *     });
	 * @return {*}
	 */
	mouseUp: function (callback) {
		if (callback) {
			this._mouseUp = callback;
			this._mouseEventsActive = true;
			return this;
		}

		return this._mouseUp;
	},

	/**
	 * Gets / sets the callback that is fired when a mouse
	 * down event is triggered.
	 * @param {Function=} callback
	 * @example #Hook the mouse down event and stop it propagating further down the scenegraph
	 *     entity.mouseDown(function (event, control) {
	 *         // Mouse down with button
	 *         console.log('Mouse down button: ' + event.button);
	 *         
	 *         // Stop the event propagating further down the scenegraph
	 *         control.stopPropagation();
	 *         
	 *         // You can ALSO stop propagation without the control object
	 *         // reference via the global reference:
	 *         ige.input.stopPropagation();
	 *     });
	 * @return {*}
	 */
	mouseDown: function (callback) {
		if (callback) {
			this._mouseDown = callback;
			this._mouseEventsActive = true;
			return this;
		}

		return this._mouseDown;
	},
	
	/**
	 * Gets / sets the callback that is fired when a mouse
	 * wheel event is triggered.
	 * @param {Function=} callback
	 * @example #Hook the mouse wheel event and stop it propagating further down the scenegraph
	 *     entity.mouseWheel(function (event, control) {
	 *         // Mouse wheel with button
	 *         console.log('Mouse wheel button: ' + event.button);
	 *         console.log('Mouse wheel delta: ' + event.wheelDelta);
	 *         
	 *         // Stop the event propagating further down the scenegraph
	 *         control.stopPropagation();
	 *         
	 *         // You can ALSO stop propagation without the control object
	 *         // reference via the global reference:
	 *         ige.input.stopPropagation();
	 *     });
	 * @return {*}
	 */
	mouseWheel: function (callback) {
		if (callback) {
			this._mouseWheel = callback;
			this._mouseEventsActive = true;
			return this;
		}

		return this._mouseWheel;
	},
	
	/**
	 * Removes the callback that is fired when a mouse
	 * move event is triggered.
	 */
	mouseMoveOff: function () {
		delete this._mouseMove;

		return this;
	},

	/**
	 * Removes the callback that is fired when a mouse
	 * over event is triggered.
	 */
	mouseOverOff: function () {
		delete this._mouseOver;

		return this;
	},
	
	/**
	 * Removes the callback that is fired when a mouse
	 * out event is triggered.
	 */
	mouseOutOff: function () {
		delete this._mouseOut;

		return this;
	},

	/**
	 * Removes the callback that is fired when a mouse
	 * up event is triggered.
	 */
	mouseUpOff: function () {
		delete this._mouseUp;

		return this;
	},
	
	/**
	 * Removes the callback that is fired when a mouse
	 * down event is triggered if the listener was registered
	 * via the mouseDown() method.
	 */
	mouseDownOff: function () {
		delete this._mouseDown;

		return this;
	},

	/**
	 * Removes the callback that is fired when a mouse
	 * wheel event is triggered.
	 */
	mouseWheelOff: function () {
		delete this._mouseWheel;

		return this;
	},
	
	triggerPolygon: function (poly) {
		if (poly !== undefined) {
			this._triggerPolygon = poly;
			return this;
		}
		
		return this._triggerPolygon;
	},

	/**
	 * Gets / sets the shape / polygon that the mouse events
	 * are triggered against. There are two options, 'aabb' and
	 * 'isoBounds'. The default is 'aabb'.
	 * @param val
	 * @returns {*}
	 * @deprecated
	 */
	mouseEventTrigger: function (val) {
		this.log('mouseEventTrigger is no longer in use. Please see triggerPolygon() instead.', 'warning');
		/*if (val !== undefined) {
			// Set default value
			this._mouseEventTrigger = 0;
			
			switch (val) {
				case 'isoBounds':
					this._mouseEventTrigger = 1;
					break;
				
				case 'custom':
					this._mouseEventTrigger = 2;
					break;
				
				case 'aabb':
					this._mouseEventTrigger = 0;
					break;
			}
			return this;
		}
		
		return this._mouseEventTrigger === 0 ? 'aabb' : 'isoBounds';*/
	},

	/**
	 * Handler method that determines which mouse-move event
	 * to fire, a mouse-over or a mouse-move.
	 * @private
	 */
	_handleMouseIn: function (event, evc, data) {
		// Check if the mouse move is a mouse over
		if (!this._mouseStateOver) {
			this._mouseStateOver = true;
			if (this._mouseOver) { this._mouseOver(event, evc, data); }
			
			/**
			 * Fires when the mouse moves over the entity.
			 * @event IgeEntity#mouseOver
			 * @param {Object} The DOM event object.
			 * @param {Object} The IGE event control object.
			 * @param {*} Any further event data.
			 */
			this.emit('mouseOver', [event, evc, data]);
		}

		if (this._mouseMove) { this._mouseMove(event, evc, data); }
		this.emit('mouseMove', [event, evc, data]);
	},

	/**
	 * Handler method that determines if a mouse-out event
	 * should be fired.
	 * @private
	 */
	_handleMouseOut: function (event, evc, data) {
		// The mouse went away from this entity so
		// set mouse-down to false, regardless of the situation
		this._mouseStateDown = false;

		// Check if the mouse move is a mouse out
		if (this._mouseStateOver) {
			this._mouseStateOver = false;
			if (this._mouseOut) { this._mouseOut(event, evc, data); }
			
			/**
			 * Fires when the mouse moves away from the entity.
			 * @event IgeEntity#mouseOut
			 * @param {Object} The DOM event object.
			 * @param {Object} The IGE event control object.
			 * @param {*} Any further event data.
			 */
			this.emit('mouseOut', [event, evc, data]);
		}
	},
	
	/**
	 * Handler method that determines if a mouse-wheel event
	 * should be fired.
	 * @private
	 */
	_handleMouseWheel: function (event, evc, data) {
		if (this._mouseWheel) { this._mouseWheel(event, evc, data); }
		
		/**
		 * Fires when the mouse wheel is moved over the entity.
		 * @event IgeEntity#mouseWheel
		 * @param {Object} The DOM event object.
		 * @param {Object} The IGE event control object.
		 * @param {*} Any further event data.
		 */
		this.emit('mouseWheel', [event, evc, data]);
	},

	/**
	 * Handler method that determines if a mouse-up event
	 * should be fired.
	 * @private
	 */
	_handleMouseUp: function (event, evc, data) {
		// Reset the mouse-down flag
		this._mouseStateDown = false;
		if (this._mouseUp) { this._mouseUp(event, evc, data); }
		
		/**
		 * Fires when a mouse up occurs on the entity.
		 * @event IgeEntity#mouseUp
		 * @param {Object} The DOM event object.
		 * @param {Object} The IGE event control object.
		 * @param {*} Any further event data.
		 */
		this.emit('mouseUp', [event, evc, data]);
	},

	/**
	 * Handler method that determines if a mouse-down event
	 * should be fired.
	 * @private
	 */
	_handleMouseDown: function (event, evc, data) {
		if (!this._mouseStateDown) {
			this._mouseStateDown = true;
			if (this._mouseDown) { this._mouseDown(event, evc, data); }
			
			/**
			 * Fires when a mouse down occurs on the entity.
			 * @event IgeEntity#mouseDown
			 * @param {Object} The DOM event object.
			 * @param {Object} The IGE event control object.
			 * @param {*} Any further event data.
			 */
			this.emit('mouseDown', [event, evc, data]);
		}
	},
	
	/**
	 * Checks mouse input types and fires the correct mouse event
	 * handler. This is an internal method that should never be
	 * called externally.
	 * @param {Object} evc The input component event control object.
	 * @param {Object} data Data passed by the input component into
	 * the new event.
	 * @private
	 */
	_mouseInTrigger: function (evc, data) {
		if (ige.input.mouseMove) {
			// There is a mouse move event
			this._handleMouseIn(ige.input.mouseMove, evc, data);
		}

		if (ige.input.mouseDown) {
			// There is a mouse down event
			this._handleMouseDown(ige.input.mouseDown, evc, data);
		}

		if (ige.input.mouseUp) {
			// There is a mouse up event
			this._handleMouseUp(ige.input.mouseUp, evc, data);
		}
		
		if (ige.input.mouseWheel) {
			// There is a mouse wheel event
			this._handleMouseWheel(ige.input.mouseWheel, evc, data);
		}
	},
	
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// TRANSFORM
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	/**
	 * Enables tracing calls which inadvertently assign NaN values to
	 * transformation properties. When called on an entity this system
	 * will break with a debug line when a transform property is set
	 * to NaN allowing you to step back through the call stack and 
	 * determine where the offending value originated.
	 * @returns {IgeEntity}
	 */
	debugTransforms: function () {
		ige.traceSet(this._translate, 'x', 1, function (val) {
			return isNaN(val);
		});
		
		ige.traceSet(this._translate, 'y', 1, function (val) {
			return isNaN(val);
		});
		
		ige.traceSet(this._translate, 'z', 1, function (val) {
			return isNaN(val);
		});
		
		ige.traceSet(this._rotate, 'x', 1, function (val) {
			return isNaN(val);
		});
		
		ige.traceSet(this._rotate, 'y', 1, function (val) {
			return isNaN(val);
		});
		
		ige.traceSet(this._rotate, 'z', 1, function (val) {
			return isNaN(val);
		});
		
		ige.traceSet(this._scale, 'x', 1, function (val) {
			return isNaN(val);
		});
		
		ige.traceSet(this._scale, 'y', 1, function (val) {
			return isNaN(val);
		});
		
		ige.traceSet(this._scale, 'z', 1, function (val) {
			return isNaN(val);
		});
		
		return this;
	},
	
	velocityTo: function (x, y, z) {
		if (x !== undefined && y!== undefined && z !== undefined) {
			this._velocity.x = x;
			this._velocity.y = y;
			this._velocity.z = z;
		} else {
			this.log('velocityTo() called with a missing or undefined x, y or z parameter!', 'error');
		}

		return this._entity || this;
	},
	
	velocityBy: function (x, y, z) {
		if (x !== undefined && y!== undefined && z !== undefined) {
			this._velocity.x += x;
			this._velocity.y += y;
			this._velocity.z += z;
		} else {
			this.log('velocityBy() called with a missing or undefined x, y or z parameter!', 'error');
		}

		return this._entity || this;
	},
	
	/**
	 * Translates the entity by adding the passed values to
	 * the current translation values.
	 * @param {Number} x The x co-ordinate.
	 * @param {Number} y The y co-ordinate.
	 * @param {Number} z The z co-ordinate.
	 * @example #Translate the entity by 10 along the x axis
	 *     entity.translateBy(10, 0, 0);
	 * @return {*}
	 */
	translateBy: function (x, y, z) {
		if (x !== undefined && y!== undefined && z !== undefined) {
			this._translate.x += x;
			this._translate.y += y;
			this._translate.z += z;
		} else {
			this.log('translateBy() called with a missing or undefined x, y or z parameter!', 'error');
		}

		return this._entity || this;
	},

	/**
	 * Translates the entity to the passed values.
	 * @param {Number} x The x co-ordinate.
	 * @param {Number} y The y co-ordinate.
	 * @param {Number} z The z co-ordinate.
	 * @example #Translate the entity to 10, 0, 0
	 *     entity.translateTo(10, 0, 0);
	 * @return {*}
	 */
	translateTo: function (x, y, z) {
		if (x !== undefined && y!== undefined && z !== undefined) {
			this._translate.x = x;
			this._translate.y = y;
			this._translate.z = z;
		} else {
			this.log('translateTo() called with a missing or undefined x, y or z parameter!', 'error');
		}

		return this._entity || this;
	},

	/**
	 * Translates the entity to the passed point.
	 * @param {IgePoint3d} point The point with co-ordinates.
	 * @example #Translate the entity to 10, 0, 0
	 *     var point = new IgePoint3d(10, 0, 0),
	 *         entity = new IgeEntity();
	 *     
	 *     entity.translateToPoint(point);
	 * @return {*}
	 */
	translateToPoint: function (point) {
		if (point !== undefined) {
			this._translate.x = point.x;
			this._translate.y = point.y;
			this._translate.z = point.z;
		} else {
			this.log('translateToPoint() called with a missing or undefined point parameter!', 'error');
		}

		return this._entity || this;
	},
	
	/**
	 * Translates the object to the tile co-ordinates passed.
	 * @param {Number} x The x tile co-ordinate.
	 * @param {Number} y The y tile co-ordinate.
	 * @param {Number=} z The z tile co-ordinate.
	 * @example #Translate entity to tile
	 *     // Create a tile map
	 *     var tileMap = new IgeTileMap2d()
	 *         .tileWidth(40)
	 *         .tileHeight(40);
	 *     
	 *     // Mount our entity to the tile map
	 *     entity.mount(tileMap);
	 *     
	 *     // Translate the entity to the tile x:10, y:12
	 *     entity.translateToTile(10, 12, 0);
	 * @return {*} The object this method was called from to allow
	 * method chaining.
	 */
	translateToTile: function (x, y, z) {
		if (this._parent && this._parent._tileWidth !== undefined && this._parent._tileHeight !== undefined) {
			var finalZ;

			// Handle being passed a z co-ordinate
			if (z !== undefined) {
				finalZ = z * this._parent._tileWidth;
			} else {
				finalZ = this._translate.z;
			}

			this.translateTo((x * this._parent._tileWidth) + this._parent._tileWidth / 2, (y * this._parent._tileHeight) + this._parent._tileWidth / 2, finalZ);
		} else {
			this.log('Cannot translate to tile because the entity is not currently mounted to a tile map or the tile map has no tileWidth or tileHeight values.', 'warning');
		}

		return this;
	},

	/**
	 * Gets the translate accessor object.
	 * @example #Use the translate accessor object to alter the y co-ordinate of the entity to 10
	 *     entity.translate().y(10);
	 * @return {*}
	 */
	translate: function () {
		if (arguments.length) {
			this.log('You called translate with arguments, did you mean translateTo or translateBy instead of translate?', 'warning');
		}

		this.x = this._translateAccessorX;
		this.y = this._translateAccessorY;
		this.z = this._translateAccessorZ;

		return this._entity || this;
	},

	/**
	 * The translate accessor method for the x axis. This
	 * method is not called directly but is accessed through
	 * the accessor object obtained by calling entity.translate().
	 * @param {Number=} val The new value to apply to the co-ordinate.
	 * @return {*}
	 * @private
	 */
	_translateAccessorX: function (val) {
		if (val !== undefined) {
			this._translate.x = val;
			return this._entity || this;
		}

		return this._translate.x;
	},

	/**
	 * The translate accessor method for the y axis. This
	 * method is not called directly but is accessed through
	 * the accessor object obtained by calling entity.translate().
	 * @param {Number=} val The new value to apply to the co-ordinate.
	 * @return {*}
	 * @private
	 */
	_translateAccessorY: function (val) {
		if (val !== undefined) {
			this._translate.y = val;
			return this._entity || this;
		}

		return this._translate.y;
	},

	/**
	 * The translate accessor method for the z axis. This
	 * method is not called directly but is accessed through
	 * the accessor object obtained by calling entity.translate().
	 * @param {Number=} val The new value to apply to the co-ordinate.
	 * @return {*}
	 * @private
	 */
	_translateAccessorZ: function (val) {
		// TODO: Do we need to do anything to the matrix here for iso views?
		//this._localMatrix.translateTo(this._translate.x, this._translate.y);
		if (val !== undefined) {
			this._translate.z = val;
			return this._entity || this;
		}

		return this._translate.z;
	},

	/**
	 * Rotates the entity by adding the passed values to
	 * the current rotation values.
	 * @param {Number} x The x co-ordinate.
	 * @param {Number} y The y co-ordinate.
	 * @param {Number} z The z co-ordinate.
	 * @example #Rotate the entity by 10 degrees about the z axis
	 *     entity.rotateBy(0, 0, Math.radians(10));
	 * @return {*}
	 */
	rotateBy: function (x, y, z) {
		if (x !== undefined && y!== undefined && z !== undefined) {
			this._rotate.x += x;
			this._rotate.y += y;
			this._rotate.z += z;
		} else {
			this.log('rotateBy() called with a missing or undefined x, y or z parameter!', 'error');
		}

		return this._entity || this;
	},

	/**
	 * Rotates the entity to the passed values.
	 * @param {Number} x The x co-ordinate.
	 * @param {Number} y The y co-ordinate.
	 * @param {Number} z The z co-ordinate.
	 * @example #Rotate the entity to 10 degrees about the z axis
	 *     entity.rotateTo(0, 0, Math.radians(10));
	 * @return {*}
	 */
	rotateTo: function (x, y, z) {
		if (x !== undefined && y!== undefined && z !== undefined) {
			this._rotate.x = x;
			this._rotate.y = y;
			this._rotate.z = z;
		} else {
			this.log('rotateTo() called with a missing or undefined x, y or z parameter!', 'error');
		}

		return this._entity || this;
	},

	/**
	 * Gets the translate accessor object.
	 * @example #Use the rotate accessor object to rotate the entity about the z axis 10 degrees
	 *     entity.rotate().z(Math.radians(10));
	 * @return {*}
	 */
	rotate: function () {
		if (arguments.length) {
			this.log('You called rotate with arguments, did you mean rotateTo or rotateBy instead of rotate?', 'warning');
		}
		
		this.x = this._rotateAccessorX;
		this.y = this._rotateAccessorY;
		this.z = this._rotateAccessorZ;

		return this._entity || this;
	},

	/**
	 * The rotate accessor method for the x axis. This
	 * method is not called directly but is accessed through
	 * the accessor object obtained by calling entity.rotate().
	 * @param {Number=} val The new value to apply to the co-ordinate.
	 * @return {*}
	 * @private
	 */
	_rotateAccessorX: function (val) {
		if (val !== undefined) {
			this._rotate.x = val;
			return this._entity || this;
		}

		return this._rotate.x;
	},

	/**
	 * The rotate accessor method for the y axis. This
	 * method is not called directly but is accessed through
	 * the accessor object obtained by calling entity.rotate().
	 * @param {Number=} val The new value to apply to the co-ordinate.
	 * @return {*}
	 * @private
	 */
	_rotateAccessorY: function (val) {
		if (val !== undefined) {
			this._rotate.y = val;
			return this._entity || this;
		}

		return this._rotate.y;
	},

	/**
	 * The rotate accessor method for the z axis. This
	 * method is not called directly but is accessed through
	 * the accessor object obtained by calling entity.rotate().
	 * @param {Number=} val The new value to apply to the co-ordinate.
	 * @return {*}
	 * @private
	 */
	_rotateAccessorZ: function (val) {
		if (val !== undefined) {
			this._rotate.z = val;
			return this._entity || this;
		}

		return this._rotate.z;
	},

	/**
	 * Scales the entity by adding the passed values to
	 * the current scale values.
	 * @param {Number} x The x co-ordinate.
	 * @param {Number} y The y co-ordinate.
	 * @param {Number} z The z co-ordinate.
	 * @example #Scale the entity by 2 on the x axis
	 *     entity.scaleBy(2, 0, 0);
	 * @return {*}
	 */
	scaleBy: function (x, y, z) {
		if (x !== undefined && y!== undefined && z !== undefined) {
			this._scale.x += x;
			this._scale.y += y;
			this._scale.z += z;
		} else {
			this.log('scaleBy() called with a missing or undefined x, y or z parameter!', 'error');
		}

		return this._entity || this;
	},

	/**
	 * Scale the entity to the passed values.
	 * @param {Number} x The x co-ordinate.
	 * @param {Number} y The y co-ordinate.
	 * @param {Number} z The z co-ordinate.
	 * @example #Set the entity scale to 1 on all axes
	 *     entity.scaleTo(1, 1, 1);
	 * @return {*}
	 */
	scaleTo: function (x, y, z) {
		if (x !== undefined && y!== undefined && z !== undefined) {
			this._scale.x = x;
			this._scale.y = y;
			this._scale.z = z;
		} else {
			this.log('scaleTo() called with a missing or undefined x, y or z parameter!', 'error');
		}

		return this._entity || this;
	},

	/**
	 * Gets the scale accessor object.
	 * @example #Use the scale accessor object to set the scale of the entity on the x axis to 1
	 *     entity.scale().x(1);
	 * @return {*}
	 */
	scale: function () {
		if (arguments.length) {
			this.log('You called scale with arguments, did you mean scaleTo or scaleBy instead of scale?', 'warning');
		}
		
		this.x = this._scaleAccessorX;
		this.y = this._scaleAccessorY;
		this.z = this._scaleAccessorZ;

		return this._entity || this;
	},

	/**
	 * The scale accessor method for the x axis. This
	 * method is not called directly but is accessed through
	 * the accessor object obtained by calling entity.scale().
	 * @param {Number=} val The new value to apply to the co-ordinate.
	 * @return {*}
	 * @private
	 */
	_scaleAccessorX: function (val) {
		if (val !== undefined) {
			this._scale.x = val;
			return this._entity || this;
		}

		return this._scale.x;
	},

	/**
	 * The scale accessor method for the y axis. This
	 * method is not called directly but is accessed through
	 * the accessor object obtained by calling entity.scale().
	 * @param {Number=} val The new value to apply to the co-ordinate.
	 * @return {*}
	 * @private
	 */
	_scaleAccessorY: function (val) {
		if (val !== undefined) {
			this._scale.y = val;
			return this._entity || this;
		}

		return this._scale.y;
	},

	/**
	 * The scale accessor method for the z axis. This
	 * method is not called directly but is accessed through
	 * the accessor object obtained by calling entity.scale().
	 * @param {Number=} val The new value to apply to the co-ordinate.
	 * @return {*}
	 * @private
	 */
	_scaleAccessorZ: function (val) {
		if (val !== undefined) {
			this._scale.z = val;
			return this._entity || this;
		}

		return this._scale.z;
	},

	/**
	 * Sets the origin of the entity by adding the passed values to
	 * the current origin values.
	 * @param {Number} x The x co-ordinate.
	 * @param {Number} y The y co-ordinate.
	 * @param {Number} z The z co-ordinate.
	 * @example #Add 0.5 to the origin on the x axis
	 *     entity.originBy(0.5, 0, 0);
	 * @return {*}
	 */
	originBy: function (x, y, z) {
		if (x !== undefined && y!== undefined && z !== undefined) {
			this._origin.x += x;
			this._origin.y += y;
			this._origin.z += z;
		} else {
			this.log('originBy() called with a missing or undefined x, y or z parameter!', 'error');
		}

		return this._entity || this;
	},

	/**
	 * Set the origin of the entity to the passed values.
	 * @param {Number} x The x co-ordinate.
	 * @param {Number} y The y co-ordinate.
	 * @param {Number} z The z co-ordinate.
	 * @example #Set the entity origin to 0.5 on all axes
	 *     entity.originTo(0.5, 0.5, 0.5);
	 * @return {*}
	 */
	originTo: function (x, y, z) {
		if (x !== undefined && y!== undefined && z !== undefined) {
			this._origin.x = x;
			this._origin.y = y;
			this._origin.z = z;
		} else {
			this.log('originTo() called with a missing or undefined x, y or z parameter!', 'error');
		}

		return this._entity || this;
	},

	/**
	 * Gets the origin accessor object.
	 * @example #Use the origin accessor object to set the origin of the entity on the x axis to 1
	 *     entity.origin().x(1);
	 * @return {*}
	 */
	origin: function () {
		this.x = this._originAccessorX;
		this.y = this._originAccessorY;
		this.z = this._originAccessorZ;

		return this._entity || this;
	},

	/**
	 * The origin accessor method for the x axis. This
	 * method is not called directly but is accessed through
	 * the accessor object obtained by calling entity.origin().
	 * @param {Number=} val The new value to apply to the co-ordinate.
	 * @return {*}
	 * @private
	 */
	_originAccessorX: function (val) {
		if (val !== undefined) {
			this._origin.x = val;
			return this._entity || this;
		}

		return this._origin.x;
	},

	/**
	 * The origin accessor method for the y axis. This
	 * method is not called directly but is accessed through
	 * the accessor object obtained by calling entity.origin().
	 * @param {Number=} val The new value to apply to the co-ordinate.
	 * @return {*}
	 * @private
	 */
	_originAccessorY: function (val) {
		if (val !== undefined) {
			this._origin.y = val;
			return this._entity || this;
		}

		return this._origin.y;
	},

	/**
	 * The origin accessor method for the z axis. This
	 * method is not called directly but is accessed through
	 * the accessor object obtained by calling entity.origin().
	 * @param {Number=} val The new value to apply to the co-ordinate.
	 * @return {*}
	 * @private
	 */
	_originAccessorZ: function (val) {
		if (val !== undefined) {
			this._origin.z = val;
			return this._entity || this;
		}

		return this._origin.z;
	},

	_rotatePoint: function (point, radians, origin) {
		var cosAngle = Math.cos(radians),
			sinAngle = Math.sin(radians);

		return {
			x: origin.x + (point.x - origin.x) * cosAngle + (point.y - origin.y) * sinAngle,
			y: origin.y - (point.x - origin.x) * sinAngle + (point.y - origin.y) * cosAngle
		};
	},

	/**
	 * Checks the current transform values against the previous ones. If
	 * any value is different, the appropriate method is called which will
	 * update the transformation matrix accordingly.
	 */
	updateTransform: function () {
		this._localMatrix.identity();
		
		if (this._mode === 0) {
			// 2d translation
			this._localMatrix.multiply(this._localMatrix._newTranslate(this._translate.x, this._translate.y));
		}

		if (this._mode === 1) {
			// iso translation
			var isoPoint = this._translateIso = new IgePoint3d(
				this._translate.x,
				this._translate.y,
				this._translate.z + this._bounds3d.z / 2
			).toIso();

			if (this._parent && this._parent._bounds3d.z) {
				// This adjusts the child entity so that 0, 0, 0 inside the
				// parent is the center of the base of the parent
				isoPoint.y += this._parent._bounds3d.z / 1.6;
			}

			this._localMatrix.multiply(this._localMatrix._newTranslate(isoPoint.x, isoPoint.y));
		}
		
		this._localMatrix.rotateBy(this._rotate.z);
		this._localMatrix.scaleBy(this._scale.x, this._scale.y);
		
		// Adjust local matrix for origin values if not at center
		if (this._origin.x !== 0.5 || this._origin.y !== 0.5) {
			this._localMatrix.translateBy(
				(this._bounds2d.x * (0.5 - this._origin.x)),
				(this._bounds2d.y * (0.5 - this._origin.y))
			);
		}
		
		// TODO: If the parent and local transforms are unchanged, we should used cached values
		if (this._parent) {
			this._worldMatrix.copy(this._parent._worldMatrix);
			this._worldMatrix.multiply(this._localMatrix);
		} else {
			this._worldMatrix.copy(this._localMatrix);
		}
		
		// Check if the world matrix has changed and if so, set a few flags
		// to allow other methods to know that a matrix change has occurred
		if (!this._worldMatrix.compare(this._oldWorldMatrix)) {
			this._oldWorldMatrix.copy(this._worldMatrix);
			this._transformChanged = true;
			this._aabbDirty = true;
			this._bounds3dPolygonDirty = true;
		} else {
			this._transformChanged = false;
		}
		
		// Check if the geometry has changed and if so, update the aabb dirty
		if (!this._oldBounds2d.compare(this._bounds2d)) {
			this._aabbDirty = true;
			
			// Record the new geometry to the oldGeometry data
			this._oldBounds2d.copy(this._bounds2d);
		}
		
		if (!this._oldBounds3d.compare(this._bounds3d)) {
			this._bounds3dPolygonDirty = true;
			
			// Record the new geometry to the oldGeometry data
			this._oldBounds3d.copy(this._bounds3d);
		}
		
		return this;
	},

	/**
	 * Gets / sets the disable interpolation flag. If set to true then
	 * stream data being received by the client will not be interpolated
	 * and will be instantly assigned instead. Useful if your entity's
	 * transformations should not be interpolated over time.
	 * @param val
	 * @returns {*}
	 */
	disableInterpolation: function (val) {
		if (val !== undefined) {
			this._disableInterpolation = val;
			return this;
		}
		
		return this._disableInterpolation;
	},

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// STREAM
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	/**
	 * Gets / sets the array of sections that this entity will
	 * encode into its stream data.
	 * @param {Array=} sectionArray An array of strings.
	 * @example #Define the sections this entity will use in the network stream. Use the default "transform" section as well as a "custom1" section
	 *     entity.streamSections('transform', 'custom1');
	 * @return {*} "this" when arguments are passed to allow method
	 * chaining or the current value if no arguments are specified.
	 */
	streamSections: function (sectionArray) {
		if (sectionArray !== undefined) {
			this._streamSections = sectionArray;
			return this;
		}

		return this._streamSections;
	},

	/**
	 * Adds a section into the existing streamed sections array.
	 * @param {String} sectionName The section name to add.
	 */
	streamSectionsPush: function (sectionName) {
		this._streamSections = this._streamSections || [];
		this._streamSections.push(sectionName);

		return this;
	},

	/**
	 * Removes a section into the existing streamed sections array.
	 * @param {String} sectionName The section name to remove.
	 */
	streamSectionsPull: function (sectionName) {
		if (this._streamSections) {
			this._streamSections.pull(sectionName);
		}

		return this;
	},

	/**
	 * Gets / sets a streaming property on this entity. If set, the
	 * property's new value is streamed to clients on the next packet.
	 *
	 * @param {String} propName The name of the property to get / set.
	 * @param {*=} propVal Optional. If provided, the property is set
	 * to this value.
	 * @return {*} "this" when a propVal argument is passed to allow method
	 * chaining or the current value if no propVal argument is specified.
	 */
	streamProperty: function (propName, propVal) {
		this._streamProperty = this._streamProperty || {};
		//this._streamPropertyChange = this._streamPropertyChange || {};

		if (propName !== undefined) {
			if (propVal !== undefined) {
				//this._streamPropertyChange[propName] = this._streamProperty[propName] !== propVal;
				this._streamProperty[propName] = propVal;

				return this;
			}

			return this._streamProperty[propName];
		}

		return undefined;
	},

	/**
	 * Gets / sets the data for the specified data section id. This method
	 * is usually not called directly and instead is part of the network
	 * stream system. General use case is to write your own custom streamSectionData
	 * method in a class that extends IgeEntity so that you can control the
	 * data that the entity will send and receive over the network stream.
	 * @param {String} sectionId A string identifying the section to
	 * handle data get / set for.
	 * @param {*=} data If present, this is the data that has been sent
	 * from the server to the client for this entity.
	 * @param {Boolean=} bypassTimeStream If true, will assign transform
	 * directly to entity instead of adding the values to the time stream.
	 * @return {*} "this" when a data argument is passed to allow method
	 * chaining or the current value if no data argument is specified.
	 */
	streamSectionData: function (sectionId, data, bypassTimeStream) {
		switch (sectionId) {
			case 'transform':
				if (data) {
					// We have received updated data
					var dataArr = data.split(',');
	
					if (!this._disableInterpolation && !bypassTimeStream && !this._streamJustCreated) {
						// Translate
						if (dataArr[0]) { dataArr[0] = parseFloat(dataArr[0]); }
						if (dataArr[1]) { dataArr[1] = parseFloat(dataArr[1]); }
						if (dataArr[2]) { dataArr[2] = parseFloat(dataArr[2]); }
	
						// Scale
						if (dataArr[3]) { dataArr[3] = parseFloat(dataArr[3]); }
						if (dataArr[4]) { dataArr[4] = parseFloat(dataArr[4]); }
						if (dataArr[5]) { dataArr[5] = parseFloat(dataArr[5]); }
	
						// Rotate
						if (dataArr[6]) { dataArr[6] = parseFloat(dataArr[6]); }
						if (dataArr[7]) { dataArr[7] = parseFloat(dataArr[7]); }
						if (dataArr[8]) { dataArr[8] = parseFloat(dataArr[8]); }
	
						// Add it to the time stream
						this._timeStream.push([ige.network.stream._streamDataTime + ige.network._latency, dataArr]);
	
						// Check stream length, don't allow higher than 10 items
						if (this._timeStream.length > 10) {
							// Remove the first item
							this._timeStream.shift();
						}
					} else {
						// Assign all the transform values immediately
						if (dataArr[0]) { this._translate.x = parseFloat(dataArr[0]); }
						if (dataArr[1]) { this._translate.y = parseFloat(dataArr[1]); }
						if (dataArr[2]) { this._translate.z = parseFloat(dataArr[2]); }
	
						// Scale
						if (dataArr[3]) { this._scale.x = parseFloat(dataArr[3]); }
						if (dataArr[4]) { this._scale.y = parseFloat(dataArr[4]); }
						if (dataArr[5]) { this._scale.z = parseFloat(dataArr[5]); }
	
						// Rotate
						if (dataArr[6]) { this._rotate.x = parseFloat(dataArr[6]); }
						if (dataArr[7]) { this._rotate.y = parseFloat(dataArr[7]); }
						if (dataArr[8]) { this._rotate.z = parseFloat(dataArr[8]); }
						
						// If we are using composite caching ensure we update the cache
						if (this._compositeCache) {
							this.cacheDirty(true);
						}
					}
				} else {
					// We should return stringified data
					return this._translate.toString(this._streamFloatPrecision) + ',' + // translate
						this._scale.toString(this._streamFloatPrecision) + ',' + // scale
						this._rotate.toString(this._streamFloatPrecision) + ','; // rotate
				}
				break;
			
			case 'depth':
					if (data !== undefined) {
						if (ige.isClient) {
							this.depth(parseInt(data));
						}
					} else {
						return String(this.depth());
					}
					break;
				
			case 'layer':
				if (data !== undefined) {
					if (ige.isClient) {
						this.layer(parseInt(data));
					}
				} else {
					return String(this.layer());
				}
				break;
			
			case 'bounds2d':
				if (data !== undefined) {
					if (ige.isClient) {
						var geom = data.split(',');
						this.bounds2d(parseFloat(geom[0]), parseFloat(geom[1]));
					}
				} else {
					return String(this._bounds2d.x + ',' + this._bounds2d.y);
				}
				break;
			
			case 'bounds3d':
				if (data !== undefined) {
					if (ige.isClient) {
						var geom = data.split(',');
						this.bounds3d(parseFloat(geom[0]), parseFloat(geom[1]), parseFloat(geom[2]));
					}
				} else {
					return String(this._bounds3d.x + ',' + this._bounds3d.y + ',' + this._bounds3d.z);
				}
				break;
			
			case 'hidden':
				if (data !== undefined) {
					if (ige.isClient) {
						if (data == 'true') {
							this.hide();
						} else {
							this.show();
						}
					}
				} else {
					return String(this.isHidden());
				}
				break;
			
			case 'mount':
				if (data !== undefined) {
					if (ige.isClient) {
						if (data) {
							var newParent = ige.$(data);
							
							if (newParent) {
								this.mount(newParent);
							}
						} else {
							// Unmount
							this.unMount();
						}
					}
				} else {
					var parent = this.parent();
					
					if (parent) {
						return this.parent().id();
					} else {
						return '';
					}
				}
				break;
			
			case 'origin':
				if (data !== undefined) {
					if (ige.isClient) {
						var geom = data.split(',');
						this.origin(parseFloat(geom[0]), parseFloat(geom[1]), parseFloat(geom[2]));
					}
				} else {
					return String(this._origin.x + ',' + this._origin.y + ',' + this._origin.z);
				}
				break;

			case 'props':
				var newData,
					changed,
					i;

				if (data !== undefined) {
					if (ige.isClient) {
						var props = JSON.parse(data);

						// Update properties that have been sent through
						for (i in props) {
							changed = false;
							if (props.hasOwnProperty(i)) {
								if (this._streamProperty[i] != props[i]) {
									changed = true;
								}
								this._streamProperty[i] = props[i];

								this.emit('streamPropChange', [i, props[i]]);
							}
						}
					}
				} else {
					newData = {};

					for (i in this._streamProperty) {
						if (this._streamProperty.hasOwnProperty(i)) {
							//if (this._streamPropertyChange[i]) {
								newData[i] = this._streamProperty[i];
								//this._streamPropertyChange[i] = false;
							//}
						}
					}

					return JSON.stringify(newData);
				}
				break;
		}
	},

	/* CEXCLUDE */
	/**
	 * Gets / sets the stream mode that the stream system will use when
	 * handling pushing data updates to connected clients.
	 * @param {Number=} val A value representing the stream mode.
	 * @example #Set the entity to disable streaming
	 *     entity.streamMode(0);
	 * @example #Set the entity to automatic streaming
	 *     entity.streamMode(1);
	 * @example #Set the entity to manual (advanced mode) streaming
	 *     entity.streamMode(2);
	 * @return {*} "this" when arguments are passed to allow method
	 * chaining or the current value if no arguments are specified.
	 */
	streamMode: function (val) {
		if (val !== undefined) {
			if (ige.isServer) {
				this._streamMode = val;
			}
			return this;
		}

		return this._streamMode;
	},

	/**
	 * Gets / sets the stream control callback function that will be called
	 * each time the entity tick method is called and stream-able data is
	 * updated.
	 * @param {Function=} method The stream control method.
	 * @example #Set the entity's stream control method to control when this entity is streamed and when it is not
	 *     entity.streamControl(function (clientId) {
	 *         // Let's use an example where we only want this entity to stream
	 *         // to one particular client with the id 4039589434
	 *         if (clientId === '4039589434') {
	 *             // Returning true tells the network stream to send data
	 *             // about this entity to the client
	 *             return true;
	 *         } else {
	 *             // Returning false tells the network stream NOT to send
	 *             // data about this entity to the client
	 *             return false;
	 *         }
	 *     });
	 * 
	 * Further reading: [Controlling Streaming](http://www.isogenicengine.com/documentation/isogenic-game-engine/versions/1-1-0/manual/networking-multiplayer/realtime-network-streaming/stream-modes-and-controlling-streaming/)
	 * @return {*} "this" when arguments are passed to allow method
	 * chaining or the current value if no arguments are specified.
	 */
	streamControl: function (method) {
		if (method !== undefined) {
			this._streamControl = method;
			return this;
		}

		return this._streamControl;
	},

	/**
	 * Gets / sets the stream sync interval. This value
	 * is in milliseconds and cannot be lower than 16. It will
	 * determine how often data from this entity is added to the
	 * stream queue.
	 * @param {Number=} val Number of milliseconds between adding
	 * stream data for this entity to the stream queue.
	 * @param {String=} sectionId Optional id of the stream data
	 * section you want to set the interval for. If omitted the
	 * interval will be applied to all sections.
	 * @example #Set the entity's stream update (sync) interval to 1 second because this entity's data is not highly important to the simulation so save some bandwidth!
	 *     entity.streamSyncInterval(1000);
	 * @example #Set the entity's stream update (sync) interval to 16 milliseconds because this entity's data is very important to the simulation so send as often as possible!
	 *     entity.streamSyncInterval(16);
	 * @return {*} "this" when arguments are passed to allow method
	 * chaining or the current value if no arguments are specified.
	 */
	streamSyncInterval: function (val, sectionId) {
		if (val !== undefined) {
			if (!sectionId) {
				if (val < 16) {
					delete this._streamSyncInterval;
				} else {
					this._streamSyncDelta = 0;
					this._streamSyncInterval = val;
				}
			} else {
				this._streamSyncSectionInterval = this._streamSyncSectionInterval || {};
				this._streamSyncSectionDelta = this._streamSyncSectionDelta || {};
				if (val < 16) {
					delete this._streamSyncSectionInterval[sectionId];
				} else {
					this._streamSyncSectionDelta[sectionId] = 0;
					this._streamSyncSectionInterval[sectionId] = val;
				}
			}
			return this;
		}

		return this._streamSyncInterval;
	},

	/**
	 * Gets / sets the precision by which floating-point values will
	 * be encoded and sent when packaged into stream data.
	 * @param {Number=} val The number of decimal places to preserve.
	 * @example #Set the float precision to 2
	 *     // This will mean that any data using floating-point values
	 *     // that gets sent across the network stream will be rounded
	 *     // to 2 decimal places. This helps save bandwidth by not
	 *     // having to send the entire number since precision above
	 *     // 2 decimal places is usually not that important to the
	 *     // simulation.
	 *     entity.streamFloatPrecision(2);
	 * @return {*} "this" when arguments are passed to allow method
	 * chaining or the current value if no arguments are specified.
	 */
	streamFloatPrecision: function (val) {
		if (val !== undefined) {
			this._streamFloatPrecision = val;

			var i, floatRemove = '\\.';

			// Update the floatRemove regular expression pattern
			for (i = 0; i < this._streamFloatPrecision; i++) {
				floatRemove += '0';
			}

			// Add the trailing comma
			floatRemove += ',';

			// Create the new regexp
			this._floatRemoveRegExp = new RegExp(floatRemove, 'g');

			return this;
		}

		return this._streamFloatPrecision;
	},

	/**
	 * Queues stream data for this entity to be sent to the
	 * specified client id or array of client ids.
	 * @param {Array} clientId An array of string IDs of each
	 * client to send the stream data to.
	 * @return {IgeEntity} "this".
	 */
	streamSync: function (clientId) {
		if (this._streamMode === 1) {
			// Check if we have a stream sync interval
			if (this._streamSyncInterval) {
				this._streamSyncDelta += ige._tickDelta;

				if (this._streamSyncDelta < this._streamSyncInterval) {
					// The stream sync interval is still higher than
					// the stream sync delta so exit without calling the
					// stream sync method
					return this;
				} else {
					// We've reached the delta we want so zero it now
					// ready for the next loop
					this._streamSyncDelta = 0;
				}
			}

			// Grab an array of connected clients from the network
			// system
			var recipientArr = [],
				clientArr = ige.network.clients(this._streamRoomId),
				i;
			
			for (i in clientArr) {
				if (clientArr.hasOwnProperty(i)) {
					// Check for a stream control method
					if (this._streamControl) {
						// Call the callback method and if it returns true,
						// send the stream data to this client
						if (this._streamControl.apply(this, [i, this._streamRoomId])) {
							recipientArr.push(i);
						}
					} else {
						// No control method so process for this client
						recipientArr.push(i);
					}
				}
			}

			this._streamSync(recipientArr);
			return this;
		}

		if (this._streamMode === 2) {
			// Stream mode is advanced
			this._streamSync(clientId, this._streamRoomId);

			return this;
		}

		return this;
	},

	/**
	 * Override this method if your entity should send data through to
	 * the client when it is being created on the client for the first
	 * time through the network stream. The data will be provided as the
	 * first argument in the constructor call to the entity class so
	 * you should expect to receive it as per this example:
	 * @example #Using and Receiving Stream Create Data
	 *     var MyNewClass = IgeEntity.extend({
	 *         classId: 'MyNewClass',
	 *         
	 *         // Define the init with the parameter to receive the
	 *         // data you return in the streamCreateData() method
	 *         init: function (myCreateData) {
	 *             this._myData = myCreateData;
	 *         },
	 *         
	 *         streamCreateData: function () {
	 *             return this._myData;
	 *         }
	 *     });
	 * 
	 * Valid return values must not include circular references!
	 */
	streamCreateData: function () {},

	/**
	 * Gets / sets the stream emit created flag. If set to true this entity
	 * emit a "streamCreated" event when it is created by the stream, but
	 * after the id and initial transform are set.
	 * @param val
	 * @returns {*}
	 */
	streamEmitCreated: function (val) {
		if (val !== undefined) {
			this._streamEmitCreated = val;
			return this;
		}
		
		return this._streamEmitCreated;
	},
	
	/**
	 * Asks the stream system to queue the stream data to the specified
	 * client id or array of ids.
	 * @param {Array} recipientArr The array of ids of the client(s) to
	 * queue stream data for. The stream data being queued
	 * is returned by a call to this._streamData().
	 * @param {String} streamRoomId The id of the room the entity belongs
	 * in (can be undefined or null if no room assigned).
	 * @private
	 */
	_streamSync: function (recipientArr, streamRoomId) {
		var arrCount = recipientArr.length,
			arrIndex,
			clientId,
			stream = ige.network.stream,
			thisId = this.id(),
			filteredArr = [],
			createResult = true; // We set this to true by default

		// Loop the recipient array
		for (arrIndex = 0; arrIndex < arrCount; arrIndex++) {
			clientId = recipientArr[arrIndex];

			// Check if the client has already received a create
			// command for this entity
			stream._streamClientCreated[thisId] = stream._streamClientCreated[thisId] || {};
			if (!stream._streamClientCreated[thisId][clientId]) {
				createResult = this.streamCreate(clientId);
			}

			// Make sure that if we had to create the entity for
			// this client that the create worked before bothering
			// to waste bandwidth on stream updates
			if (createResult) {
				// Get the stream data
				var data = this._streamData();

				// Is the data different from the last data we sent
				// this client?
				stream._streamClientData[thisId] = stream._streamClientData[thisId] || {};
				
				if (stream._streamClientData[thisId][clientId] != data) {
					filteredArr.push(clientId);

					// Store the new data for later comparison
					stream._streamClientData[thisId][clientId] = data;
				}
			}
		}
		
		if (filteredArr.length) {
			stream.queue(thisId, data, filteredArr);
		}
	},

	/**
	 * Forces the stream to push this entity's full stream data on the
	 * next stream sync regardless of what clients have received in the
	 * past. This should only be used when required rather than every
	 * tick as it will reduce the overall efficiency of the stream if
	 * used every tick.
	 * @returns {*}
	 */
	streamForceUpdate: function () {
		if (ige.isServer) {
			var thisId = this.id();
			
			// Invalidate the stream client data lookup to ensure
			// the latest data will be pushed on the next stream sync
			if (ige.network && ige.network.stream && ige.network.stream._streamClientData && ige.network.stream._streamClientData[thisId]) {
				ige.network.stream._streamClientData[thisId] = {};
			}
		}
		
		return this;
	},

	/**
	 * Issues a create entity command to the passed client id
	 * or array of ids. If no id is passed it will issue the
	 * command to all connected clients. If using streamMode(1)
	 * this method is called automatically.
	 * @param {*} clientId The id or array of ids to send
	 * the command to.
	 * @example #Send a create command for this entity to all clients
	 *     entity.streamCreate();
	 * @example #Send a create command for this entity to an array of client ids
	 *     entity.streamCreate(['43245325', '326755464', '436743453']);
	 * @example #Send a create command for this entity to a single client id
	 *     entity.streamCreate('43245325');
	 * @return {Boolean}
	 */
	streamCreate: function (clientId) {
		if (this._parent) {
			var thisId = this.id(),
				arr,
				i;

			// Send the client an entity create command first
			ige.network.send('_igeStreamCreate', [
				this.classId(),
				thisId,
				this._parent.id(),
				this.streamSectionData('transform'),
				this.streamCreateData()
			], clientId);
			
			ige.network.stream._streamClientCreated[thisId] = ige.network.stream._streamClientCreated[thisId] || {};

			if (clientId) {
				// Mark the client as having received a create
				// command for this entity
				ige.network.stream._streamClientCreated[thisId][clientId] = true;
			} else {
				// Mark all clients as having received this create
				arr = ige.network.clients();

				for (i in arr) {
					if (arr.hasOwnProperty(i)) {
						ige.network.stream._streamClientCreated[thisId][i] = true;
					}
				}
			}

			return true;
		}

		return false;
	},

	/**
	 * Issues a destroy entity command to the passed client id
	 * or array of ids. If no id is passed it will issue the
	 * command to all connected clients. If using streamMode(1)
	 * this method is called automatically.
	 * @param {*} clientId The id or array of ids to send
	 * the command to.
	 * @example #Send a destroy command for this entity to all clients
	 *     entity.streamDestroy();
	 * @example #Send a destroy command for this entity to an array of client ids
	 *     entity.streamDestroy(['43245325', '326755464', '436743453']);
	 * @example #Send a destroy command for this entity to a single client id
	 *     entity.streamDestroy('43245325');
	 * @return {Boolean}
	 */
	streamDestroy: function (clientId) {
		var thisId = this.id(),
			arr,
			i;

		// Send clients the stream destroy command for this entity
		ige.network.send('_igeStreamDestroy', [ige._currentTime, thisId], clientId);
		
		ige.network.stream._streamClientCreated[thisId] = ige.network.stream._streamClientCreated[thisId] || {};
		ige.network.stream._streamClientData[thisId] = ige.network.stream._streamClientData[thisId] || {};

		if (clientId) {
			// Mark the client as having received a destroy
			// command for this entity
			ige.network.stream._streamClientCreated[thisId][clientId] = false;
            ige.network.stream._streamClientData[thisId][clientId] = undefined;
		} else {
			// Mark all clients as having received this destroy
			arr = ige.network.clients();

			for (i in arr) {
				if (arr.hasOwnProperty(i)) {
					ige.network.stream._streamClientCreated[thisId][i] = false;
                    ige.network.stream._streamClientData[thisId][i] = undefined;
				}
			}
		}
		
		return true;
	},

	/**
	 * Generates and returns the current stream data for this entity. The
	 * data will usually include only properties that have changed since
	 * the last time the stream data was generated. The returned data is
	 * a string that has been compressed in various ways to reduce network
	 * overhead during transmission.
	 * @return {String} The string representation of the stream data for
	 * this entity.
	 * @private
	 */
	_streamData: function () {
		// Check if we already have a cached version of the streamData
		if (this._streamDataCache) {
			return this._streamDataCache;
		} else {
			// Let's generate our stream data
			var streamData = '',
				sectionDataString = '',
				sectionArr = this._streamSections,
				sectionCount = sectionArr.length,
				sectionData,
				sectionIndex,
				sectionId;

			// Add the entity id
			streamData += this.id();

			// Only send further data if the entity is still "alive"
			if (this._alive) {
				// Now loop the data sections array and compile the rest of the
				// data string from the data section return data
				for (sectionIndex = 0; sectionIndex < sectionCount; sectionIndex++) {
					sectionData = '';
					sectionId = sectionArr[sectionIndex];
					
					// Stream section sync intervals allow individual stream sections
					// to be streamed at different (usually longer) intervals than other
					// sections so you could for instance reduce the number of updates
					// a particular section sends out in a second because the data is
					// not that important compared to updated transformation data
					if (this._streamSyncSectionInterval && this._streamSyncSectionInterval[sectionId]) {
						// Check if the section interval has been reached
						this._streamSyncSectionDelta[sectionId] += ige._tickDelta;

						if (this._streamSyncSectionDelta[sectionId] >= this._streamSyncSectionInterval[sectionId]) {
							// Get the section data for this section id
							sectionData = this.streamSectionData(sectionId);

							// Reset the section delta
							this._streamSyncSectionDelta[sectionId] = 0;
						}
					} else {
						// Get the section data for this section id
						sectionData = this.streamSectionData(sectionId);
					}

					// Add the section start designator character. We do this
					// regardless of if there is actually any section data because
					// we want to be able to identify sections in a serial fashion
					// on receipt of the data string on the client
					sectionDataString += ige.network.stream._sectionDesignator;

					// Check if we were returned any data
					if (sectionData !== undefined) {
						// Add the data to the section string
						sectionDataString += sectionData;
					}
				}

				// Add any custom data to the stream string at this point
				if (sectionDataString) {
					streamData += sectionDataString;
				}

				// Remove any .00 from the string since we don't need that data
				// TODO: What about if a property is a string with something.00 and it should be kept?
				streamData = streamData.replace(this._floatRemoveRegExp, ',');
			}

			// Store the data in cache in case we are asked for it again this tick
			// the update() method of the IgeEntity class clears this every tick
			this._streamDataCache = streamData;

			return streamData;
		}
	},
	/* CEXCLUDE */

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// INTERPOLATOR
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	/**
	 * Calculates the current value based on the time along the
	 * value range.
	 * @param {Number} startValue The value that the interpolation started from.
	 * @param {Number} endValue The target value to be interpolated to.
	 * @param {Number} startTime The time the interpolation started.
	 * @param {Number} currentTime The current time.
	 * @param {Number} endTime The time the interpolation will end.
	 * @return {Number} The interpolated value.
	 */
	interpolateValue: function (startValue, endValue, startTime, currentTime, endTime) {
		var totalValue = endValue - startValue,
			dataDelta = endTime - startTime,
			offsetDelta = currentTime - startTime,
			deltaTime = offsetDelta / dataDelta;

		// Clamp the current time from 0 to 1
		if (deltaTime < 0) { deltaTime = 0; } else if (deltaTime > 1) { deltaTime = 1; }

		return (totalValue * deltaTime) + startValue;
	},

	/**
	 * Processes the time stream for the entity.
	 * @param {Number} renderTime The time that the time stream is
	 * targeting to render the entity at.
	 * @param {Number} maxLerp The maximum lerp before the value
	 * is assigned directly instead of being interpolated.
	 * @private
	 */
	_processInterpolate: function (renderTime, maxLerp) {
		// Set the maximum lerp to 200 if none is present
		if (!maxLerp) { maxLerp = 200; }

		var maxLerpSquared = maxLerp * maxLerp,
			previousData,
			nextData,
			timeStream = this._timeStream,
			dataDelta,
			offsetDelta,
			currentTime,
			previousTransform,
			nextTransform,
			currentTransform = [],
			i = 1;

		// Find the point in the time stream that is
		// closest to the render time and assign the
		// previous and next data points
		while (timeStream[i]) {
			if (timeStream[i][0] > renderTime) {
				// We have previous and next data points from the
				// time stream so store them
				previousData = timeStream[i - 1];
				nextData = timeStream[i];
				break;
			}
			i++;
		}

		// Check if we have some data to use
		if (!nextData && !previousData) {
			// No in-time data was found, check for lagging data
			if (timeStream.length > 2) {
				if (timeStream[timeStream.length - 1][0] < renderTime) {
					// Lagging data is available, use that
					previousData = timeStream[timeStream.length - 2];
					nextData = timeStream[timeStream.length - 1];
					timeStream.shift();
					
					/**
					 * Fires when the entity interpolates against old data, usually
					 * the result of slow processing on the client or too much data
					 * being sent from the server.
					 * @event IgeEntity#interpolationLag
					 */
					this.emit('interpolationLag');
				}
			}
		} else {
			// We have some new data so clear the old data
			timeStream.splice(0, i - 1);
		}

		// If we have data to use
		if (nextData && previousData) {
			// Check if the previous data has a timestamp and if not,
			// use the next data's timestamp
			if (isNaN(previousData[0])) { previousData[0] = nextData[0]; }

			// Store the data so outside systems can access them
			this._timeStreamPreviousData = previousData;
			this._timeStreamNextData = nextData;

			// Calculate the delta times
			dataDelta = nextData[0] - previousData[0];
			offsetDelta = renderTime - previousData[0];

			this._timeStreamDataDelta = Math.floor(dataDelta);
			this._timeStreamOffsetDelta = Math.floor(offsetDelta);

			// Calculate the current time between the two data points
			currentTime = offsetDelta / dataDelta;

			this._timeStreamCurrentInterpolateTime = currentTime;

			// Clamp the current time from 0 to 1
			//if (currentTime < 0) { currentTime = 0.0; } else if (currentTime > 1) { currentTime = 1.0; }

			// Set variables up to store the previous and next data
			previousTransform = previousData[1];
			nextTransform = nextData[1];

			// Translate
			currentTransform[0] = this.interpolateValue(previousTransform[0], nextTransform[0], previousData[0], renderTime, nextData[0]);
			currentTransform[1] = this.interpolateValue(previousTransform[1], nextTransform[1], previousData[0], renderTime, nextData[0]);
			currentTransform[2] = this.interpolateValue(previousTransform[2], nextTransform[2], previousData[0], renderTime, nextData[0]);
			// Scale
			currentTransform[3] = this.interpolateValue(previousTransform[3], nextTransform[3], previousData[0], renderTime, nextData[0]);
			currentTransform[4] = this.interpolateValue(previousTransform[4], nextTransform[4], previousData[0], renderTime, nextData[0]);
			currentTransform[5] = this.interpolateValue(previousTransform[5], nextTransform[5], previousData[0], renderTime, nextData[0]);
			// Rotate
			currentTransform[6] = this.interpolateValue(previousTransform[6], nextTransform[6], previousData[0], renderTime, nextData[0]);
			currentTransform[7] = this.interpolateValue(previousTransform[7], nextTransform[7], previousData[0], renderTime, nextData[0]);
			currentTransform[8] = this.interpolateValue(previousTransform[8], nextTransform[8], previousData[0], renderTime, nextData[0]);

			this.translateTo(parseFloat(currentTransform[0]), parseFloat(currentTransform[1]), parseFloat(currentTransform[2]));
			this.scaleTo(parseFloat(currentTransform[3]), parseFloat(currentTransform[4]), parseFloat(currentTransform[5]));
			this.rotateTo(parseFloat(currentTransform[6]), parseFloat(currentTransform[7]), parseFloat(currentTransform[8]));

			/*// Calculate the squared distance between the previous point and next point
			 dist = this.distanceSquared(previousTransform.x, previousTransform.y, nextTransform.x, nextTransform.y);

			 // Check that the distance is not higher than the maximum lerp and if higher,
			 // set the current time to 1 to snap to the next position immediately
			 if (dist > maxLerpSquared) { currentTime = 1; }

			 // Interpolate the entity position by multiplying the Delta times T, and adding the previous position
			 currentPosition = {};
			 currentPosition.x = ( (nextTransform.x - previousTransform.x) * currentTime ) + previousTransform.x;
			 currentPosition.y = ( (nextTransform.y - previousTransform.y) * currentTime ) + previousTransform.y;

			 // Now actually transform the entity
			 this.translate(entity, currentPosition.x, currentPosition.y);*/

			// Record the last time we updated the entity so we can disregard any updates
			// that arrive and are before this timestamp (not applicable in TCP but will
			// apply if we ever get UDP in websockets)
			this._lastUpdate = new Date().getTime();
		}
	},
	_highlightToGlobalCompositeOperation: function (val) {
		if (val) {
			if (val === true) {
				return 'lighter'
			}

			return val;
		}
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = IgeEntity; }
// TODO: Implement the _stringify() method for this class
/**
 * Creates a new UI entity. UI entities use more resources and CPU
 * than standard IgeEntity instances so only use them if an IgeEntity
 * won't do the job.
 */
var IgeUiEntity = IgeEntity.extend([
	{extension: IgeUiStyleExtension, overwrite: true},
	{extension: IgeUiPositionExtension, overwrite: true}
], {
	classId: 'IgeUiEntity',

	init: function () {
		IgeEntity.prototype.init.call(this);

		// Set some defaults
		this._color = '#000000';
		this._borderLeftWidth = 0;
		this._borderTopWidth = 0;
		this._borderRightWidth = 0;
		this._borderBottomWidth = 0;
		this._borderTopLeftRadius = 0;
		this._borderTopRightRadius = 0;
		this._borderBottomRightRadius = 0;
		this._borderBottomLeftRadius = 0;
		this._backgroundPosition = {x: 0, y: 0};
		this._paddingLeft = 0;
		this._paddingTop = 0;
		this._paddingRight = 0;
		this._paddingBottom = 0;
	},
	
	disabled: function (val) {
		if (val !== undefined) {
			this._disabled = val;
			return this;
		}
		
		return this._disabled;
	},
	
	overflow: function (val) {
		if (val !== undefined) {
			this._overflow = val;
			return this;
		}
		
		return this._overflow;
	},

	_renderBackground: function (ctx) {
		var geom = this._bounds2d,
			left, top, width, height;

		if (this._backgroundColor || this._patternFill) {
			left = -(geom.x / 2) | 0;
			top = -(geom.y / 2) | 0;
			width = geom.x;
			height = geom.y;

			ctx.save();
				ctx.beginPath();

				// Check for early exit if we are rendering a rectangle
				if (!this._borderTopRightRadius && !this._borderBottomRightRadius && !this._borderBottomLeftRadius && !this._borderTopLeftRadius) {
					ctx.rect(left, top, width, height);
				} else {
					// Top border
					ctx.moveTo(left + this._borderTopLeftRadius, top);
					ctx.lineTo(left + width - this._borderTopRightRadius, top);

					if (this._borderTopRightRadius > 0) {
						// Top-right corner
						ctx.arcTo(
							left + width,
							top,
							left + width,
							top + this._borderTopRightRadius,
							this._borderTopRightRadius
						);
					}

					// Right border
					ctx.lineTo(
						left + width,
						top + height - this._borderBottomRightRadius
					);

					if (this._borderBottomRightRadius > 0) {
						// Bottom-right corner
						ctx.arcTo(
							left + width,
							top + height,
							left + width - this._borderBottomRightRadius,
							top + height, this._borderBottomRightRadius
						);
					}

					// Bottom border
					ctx.lineTo(
						left + this._borderBottomLeftRadius,
						top + height
					);

					if (this._borderBottomLeftRadius > 0) {
						// Bottom-left corner
						ctx.arcTo(
							left,
							top + height,
							left,
							top + height - this._borderBottomLeftRadius,
							this._borderBottomLeftRadius
						);
					}

					// Left border
					ctx.lineTo(
						left,
						top + this._borderTopLeftRadius
					);

					if (this._borderTopLeftRadius > 0) {
						// Top-left corner
						ctx.arcTo(
							left,
							top,
							left + this._borderTopLeftRadius,
							top, this._borderTopLeftRadius
						);
					}

					ctx.clip();
				}

				// If there is a background colour, paint it here
				if (this._backgroundColor) {
					ctx.fillStyle = this._backgroundColor;
					ctx.fill();
				}

				// If there is a background image, paint it here
				if (this._patternFill) {
					ctx.translate(
						-(width / 2 | 0) + this._backgroundPosition.x,
						-(height / 2 | 0) + this._backgroundPosition.y
					);

					ctx.fillStyle = this._patternFill;
					ctx.fill();
				}
			ctx.restore();
		}
	},

	_renderBorder: function (ctx) {
		var rad,
			geom = this._bounds2d,
			left = (-(geom.x2) | 0) + 0.5,
			top = (-(geom.y2) | 0) + 0.5,
			width = geom.x - 1,
			height = geom.y - 1;

		// Check for early exit if we are rendering a rectangle
		if (!this._borderTopRightRadius && !this._borderBottomRightRadius && !this._borderBottomLeftRadius && !this._borderTopLeftRadius
			&& this._borderLeftWidth === this._borderWidth
			&& this._borderTopWidth === this._borderWidth
			&& this._borderRightWidth === this._borderWidth
			&& this._borderBottomWidth === this._borderWidth) {
			ctx.strokeStyle = this._borderColor;
			ctx.lineWidth = this._borderWidth;
			ctx.strokeRect(left, top, width, height);
		} else {
			var startNewStroke = function() {
				ctx.stroke();
				ctx.beginPath();
			};		
			rad = Math.PI / 180;
			
			ctx.beginPath();
			if (this._borderTopWidth) {
				// Top-left corner top-half
				ctx.strokeStyle = this._borderTopColor;
				ctx.lineWidth = this._borderTopWidth;

				if (this._borderTopLeftRadius > 0) {
					// Top-left corner top-half
					ctx.arc(left + this._borderTopLeftRadius, top + this._borderTopLeftRadius, this._borderTopLeftRadius, 225 * rad, 270 * rad);
				}

				// Top border
				ctx.moveTo(left + this._borderTopLeftRadius, top);
				ctx.lineTo(left + width - this._borderTopRightRadius, top);

				if (this._borderTopRightRadius > 0) {
					// Top-right corner top-half
					ctx.arc(left + width - this._borderTopRightRadius, top + this._borderTopRightRadius, this._borderTopRightRadius, -90 * rad, -44 * rad); // use -44 instead of -45 to fully connect with next piece
				}
			}
			
			if (!this._borderRightWidth || this._borderTopColor != this._borderRightColor || this._borderTopWidth != this._borderRightWidth)
				startNewStroke();
			if (this._borderRightWidth) {
				// Top-right corner bottom-half
				ctx.strokeStyle = this._borderRightColor;
				ctx.lineWidth = this._borderRightWidth;

				if (this._borderTopRightRadius > 0) {
					ctx.arc(left + width - this._borderTopRightRadius, top + this._borderTopRightRadius, this._borderTopRightRadius, -45 * rad, 0);
				}

				// Right border
				ctx.moveTo(left + width, top + this._borderTopRightRadius);
				ctx.lineTo(left + width, top + height - this._borderBottomRightRadius);

				if (this._borderBottomRightRadius > 0) {
					// Bottom-right corner top-half
					ctx.arc(left + width - this._borderBottomRightRadius, top + height - this._borderBottomRightRadius, this._borderTopRightRadius, 0, 46 * rad); // use 46 instead of 45 to fully connect with next piece
				}
			}

			if (!this._borderBottomWidth || this._borderRightColor != this._borderBottomColor || this._borderRightWidth != this._borderBottomWidth)
				startNewStroke();
			if (this._borderBottomWidth) {
				// Bottom-right corner bottom-half
				ctx.strokeStyle = this._borderBottomColor;
				ctx.lineWidth = this._borderBottomWidth;

				if (this._borderBottomRightRadius > 0) {
					ctx.arc(left + width - this._borderBottomRightRadius, top + height - this._borderBottomRightRadius, this._borderBottomRightRadius, 45 * rad, 90 * rad);
				}

				// Bottom border
				ctx.moveTo(left + width - this._borderBottomRightRadius, top + height);
				ctx.lineTo(left + this._borderBottomLeftRadius, top + height);

				if (this._borderBottomLeftRadius > 0) {
					// Bottom-left corner bottom-half
					ctx.arc(left + this._borderBottomLeftRadius, top + height - this._borderBottomLeftRadius, this._borderBottomLeftRadius, 90 * rad, 136 * rad); // use 136 instead of 135 to fully connect with next piece
				}
			}

			if (!this._borderLeftWidth || this._borderBottomColor != this._borderLeftColor || this._borderBottomWidth != this._borderLeftWidth)
				startNewStroke();
			if (this._borderLeftWidth) {
				// Bottom-left corner top-half
				ctx.strokeStyle = this._borderLeftColor;
				ctx.lineWidth = this._borderLeftWidth;

				if (this._borderBottomLeftRadius > 0) {
					ctx.arc(left + this._borderBottomLeftRadius, top + height - this._borderBottomLeftRadius, this._borderBottomLeftRadius, 135 * rad, 180 * rad);
				}

				// Left border
				ctx.moveTo(left, top + height - this._borderBottomLeftRadius);
				ctx.lineTo(left, top + this._borderTopLeftRadius);

				if (this._borderTopLeftRadius > 0) {
					// Top-left corner bottom-half
					ctx.arc(left + this._borderTopLeftRadius, top + this._borderTopLeftRadius, this._borderTopLeftRadius, 180 * rad, 226 * rad); // use 226 instead of 225 to fully connect with next piece
				}
			}
			ctx.stroke();
		}
	},

	cell: function (val) {
		var ret = IgeEntity.prototype.cell.call(this, val);

		if (ret === this && this._patternTexture) {
			this.backgroundImage(
				this._patternTexture,
				this._patternRepeat
			);
		}

		return ret;
	},

	mount: function (obj) {
		var ret = IgeEntity.prototype.mount.call(this, obj);

		if (this._parent) {
			// Now we're mounted update our ui calculations since we have a parent
			// to calculate from
			if (this._updateUiPosition) {
				this._updateUiPosition();
			}
			
			// Also update any children if we have any
			if(this._children.length) {
				this.updateUiChildren();
			}

			if (this._updateStyle) {
				this._updateStyle();
			}

		}

		return ret;
	},

	tick: function (ctx, dontTransform) {
		if (!this._hidden && this._inView && (!this._parent || (this._parent._inView)) && !this._streamJustCreated) {
			if (!dontTransform) {
				this._transformContext(ctx);
			}
			// TODO: Investigate caching expensive background and border calls
			//if (!this._cache || this._cacheDirty) {
				this._renderBackground(ctx);
				this._renderBorder(ctx);
			//}
	
			if (this._overflow === 'hidden') {
				// Limit drawing of child entities to within the bounds
				// of this one
				var geom = this._bounds2d,
					left = -(geom.x / 2) + this._paddingLeft | 0,
					top = -(geom.y / 2) + (this._paddingTop) | 0,
					width = geom.x + this._paddingRight,
					height = geom.y + this._paddingBottom;
	
				ctx.rect(left, top, width, height);
				//ctx.stroke();
				ctx.clip();
			}
	
			ctx.translate(this._paddingLeft, this._paddingTop);
			IgeEntity.prototype.tick.call(this, ctx, true);
		}
	},

	/**
	 * Handles screen resize events.
	 * @param event
	 * @private
	 */
	_resizeEvent: function (event) {
		
		if (this._updateUiPosition) {
			this._updateUiPosition();
		} else {
			debugger;
		}

		if (this._updateStyle) {
			this._updateStyle();
		}
		IgeEntity.prototype._resizeEvent.call(this, event);
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = IgeUiEntity; }

/**
 * Creates a new UI element. UI elements use more resources and CPU
 * than standard IgeEntity instances but provide a rich set of extra
 * positioning and styling methods as well as reacting to styles
 * defined using the IgeUiManagerComponent.
 */
var IgeUiElement = IgeUiEntity.extend({
	classId: 'IgeUiElement',

	/**
	 * Constructor
	 */
	init: function () {
		var self = this;
		
		IgeUiEntity.prototype.init.call(this);
		ige.ui.registerElement(this);
		
		this._focused = false;
		this._allowHover = true;
		this._allowFocus = true;
		this._allowActive = true;
		
		var updateStyleFunc = function () {
			self._updateStyle();
		};
		
		this.on('mouseOver', function () {
			if (this._allowHover) {
				updateStyleFunc();
				ige.input.stopPropagation();
			} else {
				this._mouseStateOver = false;
			}
		});
		this.on('mouseOut', function () {
			if (this._allowHover) {
				updateStyleFunc();
				ige.input.stopPropagation();
			} else {
				this._mouseStateOver = false;
			}
		});
		this.on('mouseDown', function () {
			if (this._allowActive) {
				updateStyleFunc();
				ige.input.stopPropagation();
			} else {
				this._mouseStateDown = false;
			}
		});
		this.on('mouseUp', function () {
			if (this._allowFocus) {
				// Try to focus the entity
				if (!self.focus()) {
					updateStyleFunc();
				} else {
					ige.input.stopPropagation();
				}
			} else if (this._allowActive) {
				updateStyleFunc();
			}
		});
		
		// Enable mouse events on this entity by default
		this.mouseEventsActive(true);
	},
	
	allowHover: function (val) {
		if (val !== undefined) {
			this._allowHover = val;
			return this;
		}
		
		return this._allowHover;
	},
	
	allowFocus: function (val) {
		if (val !== undefined) {
			this._allowFocus = val;
			return this;
		}
		
		return this._allowFocus;
	},
	
	allowActive: function (val) {
		if (val !== undefined) {
			this._allowActive = val;
			return this;
		}
		
		return this._allowActive;
	},

	/**
	 * Gets / sets the applied style by name.
	 * @param {String=} name The style name to apply.
	 * @returns {*}
	 */
	styleClass: function (name) {
		if (name !== undefined) {
			// Add a period to the class name
			name = '.' + name;
			
			// Check for existing assigned style
			if (this._styleClass && this._styleClass !== name) {
				// Unregister this element from the style
				ige.ui.unRegisterElementStyle(this);
			}
			
			// Assign the new style
			this._styleClass = name;
			
			// Register the element for this style
			ige.ui.registerElementStyle(this);
			
			// Update the element style
			this._updateStyle();
			
			return this;
		}
		
		return this._styleClass;
	},
	
	_updateStyle: function () {
		// Apply styles in order of class, class:focus, class:hover, class:active,
		// id, id:focus, id:hover, id:active
		this._processStyle(this._classId);
		this._processStyle(this._styleClass);
		this._processStyle('#' + this._id);
		
		if (this._focused) {
			this._processStyle(this._classId, 'focus');
			this._processStyle(this._styleClass, 'focus');
			this._processStyle('#' + this._id, 'focus');
		}
		
		if (this._mouseStateOver) {
			this._processStyle(this._classId, 'hover');
			this._processStyle(this._styleClass, 'hover');
			this._processStyle('#' + this._id, 'hover');
		}
		
		if (this._mouseStateDown) {
			this._processStyle(this._classId, 'active');
			this._processStyle(this._styleClass, 'active');
			this._processStyle('#' + this._id, 'active');
		}
	},
	
	_processStyle: function (styleName, state) {
		if (styleName) {
			if (state) {
				styleName += ':' + state;
			}
			
			//this.log('Checking for styles with selector: ' + styleName);
			
			// Basic
			var styleData = ige.ui.style(styleName);
			if (styleData) {
				//this.log('Applying styles with selector "' + styleName + '"');
				this.applyStyle(styleData);
			}
		}
	},

	/**
	 * Apply styles from a style data object. Usually you don't want to
	 * call this method directly but rather assign a style by name using
	 * the style() method, however it is not illegal practise to apply
	 * here if you wish if you have not defined a style by name and simply
	 * wish to apply style data directly.
	 * 
	 * Style property names must correspond to method names in the element
	 * class that the style is being applied to. You can see the default
	 * ui style methods available in the ./engine/extensions/IgeUi* files.
	 * 
	 * In the example below showing padding, you can see how the data assigned
	 * is passed to the "padding()" method as arguments, which is the same
	 * as calling "padding(10, 10, 10, 10);".
	 * 
	 * @example #Apply a background color
	 *     var elem = new IgeUiElement()
	 *         .applyStyle({
	 *             'backgroundColor': '#ffffff' // Set background color to white
	 *         });
	 *         
	 * @example #Apply padding with multiple arguments
	 *     var elem = new IgeUiElement()
	 *         .applyStyle({
	 *             'padding': [10, 10, 10, 10] // Set padding using multiple values
	 *         });
	 * 
	 * @param {Object} styleData The style object to apply. This object should
	 * contain key/value pairs where the key matches a method name and the value
	 * is the parameter to pass it.
	 */
	applyStyle: function (styleData) {
		var args;
		
		if (styleData !== undefined) {
			// Loop the style data and apply styles as required
			for (var i in styleData) {
				if (styleData.hasOwnProperty(i)) {
					// Check that the style method exists
					if (typeof(this[i]) === 'function') {
						// The method exists, call it with the arguments
						if (styleData[i] instanceof Array) {
							args = styleData[i];
						} else {
							args = [styleData[i]];
						}
						
						this[i].apply(this, args);
					}
				}
			}
		}
		
		return this;
	},

	/**
	 * Sets global UI focus to this element.
	 */
	focus: function () {
		if (ige.ui.focus(this)) {
			// Re-apply styles since the change
			this._updateStyle();
			return true;
		}
		
		return false;
	},
	
	blur: function () {
		if (ige.ui.blur(this)) {
			// Re-apply styles since the change
			this._updateStyle();
			return true;
		}
		
		return false;
	},
	
	focused: function () {
		return this._focused;
	},
	
	value: function (val) {
		if (val !== undefined) {
			this._value = val;
			return this;
		}
		
		return this._value;
	},
	
	_mounted: function () {
		this._updateStyle();
	},

	/**
	 * Destructor
	 */
	destroy: function () {
		ige.ui.unRegisterElement(this);
		IgeUiEntity.prototype.destroy.call(this);
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = IgeUiElement; }
/**
 * Creates a new font entity. A font entity will use a font sheet
 * (IgeFontSheet) or native font and render text.
 */
var IgeFontEntity = IgeUiEntity.extend({
	classId: 'IgeFontEntity',

	init: function () {
		IgeUiEntity.prototype.init.call(this);

		this._renderText = undefined;
		this._text = undefined;
		this._textAlignX = 1;
		this._textAlignY = 3;
		this._textLineSpacing = 0;
		this._nativeMode = false;

		// Enable caching by default for font entities!
		this.cache(true);
	},

	/**
	 * Extends the IgeUiEntity.width() method and if the value being
	 * set is different from the current width value then the font's
	 * cache is invalidated so it gets redrawn.
	 * @param val
	 * @param lockAspect
	 * @param modifier
	 * @param noUpdate
	 * @returns {*}
	 */
	width: function (val, lockAspect, modifier, noUpdate) {
		if (val !== undefined) {
			if (this._bounds2d.x !== val) {
				this.clearCache();
			}
		}

		var retVal = IgeUiEntity.prototype.width.call(this, val, lockAspect, modifier, noUpdate);
		
		if (this._autoWrap) {
			this._applyAutoWrap();
		}
		
		return retVal;
	},

	/**
	 * Extends the IgeUiEntity.height() method and if the value being
	 * set is different from the current height value then the font's
	 * cache is invalidated so it gets redrawn.
	 * @param val
	 * @param lockAspect
	 * @param modifier
	 * @param noUpdate
	 * @returns {*|number}
	 */
	height: function (val, lockAspect, modifier, noUpdate) {
		if (val !== undefined) {
			if (this._bounds2d.y !== val) {
				this.clearCache();
			}
		}

		return IgeUiEntity.prototype.height.call(this, val, lockAspect, modifier, noUpdate);
	},

	/**
	 * Sets the text to render for this font entity. This sets both
	 * the private properties "_text" and "_renderText". If auto-wrapping
	 * has been enabled then the "_text" remains equal to whatever
	 * text you pass into this method but "_renderText" becomes the
	 * line-broken text that the auto-wrapper method creates. When the
	 * entity renders it's text string it ALWAYS renders from "_renderText"
	 * and not the value of "_text". Effectively this means that "_text"
	 * contains the unaltered version of your original text and 
	 * "_renderText" will be either the same as "_text" if auto-wrapping
	 * is disable or a wrapped version otherwise.
	 * @param {String} text The text string to render.
	 * @returns {*}
	 */
	text: function (text) {
		if (text !== undefined) {
			var wasDifferent = false;
			
			// Ensure we have a string
			text = String(text);
			
			if (this._text !== text) {
				this.clearCache();
				wasDifferent = true;
			}
			
			this._text = text;
			
			if (this._autoWrap && wasDifferent) {
				this._applyAutoWrap();
			} else {
				this._renderText = text;
			}
			
			return this;
		}

		return this._text;
	},

	/**
	 * Allows you to bind the text output of this font entity to match
	 * the value of an object's property so that when it is updated the
	 * text will automatically update on this entity. Useful for score,
	 * position etc output where data is stored in an object and changes
	 * frequently.
	 * @param {Object} obj The object to read the property from.
	 * @param {String} propName The name of the property to read value from.
	 * @param {String} preText Text to place before the output.
	 * @param {String} postText Text to place after the output.
	 * @returns {*}
	 */
	bindData: function (obj, propName, preText, postText) {
		if (obj !== undefined && propName !== undefined) {
			this._bindDataObject = obj;
			this._bindDataProperty = propName;
			this._bindDataPreText = preText || '';
			this._bindDataPostText = postText || '';
		}

		return this;
	},

	/**
	 * Gets / sets the current horizontal text alignment. Accepts
	 * a value of 0, 1 or 2 (left, centre, right) respectively.
	 * @param {Number=} val
	 * @returns {*}
	 */
	textAlignX: function (val) {
		if (val !== undefined) {
			if (this._textAlignX !== val) {
				this.clearCache();
			}
			this._textAlignX = val;
			return this;
		}
		return this._textAlignX;
	},

	/**
	 * Gets / sets the current vertical text alignment. Accepts
	 * a value of 0, 1, 2, 3 (top, middle, bottom, justified) respectively.
	 * Defaults to 3 (justified)
	 * @param {Number} [val=3] val
	 * @returns {*}
	 */
	textAlignY: function (val) {
		if (val !== undefined) {
			if (this._textAlignY !== val) {
				this.clearCache();
			}
			this._textAlignY = val;
			return this;
		}
		return this._textAlignY;
	},

	/**
	 * Gets / sets the amount of spacing between the lines of text being
	 * rendered. Accepts negative values as well as positive ones.
	 * @param {Number=} val
	 * @returns {*}
	 */
	textLineSpacing: function (val) {
		if (val !== undefined) {
			if (this._textLineSpacing !== val) {
				this.clearCache();
			}
			this._textLineSpacing = val;
			return this;
		}
		return this._textLineSpacing;
	},

	/**
	 * Gets / sets the string hex or rgba value of the colour
	 * to use as an overlay when rending this entity's texture.
	 * @param {String=} val The colour value as hex e.g. '#ff0000'
	 * or as rgba e.g. 'rbga(255, 0, 0, 0.5)'. To remove an overlay
	 * colour simply passed an empty string.
	 * @return {*} "this" when arguments are passed to allow method
	 * chaining or the current value if no arguments are specified.
	 */
	colorOverlay: function (val) {
		if (val !== undefined) {
			if (this._colorOverlay !== val) {
				this.clearCache();
			}
			this._colorOverlay = val;
			return this;
		}

		return this._colorOverlay;
	},

	/**
	 * A proxy for colorOverlay().
	 */
	color: function (val) {
		return this.colorOverlay(val);
	},

	/**
	 * Clears the texture cache for this entity's text string.
	 */
	clearCache: function () {
		if (this._cache) {
			this.cacheDirty(true);
		}

		if (this._texture && this._texture._caching && this._texture._cacheText[this._renderText]) {
			delete this._texture._cacheText[this._renderText];
		}
	},

	/**
	 * When using native font rendering (canvasContext.fillText())
	 * this sets the font and size as per the canvasContext.font
	 * string specification.
	 * @param {String=} val The font style string.
	 * @return {*} "this" when arguments are passed to allow method
	 * chaining or the current value if no arguments are specified.
	 */
	nativeFont: function (val) {
		if (val !== undefined) {
			// Check if this font is different from the current
			// assigned font
			if (this._nativeFont !== val) {
				// The fonts are different, clear existing cache
				this.clearCache();
			}
			this._nativeFont = val;

			// Assign the native font smart texture
			var tex = new IgeTexture(IgeFontSmartTexture);
			this.texture(tex);
			
			// Set the flag indicating we are using a native font
			this._nativeMode = true;

			return this;
		}

		return this._nativeFont;
	},

	/**
	 * Gets / sets the text stroke size that applies when using
	 * a native font for text rendering.
	 * @param {Number=} val The size of the text stroke.
	 * @return {*}
	 */
	nativeStroke: function (val) {
		if (val !== undefined) {
			if (this._nativeStroke !== val) {
				this.clearCache();
			}
			this._nativeStroke = val;
			return this;
		}

		return this._nativeStroke;
	},

	/**
	 * Gets / sets the text stroke color that applies when using
	 * a native font for text rendering.
	 * @param {Number=} val The color of the text stroke.
	 * @return {*}
	 */
	nativeStrokeColor: function (val) {
		if (val !== undefined) {
			if (this._nativeStrokeColor !== val) {
				this.clearCache();
			}
			this._nativeStrokeColor = val;
			return this;
		}

		return this._nativeStrokeColor;
	},

	/**
	 * Gets / sets the auto-wrapping mode. If set to true then the
	 * text this font entity renders will be automatically line-broken
	 * when a line reaches the width of the entity.
	 * @param val
	 * @returns {*}
	 */
	autoWrap: function (val) {
		if (val !== undefined) {
			this._autoWrap = val;
			
			// Execute an auto-wrap modification of the text
			if (this._text) {
				this._applyAutoWrap();
				this.clearCache();
			}
			return this;
		}
		
		return this._autoWrap;
	},

	/**
	 * Automatically detects where line-breaks need to occur in the text
	 * assigned to the entity and adds them.
	 * @private
	 */
	_applyAutoWrap: function () {
		if (this._text) {
			// Un-wrap the text so it is all on one line
			var oneLineText = this._text.replace(/\n/g, ' '),
				words,
				wordIndex,
				textArray = [],
				currentTextLine = '',
				lineWidth;
			
			// Break the text into words
			words = oneLineText.split(' ');
			
			// There are multiple words - loop the words
			for (wordIndex = 0; wordIndex < words.length; wordIndex++) {
				if (currentTextLine) {
					currentTextLine += ' ';
				}
				currentTextLine += words[wordIndex];
				
				// Check the width and if greater than the width of the entity,
				// add a line break before the word
				lineWidth = this.measureTextWidth(currentTextLine);
				
				if (lineWidth >= this._bounds2d.x) {
					// Start a new line
					currentTextLine = words[wordIndex];
					
					// Add a line break
					textArray.push('\n' + words[wordIndex]);
				} else {
					textArray.push(words[wordIndex]);
				}
				
			}
			
			this._renderText = textArray.join(' ');
		}
	},

	/**
	 * Will measure and return the width in pixels of a line or multiple
	 * lines of text. If no text parameter is passed, will use the current
	 * text assigned to the font entity.
	 * @param {String=} text Optional text to measure, used existing entity
	 * text value if none is provided.
	 * @returns {Number} The width of the text in pixels.
	 */
	measureTextWidth: function (text) {
		text = text || this._text;
		
		// Both IgeFontSheet and the IgeFontSmartTexture have a method
		// called measureTextWidth() so we can just asks the current
		// texture for the width :)
		if (this._texture._mode === 0) {
			return this._texture.measureTextWidth(text);
		} else {
			return this._texture.script.measureTextWidth(text, this);
		}
	},

	tick: function (ctx) {
		// Check for an auto-progress update
		if (this._bindDataObject && this._bindDataProperty) {
			if (this._bindDataObject._alive === false) {
				// The object we have bind data from has been
				// destroyed so release our reference to it!
				delete this._bindDataObject;
			} else {
				this.text(this._bindDataPreText + this._bindDataObject[this._bindDataProperty] + this._bindDataPostText);
			}
		}

		IgeUiEntity.prototype.tick.call(this, ctx);
	},

	/**
	 * Returns a string containing a code fragment that when
	 * evaluated will reproduce this object's properties via
	 * chained commands. This method will only check for
	 * properties that are directly related to this class.
	 * Other properties are handled by their own class method.
	 * @return {String}
	 */
	_stringify: function () {
		// Get the properties for all the super-classes
		var str = IgeUiEntity.prototype._stringify.call(this), i;

		// Loop properties and add property assignment code to string
		for (i in this) {
			if (this.hasOwnProperty(i) && this[i] !== undefined) {
				switch (i) {
					case '_text':
						str += ".text(" + this.text() + ")";
						break;
					case '_textAlignX':
						str += ".textAlignX(" + this.textAlignX() + ")";
						break;
					case '_textAlignY':
						str += ".textAlignY(" + this.textAlignY() + ")";
						break;
					case '_textLineSpacing':
						str += ".textLineSpacing(" + this.textLineSpacing() + ")";
						break;
				}
			}
		}

		return str;
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = IgeFontEntity; }
/**
 * Creates a new particle emitter.
 */
var IgeParticleEmitter = IgeUiEntity.extend({
	classId: 'IgeParticleEmitter',
	IgeParticleEmitter: true,

	init: function () {
		// IgeBody.init()
		IgeUiEntity.prototype.init.call(this);

		// Set some defaults
		this._currentDelta = 0;
		this._started = false;
		this._particles = [];

		this.applyDepthToParticles(true);
		this.applyLayerToParticles(true);
		this.quantityTimespan(1000);
		this.quantityBase(10);
		this.quantityVariance(0, 0);
		this.translateBaseX(0);
		this.translateBaseY(0);
		this.translateBaseZ(0);
		this.translateVarianceX(0, 0);
		this.translateVarianceY(0, 0);
		this.translateVarianceZ(0, 0);
		this.rotateBase(0);
		this.rotateVariance(0, 0);
		this.deathRotateBase(0);
		this.deathRotateVariance(0, 0);
		this.scaleBaseX(1);
		this.scaleBaseY(1);
		this.scaleBaseZ(1);
		this.scaleVarianceX(0, 0);
		this.scaleVarianceY(0, 0);
		this.scaleVarianceZ(0, 0);
		this.scaleLockAspect(false);
		this.deathScaleBaseX(0);
		this.deathScaleBaseY(0);
		this.deathScaleBaseZ(0);
		this.deathScaleVarianceX(0, 0);
		this.deathScaleVarianceY(0, 0);
		this.deathScaleVarianceZ(0, 0);
		this.deathScaleLockAspect(false);
		this.opacityBase(1);
		this.opacityVariance(0, 0);
		this.deathOpacityBase(1);
		this.deathOpacityVariance(0, 0);
		this.lifeBase(1000);
		this.lifeVariance(0, 0);
	},

	/**
	 * Sets the class that all particles emitted from this
	 * emitter will be created from.
	 * @param {IgeEntity} obj
	 * @return {*}
	 */
	particle: function (obj) {
		this._particle = obj;
		return this;
	},

	particleMountTarget: function (obj) {
		this._particleMountTarget = obj;
		return this;
	},

	applyDepthToParticles: function (val) {
		this._applyDepthToParticles = val;
		return this;
	},

	applyLayerToParticles: function (val) {
		this._applyLayerToParticles = val;
		return this;
	},

	quantityTimespan: function (val) {
		this._quantityTimespan = val;
		return this;
	},

	quantityBase: function (val) {
		this._quantityBase = val;
		return this;
	},

	quantityVariance: function (a, b) {
		this._quantityVariance = [a, b];
		return this;
	},

	quantityMax: function (val) {
		this._quantityMax = val;
		this._quantityProduced = 0;
		return this;
	},

	translateBaseX: function (val) {
		this._translateBaseX = val;
		return this;
	},

	translateBaseY: function (val) {
		this._translateBaseY = val;
		return this;
	},

	translateBaseZ: function (val) {
		this._translateBaseZ = val;
		return this;
	},

	translateVarianceX: function (a, b) {
		this._translateVarianceX = [a, b];
		return this;
	},

	translateVarianceY: function (a, b) {
		this._translateVarianceY = [a, b];
		return this;
	},

	translateVarianceZ: function (a, b) {
		this._translateVarianceZ = [a, b];
		return this;
	},

	rotateBase: function (val) {
		this._rotateBase = val;
		return this;
	},

	rotateVariance: function (a, b) {
		this._rotateVariance = [a, b];
		return this;
	},

	deathRotateBase: function (val) {
		this._deathRotateBase = val;
		return this;
	},

	deathRotateVariance: function (a, b) {
		this._deathRotateVariance = [a, b];
		return this;
	},

	scaleBaseX: function (val) {
		this._scaleBaseX = val;
		return this;
	},

	scaleBaseY: function (val) {
		this._scaleBaseY = val;
		return this;
	},

	scaleBaseZ: function (val) {
		this._scaleBaseZ = val;
		return this;
	},

	scaleVarianceX: function (a, b) {
		this._scaleVarianceX = [a, b];
		return this;
	},

	scaleVarianceY: function (a, b) {
		this._scaleVarianceY = [a, b];
		return this;
	},

	scaleVarianceZ: function (a, b) {
		this._scaleVarianceZ = [a, b];
		return this;
	},

	scaleLockAspect: function (val) {
		this._scaleLockAspect = val;
		return this;
	},

	deathScaleBaseX: function (val) {
		this._deathScaleBaseX = val;
		return this;
	},

	deathScaleBaseY: function (val) {
		this._deathScaleBaseY = val;
		return this;
	},

	deathScaleBaseZ: function (val) {
		this._deathScaleBaseZ = val;
		return this;
	},

	deathScaleVarianceX: function (a, b) {
		this._deathScaleVarianceX = [a, b];
		return this;
	},

	deathScaleVarianceY: function (a, b) {
		this._deathScaleVarianceY = [a, b];
		return this;
	},

	deathScaleVarianceZ: function (a, b) {
		this._deathScaleVarianceZ = [a, b];
		return this;
	},

	deathScaleLockAspect: function (val) {
		this._deathScaleLockAspect = val;
		return this;
	},

	opacityBase: function (val) {
		this._opacityBase = val;
		return this;
	},

	opacityVariance: function (a, b) {
		this._opacityVariance = [a, b];
		return this;
	},

	deathOpacityBase: function (val) {
		this._deathOpacityBase = val;
		return this;
	},

	deathOpacityVariance: function (a, b) {
		this._deathOpacityVariance = [a, b];
		return this;
	},

	lifeBase: function (val) {
		this._lifeBase = val;
		return this;
	},

	lifeVariance: function (a, b) {
		this._lifeVariance = [a, b];
		return this;
	},

	/**
	 * Sets the base velocity vector of each emitted particle and optionally
	 * the min and max vectors that are used to randomize the resulting particle
	 * velocity vector.
	 * @param baseVector
	 * @param minVector
	 * @param maxVector
	 */
	velocityVector: function (baseVector, minVector, maxVector) {
		this._velocityVector = {
			base: baseVector,
			min: minVector,
			max: maxVector
		};

		return this;
	},

	linearForceVector: function (baseVector, minVector, maxVector) {
		this._linearForceVector = {
			base: baseVector,
			min: minVector,
			max: maxVector
		};

		return this;
	},

	/**
	 * Starts the particle emitter which will begin spawning
	 * particle entities based upon the emitter's current settings.
	 * @return {*}
	 */
	start: function () {
		if (this._particle) {
			// Update the transform matrix before starting
			// otherwise some particles might read the old
			// matrix values if the start method was chained!
			this.updateTransform();

			this._quantityTimespan = this._quantityTimespan !== undefined ? this._quantityTimespan : 1000;
			this._maxParticles = this.baseAndVarianceValue(this._quantityBase, this._quantityVariance, true);
			this._particlesPerTimeVector = this._quantityTimespan / this._maxParticles; // 1 Particle every x milliseconds (x stored in this._particlesPerTimeVector)
			this._currentDelta = 0;

			// Set the emitter started flag
			this._quantityProduced = 0;
			this._started = true;
		} else {
			this.log('Cannot start particle emitter because no particle class was specified with a call to particle()', 'error');
		}

		return this;
	},
	
	updateSettings: function () {
		this._maxParticles = this.baseAndVarianceValue(this._quantityBase, this._quantityVariance, true);
		this._particlesPerTimeVector = this._quantityTimespan / this._maxParticles; // 1 Particle every x milliseconds (x stored in this._particlesPerTimeVector)
	},

	/**
	 * Stops the particle emitter. The current particles will
	 * continue to process until they reach their natural lifespan.
	 * @return {*}
	 */
	stop: function () {
		this._started = false;
		return this;
	},

	/**
	 * Stops the particle emitter. The current particles will be
	 * destroyed immediately.
	 * @return {*}
	 */
	stopAndKill: function () {
		this._started = false;

		// Loop the particles array and destroy all the particles
		var arr = this._particles,
			arrCount = arr.length;

		while (arrCount--) {
			arr[arrCount].destroy();
		}

		// Remove all references to the particles by
		// re-initialising the particles array
		this._particles = [];

		return this;
	},

	/**
	 * Takes a base value and a variance range and returns a random
	 * value between the range, added to the base.
	 * @param {Number} base The base value.
	 * @param {Array} variance An array containing the two values of
	 * the variance range.
	 * @param {Boolean} floorIt If set to true, will cause the returned
	 * value to be passed through Math.floor().
	 * @return {Number} Returns the final value based upon the base
	 * value and variance range.
	 */
	baseAndVarianceValue: function (base, variance, floorIt) {
		base = base || 0;
		variance = variance || [0, 0];
		var variant = 0;

		if (floorIt) {
			variant = Math.floor(variance[0] + Math.random() * (variance[1] - variance[0]));
		} else {
			variant = (variance[0] + Math.random() * (variance[1] - variance[0]));
		}

		return base + variant;
	},

	vectorFromBaseMinMax: function (vectorData) {
		if (vectorData.min && vectorData.max) {
			var base = vectorData.base,
				min = vectorData.min,
				max = vectorData.max,
				newVector = {};

			newVector.x = base.x + (min.x + Math.random() * (max.x - min.x));
			newVector.y = base.y + (min.y + Math.random() * (max.y - min.y));
			newVector.z = base.z + (min.z + Math.random() * (max.z - min.z));

			return newVector;
		} else {
			// There was no variance data so return the base vector
			return vectorData.base;
		}
	},

	/**
	 * Creates and maintains the particles that this emitter is
	 * responsible for spawning and controlling.
	 * @param ctx
	 */
	tick: function (ctx) {
		this._currentDelta += ige._tickDelta;

		// Check if the emitter is mounted to anything and started, if not
		// then don't bother creating particles!
		if (this._parent && this._started) {
			if (!this._quantityMax || this._quantityProduced < this._quantityMax) {
				var particleCount,
					translateX,
					translateY,
					translateZ,
					//vectorAngle,
					//vectorPower,
					velocityVector,
					newVecX, newVecY,
					rotX, rotY,
					cosRot, sinRot,
					scaleX,
					scaleY,
					scaleZ,
					rotate,
					opacity,
					life,
					//linearForceAngle,
					//linearForcePower,
					linearForceVector,
					deathScaleX,
					deathScaleY,
					deathScaleZ,
					deathRotate,
					deathOpacity,
					tempParticle,
					tweens,
					scaleProps,
					i;

				if (this._currentDelta > this._quantityTimespan) {
					this._currentDelta = this._quantityTimespan;
				}

				if (this._currentDelta >= this._particlesPerTimeVector) {
					particleCount = ((this._currentDelta / this._particlesPerTimeVector)|0); // Bitwise floor
					this._currentDelta -= (this._particlesPerTimeVector * particleCount);

					// Loop the particle array and if no particle exists,
					// create one to fill the space. Basically this keeps
					// the emitters creating new particles until it is
					// stopped.
					if (particleCount) {
						while (particleCount--) {
							if (this._quantityMax) {
								this._quantityProduced ++;

								// If the number of particles produced is equal to or greater
								// than the max we should produce then exit the loop
								if (this._quantityProduced >= this._quantityMax) {
									this.stop();
									break;
								}
							}

							// Create the initial particle values based on
							// the emitter options values

							// Generate the particle's initial translate values
							translateX = this.baseAndVarianceValue(this._translateBaseX, this._translateVarianceX, true);
							translateY = this.baseAndVarianceValue(this._translateBaseY, this._translateVarianceY, true);
							translateZ = this.baseAndVarianceValue(this._translateBaseZ, this._translateVarianceZ, true);

							//translateX += this._worldMatrix.matrix[2];
							//translateY += this._worldMatrix.matrix[5];

							if (this._velocityVector) {
								// Generate the particle's initial vector angle and power
								velocityVector = this.vectorFromBaseMinMax(this._velocityVector);

								// Rotate the vector's point to match the current emitter rotation
								rotX = velocityVector.x;
								rotY = velocityVector.y;
								cosRot = this._worldMatrix.matrix[0]; //Math.cos(this._rotate.z);
								sinRot = this._worldMatrix.matrix[3]; //Math.sin(this._rotate.z);
								newVecX = rotX * cosRot - rotY * sinRot;
								newVecY = rotY * cosRot + rotX * sinRot;

								// Assign the rotated vector back again
								velocityVector.x = newVecX;
								velocityVector.y = newVecY;
							}

							//vectorAngle = this.baseAndVarianceValue(this._vectorAngleBase, this._vectorAngleVariance, true);
							//vectorPower = this.baseAndVarianceValue(this._vectorPowerBase, this._vectorPowerVariance, false);

							// Generate the particle's initial scale
							scaleX = this.baseAndVarianceValue(this._scaleBaseX, this._scaleVarianceX, false);
							scaleZ = scaleY = scaleX;
							if (!this._scaleLockAspect) {
								scaleY = this.baseAndVarianceValue(this._scaleBaseY, this._scaleVarianceY, false);
								scaleZ = this.baseAndVarianceValue(this._scaleBaseZ, this._scaleVarianceZ, false);
							}

							// Generate the particle's initial rotation
							rotate = this.baseAndVarianceValue(this._rotateBase, this._rotateVariance, true);

							// Generate the particle's initial opacity
							opacity = this.baseAndVarianceValue(this._opacityBase, this._opacityVariance, false);

							// Generate the particle's initial lifespan
							life = this.baseAndVarianceValue(this._lifeBase, this._lifeVariance, true);

							// Generate the particle's linear force vector angle and power
							if (this._linearForceVector) {
								linearForceVector = this.vectorFromBaseMinMax(this._linearForceVector);

								// Rotate the vector's point to match the current emitter rotation
								rotX = linearForceVector.x;
								rotY = linearForceVector.y;
								cosRot = this._worldMatrix.matrix[0]; //Math.cos(this._rotate.z);
								sinRot = this._worldMatrix.matrix[3]; //Math.sin(this._rotate.z);
								newVecX = rotX * cosRot - rotY * sinRot;
								newVecY = rotY * cosRot + rotX * sinRot;

								// Assign the rotated vector back again
								linearForceVector.x = newVecX;
								linearForceVector.y = newVecY;
							}

							//linearForceAngle = this.baseAndVarianceValue(this._linearForceAngleBase, this._linearForceAngleVariance);
							//linearForcePower = this.baseAndVarianceValue(this._linearForcePowerBase, this._linearForcePowerVariance, false);

							// Generate the particle's death scale
							if (typeof(this._deathScaleBaseX) !== 'undefined') {
								deathScaleX = this.baseAndVarianceValue(
									this._deathScaleBaseX,
									this._deathScaleVarianceX,
									false
								);
							}
							if (typeof(this._deathScaleBaseY) !== 'undefined' && !this._deathScaleLockAspect) {
								deathScaleY = this.baseAndVarianceValue(
									this._deathScaleBaseY,
									this._deathScaleVarianceY,
									false
								);
							}
							if (typeof(this._deathScaleBaseZ) !== 'undefined' && !this._deathScaleLockAspect) {
								deathScaleZ = this.baseAndVarianceValue(
									this._deathScaleBaseZ,
									this._deathScaleVarianceZ,
									false
								);
							}
							if (this._deathScaleLockAspect) {
								deathScaleZ = deathScaleY = deathScaleX;
							}

							// Generate the particle's death rotation
							if (typeof(this._deathRotateBase) !== 'undefined') {
								deathRotate = this.baseAndVarianceValue(
									this._deathRotateBase,
									this._deathRotateVariance,
									true
								);
							}

							// Generate the particle's death opacity
							if (typeof(this._deathOpacityBase) !== 'undefined') {
								deathOpacity = this.baseAndVarianceValue(
									this._deathOpacityBase,
									this._deathOpacityVariance,
									false
								);
							}

							// Create the particle entity
							tempParticle = new this._particle(this);

							// Add the current transform of the emitter to the final
							// particle transforms
							if (this._ignoreCamera) {
								translateX += this._translate.x;
								translateY += this._translate.y;
							} else {
								translateX += this._worldMatrix.matrix[2];
								translateY += this._worldMatrix.matrix[5];
							}
							translateZ += this._translate.z;

							scaleX *= this._scale.x;
							scaleY *= this._scale.y;
							scaleZ *= this._scale.z;

							deathScaleX *= this._scale.x;
							deathScaleY *= this._scale.y;
							deathScaleZ *= this._scale.z;

							// Apply all the transforms (don't do this in the initial
							// entity definition because some components may already
							// have initialised due to the particle template
							tempParticle.translateTo(translateX, translateY, translateZ);
							tempParticle.rotateTo(0, 0, Math.radians(rotate));
							tempParticle.scaleTo(scaleX, scaleY, scaleZ);
							tempParticle.opacity(opacity);

							if (this._applyDepthToParticles) { tempParticle.depth(this._depth); }
							if (this._applyLayerToParticles) { tempParticle.layer(this._layer); }

							if (typeof(velocityVector) === 'object') {
								tempParticle.velocity.vector3(velocityVector, false);
							}

							if (typeof(linearForceVector) === 'object') {
								tempParticle.velocity.linearForceVector3(linearForceVector, false);
							}

							tweens = [];
							if (typeof(deathRotate) !== 'undefined') {
								tweens.push(new IgeTween()
									.targetObj(tempParticle._rotate)
									.properties({z: Math.radians(deathRotate)})
									.duration(life));
							}
							if (typeof(deathOpacity) !== 'undefined') {
								tweens.push(new IgeTween()
									.targetObj(tempParticle)
									.properties({_opacity: deathOpacity})
									.duration(life));
							}

							scaleProps = {};
							if (typeof(deathScaleX) !== 'undefined') {
								scaleProps.x = deathScaleX;
							}
							if (typeof(deathScaleY) !== 'undefined') {
								scaleProps.y = deathScaleY;
							}
							if (typeof(deathScaleZ) !== 'undefined') {
								scaleProps.z = deathScaleZ;
							}

							if (scaleProps.x || scaleProps.y || scaleProps.z) {
								tweens.push(new IgeTween()
									.targetObj(tempParticle._scale)
									.properties(scaleProps)
									.duration(life));
							}

							if (typeof(life) === 'number') {
								tempParticle.lifeSpan(life);
							}

							// Add the particle to this emitter's particle array
							this._particles.push(tempParticle);

							// Add the particle to the scene
							tempParticle.mount(this._particleMountTarget || this._parent);

							// Start the relevant tweens
							for (i = 0; i < tweens.length; i++) {
								tweens[i].start();
							}
						}
					}
				}
			}
		}

		IgeUiEntity.prototype.tick.call(this, ctx);
	},

	/**
	 * Returns an array of the current particle entities that this
	 * emitter has spawned.
	 * @return {Array} The array of particle entities the emitter spawned.
	 */
	particles: function () {
		return this._particles;
	},

	/**
	 * Returns a string containing a code fragment that when
	 * evaluated will reproduce this object's properties via
	 * chained commands. This method will only check for
	 * properties that are directly related to this class.
	 * Other properties are handled by their own class method.
	 * @return {String}
	 */
	_stringify: function () {
		// Get the properties for all the super-classes
		var str = IgeUiEntity.prototype._stringify.call(this), i;
		return str;

		// TODO: WRITE THIS FOR THIS CLASS - EPIC AMOUNT OF WORK HERE
		// Loop properties and add property assignment code to string
		for (i in this) {
			if (this.hasOwnProperty(i) && this[i] !== undefined) {
				switch (i) {
					case '':
						str += ".text(" + this.text() + ")";
						break;
				}
			}
		}

		return str;
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = IgeParticleEmitter; }
var IgeParticle = IgeEntity.extend({
	classId: 'IgeParticle',
	
	init: function (emitter) {
		this._emitter = emitter;
		IgeEntity.prototype.init.call(this);

		// Setup the particle default values
		this.addComponent(IgeVelocityComponent);
	},

	destroy: function () {
		// Remove ourselves from the emitter
		if (this._emitter !== undefined) {
			this._emitter._particles.pull(this);
		}
		IgeEntity.prototype.destroy.call(this);
	}
});
/**
 * Creates a new map that has two dimensions (x and y) to it's data.
 */
var IgeMap2d = IgeClass.extend({
	classId: 'IgeMap2d',

	init: function (data) {
		this._mapData = data || [];
	},

	/**
	 * Gets / sets a value on the specified map tile co-ordinates.
	 * @param {Number} x
	 * @param {Number} y
	 * @param {*=} val The data to set on the map tile co-ordinate.
	 * @return {*}
	 */
	tileData: function (x, y, val) {
		if (x !== undefined && y !== undefined) {
			if (val !== undefined) {
				// Assign a value
				this._mapData[y] = this._mapData[y] || [];
				this._mapData[y][x] = val;
				return this;
			} else {
				// No assignment so see if we have data to return
				if (this._mapData[y]) {
					return this._mapData[y][x];
				}
			}
		}

		// Either no x, y was specified or there was
		// no data at the x, y so return undefined
		return undefined;
	},

	/**
	 * Clears any data set at the specified map tile co-ordinates.
	 * @param x
	 * @param y
	 * @return {Boolean} True if data was cleared or false if no data existed.
	 */
	clearData: function (x, y) {
		if (x !== undefined && y !== undefined) {
			if (this._mapData[y] !== undefined) {
				delete this._mapData[y][x];
				return true;
			}
		}

		return false;
	},

	/**
	 * Checks if the tile area passed has any data stored in it. If
	 * so, returns true, otherwise false.
	 * @param x
	 * @param y
	 * @param width
	 * @param height
	 */
	collision: function (x, y, width, height) {
		var xi, yi;

		if (width === undefined) { width = 1; }
		if (height === undefined) { height = 1; }

		if (x !== undefined && y !== undefined) {
			for (yi = 0; yi < height; yi++) {
				for (xi = 0; xi < width; xi++) {
					if (this.tileData(x + xi, y + yi)) {
						return true;
					}
				}
			}
		}

		return false;
	},
	
	/**
	 * Checks if the tile area passed has data stored in it that matches
	 * the passed data. If so, returns true, otherwise false.
	 * @param x
	 * @param y
	 * @param width
	 * @param height
	 * @param data
	 */
	collisionWith: function (x, y, width, height, data) {
		var xi, yi;

		if (width === undefined) { width = 1; }
		if (height === undefined) { height = 1; }

		if (x !== undefined && y !== undefined) {
			for (yi = 0; yi < height; yi++) {
				for (xi = 0; xi < width; xi++) {
					if (this.tileData(x + xi, y + yi) === data) {
						return true;
					}
				}
			}
		}

		return false;
	},
	
	/**
	 * Checks if the tile area passed has data stored in it that matches
	 * the passed data and does not collide with any other stored tile
	 * data. If so, returns true, otherwise false.
	 * @param x
	 * @param y
	 * @param width
	 * @param height
	 * @param data
	 */
	collisionWithOnly: function (x, y, width, height, data) {
		var xi, yi,
			tileData,
			withData = false;

		if (width === undefined) { width = 1; }
		if (height === undefined) { height = 1; }

		if (x !== undefined && y !== undefined) {
			for (yi = 0; yi < height; yi++) {
				for (xi = 0; xi < width; xi++) {
					tileData = this.tileData(x + xi, y + yi);
					if (tileData) {
						if (this.tileData(x + xi, y + yi) === data) {
							withData = true;
						} else {
							return false;
						}
					}
				}
			}
		}

		return withData;
	},

	/**
	 * Gets / sets the map's tile data.
	 * @param {Array} val The map data array.
	 * @param {Integer} startX The start x co-ordinate of the data.
	 * @param {Integer} startY The start y co-ordinate of the data.
	 * @return {*}
	 */
	mapData: function (val, startX, startY) {
		if (val !== undefined) {
			if (!startX && !startY) {
				this._mapData = val;
			} else {
				// Loop the map data and apply based on the start positions
				var x, y;
				
				for (y in val) {
					for (x in val[y]) {
						this._mapData[startY + parseInt(y)][startX + parseInt(x)] = val[y][x];
					}
				}
			}
			return this;
		}

		return this._mapData;
	},
	
	sortedMapDataAsArray: function () {
		var data = this.mapData(),
			finalData = {};
		
		var x, y, xArr, yArr, i, k;
				
		yArr = this._sortKeys(data);
		
		for (i = 0; i < yArr.length; i++) {
			y = yArr[i];
			xArr = this._sortKeys(data[y]);
			
			finalData[y] = finalData[y] || {};
			
			for (k = 0; k < xArr.length; k++) {
				x = xArr[k];
				finalData[y][x] = data[y][x];
			}
		}
		
		return finalData;
	},
	
	_sortKeys: function (obj) {
		var arr = [];
		
		for (var i in obj) {
			arr.push(i);
		}
		
		arr.sort();
		return arr;
	},

	/**
	 * Returns a string of the map's data in JSON format.
	 * @return {String}
	 */
	mapDataString: function () {
		return JSON.stringify(this.mapData());
	},

	/**
	 * Inserts map data into the map at the given co-ordinates. Please note this
	 * is not used for setting a tile's value. This is used to add large sections
	 * of map data at the specified co-ordinates. To set an individual tile value,
	 * please use tile(x, y, val).
	 * @param {Number} x
	 * @param {Number} y
	 * @param {Array} val The map data array.
	 */
		//TODO: Write this function's internals!
	insertMapData: function (x, y, val) {
		// Loop the data and fill the map data with it
	},

	/**
	 * Rotates map data either -90 degrees (anti-clockwise), 90 degrees (clockwise) or
	 * 180 degrees. Useful when you want to define one section of a map and then re-use
	 * it in slightly different layouts.
	 * @param {Array} val The map data array to rotate.
	 * @param {Number} mode Either -90, 90 or 180 to denote the type of rotation to perform.
	 */
		//TODO: Write this function's internals!
	rotateData: function (val, mode) {
		switch (mode) {
			case -90:
				// Rotate the data
			break;

			case 180:
			break;

			case 90:
			default:
			break;
		}
	},
	
	translateDataBy: function (transX, transY) {
		var yArr = this.mapData(),
			newArr = [],
			x, y,
			xArr,
			i, k;
		
		for (y in yArr) {
			if (yArr.hasOwnProperty(y)) {
				i = parseInt(y, 10);
				xArr = yArr[i];
				
				newArr[i + transY] = newArr[i + transY] || {};
				
				for (x in xArr) {
					if (xArr.hasOwnProperty(x)) {
						k = parseInt(x, 10);
						newArr[i + transY][k + transX] = yArr[y][x];
					}
				}
			}
		}
		
		this.mapData(newArr, 0, 0);
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = IgeMap2d; }
/**
 * Tile maps provide a way to align mounted child objects to a tile-based grid.
 * NOTE: These are not to be confused with IgeTextureMap's which allow you to
 * paint a bunch of tiles to a grid.
 */
var IgeTileMap2d = IgeEntity.extend({
	classId: 'IgeTileMap2d',
	IgeTileMap2d: true,

	init: function (tileWidth, tileHeight) {
		IgeEntity.prototype.init.call(this);

		tileWidth = tileWidth !== undefined ? tileWidth : 40;
		tileHeight = tileHeight !== undefined ? tileHeight : 40;
		
		var self = this;

		if (!ige.isServer) {
			var tex = new IgeTexture(IgeTileMap2dSmartTexture);
			self.texture(tex);
		}
		
		self.map = new IgeMap2d();
		self._adjustmentMatrix = new IgeMatrix2d();

		self.tileWidth(tileWidth);
		self.tileHeight(tileHeight);
		self.gridSize(3, 3);

		self._drawGrid = 0;
        self._gridColor = '#ffffff';
	},

	/**
	 * Gets / sets the flag that determines if the tile map will paint the
	 * occupied tiles with an overlay colour so that it is easy to spot them.
	 * @param val
	 * @return {*}
	 */
	highlightOccupied: function (val) {
		if (val !== undefined) {
			this._highlightOccupied = val;
			return this;
		}

		return this._highlightOccupied;
	},

	highlightTileRect: function (val) {
		if (val !== undefined) {
			this._highlightTileRect = val;
			return this;
		}

		return this._highlightTileRect;
	},

	/**
	 * Gets / sets the map's tile width.
	 * @param {Number} val Tile width.
	 * @return {*}
	 */
	tileWidth: function (val) {
		if (val !== undefined) {
			this._tileWidth = val;
			if (this._gridSize && this._gridSize.x) {
				this.width(this._tileWidth * this._gridSize.x);
				this._updateAdjustmentMatrix();
			}
			
			return this;
		}

		return this._tileWidth;
	},

	/**
	 * Gets / sets the map's tile height.
	 * @param {Number} val Tile height.
	 * @return {*}
	 */
	tileHeight: function (val) {
		if (val !== undefined) {
			this._tileHeight = val;
			if (this._gridSize && this._gridSize.y) {
				this.height(this._tileHeight * this._gridSize.y);
				this._updateAdjustmentMatrix();
			}
			
			return this;
		}

		return this._tileHeight;
	},
	
	gridSize: function (x, y) {
		if (x !== undefined && y !== undefined) {
			this._gridSize = new IgePoint2d(x, y);
			
			// If in 2d mount mode
			if (this._mountMode === 0) {
				if (this._tileWidth) {
					this.width(this._tileWidth * this._gridSize.x);
				}
			}
			
			// If in isometric mount mode
			if (this._mountMode === 1) {
				if (this._tileWidth) {
					this.width((this._tileWidth * 2) * this._gridSize.x);
				}
			}
			
			if (this._tileHeight) {
				this.height(this._tileHeight * this._gridSize.y);
			}
			
			this._updateAdjustmentMatrix();
			
			return this;
		}

		return this._gridSize;
	},
	
	/**
	 * Gets / sets if the tile map should paint a grid to the context during
	 * the tick method.
	 * @param {Boolean=} val If true, will paint the grid on tick.
	 * @return {*}
	 */
	drawGrid: function (val)  {
		if (val !== undefined) {
			this._drawGrid = val;
			return this;
		}

		return this._drawGrid;
	},

	/**
	 * Gets / sets the color of the grid overlay. It accepts a string color
	 * definition with the same specifications as the canvas context strokeStyle
	 * property.
	 * @param {String=} val The color of the grid.
	 * @return {*}
	 */
	gridColor: function (val)  {
		if (val !== undefined) {
			this._gridColor = val;
			return this;
		}

		return this._gridColor;
	},
	
	/**
	 * Sets a tile or area as occupied by the passed obj parameter.
	 * Any previous occupy data on the specified tile or area will be
	 * overwritten.
	 * @param {Number} x X co-ordinate of the tile to un-occupy.
	 * @param {Number} y Y co-ordinate of the tile to un-occupy.
	 * @param {Number} width Number of tiles along the x-axis to occupy.
	 * @param {Number} height Number of tiles along the y-axis to occupy.
	 * @param {*} obj
	 * @return {*}
	 */
	occupyTile: function (x, y, width, height, obj) {
		var xi, yi;

		if (width === undefined) { width = 1; }
		if (height === undefined) { height = 1; }

		// Floor the values
		x = Math.floor(x);
		y = Math.floor(y);
		width = Math.floor(width);
		height = Math.floor(height);

		if (x !== undefined && y !== undefined) {
			for (xi = 0; xi < width; xi++) {
				for (yi = 0; yi < height; yi++) {
					this.map.tileData(x + xi, y + yi, obj);
				}
			}

			// Create an IgeRect to represent the tiles this
			// entity has just occupied
			if (obj._classId) {
				obj._occupiedRect = new IgeRect(x, y, width, height);
			}
		}
		return this;
	},

	/**
	 * Removes all data from the specified tile or area.
	 * @param {Number} x
	 * @param {Number} y
	 * @param {Number=} width
	 * @param {Number=} height
	 * @return {*}
	 */
	unOccupyTile: function (x, y, width, height) {
		var xi, yi, item;

		if (width === undefined) { width = 1; }
		if (height === undefined) { height = 1; }

		// Floor the values
		x = Math.floor(x);
		y = Math.floor(y);
		width = Math.floor(width);
		height = Math.floor(height);

		if (x !== undefined && y !== undefined) {
			for (xi = 0; xi < width; xi++) {
				for (yi = 0; yi < height; yi++) {
					item = this.map.tileData(x + xi, y + yi);
					if (item && item._occupiedRect) {
						delete item._occupiedRect;
					}
					this.map.clearData(x + xi, y + yi);
				}
			}


		}
		return this;
	},

	/**
	 * Returns true if the specified tile or tile area has
	 * an occupied status.
	 * @param {Number} x
	 * @param {Number} y
	 * @param {Number=} width
	 * @param {Number=} height
	 * @return {*}
	 */
	isTileOccupied: function (x, y, width, height) {
		if (width === undefined) { width = 1; }
		if (height === undefined) { height = 1; }

		return this.map.collision(x, y, width, height);
	},

	tileOccupiedBy: function (x, y) {
		return this.map.tileData(x, y);
	},

	/**
	 * Returns the tile co-ordinates of the tile that the point's world
	 * co-ordinates reside inside.
	 * @param {IgePoint3d} point
	 * @return {IgePoint3d} The tile co-ordinates as a point object.
	 */
	pointToTile: function (point) {
		// TODO: Could this do with some caching to check if the input values have changed and if not,
		// TODO: supply the same pre-calculated data if it already exists?
		var mx = point.x,
			my = point.y,
			dx, dy, tilePos;

		if (this._mountMode === 0) {
			// 2d
			dx = mx; //+ this._tileWidth / 2;
			dy = my; //+ this._tileHeight / 2;

			tilePos = new IgePoint3d(
				Math.floor(dx / this._tileWidth),
				Math.floor(dy / this._tileWidth),
				0
			);
		}

		if (this._mountMode === 1) {
			// iso
			dx = mx;
			dy = my;
			
			tilePos = new IgePoint3d(
				Math.floor(dx / this._tileWidth),
				Math.floor(dy / this._tileHeight),
				0
			);
		}

		return tilePos;
	},

	/**
	 * Returns the world co-ordinates of the tile the mouse is currently over.
	 * @return {IgePoint3d}
	 */
	mouseTilePoint: function () {
		var tilePos = this.mouseToTile()
			.thisMultiply(this._tileWidth, this._tileHeight, 1);

		tilePos.x += this._tileWidth / 2;
		tilePos.y += this._tileHeight / 2;
		
		return tilePos;
	},
	
	tileToPoint: function (x, y) {
		var point;
		
		if (this._mountMode === 0) {
			point = new IgePoint3d(x, y, 0)
				.thisMultiply(this._tileWidth, this._tileHeight, 1);
			
			point.x -= this._bounds2d.x2 - (this._tileWidth / 2);
			point.y -= this._bounds2d.y2 - (this._tileHeight / 2);
		}
		
		if (this._mountMode === 1) {
			point = new IgePoint3d(x * this._tileWidth + this._tileWidth / 2, y * this._tileHeight + this._tileHeight / 2, 0);
			point.x -= this._bounds2d.x2 / 2;
			point.y -= this._bounds2d.y2;
		}
		
		point.x2 = point.x / 2;
		point.y2 = point.y / 2;
		
		return point;
	},

	/**
	 * Returns the tile co-ordinates of the tile the mouse is currently over.
	 * @return {IgePoint3d}
	 */
	mouseToTile: function () {
		var tilePos;
		
		if (this._mountMode === 0) {
			tilePos = this.pointToTile(this.mousePos());
		} else {
			tilePos = this.pointToTile(this.mousePos().to2d());
		}
		
		return tilePos;
	},

	/**
	 * Scans the map data and returns an array of rectangle
	 * objects that encapsulate the map data into discrete
	 * rectangle areas.
	 * @param {Function=} callback Returns true or false for
	 * the passed map data determining if it should be included
	 * in a rectangle or not.
	 * @return {Array}
	 */
	scanRects: function (callback) {
		var x, y,
			rectArray = [],
			mapData = this.map._mapData.clone();

		// Loop the map data and scan for blocks that can
		// be converted into static box2d rectangle areas
		for (y in mapData) {
			if (mapData.hasOwnProperty(y)) {
				for (x in mapData[y]) {
					if (mapData[y].hasOwnProperty(x)) {
						if (mapData[y][x] && (!callback || (callback && callback(mapData[y][x], x, y)))) {
							rectArray.push(this._scanRects(mapData, parseInt(x, 10), parseInt(y, 10), callback));
						}
					}
				}
			}
		}

		return rectArray;
	},

	_scanRects: function (mapData, x, y, callback) {
		var rect = {
				x: x,
				y: y,
				width: 1,
				height: 1
			},
			nx = x + 1,
			ny = y + 1;

		// Clear the current x, y cell mapData
		mapData[y][x] = 0;

		while (mapData[y][nx] && (!callback || (callback && callback(mapData[y][nx], nx, y)))) {
			rect.width++;

			// Clear the mapData for this cell
			mapData[y][nx] = 0;

			// Next column
			nx++;
		}

		while (mapData[ny] && mapData[ny][x] && (!callback || (callback && callback(mapData[ny][x], x, ny)))) {
			// Check for mapData either side of the column width
			if ((mapData[ny][x - 1] && (!callback || (callback && callback(mapData[ny][x - 1], x - 1, ny)))) || (mapData[ny][x + rect.width] && (!callback || (callback && callback(mapData[ny][x + rect.width], x + rect.width, ny))))) {
				return rect;
			}

			// Loop the column's map data and check that there is
			// an intact column the same width as the starting column
			for (nx = x; nx < x + rect.width; nx++) {
				if (!mapData[ny][nx] || (callback && !callback(mapData[ny][nx], nx, ny))) {
					// This row has a different column width from the starting
					// column so return the rectangle as it stands
					return rect;
				}
			}

			// Mark the row as cleared
			for (nx = x; nx < x + rect.width; nx++) {
				mapData[ny][nx] = 0;
			}

			rect.height++;
			ny++;
		}

		return rect;
	},
	
	inGrid: function (x, y, width, height) {
		if (width === undefined) { width = 1; }
		if (height === undefined) { height = 1; }
		
		// Checks if the passed area is inside the tile map grid as defined by gridSize
		return x >= 0 && y >= 0 && x + width <= this._gridSize.x && y + height <= this._gridSize.y;
	},

	/**
	 * Gets / sets the mouse tile hover color used in conjunction with the
	 * drawMouse() method.
	 * @param {String=} val The hex or rbg string color definition e.g. #ff0099.
	 * @returns {*}
	 */
	hoverColor: function (val) {
		if (val !== undefined) {
			this._hoverColor = val;
			return this;
		}
		
		return this._hoverColor;
	},
	
	/**
	 * Loads map data from a saved map.
	 * @param {Object} map The map data object.
	 */
	loadMap: function (map) {
		// Just fill in the map data
		this.map.mapData(map.data, 0, 0);

		return this;
	},

	/**
	 * Returns a map JSON string that can be saved to a data file and loaded
	 * with the loadMap() method.
	 * @return {Object} The map data object.
	 */
	saveMap: function () {
		// in URL format
		var textures = [], i,
			x, y,
			dataX = 0, dataY = 0,
			mapData = this.map._mapData;

		// Get the lowest x, y
		for (y in mapData) {
			if (mapData.hasOwnProperty(y)) {
				for (x in mapData[y]) {
					if (mapData[y].hasOwnProperty(x)) {
						if (parseInt(x) < parseInt(dataX)) {
							dataX = parseInt(x);
						}

						if (parseInt(y) < parseInt(dataY)) {
							dataY = parseInt(y);
						}
					}
				}
			}
		}

		return JSON.stringify({
			data: this.map.sortedMapDataAsArray(),
			dataXY: [parseInt(dataX, 10), parseInt(dataY, 10)]
		});
	},
	
	isometricMounts: function (val) {
		if (val !== undefined) {
			IgeEntity.prototype.isometricMounts.call(this, val);
			
			// Re-call the methods that check iso mounts property
			this.tileWidth(this._tileWidth);
			this.tileHeight(this._tileHeight);
			this.gridSize(this._gridSize.x, this._gridSize.y);
			
			this._updateAdjustmentMatrix();
			return this;
		}
		
		return this._mountMode;
	},
	
	tileMapHitPolygon: function (mousePoint) {
		if (this._mountMode === 0) {
			return this.aabb();
		}
		
		if (this._mountMode === 1) {
			var aabb = this.aabb(),
				poly = new IgePoly2d();
			
			poly.addPoint(aabb.x + aabb.width / 2, aabb.y);
			poly.addPoint(aabb.x + aabb.width, aabb.y + aabb.height / 2);
			poly.addPoint(aabb.x + aabb.width / 2, (aabb.y + aabb.height) - 1);
			poly.addPoint(aabb.x - 1, (aabb.y + aabb.height / 2) - 1);
			
			return poly;
		}
	},
	
	_processTriggerHitTests: function () {
		// This method overrides the one in IgeEntity
		if (this._mouseEventsActive && ige._currentViewport) {
			if (!this._mouseAlwaysInside) {
				var mouseTile = this.mouseToTile();
				if (mouseTile.x >= 0 && mouseTile.y >= 0 && mouseTile.x < this._gridSize.x && mouseTile.y < this._gridSize.y) {
					return true;
				} else {
					return false;
				}
			} else {
				return true;
			}
		}
		
		return false;
	},
	
	_updateAdjustmentMatrix: function () {
		if (this._bounds2d.x2 && this._bounds2d.y2 && this._tileWidth && this._tileHeight) {
			if (this._mountMode === 0) {
				this._adjustmentMatrix.translateTo(this._bounds2d.x2, this._bounds2d.y2);
			}
			
			if (this._mountMode === 1) {
				this._adjustmentMatrix.translateTo(0, this._bounds2d.y2);
			}
		}
	},

	_childMounted: function (obj) {
		// We can also re-use the tile size methods since
		// they alter the same properties on the calling
		// entity anyway.
		obj.tileWidth = obj.tileWidth || this.tileWidth;
		obj.tileHeight = obj.tileHeight || this.tileHeight;

		// Set default values
		obj._tileWidth = obj._tileWidth || 1;
		obj._tileHeight = obj._tileHeight || 1;

		IgeEntity.prototype._childMounted.call(this, obj);
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = IgeTileMap2d; }
// TODO: Implement the _stringify() method for this class
/**
 * Texture maps provide a way to display textures / cells across a tile map.
 */
var IgeTextureMap = IgeTileMap2d.extend({
	classId: 'IgeTextureMap',

	init: function (tileWidth, tileHeight) {
		IgeTileMap2d.prototype.init.call(this, tileWidth, tileHeight);
		this.map = new IgeMap2d();
		this._textureList = [];
		this._renderCenter = new IgePoint3d(0, 0, 0);
		this._cacheDirty = true;
	},

	/**
	 * Gets / sets the auto sectioning mode. If enabled the texture map
	 * will render to off-screen canvases in sections denoted by the
	 * number passed. For instance if you pass 10, the canvas sections
	 * will be 10x10 tiles in size.
	 * @param {Number=} val The size in tiles of each section.
	 * @return {*}
	 */
	autoSection: function (val) {
		if (val !== undefined) {
			this._autoSection = val;
			return this;
		}

		return this._autoSection;
	},

	/**
	 * Gets / sets the draw sections flag. If true the texture map will
	 * output debug lines between each section of the map when using the
	 * auto section system.
	 * @param {Number=} val The boolean flag value.
	 * @return {*}
	 */
	drawSectionBounds: function (val) {
		if (val !== undefined) {
			this._drawSectionBounds = val;
			return this;
		}

		return this._drawSectionBounds;
	},

	/**
	 * Forces a cache redraw on the next tick.
	 */
	cacheForceFrame: function () {
		this._cacheDirty = true;
	},

	/**
	 * Takes another map and removes any data from this map where data already
	 * exists in the other.
	 * @param {IgeTileMap2d} entity The other map to read map data from.
	 * @return {*}
	 */
	negate: function (entity) {
		if (entity !== undefined) {
			var x, y,
				entityMapData = entity.map._mapData,
				thisMapData = this.map._mapData;

			for (y in entityMapData) {
				if (entityMapData.hasOwnProperty(y)) {
					for (x in entityMapData[y]) {
						if (entityMapData[y].hasOwnProperty(x)) {
							if (thisMapData[y] && thisMapData[y][x]) {
								// This map has data in the same place as the passed
								// entity's map so remove this map's data
								delete thisMapData[y][x];
							}
						}
					}
				}
			}
		}

		return this;
	},

	/**
	 * Adds a texture to the texture map's internal texture list so
	 * that it can be referenced via an index so that the texture map's
	 * data will be something like [[textureId, textureCell]]
	 * or a real world example: [[0, 1], [1, 1]].
	 * @param {IgeTexture} texture
	 * @return {Integer} The index of the texture you just added.
	 */
	addTexture: function (texture) {
		this._textureList.push(texture);
		if (!texture._loaded) {
			this._allTexturesLoaded = false;
		}
		return this._textureList.length - 1;
	},

	/**
	 * Checks the status of all the textures that have been added to
	 * this texture map and returns true if they are all loaded.
	 * @return {Boolean} True if all textures are loaded, false if
	 * not.
	 */
	allTexturesLoaded: function () {
		if (!this._allTexturesLoaded) {
			var arr = this._textureList,
				arrCount = arr.length;

			while (arrCount--) {
				if (!arr[arrCount]._loaded) {
					return false;
				}
			}
		}

		this._allTexturesLoaded = true;
		return true;
	},

	/**
	 * Sets the specified tile's texture index and cell that will be used
	 * when rendering the texture map.
	 * @param {Number} x The tile x co-ordinate.
	 * @param {Number} y The tile y co-ordinate.
	 * @param {Number} textureIndex The texture index.
	 * @param {Number} cell The cell index.
	 */
	paintTile: function (x, y, textureIndex, cell) {
		if (x !== undefined && y !== undefined && textureIndex !== undefined) {
			if (cell === undefined || cell < 1) {
				cell = 1; // Set the cell default to 1
			}
			this.map.tileData(x, y, [textureIndex, cell]);
		}
	},

	/**
	 * Clears any previous tile texture and cell data for the specified
	 * tile co-ordinates.
	 * @param {Number} x The tile x co-ordinate.
	 * @param {Number} y The tile y co-ordinate.
	 */
	clearTile: function (x, y) {
		this.map.clearData(x, y);
	},

	/**
	 * Reads the map data from a standard map object and fills the map
	 * with the data found.
	 * @param {Object} map The map data object.
	 */
	loadMap: function (map) {
		if (map.textures) {
			// Empty the existing array
			this._textureList = [];

			var tex = [], i,
				self = this;

			// Loop the texture list and create each texture object
			for (i = 0; i < map.textures.length; i++) {
				// Load each texture
				eval('tex[' + i + '] = ' + map.textures[i]);
				self.addTexture(tex[i]);
			}

			// Fill in the map data
			self.map.mapData(map.data);
		} else {
			// Just fill in the map data
			this.map.mapData(map.data);
		}

		return this;
	},

	/**
	 * Returns a map JSON string that can be saved to a data file and loaded
	 * with the loadMap() method.
	 * @return {Object} The map data object.
	 */
	saveMap: function () {
		// in URL format
		var textures = [], i,
			x, y,
			dataX = 0, dataY = 0,
			mapData = this.map._mapData;

		// Grab all the texture definitions
		for (i = 0; i < this._textureList.length; i++) {
			textures.push(this._textureList[i].stringify());
		}

		// Get the lowest x, y
		for (y in mapData) {
			if (mapData.hasOwnProperty(y)) {
				for (x in mapData[y]) {
					if (mapData[y].hasOwnProperty(x)) {
						if (x < dataX) {
							dataX = x;
						}

						if (y < dataY) {
							dataY = y;
						}
					}
				}
			}
		}

		return JSON.stringify({
			textures: textures,
			data: this.map.mapData(),
			dataXY: [dataX, dataY]
		});
	},

	/**
	 * Clears the tile data from the map effectively wiping it clean. All
	 * existing map data will be removed. The textures assigned to the texture
	 * map will not be affected.
	 * @returns {*}
	 */
	clearMap: function () {
		this.map.mapData([]);
		return this;
	},

	/**
	 * Clears tile data from the map and also removes any textures from the
	 * map that were previously assigned to it. This is useful for reverting
	 * the texture map to it's virgin state as if it had just been created.
	 * @returns {*}
	 */
	reset: function () {
		this.clearMap();
		this._textureList = [];
		
		return this;
	},

	/**
	 * Gets / sets the specified tile's texture index.
	 * @param {Number} x The tile x co-ordinate.
	 * @param {Number} y The tile y co-ordinate.
	 * @param {Number=} textureIndex The new texture index.
	 */
	tileTextureIndex: function (x, y, textureIndex) {
		if (x !== undefined && y !== undefined) {
			var obj = this.map.tileData(x, y);
			if (textureIndex !== undefined) {
				// Set the cell
				obj[0] = textureIndex;
			} else {
				return obj[0];
			}
		}
	},

	/**
	 * Gets / sets the specified tile's texture cell.
	 * @param {Number} x The tile x co-ordinate.
	 * @param {Number} y The tile y co-ordinate.
	 * @param {Number} cell The new cell index.
	 */
	tileTextureCell: function (x, y, cell) {
		if (x !== undefined && y !== undefined) {
			var obj = this.map.tileData(x, y);
			if (cell !== undefined) {
				// Set the cell
				obj[1] = cell;
			} else {
				return obj[1];
			}
		}
	},

	/**
	 * Converts data that is saved in the format [x][y] to the IGE standard
	 * of [y][x] and then returns the data.
	 * @param {Array} mapData The map data array.
	 * @return {Object} The new map data.
	 */
	convertHorizontalData: function (mapData) {
		var newData = [],
			x, y;

		for (x in mapData) {
			if (mapData.hasOwnProperty(x)) {
				for (y in mapData[x]) {
					if (mapData[x].hasOwnProperty(y)) {
						// Displace the data from the x axis to the y axis
						newData[y] = newData[y] || [];
						newData[y][x] = mapData[x][y];
					}
				}
			}
		}

		return newData;
	},

	/**
	 * Handles rendering the texture map during engine tick events.
	 * @param {CanvasRenderingContext2d} ctx
	 */
	tick: function (ctx) {
		// TODO: This is being called at the wrong time, drawing children before this parent! FIX THIS
		// Run the IgeTileMap2d tick method
		IgeTileMap2d.prototype.tick.call(this, ctx);

		// Draw each image that has been defined on the map
		var mapData = this.map._mapData,
			x, y,
			tx, ty,
			xInt, yInt,
			finalX, finalY,
			finalPoint,
			tileData, tileEntity = this._newTileEntity(), // TODO: This is wasteful, cache it?
			sectionX, sectionY,
			tempSectionX, tempSectionY,
			_ctx,
			regions, region, i;

		if (this._autoSection > 0) {
			if (this._cacheDirty) {
				// Check that all the textures we need to use are loaded
				if (this.allTexturesLoaded()) {
					// We have a dirty cache so render the section cache
					// data first
				    // TODO: Shouldn't we be replacing these arrays with new ones to drop the old ones from memory?
				    // TODO: Gonna do that now and see what the result is.
                    this._sections = []; //this._sections || [];
                    this._sectionCtx = []; //this._sectionCtx || [];
                    // TODO: This isn't ideal because we are almost certainly dropping sections that are still relevant,
                    // TODO: so we should scan and garbage collect I think, instead.

					// Loop the map data
					for (y in mapData) {
						if (mapData.hasOwnProperty(y)) {
							for (x in mapData[y]) {
								if (mapData[y].hasOwnProperty(x)) {
									xInt = parseInt(x);
									yInt = parseInt(y);

									// Calculate the tile's final resting position in absolute
									// co-ordinates so we can work out which section canvas to
									// paint the tile to
									if (this._mountMode === 0) {
										// We're rendering a 2d map
										finalX = xInt;
										finalY = yInt;
									}

									if (this._mountMode === 1) {
										// We're rendering an iso map
										// Convert the tile x, y to isometric
										tx = xInt * this._tileWidth;
										ty = yInt * this._tileHeight;
										finalX = (tx - ty) / this._tileWidth;
										finalY = ((tx + ty) * 0.5) / this._tileHeight;
									}

									// Grab the tile data to paint
									tileData = mapData[y][x];

									// Work out which section to paint to
									sectionX = Math.floor(finalX / this._autoSection);
									sectionY = Math.floor(finalY / this._autoSection);
									
									// Check if an off-screen canvas already exists for this section
									// and if not, create one
									this._ensureSectionExists(sectionX, sectionY);
									
									// Grab the drawing context for the section
									_ctx = this._sectionCtx[sectionX][sectionY];

									if (tileData) {
										regions = this._renderTile(
											_ctx,
											xInt,
											yInt,
											tileData,
											tileEntity,
											null,
											sectionX,
											sectionY
										);

										// Check if the tile overlapped another section
										if (regions) {
											// Loop the regions and re-render the tile on the
											// other sections that it overlaps
											for (i = 0; i < regions.length; i++) {
												region = regions[i];

												tempSectionX = sectionX;
												tempSectionY = sectionY;

												if (region.x) {
													tempSectionX += region.x;
												}

												if (region.y) {
													tempSectionY += region.y;
												}

												this._ensureSectionExists(tempSectionX, tempSectionY);
												_ctx = this._sectionCtx[tempSectionX][tempSectionY];

												this._sectionTileRegion = this._sectionTileRegion || [];
												this._sectionTileRegion[tempSectionX] = this._sectionTileRegion[tempSectionX] || [];
												this._sectionTileRegion[tempSectionX][tempSectionY] = this._sectionTileRegion[tempSectionX][tempSectionY] || [];
												this._sectionTileRegion[tempSectionX][tempSectionY][xInt] = this._sectionTileRegion[tempSectionX][tempSectionY][xInt] || [];

												if (!this._sectionTileRegion[tempSectionX][tempSectionY][xInt][yInt]) {
													this._sectionTileRegion[tempSectionX][tempSectionY][xInt][yInt] = true;

													this._renderTile(
														_ctx,
														xInt,
														yInt,
														tileData,
														tileEntity,
														null,
														tempSectionX,
														tempSectionY
													);
												}
											}
										}
									}
								}
							}
						}
					}

					// Set the cache to clean!
					this._cacheDirty = false;

					// Remove the temporary section tile painted data
					delete this._sectionTileRegion;
				}
			}

			this._drawSectionsToCtx(ctx);
		} else {
			// Check that all the textures we need to use are loaded
			if (this.allTexturesLoaded()) {
				// Render the whole map
				for (y in mapData) {
					if (mapData.hasOwnProperty(y)) {
						for (x in mapData[y]) {
							if (mapData[y].hasOwnProperty(x)) {
								// Grab the tile data to paint
								tileData = mapData[y][x];
	
								if (tileData) {
									this._renderTile(ctx, x, y, tileData, tileEntity);
								}
							}
						}
					}
				}
			}
		}
	},

	/**
	 * Private method, checks if the specified section currently exists in the cache
	 * and if not, creates it.
	 * @param {Number} sectionX The section's x co-ordinate.
	 * @param {Number} sectionY The section's y co-ordinate.
	 * @private
	 */
	_ensureSectionExists: function (sectionX, sectionY) {
		var sectionCtx;

		this._sections[sectionX] = this._sections[sectionX] || [];
		this._sectionCtx[sectionX] = this._sectionCtx[sectionX] || [];

		if (!this._sections[sectionX][sectionY]) {
			this._sections[sectionX][sectionY] = document.createElement('canvas');
			this._sections[sectionX][sectionY].width = (this._tileWidth * this._autoSection);
			this._sections[sectionX][sectionY].height = (this._tileHeight * this._autoSection);

			sectionCtx = this._sectionCtx[sectionX][sectionY] = this._sections[sectionX][sectionY].getContext('2d');

			// Ensure the canvas is using the correct image antialiasing mode
			if (!ige._globalSmoothing) {
				sectionCtx.imageSmoothingEnabled = false;
			} else {
				sectionCtx.imageSmoothingEnabled = true;
			}

			// One-time translate the context
			sectionCtx.translate(this._tileWidth / 2, this._tileHeight / 2);
		}
	},

	/**
	 * Private method, draws cached image sections to the canvas context.
	 * @param {CanvasRenderingContext2d} ctx
	 * @private
	 */
	_drawSectionsToCtx: function (ctx) {
		var x, y, tileData,
			sectionRenderX, sectionRenderY,
			sectionAbsX, sectionAbsY,
			sectionWidth, sectionHeight,
			viewArea = ige._currentViewport.viewArea();

		// Render the map sections
		//ctx.translate(-(this._tileWidth / 2), -(this._tileHeight / 2));

		sectionWidth = (this._tileWidth * this._autoSection);
		sectionHeight = (this._tileHeight * this._autoSection);

		for (x in this._sections) {
			if (this._sections.hasOwnProperty(x)) {
				for (y in this._sections[x]) {
					if (this._sections[x].hasOwnProperty(y)) {
						sectionRenderX = x * (this._tileWidth * this._autoSection);
						sectionRenderY = y * (this._tileHeight * this._autoSection);
						sectionAbsX = this._translate.x + sectionRenderX - ige._currentCamera._translate.x;
						sectionAbsY = this._translate.y + sectionRenderY - ige._currentCamera._translate.y;

						// Check if we are drawing isometrically and adjust
						if (this._mountMode === 1) {
							sectionAbsX -= (this._tileWidth / 2);
							sectionAbsY -= (this._tileHeight / 2);
						}

						// Check if the section is "on screen"
						if ((sectionAbsX + sectionWidth + (this._tileHeight / 2) >= -(viewArea.width / 2) && sectionAbsX - (this._tileWidth / 2) <= (viewArea.width / 2)) && (sectionAbsY + sectionHeight + (this._tileHeight / 2) >= -(viewArea.height / 2) && sectionAbsY <= (viewArea.height / 2))) {
							// Grab the canvas to paint
							tileData = this._sections[x][y];

							ctx.drawImage(
								tileData,
								0, 0,
								sectionWidth,
								sectionHeight,
								sectionRenderX,
								sectionRenderY,
								sectionWidth,
								sectionHeight
							);

							ige._drawCount++;

							if (this._drawSectionBounds) {
								// Draw a bounding rectangle around the section
								ctx.strokeStyle = '#ff00f6';
								ctx.strokeRect(
									x * (this._tileWidth * this._autoSection),
									y * (this._tileHeight * this._autoSection),
									(this._tileWidth * this._autoSection),
									(this._tileHeight * this._autoSection)
								);
							}
						}
					}
				}
			}
		}
	},

	/**
	 * Private method, renders a tile texture based on data from the texture map,
	 * to a cached section. 
	 * @param {CanvasRenderingContext2d} ctx
	 * @param {Number} x The tile x co-ordinate.
	 * @param {Number} y The tile y co-ordinate.
	 * @param {Object} tileData The tile's texture and cell data.
	 * @param {Object} tileEntity The object that represents the tile.
	 * @param {IgeRect=} rect The rectangular area to limit drawing to.
	 * @param {Number} sectionX The x co-ordinate of the section to draw to.
	 * @param {Number} sectionY The y co-ordinate of the section to draw to.
	 * @return {*}
	 * @private
	 */
	_renderTile: function (ctx, x, y, tileData, tileEntity, rect, sectionX, sectionY) {
		// TODO: Handle scaling so tiles don't loose res on scaled cached sections
		var finalX, finalY, regions,
			xm1, xp1, ym1, yp1, regObj,
			xAdjust = this._mountMode === 1 ? this._tileWidth / 2 : 0,
			yAdjust = this._mountMode === 1 ? this._tileHeight / 2 : 0,
			tx, ty, sx, sy,
			texture;
		
		// Translate the canvas to the tile position
		if (this._mountMode === 0) {
			finalX = x * this._tileWidth;
			finalY = y * this._tileHeight;
		}

		if (this._mountMode === 1) {
			// Convert the tile x, y to isometric
			tx = x * this._tileWidth;
			ty = y * this._tileHeight;
			sx = tx - ty;
			sy = (tx + ty) * 0.5;

			finalX = sx - this._tileWidth / 2;
			finalY = sy;
		}

		if (sectionX !== undefined) {
			finalX -= sectionX * this._autoSection * this._tileWidth;
		}
		if (sectionY !== undefined) {
			finalY -= sectionY * this._autoSection * this._tileHeight;
		}

		// If we have a rectangle region we are limiting to...
		if (rect) {
			// Check the bounds first
			if (!rect.xyInside(finalX, finalY)) {
				// The point is not inside the bounds, return
				return;
			}
		}

		if (finalX - (xAdjust) < 0) {
			regions = regions || [];
			regions.push({x: -1});
			xm1 = true;

			regObj = regObj || {};
			regObj.x = -1;
		}

		if (finalX + (xAdjust) > (ctx.canvas.width - (this._tileWidth))) {
			regions = regions || [];
			regions.push({x: 1});
			xp1 = true;

			regObj = regObj || {};
			regObj.x = 1;
		}

		if (finalY - (0) < 0) {
			regions = regions || [];
			regions.push({y: -1});
			ym1 = true;

			regObj = regObj || {};
			regObj.y = -1;
		}

		if (finalY + (0) > (ctx.canvas.height - (this._tileHeight))) {
			regions = regions || [];
			regions.push({y: 1});
			yp1 = true;

			regObj = regObj || {};
			regObj.y = 1;
		}

		if (xm1 || ym1 || xp1 || yp1) {
			regions.push(regObj);
		}

		ctx.save();
		ctx.translate(finalX, finalY);
		
		// Set the correct texture data
		texture = this._textureList[tileData[0]];
		tileEntity._cell = tileData[1];

		// Paint the texture
		if (texture) {
			texture.render(ctx, tileEntity, ige._tickDelta);
		}
		ctx.restore();

		return regions;
	},

	/**
	 * Private method, creates an entity object that a texture can use to render
	 * itself. This is basically a dummy object that has the minimum amount of data
	 * in it that a texture requires to render such as geometry, texture
	 * cell and rendering position.
	 * @return {Object} The new tile entity object.
	 * @private
	 */
	_newTileEntity: function () {
		if (this._mountMode === 0) {
			return {
				_cell: 1,
				_bounds2d: {
					x: this._tileWidth,
					y: this._tileHeight
				},
				_renderPos: {
					x: -this._tileWidth / 2,
					y: -this._tileHeight / 2
				}
			};
		}

		if (this._mountMode === 1) {
			return {
				_cell: 1,
				_bounds2d: {
					x: this._tileWidth * 2,
					y: this._tileHeight
				},
				_renderPos: {
					x: -this._tileWidth,
					y: -this._tileHeight / 2
				}
			};
		}
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = IgeTextureMap; }

var IgeTileMap2dSmartTexture = {
	render: function (ctx, entity) {
		var tileWidth = entity._tileWidth,
			tileHeight = entity._tileHeight,
			bounds2d = entity.bounds2d(),
			gridSize = entity._gridSize,
			x = 0, y = 0;
		
		/*ctx.save();
		var triggerPoly = entity.tileMapHitPolygon();
		
		ctx.strokeStyle = '#00ff00';
		ctx.fillStyle = '#ff99f4';
		
		if (entity._processTriggerHitTests()) {
			ctx.fillStyle = '#ff26e8';
		}
		
		if (entity._mountMode === 0) {
			ctx.translate(bounds2d.x2, bounds2d.y2);
		}
		
		if (entity._mountMode === 1) {
			ctx.translate(-entity._translate.x, -entity._translate.y);
			triggerPoly.render(ctx, true);
		}
		
		//
		ctx.restore();*/
		
		if (entity._drawGrid) {
			ctx.strokeStyle = entity._gridColor;
			var gridMaxX = x + tileWidth * gridSize.x,
				gridMaxY = y + tileHeight * gridSize.y,
				index,
				gStart,
				gEnd;
			
			x = 0;
			y = 0;
	
			for (index = 0; index <= gridSize.y; index++) {
				gStart = new IgePoint2d(x, y + (tileHeight * index));
				gEnd = new IgePoint2d(gridMaxX, y + (tileHeight * index));
	
				if (entity._mountMode === 1) {
					// Iso grid
					gStart = gStart.toIso();
					gEnd = gEnd.toIso();
				}
	
				ctx.beginPath();
				ctx.moveTo(gStart.x, gStart.y);
				ctx.lineTo(gEnd.x, gEnd.y);
				ctx.stroke();
			}
	
			for (index = 0; index <= gridSize.x; index++) {
				gStart = new IgePoint2d(x + (tileWidth * index), y);
				gEnd = new IgePoint2d(x + (tileWidth * index), gridMaxY);
	
				if (entity._mountMode === 1) {
					// Iso grid
					gStart = gStart.toIso();
					gEnd = gEnd.toIso();
				}
	
				ctx.beginPath();
				ctx.moveTo(gStart.x, gStart.y);
				ctx.lineTo(gEnd.x, gEnd.y);
				ctx.stroke();
			}
		}
		
		if (entity._highlightOccupied) {
			ctx.fillStyle = '#ff0000';
			for (y in entity.map._mapData) {
				if (entity.map._mapData[y]) {
					for (x in entity.map._mapData[y]) {
						if (entity.map._mapData[y][x]) {
							// Tile is occupied
							tilePoint = new IgePoint2d(tileWidth * x, tileHeight * y);

							// TODO: Abstract out the tile drawing method so that it can be overridden for other projections etc
							if (entity._mountMode === 0) {
								// 2d
								ctx.fillRect(
									tilePoint.x,
									tilePoint.y,
									tileWidth,
									tileHeight
								);
							}

							if (entity._mountMode === 1) {
								// iso
								tilePoint.thisToIso();

								ctx.beginPath();
								ctx.moveTo(tilePoint.x, tilePoint.y);
								ctx.lineTo(tilePoint.x + tileWidth, tilePoint.y + tileHeight / 2);
								ctx.lineTo(tilePoint.x, tilePoint.y + tileHeight);
								ctx.lineTo(tilePoint.x - tileWidth, tilePoint.y + tileHeight / 2);
								ctx.lineTo(tilePoint.x, tilePoint.y);
								ctx.fill();
							}
						}
					}
				}
			}
		}

		if (entity._highlightTileRect) {
			ctx.fillStyle = '#e4ff00';
			for (y = entity._highlightTileRect.y; y < entity._highlightTileRect.y + entity._highlightTileRect.height; y++) {
				for (x = entity._highlightTileRect.x; x < entity._highlightTileRect.x + entity._highlightTileRect.width; x++) {
					// Tile is occupied
					tilePoint = new IgePoint2d(tileWidth * x, tileHeight * y);

					// TODO: Abstract out the tile drawing method so that it can be overridden for other projections etc
					if (entity._mountMode === 0) {
						// 2d
						ctx.fillRect(
							tilePoint.x,
							tilePoint.y,
							tileWidth,
							tileHeight
						);
					}

					if (entity._mountMode === 1) {
						// iso
						tilePoint.thisToIso();

						ctx.beginPath();
						ctx.moveTo(tilePoint.x, tilePoint.y - tileHeight / 2);
						ctx.lineTo(tilePoint.x + tileWidth, tilePoint.y);
						ctx.lineTo(tilePoint.x, tilePoint.y + tileHeight / 2);
						ctx.lineTo(tilePoint.x - tileWidth, tilePoint.y);
						ctx.lineTo(tilePoint.x, tilePoint.y - tileHeight / 2);
						ctx.fill();
					}
				}
			}
		}

		if (entity._drawMouse) {
			// Get mouse position
			var mousePos = entity.mousePos(),
				mouseTile = entity.mouseToTile(),
				tilePoint,
				text,
				textMeasurement;
			
			if (mouseTile.x >= 0 && mouseTile.y >= 0 && mouseTile.x < gridSize.x && mouseTile.y < gridSize.y) {
				// Paint the tile the mouse is currently intersecting
				ctx.fillStyle = entity._hoverColor || '#6000ff';
				if (entity._mountMode === 0) {
					// 2d
					ctx.fillRect(
						(mouseTile.x * tileWidth),
						(mouseTile.y * tileHeight),
						tileWidth,
						tileHeight
					);
				}
	
				if (entity._mountMode === 1) {
					// iso
					tilePoint = mouseTile
						.clone()
						.thisMultiply(tileWidth, tileHeight, 0)
						.thisToIso();
					
					tilePoint.y += tileHeight / 2;
	
					ctx.beginPath();
					ctx.moveTo(tilePoint.x, tilePoint.y - tileHeight / 2);
					ctx.lineTo(tilePoint.x + tileWidth, tilePoint.y);
					ctx.lineTo(tilePoint.x, tilePoint.y + tileHeight / 2);
					ctx.lineTo(tilePoint.x - tileWidth, tilePoint.y);
					ctx.lineTo(tilePoint.x, tilePoint.y - tileHeight / 2);
					ctx.fill();
				}
				
				if (entity._drawMouseData) {
					text = 'Tile X: ' + mouseTile.x + ' Y: ' + mouseTile.y;
					textMeasurement = ctx.measureText(text);
					ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
					ctx.fillRect(Math.floor(mousePos.x - textMeasurement.width / 2 - 5), Math.floor(mousePos.y - 40), Math.floor(textMeasurement.width + 10), 14);
					ctx.fillStyle = '#ffffff';
					ctx.fillText(text, Math.floor(mousePos.x - textMeasurement.width / 2), Math.floor(mousePos.y - 30));
				}
			}
		}
	}
};
var IgeCollisionMap2d = IgeEntity.extend({
	classId: 'IgeCollisionMap2d',

	init: function (tileWidth, tileHeight) {
		IgeEntity.prototype.init.call(this);
		var self = this;

		this.map = new IgeMap2d();
	},

	mapData: function (val) {
		if (val !== undefined) {
			this.map.mapData(val);
			return this;
		}

		return this.map.mapData();
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = IgeCollisionMap2d; }
/**
 * Creates a new camera that will be attached to a viewport.
 */
var IgeCamera = IgeEntity.extend({
	classId: 'IgeCamera',

	init: function (entity) {
		IgeEntity.prototype.init.call(this);

		this._trackRotateTarget = undefined;
		this._trackTranslateTarget = undefined;
		this._trackRotateSmoothing = undefined;
		this._trackTranslateSmoothing = undefined;

		// Store the viewport this camera is attached to
		this._entity = entity;
	},

	/**
	 * Gets / sets the rectangle that the camera translate
	 * will be limited to using an IgeRect instance.
	 * @param {IgeRect=} rect
	 * @return {*}
	 */
	limit: function (rect) {
		// TODO: Write the usage of this limit data, currently does nothing
		if (rect !== undefined) {
			this._limit = rect;
			return this._entity;
		}

		return this._limit;
	},

	/**
	 * Pan (tween) the camera to the new specified point in
	 * the specified time.
	 * @param {IgePoint3d} point The point describing the co-ordinates to pan to.
	 * @param {Number} durationMs The number of milliseconds to span the pan operation over.
	 * @param {String=} easing Optional easing method name.
	 */
	panTo: function (point, durationMs, easing) {
		if (point !== undefined) {
			this._translate.tween()
				.properties({
					x: point.x,
					y: point.y,
					z: point.z
				})
				.duration(durationMs)
				.easing(easing)
				.start();
		}

		return this._entity;
	},

	/**
	 * Pan (tween) the camera by the new specified point in
	 * the specified time.
	 * @param {IgePoint3d} point The point describing the co-ordinates to pan by.
	 * @param {Number} durationMs The number of milliseconds to span the pan operation over.
	 * @param {String=} easing Optional easing method name.
	 */
	panBy: function (point, durationMs, easing) {
		if (point !== undefined) {
			this._translate.tween()
				.properties({
					x: point.x + this._translate.x,
					y: point.y + this._translate.y,
					z: point.z + this._translate.z
				})
				.duration(durationMs)
				.easing(easing)
				.start();
		}

		return this._entity;
	},

	/**
	 * Tells the camera to track the movement of the specified
	 * target entity. The camera will center on the entity.
	 * @param {IgeEntity} entity
	 * @param {Number=} smoothing Determines how quickly the camera
	 * will track the target, the higher the number, the slower the
	 * tracking will be.
	 * @param {Boolean=} rounding Sets if the smoothing system is
	 * allowed to use floating point values or not. If enabled then
	 * it will not use floating point values.
	 * @return {*}
	 */
	trackTranslate: function (entity, smoothing, rounding) {
		if (entity !== undefined) {
			this.log('Camera on viewport ' + this._entity.id() + ' is now tracking translation target ' + entity.id());
			if (rounding !== undefined) {
				this._trackTranslateRounding = rounding;
			}
			
			if (smoothing !== undefined) {
				this._trackTranslateSmoothing = smoothing >= 1  ? smoothing : 0;
			}
			
			this._trackTranslateTarget = entity;
			return this._entity;
		}

		return this._trackTranslateTarget;
	},

	/**
	 * Gets / sets the translate tracking smoothing value.
	 * @param {Number=} val
	 * @return {*}
	 */
	trackTranslateSmoothing: function (val) {
		if (val !== undefined) {
			this._trackTranslateSmoothing = val;
			return this;
		}

		return this._trackTranslateSmoothing;
	},

	/**
	 * Gets / sets the translate tracking smoothing rounding
	 * either enabled or disabled. When enabled the translate
	 * smoothing value will be rounded so that floating point
	 * values are not used which can help when smoothing on a
	 * scene that has texture smoothing disabled so sub-pixel
	 * rendering doesn't work and objects appear to "snap"
	 * into position as the smoothing interpolates.
	 * @param {Boolean=} val
	 * @return {*}
	 */
	trackTranslateRounding: function (val) {
		if (val !== undefined) {
			this._trackTranslateRounding = val;
			return this;
		}

		return this._trackTranslateRounding;
	},

	/**
	 * Stops tracking the current tracking target's translation.
	 */
	unTrackTranslate: function () {
		delete this._trackTranslateTarget;
	},

	/**
	 * Tells the camera to track the rotation of the specified
	 * target entity.
	 * @param {IgeEntity} entity
	 * @param {Number=} smoothing Determines how quickly the camera
	 * will track the target, the higher the number, the slower the
	 * tracking will be.
	 * @return {*}
	 */
	trackRotate: function (entity, smoothing) {
		if (entity !== undefined) {
			this.log('Camera on viewport ' + this._entity.id() + ' is now tracking rotation of target ' + entity.id());
			this._trackRotateSmoothing = smoothing >= 1 ? smoothing : 0;
			this._trackRotateTarget = entity;
			return this._entity;
		}

		return this._trackRotateTarget;
	},

	/**
	 * Gets / sets the rotate tracking smoothing value.
	 * @param {Number=} val
	 * @return {*}
	 */
	trackRotateSmoothing: function (val) {
		if (val !== undefined) {
			this._trackRotateSmoothing = val;
			return this;
		}

		return this._trackRotateSmoothing;
	},

	/**
	 * Stops tracking the current tracking target.
	 */
	unTrackRotate: function () {
		delete this._trackRotateTarget;
	},

	/**
	 * Translates the camera to the center of the specified entity so
	 * that the camera is "looking at" the entity.
	 * @param {IgeEntity} entity The entity to look at.
	 * @param {Number=} durationMs If specified, will cause the
	 * camera to tween to the location of the entity rather than
	 * snapping to it instantly.
	 * @param {String=} easing The easing method name to use if
	 * tweening by duration.
	 * @return {*}
	 */
	lookAt: function (entity, durationMs, easing) {
		if (entity !== undefined) {
			entity.updateTransform();

			if (!durationMs) {
				// Copy the target's world matrix translate data
				this._translate.x = Math.floor(entity._worldMatrix.matrix[2]);
				this._translate.y = Math.floor(entity._worldMatrix.matrix[5]);
			} else {
				this._translate.tween()
					.properties({
						x: Math.floor(entity._worldMatrix.matrix[2]),
						y: Math.floor(entity._worldMatrix.matrix[5]),
						z: 0
					})
					.duration(durationMs)
					.easing(easing)
					.start();
			}

			this.updateTransform();
		}

		return this;
	},
	
	update: function (ctx) {
		// Process any behaviours assigned to the camera
		this._processUpdateBehaviours(ctx);
					
		// Check if we are tracking the translate value of a target
		if (this._trackTranslateTarget) {
			var targetEntity = this._trackTranslateTarget,
				targetMatrix = targetEntity._worldMatrix.matrix,
				targetX = targetMatrix[2],
				targetY = targetMatrix[5],
				sourceX, sourceY, distX, distY, destinationX, destinationY;

			if (!this._trackTranslateSmoothing) {
				// Copy the target's world matrix translate data
				this.lookAt(this._trackTranslateTarget);
			} else {
				// Ease between the current and target values
				sourceX = this._translate.x;
				sourceY = this._translate.y;

				distX = Math.round(targetX - sourceX);
				distY = Math.round(targetY - sourceY);

				if (this._trackTranslateRounding) {
					destinationX = this._translate.x + Math.round(distX / this._trackTranslateSmoothing);
					destinationY = this._translate.y + Math.round(distY / this._trackTranslateSmoothing);
				} else {
					destinationX = this._translate.x + distX / this._trackTranslateSmoothing;
					destinationY = this._translate.y + distY / this._trackTranslateSmoothing;
				}

				// Check camera Limits
				if ( this._limit){
	
					if (destinationX < this._limit.x) {
						destinationX = this._limit.x;
					}
					if (destinationX > this._limit.x + this._limit.width) {
						destinationX = this._limit.x + this._limit.width;
					}
					if (destinationY < this._limit.y) {
						destinationY = this._limit.y;
					}
					if (destinationY > this._limit.y + this._limit.height) {
						destinationY = this._limit.y + this._limit.height;
					}
						
				}

				this._translate.x = destinationX;
				this._translate.y = destinationY;

			 } 
		}

		// Check if we are tracking the rotation values of a target
		if (this._trackRotateTarget) {
			var targetParentRZ = this._trackRotateTarget._parent !== undefined ? this._trackRotateTarget._parent._rotate.z : 0,
				targetZ = -(targetParentRZ + this._trackRotateTarget._rotate.z),
				sourceZ, distZ;

			if (!this._trackRotateSmoothing) {
				// Copy the target's rotate data
				this._rotate.z = targetZ;
			} else {
				// Interpolate between the current and target values
				sourceZ = this._rotate.z;
				distZ = targetZ - sourceZ;

				this._rotate.z += distZ / this._trackRotateSmoothing;
			}
		}

		this.updateTransform();
	},

	/**
	 * Process operations during the engine tick.
	 * @param {CanvasRenderingContext2D} ctx
	 */
	tick: function (ctx) {
		// Process any behaviours assigned to the camera
		this._processTickBehaviours(ctx);
		
		// Updated local transform matrix and then transform the context
		this._localMatrix.transformRenderingContext(ctx);
	},

	/**
	 * Checks the current transform values against the previous ones. If
	 * any value is different, the appropriate method is called which will
	 * update the transformation matrix accordingly. This version of the
	 * method is specifically designed for cameras!
	 */
	updateTransform: function () {
		this._localMatrix.identity();

		// On cameras we do the rotation and scaling FIRST
		this._localMatrix.multiply(this._localMatrix._newRotate(this._rotate.z));
		this._localMatrix.multiply(this._localMatrix._newScale(this._scale.x, this._scale.y));

		// 2d translation - cameras are never in iso mode!
		this._localMatrix.multiply(this._localMatrix._newTranslate(-this._translate.x, -this._translate.y));

		if (this._parent) {
			this._worldMatrix.copy(this._parent._worldMatrix);
			this._worldMatrix.multiply(this._localMatrix);
		} else {
			this._worldMatrix.copy(this._localMatrix);
		}
	},

	/**
	 * Returns a string containing a code fragment that when
	 * evaluated will reproduce this object's properties via
	 * chained commands. This method will only check for
	 * properties that are directly related to this class.
	 * Other properties are handled by their own class method.
	 * @private
	 * @return {String}
	 */
	_stringify: function () {
		// Get the properties for all the super-classes
		var str = IgeEntity.prototype._stringify.call(this), i;

		// Loop properties and add property assignment code to string
		for (i in this) {
			if (this.hasOwnProperty(i) && this[i] !== undefined) {
				switch (i) {
					case '_trackTranslateTarget':
						str += ".trackTranslate(ige.$('" + this._trackTranslateTarget.id() + "'), " + this.trackTranslateSmoothing() + ")";
						break;
					case '_trackRotateTarget':
						str += ".trackRotate(ige.$('" + this._trackRotateTarget.id() + "'), " + this.trackRotateSmoothing() + ")";
						break;
				}
			}
		}

		return str;
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = IgeCamera; }
/**
 * Creates a new viewport.
 */
var IgeViewport = IgeEntity.extend([
	{extension: IgeUiStyleExtension, overwrite: true},
	{extension: IgeUiPositionExtension, overwrite: true}
], {
	classId: 'IgeViewport',
	IgeViewport: true,

	init: function (options) {
		var width, height;
		
		this._alwaysInView = true;
		IgeEntity.prototype.init.call(this);

		this._mouseAlwaysInside = true;
		this._mousePos = new IgePoint3d(0, 0, 0);
		this._overflow = '';
		this._clipping = true;
		this._bornTime = undefined;

		// Set default options if not specified
		// TODO: Is this required or even used?
		if (options) {
			width = options.width;
			height = options.height;
			
			if (options && options.scaleToWidth && options.scaleToHeight) {
				// Store the w/h we want to lock to
				this._lockDimension = new IgePoint3d(options.scaleToWidth, options.scaleToHeight, 0);
			}
		}

		// Setup default objects
		this._bounds2d = new IgePoint3d(width || ige._bounds2d.x, height || ige._bounds2d.y, 0);
		this.camera = new IgeCamera(this);
		this.camera._entity = this;
		//this._drawMouse = true;
	},

	/**
	 * Sets the minimum amount of world in pixels to display in width and height.
	 * When set, if the viewport's geometry is reduced below the minimum width or
	 * height, the viewport's camera is automatically scaled to ensure that the
	 * minimum area remains visible in the viewport.
	 * @param {Integer} width Width in pixels.
	 * @param {Integer} height Height in pixels.
	 * @returns {*}
	 */
	minimumVisibleArea: function (width, height) {
		// Store the w/h we want to lock to
		this._lockDimension = new IgePoint3d(width, height, 0);
		if (ige.isClient) {
			this._resizeEvent({});
		}
		
		return this;
	},

	/**
	 * Gets / sets the auto-size property. If set to true, the viewport will
	 * automatically resize to fill the entire scene.
	 * @param val
	 * @return {*}
	 */
	autoSize: function (val) {
		if (typeof(val) !== 'undefined') {
			this._autoSize = val;
			return this;
		}

		return this._autoSize;
	},

	/**
	 * Gets / sets the scene that the viewport will render.
	 * @param {IgeScene2d} scene
	 * @return {*}
	 */
	scene: function (scene) {
		if (typeof(scene) !== 'undefined') {
			this._scene = scene;
			return this;
		}

		return this._scene;
	},

	/**
	 * Returns the viewport's mouse position.
	 * @return {IgePoint3d}
	 */
	mousePos: function () {
		// Viewport mouse position is calculated and assigned in the
		// IgeInputComponent class.
		return this._mousePos.clone();
	},
	
	mousePosWorld: function () {
		return this._transformPoint(this._mousePos.clone());
	},

	/**
	 * Gets the current rectangular area that the viewport is "looking at"
	 * in the world. The co-ordinates are in world space.
	 * @returns {IgeRect}
	 */
	viewArea: function () {
		var aabb = this.aabb(),
			camTrans = this.camera._translate,
			camScale = this.camera._scale,
			width = aabb.width * (1 / camScale.x),
			height = aabb.height * (1 / camScale.y);
		
		return new IgeRect(
			(camTrans.x - width / 2),
			(camTrans.y - height / 2),
			width,
			height
		);
	},

	/**
	 * Processes the updates before the render tick is called.
	 * @param ctx
	 */
	update: function (ctx, tickDelta) {
		// Check if we have a scene attached to this viewport
		if (this._scene) {
			// Store the viewport camera in the main ige so that
			// down the scenegraph we can choose to negate the camera
			// transform effects
			ige._currentCamera = this.camera;
			ige._currentViewport = this;

			this._scene._parent = this;

			this.camera.update(ctx, tickDelta);
			IgeEntity.prototype.update.call(this, ctx, tickDelta);
			
			if (this._scene.newFrame()) {
				this._scene.update(ctx, tickDelta);
			}
		}
	},

	/**
	 * Processes the actions required each render frame.
	 */
	tick: function (ctx, scene) {
		// Check if we have a scene attached to this viewport
		if (this._scene) {
			// Store the viewport camera in the main ige so that
			// down the scenegraph we can choose to negate the camera
			// transform effects
			ige._currentCamera = this.camera;
			ige._currentViewport = this;

			this._scene._parent = this;

			// Render our scene data
			//ctx.globalAlpha = ctx.globalAlpha * this._parent._opacity * this._opacity;
			IgeEntity.prototype.tick.call(this, ctx);

			// Translate to the top-left of the viewport
			ctx.translate(
				-(this._bounds2d.x * this._origin.x) | 0,
				-(this._bounds2d.y * this._origin.y) | 0
			);

			// Clear the rectangle area of the viewport
			ctx.clearRect(0, 0, this._bounds2d.x, this._bounds2d.y);

			// Clip the context so we only draw "inside" the viewport area
			if (this._clipping || this._borderColor) {
				ctx.beginPath();
				ctx.rect(0, 0, this._bounds2d.x / ige._scale.x, this._bounds2d.y / ige._scale.x);

				// Paint a border if required
				if (this._borderColor) {
					ctx.strokeStyle = this._borderColor;
					ctx.stroke();
				}
				
				if (this._clipping) {
					ctx.clip();
				}
			}

			// Translate back to the center of the viewport
			ctx.translate(((this._bounds2d.x / 2) | 0) + ige._translate.x, ((this._bounds2d.y / 2) | 0) + ige._translate.y);
			/*ctx.translate(ige._translate.x, ige._translate.y);*/
			if (ige._scale.x !== 1 || ige._scale.y !== 1) {
				ctx.scale(ige._scale.x, ige._scale.y);
			}

			// Transform the context to the center of the viewport
			// by processing the viewport's camera tick method
			this.camera.tick(ctx);

			// Draw the scene
			ctx.save();
				this._scene.tick(ctx);
			ctx.restore();

			// Check if we should draw guides
			if (this._drawGuides && ctx === ige._ctx) {
				ctx.save();
				ctx.translate(-this._translate.x, -this._translate.y);
				this.paintGuides(ctx);
				ctx.restore();
			}
			
			// Check if we should draw bounds on this viewport
			// (usually for debug purposes)
			if (this._drawBounds && ctx === ige._ctx) {
				// Traverse the scenegraph and draw axis-aligned
				// bounding boxes for every object
				ctx.save();
				ctx.translate(-this._translate.x, -this._translate.y);
				this.paintAabbs(ctx, this._scene, 0);
				ctx.restore();
			}

			// Check if we should draw the mouse position on this
			// viewport (usually for debug purposes)
			if (this._drawMouse && ctx === ige._ctx) {
				ctx.save();
				var mp = this.mousePos(),
					text,
					mx,
					my,
					textMeasurement;

				// Re-scale the context to ensure that output is always 1:1
				ctx.scale(1 / this.camera._scale.x, 1 / this.camera._scale.y);

				// Work out the re-scale mouse position
				mx = Math.floor(mp.x * this.camera._scale.x);
				my = Math.floor(mp.y * this.camera._scale.y);

				ctx.fillStyle = '#fc00ff';
				ctx.fillRect(mx - 5, my - 5, 10, 10);

				text = this.id() + ' X: ' + mx + ', Y: ' + my;
				textMeasurement = ctx.measureText(text);
				ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
				ctx.fillRect(Math.floor(mx - textMeasurement.width / 2 - 5), Math.floor(my - 25), Math.floor(textMeasurement.width + 10), 14);
				ctx.fillStyle = '#ffffff';
				ctx.fillText(text, mx - textMeasurement.width / 2, my - 15);
				ctx.restore();
			}
			
			if (this._drawViewArea) {
				ctx.save();
					var va = this.viewArea();
					ctx.rect(va.x, va.y, va.width, va.height);
					ctx.stroke();
				ctx.restore();
			}
		}
	},

	/**
	 * Returns the screen position of the viewport as an IgePoint3d where x is the
	 * "left" and y is the "top", useful for positioning HTML elements at the
	 * screen location of an IGE entity. The returned values indicate the center
	 * of the viewport on the screen.
	 * 
	 * This method assumes that the top-left
	 * of the main canvas element is at 0, 0. If not you can adjust the values
	 * yourself to allow for offset.
	 * @example #Get the screen position of the entity
	 *     var screenPos = entity.screenPosition();
	 * @return {IgePoint3d} The screen position of the entity.
	 */
	screenPosition: function () {
		return new IgePoint3d(
			Math.floor(this._worldMatrix.matrix[2] + ige._bounds2d.x2),
			Math.floor(this._worldMatrix.matrix[5] + ige._bounds2d.y2),
			0
		);
	},
	
	drawViewArea: function (val) {
		if (val !== undefined) {
			this._drawViewArea = val;
			return this;
		}
		
		return this._drawViewArea;
	},

	drawBoundsLimitId: function (id) {
		if (id !== undefined) {
			this._drawBoundsLimitId = id;
			return this;
		}

		return this._drawBoundsLimitId;
	},

	drawBoundsLimitCategory: function (category) {
		if (category !== undefined) {
			this._drawBoundsLimitCategory = category;
			return this;
		}

		return this._drawBoundsLimitCategory;
	},
	
	drawCompositeBounds: function (val) {
		if (val !== undefined) {
			this._drawCompositeBounds = val;
			return this;
		}
		
		return this._drawCompositeBounds;
	},
	
	drawGuides: function (val) {
		if (val !== undefined) {
			this._drawGuides = val;
			return this;
		}
		
		return this._drawGuides;
	},
	
	paintGuides: function (ctx) {
		var geom = ige._bounds2d;
		
		// Check draw-guides setting
		if (this._drawGuides) {
			ctx.strokeStyle = '#ffffff';
			
			ctx.translate(0.5, 0.5);
			
			// Draw guide lines in the center
			ctx.beginPath();
			ctx.moveTo(0, -geom.y2);
			ctx.lineTo(0, geom.y);
			ctx.stroke();
			
			ctx.beginPath();
			ctx.moveTo(-geom.x2, 0);
			ctx.lineTo(geom.x, 0);
			ctx.stroke();
		}
	},

	/**
	 * Draws the bounding data for each entity in the scenegraph.
	 * @param ctx
	 * @param rootObject
	 * @param index
	 */
	paintAabbs: function (ctx, rootObject, index) {
		var arr = rootObject._children,
			arrCount,
			obj,
			aabb,
			aabbC,
			bounds3dPoly,
			ga,
			r3d,
			xl1, xl2, xl3, xl4, xl5, xl6,
			bf1, bf2, bf3, bf4,
			tf1, tf2, tf3, tf4;

		if (arr) {
			arrCount = arr.length;

			while (arrCount--) {
				obj = arr[arrCount];
				index++;

				if (obj._shouldRender !== false) {
					if (obj._classId !== 'IgeScene2d' && (!this._drawBoundsLimitId && !this._drawBoundsLimitCategory) || ((this._drawBoundsLimitId && (this._drawBoundsLimitId instanceof Array ? this._drawBoundsLimitId.indexOf(obj.id()) > -1 : this._drawBoundsLimitId === obj.id())) || (this._drawBoundsLimitCategory && this._drawBoundsLimitCategory === obj.category()))) {
						if (typeof(obj.aabb) === 'function') {
							// Grab the AABB and then draw it
							aabb = obj.aabb();

							if (this._drawCompositeBounds && obj._compositeCache) {
								aabbC = obj.compositeAabb();
								
								// Draw composite bounds
								ctx.strokeStyle = '#ff0000';
								ctx.strokeRect(aabbC.x, aabbC.y, aabbC.width, aabbC.height);
							}
							
							if (aabb) {
								if (obj._drawBounds || obj._drawBounds === undefined) {
									//if (!obj._parent || (obj._parent && obj._parent._mountMode !== 1)) {
										// Draw a rect around the bounds of the object transformed in world space
										/*ctx.save();
											obj._worldMatrix.transformRenderingContext(ctx);
											ctx.strokeStyle = '#9700ae';
											ctx.strokeRect(-obj._bounds2d.x2, -obj._bounds2d.y2, obj._bounds2d.x, obj._bounds2d.y);
										ctx.restore();*/
										
										// Draw individual bounds
										ctx.strokeStyle = '#00deff';
										ctx.strokeRect(aabb.x, aabb.y, aabb.width, aabb.height);
									//}

									// Check if the object is mounted to an isometric mount
									if (obj._parent && obj._parent._mountMode === 1) {
										bounds3dPoly = obj.bounds3dPolygon().aabb();
										ctx.save();
											ctx.strokeStyle = '#0068b8';
											ctx.strokeRect(bounds3dPoly.x, bounds3dPoly.y, bounds3dPoly.width, bounds3dPoly.height);
										ctx.restore();
										
										ctx.save();
											ctx.translate(
												bounds3dPoly.x + bounds3dPoly.width / 2,
												bounds3dPoly.y + bounds3dPoly.height / 2
											);
											//obj._transformContext(ctx);

											// Calculate the 3d bounds data
											r3d = obj._bounds3d;
											xl1 = new IgePoint3d(-(r3d.x / 2), 0, 0).toIso();
											xl2 = new IgePoint3d(+(r3d.x / 2), 0, 0).toIso();
											xl3 = new IgePoint3d(0, -(r3d.y / 2), 0).toIso();
											xl4 = new IgePoint3d(0, +(r3d.y / 2), 0).toIso();
											xl5 = new IgePoint3d(0, 0, -(r3d.z / 2)).toIso();
											xl6 = new IgePoint3d(0, 0, +(r3d.z / 2)).toIso();
											// Bottom face
											bf1 = new IgePoint3d(-(r3d.x / 2), -(r3d.y / 2),  -(r3d.z / 2)).toIso();
											bf2 = new IgePoint3d(+(r3d.x / 2), -(r3d.y / 2),  -(r3d.z / 2)).toIso();
											bf3 = new IgePoint3d(+(r3d.x / 2), +(r3d.y / 2),  -(r3d.z / 2)).toIso();
											bf4 = new IgePoint3d(-(r3d.x / 2), +(r3d.y / 2),  -(r3d.z / 2)).toIso();
											// Top face
											tf1 = new IgePoint3d(-(r3d.x / 2), -(r3d.y / 2),  (r3d.z / 2)).toIso();
											tf2 = new IgePoint3d(+(r3d.x / 2), -(r3d.y / 2),  (r3d.z / 2)).toIso();
											tf3 = new IgePoint3d(+(r3d.x / 2), +(r3d.y / 2),  (r3d.z / 2)).toIso();
											tf4 = new IgePoint3d(-(r3d.x / 2), +(r3d.y / 2),  (r3d.z / 2)).toIso();

											ga = ctx.globalAlpha;

											// Axis lines
											ctx.globalAlpha = 1;
											ctx.strokeStyle = '#ff0000';
											ctx.beginPath();
											ctx.moveTo(xl1.x, xl1.y);
											ctx.lineTo(xl2.x, xl2.y);
											ctx.stroke();
											ctx.strokeStyle = '#00ff00';
											ctx.beginPath();
											ctx.moveTo(xl3.x, xl3.y);
											ctx.lineTo(xl4.x, xl4.y);
											ctx.stroke();
											ctx.strokeStyle = '#fffc00';
											ctx.beginPath();
											ctx.moveTo(xl5.x, xl5.y);
											ctx.lineTo(xl6.x, xl6.y);
											ctx.stroke();

											ctx.strokeStyle = '#a200ff';

											if (obj._highlight) {
												ctx.globalAlpha = 0.9;
											} else {
												ctx.globalAlpha = 0.6;
											}

											// Left face
											ctx.fillStyle = '#545454';
											ctx.beginPath();
											ctx.moveTo(bf3.x, bf3.y);
											ctx.lineTo(bf4.x, bf4.y);
											ctx.lineTo(tf4.x, tf4.y);
											ctx.lineTo(tf3.x, tf3.y);
											ctx.lineTo(bf3.x, bf3.y);
											ctx.fill();
											ctx.stroke();

											// Right face
											ctx.fillStyle = '#282828';
											ctx.beginPath();
											ctx.moveTo(bf3.x, bf3.y);
											ctx.lineTo(bf2.x, bf2.y);
											ctx.lineTo(tf2.x, tf2.y);
											ctx.lineTo(tf3.x, tf3.y);
											ctx.lineTo(bf3.x, bf3.y);
											ctx.fill();
											ctx.stroke();

											// Top face
											ctx.fillStyle = '#676767';
											ctx.beginPath();
											ctx.moveTo(tf1.x, tf1.y);
											ctx.lineTo(tf2.x, tf2.y);
											ctx.lineTo(tf3.x, tf3.y);
											ctx.lineTo(tf4.x, tf4.y);
											ctx.lineTo(tf1.x, tf1.y);
											ctx.fill();
											ctx.stroke();

											ctx.globalAlpha = ga;
										ctx.restore();
									}
								}

								if (this._drawBoundsData  && (obj._drawBounds || obj._drawBoundsData === undefined)) {
									ctx.globalAlpha = 1;
									ctx.fillStyle = '#f6ff00';
									ctx.fillText('ID: ' + obj.id() + ' ' + '(' + obj.classId() + ') ' + obj.layer() + ':' + obj.depth().toFixed(0), aabb.x + aabb.width + 3, aabb.y + 10);
									ctx.fillText('X: ' + obj._translate.x.toFixed(2) + ', ' + 'Y: ' + obj._translate.y.toFixed(2) + ', ' + 'Z: ' + obj._translate.z.toFixed(2), aabb.x + aabb.width + 3, aabb.y + 20);
									ctx.fillText('Num Children: ' + obj._children.length, aabb.x + aabb.width + 3, aabb.y + 40);
								}
							}
						}
					}

					this.paintAabbs(ctx, obj, index);
				}
			}
		}
	},

	/**
	 * Handles screen resize events.
	 * @param event
	 * @private
	 */
	_resizeEvent: function (event) {
		if (this._autoSize && this._parent) {
			this._bounds2d = this._parent._bounds2d.clone();
		}

		this._updateUiPosition();

		// Resize the scene
		if (this._scene) {
			this._scene._resizeEvent(event);
		}
		
		// Process locked dimension scaling
		if (this._lockDimension) {
			// Calculate the new camera scale
			var ratio = 1,
				tmpX,
				tmpY;
			
			if (this._bounds2d.x > this._lockDimension.x && this._bounds2d.y > this._lockDimension.y) {
				// Scale using lowest ratio
				tmpX = this._bounds2d.x / this._lockDimension.x;
				tmpY = this._bounds2d.y / this._lockDimension.y;
				
				ratio = tmpX < tmpY ? tmpX : tmpY;
			} else {
				if (this._bounds2d.x > this._lockDimension.x && this._bounds2d.y < this._lockDimension.y) {
					// Scale out to show height
					ratio = this._bounds2d.y / this._lockDimension.y;
				}
				
				if (this._bounds2d.x < this._lockDimension.x && this._bounds2d.y > this._lockDimension.y) {
					// Scale out to show width
					ratio = this._bounds2d.x / this._lockDimension.x;
				}
				
				if (this._bounds2d.x < this._lockDimension.x && this._bounds2d.y < this._lockDimension.y) {
					// Scale using lowest ratio
					tmpX = this._bounds2d.x / this._lockDimension.x;
					tmpY = this._bounds2d.y / this._lockDimension.y;
					
					ratio = tmpX < tmpY ? tmpX : tmpY;
				}
			}
			
			this.camera.scaleTo(ratio, ratio, ratio);
		}
	},

	/**
	 * Returns a string containing a code fragment that when
	 * evaluated will reproduce this object's properties via
	 * chained commands. This method will only check for
	 * properties that are directly related to this class.
	 * Other properties are handled by their own class method.
	 * @return {String}
	 */
	_stringify: function () {
		// Get the properties for all the super-classes
		var str = IgeEntity.prototype._stringify.call(this), i;

		// Loop properties and add property assignment code to string
		for (i in this) {
			if (this.hasOwnProperty(i) && this[i] !== undefined) {
				switch (i) {
					case '_autoSize':
						str += ".autoSize(" + this._autoSize + ")";
						break;
					case '_scene':
						str += ".scene(ige.$('" + this.scene().id() + "'))";
						break;
				}
			}
		}

		return str;
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = IgeViewport; }
/**
 * Creates a new 2d scene.
 */
var IgeScene2d = IgeEntity.extend({
	classId: 'IgeScene2d',

	init: function () {
		this._mouseAlwaysInside = true;
		this._alwaysInView = true;
		IgeEntity.prototype.init.call(this);

		this._shouldRender = true;
		this._autoSize = true;

		// Set the geometry of the scene to the main canvas
		// width / height - used when positioning UI elements
		this._bounds2d.x = ige._bounds2d.x;
		this._bounds2d.y = ige._bounds2d.y;
		
		this.streamSections(['transform', 'ignoreCamera']);
	},

	/**
	 * Gets / sets the stream room id. If set, any streaming entities that
	 * are mounted to this scene will only sync with clients that have been
	 * assigned to this room id.
	 * 
	 * @param {String} id The id of the room. 
	 * @returns {*}
	 */
	streamRoomId: function (id) {
		if (id !== undefined) {
			this._streamRoomId = id;
			return this;
		}
		
		return this._streamRoomId;
	},

	/**
	 * Overrides the default entity stream sections to also stream important
	 * data about scenes to the client.
	 * @param sectionId
	 * @param data
	 * @returns {*}
	 */
	streamSectionData: function (sectionId, data) {
		switch (sectionId) {
			case 'ignoreCamera':
				if (data !== undefined) {
					// Setter
					if (data === 'false') {
						this.ignoreCamera(false);
					} else {
						this.ignoreCamera(true);
					}
				} else {
					// Getter
					return String(this._ignoreCamera);
				}
				break;
			
			default:
				IgeEntity.prototype.streamSectionData.call(this, sectionId, data);
				break;
		}
	},

	/**
	 * Gets / sets the auto-size property. If set to true, the scene will
	 * automatically resize to the engine's canvas geometry.
	 * @param {Boolean=} val If true, will autosize the scene to match the
	 * main canvas geometry. This is enabled by default and is unlikely to
	 * help you if you switch it off.
	 * @return {*}
	 */
	autoSize: function (val) {
		if (typeof(val) !== 'undefined') {
			this._autoSize = val;
			return this;
		}

		return this._autoSize;
	},

	/**
	 * Gets / sets the _shouldRender property. If set to true, the scene's child
	 * object's tick methods will be called.
	 * @param {Boolean} val If set to false, no child entities will be rendered.
	 * @return {Boolean}
	 */
	shouldRender: function (val) {
		if (val !== undefined) {
			this._shouldRender = val;
			return this;
		}

		return this._shouldRender;
	},

	/**
	 * Gets / sets the flag that determines if the scene will ignore camera
	 * transform values allowing the scene to remain static on screen
	 * regardless of the camera transform.
	 * @param {Boolean=} val True to ignore, false to not ignore.
	 * @return {*}
	 */
	ignoreCamera: function (val) {
		if (val !== undefined) {
			this._ignoreCamera = val;
			return this;
		}

		return this._ignoreCamera;
	},
	
	update: function (ctx, tickDelta) {
		if (this._ignoreCamera) {
			// Translate the scene so it is always center of the camera
			var cam = ige._currentCamera;
			this.translateTo(cam._translate.x, cam._translate.y, cam._translate.z);
			this.scaleTo(1 / cam._scale.x, 1 / cam._scale.y, 1 / cam._scale.z);
			this.rotateTo(-cam._rotate.x, -cam._rotate.y, -cam._rotate.z);
			//this._localMatrix.multiply(ige._currentCamera._worldMatrix.getInverse());
		}
		
		IgeEntity.prototype.update.call(this, ctx, tickDelta);
	},

	/**
	 * Processes the actions required each render frame.
	 * @param {CanvasRenderingContext2D} ctx The canvas context to render to.
	 */
	tick: function (ctx) {
		if (this._shouldRender) {
			IgeEntity.prototype.tick.call(this, ctx);
		}
	},

	/**
	 * Handles screen resize events.
	 * @param event
	 * @private
	 */
	_resizeEvent: function (event) {
		// Set width / height of scene to match main ige (SCENES ARE ALWAYS THE FULL IGE SIZE!!)
		if (this._autoSize) {
			this._bounds2d = ige._bounds2d.clone();
		}

		// Resize any children
		var arr = this._children,
			arrCount = arr.length;

		while (arrCount--) {
			arr[arrCount]._resizeEvent(event);
		}
	},

	/**
	 * Returns a string containing a code fragment that when
	 * evaluated will reproduce this object's properties via
	 * chained commands. This method will only check for
	 * properties that are directly related to this class.
	 * Other properties are handled by their own class method.
	 * @return {String}
	 */
	_stringify: function () {
		// Get the properties for all the super-classes
		var str = IgeEntity.prototype._stringify.call(this), i;

		// Loop properties and add property assignment code to string
		for (i in this) {
			if (this.hasOwnProperty(i) && this[i] !== undefined) {
				switch (i) {
					case '_shouldRender':
						str += ".shouldRender(" + this.shouldRender() + ")";
						break;
					case '_autoSize':
						str += ".autoSize(" + this.autoSize() + ")";
						break;
				}
			}
		}

		return str;
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = IgeScene2d; }
var IgeQuest = IgeEventingClass.extend({
	classId: 'IgeQuest',

	init: function (questDefinition, completeCallback) {
		this._linear = false;
		this._items = [];

		this._itemCount = 0;
		this._eventCount = 0;
		this._itemCompleteCount = 0;
		this._eventCompleteCount = 0;

		this._started = false;
		this._isComplete = false;

		if (questDefinition !== undefined) {
			this.items(questDefinition);
		}

		if (completeCallback !== undefined) {
			this._completeCallback = completeCallback;
		}
	},

	/**
	 * Gets / sets the callback method that will fire when
	 * the quest has been completed.
	 * @param callback
	 * @return {*}
	 */
	complete: function (callback) {
		if (callback !== undefined) {
			this._completeCallback = callback;
			return this;
		}

		return this._completeCallback;
	},

	/**
	 * Gets / sets the flag that determines if the quest
	 * has been completed successfully or not.
	 * @param val
	 * @return {*}
	 */
	isComplete: function (val) {
		if (val !== undefined) {
			this._isComplete = val;
			return this;
		}

		return this._isComplete;
	},

	/**
	 * Gets / sets the flag that determines if the quest items
	 * need to be completed in order (true) or if they can be
	 * completed in any order (false). Default is false.
	 * @param val
	 * @return {*}
	 */
	linear: function (val) {
		if (val !== undefined) {
			this._linear = val;
			return this;
		}

		return this._linear;
	},

	/**
	 * Gets / sets the items array containing the quest item
	 * definition objects.
	 * @param val
	 * @return {*}
	 */
	items: function (val) {
		if (val !== undefined) {
			this._items = val;

			// Set the event and item counts
			var arr = this._items,
				arrCount = arr.length,
				i,
				eventCount = 0;

			for (i = 0; i < arrCount; i++) {
				eventCount += arr[i].count;
			}

			this._eventCount = eventCount;
			this._itemCount = arrCount;

			return this;
		}

		return this._items;
	},

	/**
	 * Returns the number of quest items this quest has.
	 * @return {Number}
	 */
	itemCount: function () {
		return this._itemCount;
	},

	/**
	 * Returns the sum of all event counts for every item
	 * in the quest giving an overall number of events that
	 * need to fire in order for the quest to be completed.
	 * @return {Number}
	 */
	eventCount: function () {
		return this._eventCount;
	},

	/**
	 * Returns the number of events that have been completed.
	 * @return {Number}
	 */
	eventCompleteCount: function () {
		return this._eventCompleteCount;
	},

	/**
	 * Returns the number of items that have been completed.
	 * @return {Number}
	 */
	itemCompleteCount: function () {
		return this._itemCompleteCount;
	},

	/**
	 * Returns the percentage representation of the quest's
	 * overall completion based on number of overall events and
	 * number of events that have been completed.
	 * @return {Number} A number from zero to one-hundred.
	 */
	percentComplete: function () {
		return Math.floor((100 / this._eventCount) * this._eventCompleteCount);
	},

	/**
	 * Starts the quest by setting up the quest event
	 * listeners.
	 */
	start: function () {
		if (!this._started) {
			var self = this,
				arr = this._items,
				arrCount = arr.length,
				i;

			// Mark the quest as started
			this._started = true;

			// Check if we have a linear quest or a non-linear one
			if (!this._linear) {
				// The quest is non-linear so activate all the item listeners now...
				// Loop the quest items array
				for (i = 0; i < arrCount; i++) {
					// Setup the listener for this item
					this._setupItemListener(arr[i]);
				}
			} else {
				// The quest is linear so only activate the first listener for now...
				this._setupItemListener(arr[0]);
			}

			this.emit('started');
		} else {
			// Quest already started!
			this.log('Cannot start quest because it has already been started!', 'warning');
			this.emit('alreadyStarted');
		}

		return this;
	},

	/**
	 * Stops the quest and sets all the event listeners to
	 * ignore events until the quest is restarted.
	 */
	stop: function () {
		if (this._started) {
			this._started = false;
			this.emit('stopped');
		} else {
			this.log('Cannot stop quest because it has not been started yet!', 'warning');
			this.emit('notStarted');
		}

		return this;
	},

	/**
	 * Resets the quest and item internals back to their
	 * original values and cancels all current event listeners.
	 */
	reset: function () {
		var arr = this._items,
			arrCount = arr.length,
			i, item;

		for (i = 0; i < arrCount; i++) {
			item = arr[i];

			// Reset all the item internals
			item._complete = false;
			item._eventCount = 0;

			// Cancel the event listener
			if (item._listener) {
				item.emitter.off(item.eventName, item._listener);
			}

			// Clear the reference holding the item listener
			delete item._listener;
		}

		// Reset quest internals
		this._eventCompleteCount = 0;
		this._itemCompleteCount = 0;
		this._isComplete = false;

		this.emit('reset');

		return this;
	},

	/**
	 * Sets up a quest item's event listener.
	 * @param item
	 * @private
	 */
	_setupItemListener: function (item) {
		var self = this;

		// Check for an existing listener
		if (!item._listener) {
			// Set the item's internal event count to zero
			// (number of times the event has fired)
			item._eventCount = 0;
			item._complete = false;

			// Create the event listener
			item._listener = item.emitter.on(item.eventName, function () {
				// Check if the quest is currently started
				if (self._started) {
					// If the item has an event evaluator method...
					if (item.eventEvaluate) {
						// Check if the event's data evaluated to true
						if (item.eventEvaluate.apply(self, arguments)) {
							// The evaluator returned true so complete the event
							self._eventComplete(item);
						}
					} else {
						self._eventComplete(item);
					}
				}
			});
		}
	},

	/**
	 * Handles when an event has been fired for a quest item.
	 * @param item
	 * @private
	 */
	_eventComplete: function (item) {
		// Increment the internal event count
		item._eventCount++;

		// Increment the quest's internal event count
		this._eventCompleteCount++;

		// Fire the callback to the game logic
		if (item.eventCallback) {
			item.eventCallback.apply(this, item);
		}

		// Emit the event complete event
		this.emit('eventComplete', item);

		// Check if we've reached our designated event count
		if (item._eventCount === item.count) {
			this._itemComplete(item);
		}
	},

	/**
	 * Handles when an item's events have all been fired.
	 * @param item
	 * @private
	 */
	_itemComplete: function (item) {
		var itemIndex,
			arr = this._items;

		// Mark the item as complete
		item._complete = true;

		// Cancel the listener
		item.emitter.off(item.eventName, item._listener);
		delete item._listener;

		// Increment the quest's item complete count
		this._itemCompleteCount++;

		// Fire the item's itemCallback to the game logic
		if (item.itemCallback) {
			item.itemCallback.apply(this, item);
		}

		// Emit the item complete event
		this.emit('itemComplete', item);

		// Tell the quest to check it's internals
		this._update();

		// Check if the quest is linear
		if (this._started && this._linear && this._itemCompleteCount < this.itemCount()) {
			// Advance the listener to the next item
			itemIndex = arr.indexOf(item);
			this._setupItemListener(arr[itemIndex + 1]);

			// Emit the nextItem event (linear quests only)
			this.emit('nextItem', arr[itemIndex + 1]);
		}
	},

	/**
	 * Called when a quest item has been completed to determine
	 * if the quest should continue or if it has also been
	 * completed.
	 * @private
	 */
	_update: function () {
		// Check if all our items are complete
		if (this._itemCompleteCount === this.itemCount()) {
			// Mark the quest as complete
			this._isComplete = true;

			// Fire the quest completed callback
			this._completeCallback.apply(this);

			// Emit the quest complete event
			this.emit('complete');

			// Stop the quest
			this.stop();

			// Reset the quest (kills current event listeners)
			this.reset();
		}
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = IgeQuest; }
/**
 * Provides an alternative to setInterval() which works based on the engine's internal
 * time system allowing intervals to fire correctly, taking into account pausing the
 * game and differences in rendering speed etc. 
 */
var IgeInterval = IgeEventingClass.extend({
	classId: 'IgeInterval',

	/**
	 * Creates a new timer that will call the method every given number of
	 * milliseconds specified by the interval parameter.
	 * @param {Function} method The method to call each interval.
	 * @param {Number} interval The number of milliseconds between each interval.
	 */
	init: function (method, interval) {
		var self = this;
		
		this._method = method;
		this._interval = interval;
		this._time = 0;
		this._started = ige._currentTime;
		
		// Attach ourselves to the time system
		ige.time.addTimer(this);
	},

	/**
	 * Adds time to the timer's internal clock. 
	 * @param {Number} time The time in milliseconds to add to the timer's internal clock.
	 * @returns {*}
	 */
	addTime: function (time) {
		this._time += time;
		return this;
	},

	/**
	 * Cancels the timer stopping all future method calls.
	 * @returns {*}
	 */
	cancel: function () {
		ige.time.removeTimer(this);
		return this;
	},

	/**
	 * Checks for a timer event to see if we should call the timer method. This is
	 * called automatically by the IgeTimeComponent class and does not need to be
	 * called manually.
	 * @returns {*}
	 */
	update: function () {
		if (this._time > this._interval) {
			// Fire an interval
			this._method(ige._currentTime);
			this._time -= this._interval;
		}
		
		return this;
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = IgeInterval; }
/**
 * Provides an alternative to setTimeout() which works based on the engine's internal
 * time system allowing timeouts to fire correctly, taking into account pausing the
 * game and differences in rendering speed etc.
 */
var IgeTimeout = IgeInterval.extend({
	classId: 'IgeTimeout',
	
	/**
	 * Creates a new timeout that will call the passed method after the number of
	 * milliseconds specified by the timeout parameter has been reached.
	 * @param {Function} method The method to call on timeout.
	 * @param {Number} timeout The number of milliseconds before the timeout.
	 */
	init: function (method, timeout) {
		IgeInterval.prototype.init.call(this, method, timeout);
	},

    /**
     * Cancels the timer, stops the timeout.
     * @returns {*}
     */
    cancel: function () {
        return IgeInterval.prototype.cancel.call(this);
    },

    /**
     * Resets the time and lets the timeout begin anew.
     * @returns {*}
     */
    reset: function() {
        this._time = 0;
        if (ige.time._timers.indexOf(this) == -1) {
            ige.time.addTimer(this);
        }
    },
	
	/**
	 * Checks for a timeout event to see if we should call the timeout method. This is
	 * called automatically by the IgeTimeComponent class and does not need to be
	 * called manually.
	 * @returns {*}
	 */
	update: function () {
		if (this._time > this._interval) {
			// Fire an interval
			this._method(ige._currentTime);
			ige.time.removeTimer(this);
		}
		
		return this;
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = IgeTimeout; }
var IgeCuboidSmartTexture = {
	render: function (ctx, entity) {
		var poly = entity.localIsoBoundsPoly();
		
		ctx.strokeStyle = '#a200ff';
		
		poly.render(ctx);
	}
};
var IgeCuboid = IgeEntity.extend({
	classId: 'IgeCuboid',
	
	init: function () {
		IgeEntity.prototype.init.call(this);
		
		this.bounds3d(40, 40, 40);
		
		var tex = new IgeTexture(IgeCuboidSmartTexture);
		this.texture(tex);
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = IgeCuboid; }
var IgeArray = function () {};
IgeArray.prototype = [];

// Empower the IgeArray with all the method calls of the an IgeEntity
for (var methodName in IgeEntity.prototype) {
	if (IgeEntity.prototype.hasOwnProperty(methodName)) {
		if (methodName !== 'init') {
			IgeArray.prototype[methodName] = function (methodName) {
				return function () {
					var c = this.length;
					for (var i = 0; i < c; i++) {
						this[i][methodName].apply(this[i], arguments);
					}
				}
			}(methodName);
		}
	}
}

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = IgeArray; }
/**
 * Manages audio mixing and output.
 */
var IgeAudioComponent = IgeEventingClass.extend({
	classId: 'IgeAudioComponent',
	componentId: 'audio',
	
	init: function (entity, options) {
		this._active = false;
		this._disabled = false;
		this._ctx = this.getContext();
		
		if (!this._ctx) {
			this.log('No web audio API support, cannot play sounds!', 'warning');
			this._disabled = true;
			return;
		}
		
		this.log('Web audio API connected successfully');
	},

	/**
	 * Gets / sets the active flag to enable or disable audio support.
	 * @param {Boolean=} val True to enable audio support.
	 * @returns {*}
	 */
	active: function (val) {
		if (val !== undefined && !this._disabled) {
			this._active = val;
			return this;
		}
		
		return this._active;
	},

	/**
	 * Returns an audio context.
	 * @returns {*}
	 */
	getContext: function () {
		var ctxProto = window.AudioContext || window.webkitAudioContext;
		
		if (ctxProto) {
			return new ctxProto();
		} else {
			return undefined;
		}
	},

	/**
	 * Loads an audio file from the given url and assigns it the id specified.
	 * @param {String} url The url to load the audio from.
	 * @param {String=} id The id to assign the audio.
	 */
	load: function (url, id) {
		var audio = new IgeAudio(url);
		
		if (id) {
			audio.id(id);
		}
	},

	/**
	 * Decodes audio data and calls back with an audio buffer.
	 * @param {ArrayBuffer} data The audio data to decode.
	 * @param {Function} callback The callback to pass the buffer to.
	 */
	decode: function (data, callback) {
		this._ctx.decodeAudioData(data, function (buffer) {
			callback(false, buffer);
		}, function (err) {
			callback(err);
		});
	},
	
	play: function (id) {
		var audio = ige.$(id);
		if (audio) {
			if (audio.prototype.play) {
				audio.play();
			} else {
				this.log('Trying to play audio with id "" but object with this id is not an IgeAudio instance, or does not implement the .play() method!', 'warnign');
			}
		}
	}
});
var IgeAudio = IgeEventingClass.extend({
	classId: 'IgeAudio',
	
	init: function (url) {
		if (url) {
			this.load(url);
		}
	},
	
	/**
	 * Gets / sets the current object id. If no id is currently assigned and no
	 * id is passed to the method, it will automatically generate and assign a
	 * new id as a 16 character hexadecimal value typed as a string.
	 * @param {String=} id The id to set to.
	 * @return {*} Returns this when setting the value or the current value if none is specified.
	 */
	id: function (id) {
		if (id !== undefined) {
			// Check if this ID already exists in the object register
			if (ige._register[id]) {
				if (ige._register[id] === this) {
					// We are already registered as this id
					return this;
				}
				
				// Already an object with this ID!
				this.log('Cannot set ID of object to "' + id + '" because that ID is already in use by another object!', 'error');
			} else {
				// Check if we already have an id assigned
				if (this._id && ige._register[this._id]) {
					// Unregister the old ID before setting this new one
					ige.unRegister(this);
				}

				this._id = id;

				// Now register this object with the object register
				ige.register(this);

				return this;
			}
		}

		if (!this._id) {
			// The item has no id so generate one automatically
			if (this._url) {
				// Generate an ID from the URL string of the audio file
				// this instance is using. Useful for always reproducing
				// the same ID for the same file :)
				this._id = ige.newIdFromString(this._url);
			} else {
				// We don't have a URL so generate a random ID
				this._id = ige.newIdHex();
			}
			ige.register(this);
		}

		return this._id;
	},

	/**
	 * Loads an audio file from the given url.
	 * @param {String} url The url to load the audio file from.
	 * @param {Function=} callback Optional callback method to call when the audio
	 * file has loaded or on error.
	 */
	load: function (url, callback) {
		var self = this,
			request = new XMLHttpRequest();
		
		request.open('GET', url, true);
		request.responseType = 'arraybuffer';
		
		// Decode asynchronously
		request.onload = function() {
			self._data = request.response;
			self._url = url;
			self._loaded(callback);
		};
		
		request.onerror = function (err) {
			callback.apply(self, [err]);
		};
		
		request.send();
	},
	
	_loaded: function (callback) {
		var self = this;
		
		ige.audio.decode(self._data, function(err, buffer) {
			if (!err) {
				self._buffer = buffer;
				ige.audio.log('Audio file (' + self._url + ') loaded successfully');
				
				if (callback) { callback.apply(self, [false]); }
			} else {
				self.log('Failed to decode audio data from: ' + self._url, 'warning');
				if (callback) { callback.apply(self, [err]); }
			}
		});
	},

	/**
	 * Plays the audio.
	 */
	play: function () {
		var self = this,
			bufferSource;
		
		if (self._buffer) {
			bufferSource = ige.audio._ctx.createBufferSource();
			bufferSource.buffer = self._buffer;
			bufferSource.connect(ige.audio._ctx.destination);
			bufferSource.start(0);
		}
	}
});
/**
 * The engine's box2d component class.
 */
var IgeBox2dComponent = IgeEventingClass.extend({
	classId: 'IgeBox2dComponent',
	componentId: 'box2d',

	init: function (entity, options) {
		// Check that the engine has not already started
		// as this will mess everything up if it has
		if (ige._state !== 0) {
			this.log('Cannot add box2d component to the ige instance once the engine has started!', 'error');
		}

		this._entity = entity;
		this._options = options;
		this._mode = 0;

		this.b2Color = Box2D.Common.b2Color;
		this.b2Vec2 = Box2D.Common.Math.b2Vec2;
		this.b2Math = Box2D.Common.Math.b2Math;
		this.b2Shape = Box2D.Collision.Shapes.b2Shape;
		this.b2BodyDef = Box2D.Dynamics.b2BodyDef;
		this.b2Body = Box2D.Dynamics.b2Body;
		this.b2FixtureDef = Box2D.Dynamics.b2FixtureDef;
		this.b2Fixture = Box2D.Dynamics.b2Fixture;
		this.b2World = Box2D.Dynamics.b2World;
		this.b2MassData = Box2D.Collision.Shapes.b2MassData;
		this.b2PolygonShape = Box2D.Collision.Shapes.b2PolygonShape;
		this.b2CircleShape = Box2D.Collision.Shapes.b2CircleShape;
		this.b2DebugDraw = Box2D.Dynamics.b2DebugDraw;
		this.b2ContactListener = Box2D.Dynamics.b2ContactListener;
		this.b2Distance = Box2D.Collision.b2Distance;
		this.b2Contact = Box2D.Dynamics.Contacts.b2Contact;
		this.b2FilterData = Box2D.Dynamics.b2FilterData;
		this.b2DistanceJointDef = Box2D.Dynamics.Joints.b2DistanceJointDef;

		// Extend the b2Contact class to allow the IGE entity accessor
		// and other helper methods
		this.b2Contact.prototype.igeEntityA = function () {
			var ent = this.m_fixtureA.m_body._entity;
			ent._box2dOurContactFixture = this.m_fixtureA;
			ent._box2dTheirContactFixture = this.m_fixtureB;
			return ent;
		};

		this.b2Contact.prototype.igeEntityB = function () {
			var ent = this.m_fixtureB.m_body._entity;
			ent._box2dOurContactFixture = this.m_fixtureB;
			ent._box2dTheirContactFixture = this.m_fixtureA;
			return ent;
		};

		this.b2Contact.prototype.igeEitherId = function (id1, id2) {
			if (!id2) {
				return this.m_fixtureA.m_body._entity._id === id1 || this.m_fixtureB.m_body._entity._id === id1;
			} else {
				return (this.m_fixtureA.m_body._entity._id === id1 || this.m_fixtureB.m_body._entity._id === id1) &&
					(this.m_fixtureA.m_body._entity._id === id2 || this.m_fixtureB.m_body._entity._id === id2);
			}
		};

		this.b2Contact.prototype.igeEitherCategory = function (category1, category2) {
			if (!category2) {
				return this.m_fixtureA.m_body._entity._category === category1 || this.m_fixtureB.m_body._entity._category === category1;
			} else {
				return (this.m_fixtureA.m_body._entity._category === category1 || this.m_fixtureB.m_body._entity._category === category1) &&
					(this.m_fixtureA.m_body._entity._category === category2 || this.m_fixtureB.m_body._entity._category === category2);
			}
		};

		this.b2Contact.prototype.igeBothCategories = function (category1) {
			return (this.m_fixtureA.m_body._entity._category === category1 && this.m_fixtureB.m_body._entity._category === category1);
		};

		this.b2Contact.prototype.igeEntityByCategory = function (category) {
			if (this.m_fixtureA.m_body._entity._category === category) {
				return this.igeEntityA();
			}

			if (this.m_fixtureB.m_body._entity._category === category) {
				return this.igeEntityB();
			}
		};

		this.b2Contact.prototype.igeEntityById = function (id) {
			if (this.m_fixtureA.m_body._entity._id === id) {
				return this.igeEntityA();
			}

			if (this.m_fixtureB.m_body._entity._id === id) {
				return this.igeEntityB();
			}
		};

		this.b2Contact.prototype.igeEntityByFixtureId = function (id) {
			if (this.m_fixtureA.igeId === id) {
				return this.igeEntityA();
			}

			if (this.m_fixtureB.igeId === id) {
				return this.igeEntityB();
			}
		};

		this.b2Contact.prototype.igeOtherEntity = function (entity) {
			if (this.m_fixtureA.m_body._entity === entity) {
				return this.igeEntityB();
			} else {
				return this.igeEntityA();
			}
		};

		this._sleep = true;
		this._scaleRatio = 30;
		this._gravity = new this.b2Vec2(0, 0);

		this._removeWhenReady = [];

		this.log('Physics component initiated!');
	},

	useWorker: function (val) {
		if (typeof(Worker) !== 'undefined') {
			if (val !== undefined) {
				this._useWorker = val;
				return this._entity;
			}

			return this._useWorker;
		} else {
			this.log('Web workers were not detected on this browser. Cannot access useWorker() method.', 'warning');
		}
	},

	/**
	 * Gets / sets the world interval mode. In mode 0 (zero) the
	 * box2d simulation is synced to the framerate of the engine's
	 * renderer. In mode 1 the box2d simulation is stepped at a constant
	 * speed regardless of the engine's renderer. This must be set *before*
	 * calling the start() method in order for the setting to take effect.
	 * @param {Integer} val The mode, either 0 or 1.
	 * @returns {*}
	 */
	mode: function (val) {
		if (val !== undefined) {
			this._mode = val;
			return this._entity;
		}

		return this._mode;
	},

	/**
	 * Gets / sets if the world should allow sleep or not.
	 * @param {Boolean=} val
	 * @return {*}
	 */
	sleep: function (val) {
		if (val !== undefined) {
			this._sleep = val;
			return this._entity;
		}

		return this._sleep;
	},

	/**
	 * Gets / sets the current engine to box2d scaling ratio.
	 * @param val
	 * @return {*}
	 */
	scaleRatio: function (val) {
		if (val !== undefined) {
			this._scaleRatio = val;
			return this._entity;
		}

		return this._scaleRatio;
	},

	/**
	 * Gets / sets the gravity vector.
	 * @param x
	 * @param y
	 * @return {*}
	 */
	gravity: function (x, y) {
		if (x !== undefined && y !== undefined) {
			this._gravity = new this.b2Vec2(x, y);
			return this._entity;
		}

		return this._gravity;
	},

	/**
	 * Gets the current Box2d world object.
	 * @return {b2World}
	 */
	world: function () {
		return this._world;
	},

	/**
	 * Creates the Box2d world.
	 * @param {String=} id
	 * @param {Object=} options
	 * @return {*}
	 */
	createWorld: function (id, options) {
		this._world = new this.b2World(
			this._gravity,
			this._sleep
		);

		this.log('World created');

		return this._entity;
	},

	/**
	 * Creates a Box2d fixture and returns it.
	 * @param params
	 * @return {b2FixtureDef}
	 */
	createFixture: function (params) {
		var tempDef = new this.b2FixtureDef(),
			param;

		for (param in params) {
			if (params.hasOwnProperty(param)) {
				if (param !== 'shape' && param !== 'filter') {
					tempDef[param] = params[param];
				}
			}
		}

		return tempDef;
	},

	/**
	 * Creates a Box2d body and attaches it to an IGE entity
	 * based on the supplied body definition.
	 * @param {IgeEntity} entity
	 * @param {Object} body
	 * @return {b2Body}
	 */
	createBody: function (entity, body) {
		var tempDef = new this.b2BodyDef(),
			param,
			tempBod,
			fixtureDef,
			tempFixture,
			finalFixture,
			tempShape,
			tempFilterData,
			i,
			finalX, finalY,
			finalWidth, finalHeight;

		// Process body definition and create a box2d body for it
		switch (body.type) {
			case 'static':
				tempDef.type = this.b2Body.b2_staticBody;
				break;

			case 'dynamic':
				tempDef.type = this.b2Body.b2_dynamicBody;
				break;
			
			case 'kinematic':
                tempDef.type = this.b2Body.b2_kinematicBody;
                break;
		}

		// Add the parameters of the body to the new body instance
		for (param in body) {
			if (body.hasOwnProperty(param)) {
				switch (param) {
					case 'type':
					case 'gravitic':
					case 'fixedRotation':
					case 'fixtures':
						// Ignore these for now, we process them
						// below as post-creation attributes
						break;

					default:
						tempDef[param] = body[param];
						break;
				}
			}
		}

		// Set the position
		tempDef.position = new this.b2Vec2(entity._translate.x / this._scaleRatio, entity._translate.y / this._scaleRatio);

		// Create the new body
		tempBod = this._world.CreateBody(tempDef);

		// Now apply any post-creation attributes we need to
		for (param in body) {
			if (body.hasOwnProperty(param)) {
				switch (param) {
					case 'gravitic':
						if (!body.gravitic) {
							tempBod.m_nonGravitic = true;
						}
						break;

					case 'fixedRotation':
						if (body.fixedRotation) {
							tempBod.SetFixedRotation(true);
						}
						break;

					case 'fixtures':
						if (body.fixtures && body.fixtures.length) {
							for (i = 0; i < body.fixtures.length; i++) {
								// Grab the fixture definition
								fixtureDef = body.fixtures[i];
	
								// Create the fixture
								tempFixture = this.createFixture(fixtureDef);
								tempFixture.igeId = fixtureDef.igeId;
	
								// Check for a shape definition for the fixture
								if (fixtureDef.shape) {
									// Create based on the shape type
									switch (fixtureDef.shape.type) {
										case 'circle':
											tempShape = new this.b2CircleShape();
											if (fixtureDef.shape.data && typeof(fixtureDef.shape.data.radius) !== 'undefined') {
												tempShape.SetRadius(fixtureDef.shape.data.radius / this._scaleRatio);
											} else {
												tempShape.SetRadius((entity._bounds2d.x / this._scaleRatio) / 2);
											}
											
											if (fixtureDef.shape.data) {
												finalX = fixtureDef.shape.data.x !== undefined ? fixtureDef.shape.data.x : 0;
												finalY = fixtureDef.shape.data.y !== undefined ? fixtureDef.shape.data.y : 0;
												
												tempShape.SetLocalPosition(new this.b2Vec2(finalX / this._scaleRatio, finalY / this._scaleRatio));
											}
											break;
	
										case 'polygon':
											tempShape = new this.b2PolygonShape();
											tempShape.SetAsArray(fixtureDef.shape.data._poly, fixtureDef.shape.data.length());
											break;
	
										case 'rectangle':
											tempShape = new this.b2PolygonShape();
	
											if (fixtureDef.shape.data) {
												finalX = fixtureDef.shape.data.x !== undefined ? fixtureDef.shape.data.x : 0;
												finalY = fixtureDef.shape.data.y !== undefined ? fixtureDef.shape.data.y : 0;
												finalWidth = fixtureDef.shape.data.width !== undefined ? fixtureDef.shape.data.width : (entity._bounds2d.x / 2);
												finalHeight = fixtureDef.shape.data.height !== undefined ? fixtureDef.shape.data.height : (entity._bounds2d.y / 2);
											} else {
												finalX = 0;
												finalY = 0;
												finalWidth = (entity._bounds2d.x / 2);
												finalHeight = (entity._bounds2d.y / 2);
											}
	
											// Set the polygon as a box
											tempShape.SetAsOrientedBox(
												(finalWidth / this._scaleRatio),
												(finalHeight / this._scaleRatio),
												new this.b2Vec2(finalX / this._scaleRatio, finalY / this._scaleRatio),
												0
											);
											break;
									}
	
									if (tempShape) {
										tempFixture.shape = tempShape;
										finalFixture = tempBod.CreateFixture(tempFixture);
										finalFixture.igeId = tempFixture.igeId;
									}
								}
	
								if (fixtureDef.filter && finalFixture) {
									tempFilterData = new this._entity.box2d.b2FilterData();
	
									if (fixtureDef.filter.categoryBits !== undefined) { tempFilterData.categoryBits = fixtureDef.filter.categoryBits; }
									if (fixtureDef.filter.maskBits !== undefined) { tempFilterData.maskBits = fixtureDef.filter.maskBits; }
									if (fixtureDef.filter.categoryIndex !== undefined) { tempFilterData.categoryIndex = fixtureDef.filter.categoryIndex; }
	
									finalFixture.SetFilterData(tempFilterData);
								}
	
								if (fixtureDef.density !== undefined && finalFixture) {
									finalFixture.SetDensity(fixtureDef.density);
								}
							}
						} else {
							this.log('Box2D body has no fixtures, have you specified fixtures correctly? They are supposed to be an array of fixture objects.', 'warning');
						}
						break;
				}
			}
		}

		// Store the entity that is linked to this body
		tempBod._entity = entity;

		// Add the body to the world with the passed fixture
		return tempBod;
	},

	/**
	 * Produces static box2d bodies from passed map data.
	 * @param {IgeTileMap2d} mapLayer
	 * @param {Function=} callback Returns true or false depending
	 * on if the passed map data should be included as part of the
	 * box2d static object data. This allows you to control what
	 * parts of the map data are to be considered for box2d static
	 * objects and which parts are to be ignored. If not passed then
	 * any tile with any map data is considered part of the static
	 * object data.
	 */
	staticsFromMap: function (mapLayer, callback) {
		if (mapLayer.map) {
			var tileWidth = mapLayer.tileWidth(),
				tileHeight = mapLayer.tileHeight(),
				posX, posY,
				rectArray, rectCount, rect;

			// Get the array of rectangle bounds based on
			// the map's data
			rectArray = mapLayer.scanRects(callback);
			rectCount = rectArray.length;

			while (rectCount--) {
				rect = rectArray[rectCount];

				posX = (tileWidth * (rect.width / 2));
				posY = (tileHeight * (rect.height / 2));

				new IgeEntityBox2d()
					.translateTo(rect.x * tileWidth + posX, rect.y * tileHeight + posY, 0)
					.width(rect.width * tileWidth)
					.height(rect.height * tileHeight)
					.drawBounds(true)
					.drawBoundsData(false)
					.box2dBody({
						type: 'static',
						allowSleep: true,
						fixtures: [{
							shape: {
								type: 'rectangle'
							}
						}]
					});
			}
		} else {
			this.log('Cannot extract box2d static bodies from map data because passed map does not have a .map property!', 'error');
		}
	},

	/**
	 * Creates a contact listener with the specified callbacks. When
	 * contacts begin and end inside the box2d simulation the specified
	 * callbacks are fired.
	 * @param {Function} beginContactCallback The method to call when the contact listener detects contact has started.
	 * @param {Function} endContactCallback The method to call when the contact listener detects contact has ended.
	 * @param {Function} preSolve
	 * @param {Function} postSolve
	 */
	contactListener: function (beginContactCallback, endContactCallback, preSolve, postSolve) {
		var contactListener = new this.b2ContactListener();
		if (beginContactCallback !== undefined) {
			contactListener.BeginContact = beginContactCallback;
		}

		if (endContactCallback !== undefined) {
			contactListener.EndContact = endContactCallback;
		}

		if (preSolve !== undefined) {
			contactListener.PreSolve = preSolve;
		}

		if (postSolve !== undefined) {
			contactListener.PostSolve = postSolve;
		}
		this._world.SetContactListener(contactListener);
	},
	
	/**
	 * If enabled, sets the physics world into network debug mode which
	 * will stop the world from generating collisions but still allow us
	 * to see shape outlines as they are attached to bodies. Useful when
	 * your physics system is server-side but seeing client-side shape
	 * data is useful for debugging collisions.
	 * @param {Boolean} val
	 */
	networkDebugMode: function (val) {
		if (val !== undefined) {
			this._networkDebugMode = val;
			
			if (val === true) {
				// We are enabled so disable all physics contacts
				this.contactListener(
					// Begin contact
					function (contact) {},
					// End contact
					function (contact) {},
					// Pre-solve
					function (contact) {
						// Cancel the contact
						contact.SetEnabled(false);
					},
					// Post-solve
					function (contact) {}
				);
			} else {
				// Re-enable contacts
				this.contactListener();
			}
			
			return this._entity;
		}
		
		return this._networkDebugMode;
	},

	/**
	 * Creates a debug entity that outputs the bounds of each box2d
	 * body during standard engine ticks.
	 * @param {IgeEntity} mountScene
	 */
	enableDebug: function (mountScene) {
		if (mountScene) {
			// Define the debug drawing instance
			var debugDraw = new this.b2DebugDraw();
			this._box2dDebug = true;

			debugDraw.SetSprite(ige._ctx);
			debugDraw.SetDrawScale(this._scaleRatio);
			debugDraw.SetFillAlpha(0.3);
			debugDraw.SetLineThickness(1.0);
			debugDraw.SetFlags(
				this.b2DebugDraw.e_controllerBit
				| this.b2DebugDraw.e_jointBit
				| this.b2DebugDraw.e_pairBit
				| this.b2DebugDraw.e_shapeBit
				//| this.b2DebugDraw.e_aabbBit
				//| this.b2DebugDraw.e_centerOfMassBit
			);

			// Set the debug draw for the world
			this._world.SetDebugDraw(debugDraw);

			// Create the debug painter entity and mount
			// it to the passed scene
			new igeClassStore.IgeBox2dDebugPainter(this._entity)
				.depth(40000) // Set a really high depth
				.drawBounds(false)
				.mount(mountScene);
		} else {
			this.log('Cannot enable box2d debug drawing because the passed argument is not an object on the scenegraph.', 'error');
		}
	},

	/**
	 * Queues a body for removal from the physics world.
	 * @param body
	 */
	destroyBody: function (body) {
		this._removeWhenReady.push(body);
	},

	/**
	 * Gets / sets the callback method that will be called after
	 * every physics world step.
	 * @param method
	 * @return {*}
	 */
	updateCallback: function (method) {
		if (method !== undefined) {
			this._updateCallback = method;
			return this._entity;
		}

		return this._updateCallback;
	},

	start: function () {
		if (!this._active) {
			this._active = true;
			
			if (!this._networkDebugMode) {
				if (this._mode === 0) {
					// Add the box2d behaviour to the ige
					this._entity.addBehaviour('box2dStep', this._behaviour);
				} else {
					this._intervalTimer = setInterval(this._behaviour, 1000 / 60);
				}
			}
		}
	},

	stop: function () {
		if (this._active) {
			this._active = false;

			if (this._mode === 0) {
				// Add the box2d behaviour to the ige
				this._entity.removeBehaviour('box2dStep');
			} else {
				clearInterval(this._intervalTimer);
			}
		}
	},

	/**
	 * Steps the physics simulation forward.
	 * @param ctx
	 * @private
	 */
	_behaviour: function (ctx) {
		var self = this.box2d,
			tempBod,
			entity,
			entityBox2dBody,
			removeWhenReady,
			count,
			destroyBody;

		if (self._active && self._world) {
			if (!self._world.IsLocked()) {
				// Remove any bodies that were queued for removal
				removeWhenReady = self._removeWhenReady;
				count = removeWhenReady.length;

				if (count) {
					destroyBody = self._world.DestroyBody;
					while (count--) {
						destroyBody.apply(self._world, [removeWhenReady[count]]);
					}
					self._removeWhenReady = [];
					removeWhenReady = null;
				}
			}

			// Call the world step; frame-rate, velocity iterations, position iterations
			if (self._mode === 0) {
				self._world.Step(ige._tickDelta / 1000, 8, 3);
			} else {
				self._world.Step(1 / 60, 8, 3);
			}

			// Loop the physics objects and move the entities they are assigned to
			tempBod = self._world.GetBodyList();
			while (tempBod) {
				if (tempBod._entity) {
					// Body has an entity assigned to it
					entity = tempBod._entity; //self.ige.entities.read(tempBod.m_userData);
					entityBox2dBody = entity._box2dBody;

					// Check if the body is awake and is dynamic (we don't transform static bodies)
					if (tempBod.IsAwake() && tempBod.m_type !== 0) {
						// Update the entity data to match the body data
						entityBox2dBody.updating = true;
						entity.translateTo(tempBod.m_xf.position.x * self._scaleRatio, tempBod.m_xf.position.y * self._scaleRatio, entity._translate.z);
						entity.rotateTo(entity._rotate.x, entity._rotate.y, tempBod.GetAngle());
						entityBox2dBody.updating = false;

						if (entityBox2dBody.asleep) {
							// The body was asleep last frame, fire an awake event
							entityBox2dBody.asleep = false;
							self.emit('afterAwake', entity);
						}
					} else {
						if (!entityBox2dBody.asleep) {
							// The body was awake last frame, fire an asleep event
							entityBox2dBody.asleep = true;
							self.emit('afterAsleep', entity);
						}
					}
				}

				tempBod = tempBod.GetNext();
			}

			// Clear forces because we have ended our physics simulation frame
			self._world.ClearForces();

			tempBod = null;
			entity = null;

			if (typeof(self._updateCallback) === 'function') {
				self._updateCallback();
			}
		}
	},

	destroy: function () {
		// Stop processing box2d steps
		this._entity.removeBehaviour('box2dStep');

		// Destroy all box2d world bodies

	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = IgeBox2dComponent; }
/**
 * The engine's box2d multi-world component class.
 */
var IgeBox2dMultiWorldComponent = IgeEventingClass.extend({
	classId: 'IgeBox2dMultiWorldComponent',
	componentId: 'box2d',

	init: function (entity, options) {
		this._entity = entity;
		this._options = options;
		
		this._worlds = {};

		this.b2Color = Box2D.Common.b2Color;
		this.b2Vec2 = Box2D.Common.Math.b2Vec2;
		this.b2Math = Box2D.Common.Math.b2Math;
		this.b2Shape = Box2D.Collision.Shapes.b2Shape;
		this.b2BodyDef = Box2D.Dynamics.b2BodyDef;
		this.b2Body = Box2D.Dynamics.b2Body;
		this.b2FixtureDef = Box2D.Dynamics.b2FixtureDef;
		this.b2Fixture = Box2D.Dynamics.b2Fixture;
		this.b2World = Box2D.Dynamics.b2World;
		this.b2MassData = Box2D.Collision.Shapes.b2MassData;
		this.b2PolygonShape = Box2D.Collision.Shapes.b2PolygonShape;
		this.b2CircleShape = Box2D.Collision.Shapes.b2CircleShape;
		this.b2DebugDraw = Box2D.Dynamics.b2DebugDraw;
		this.b2ContactListener = Box2D.Dynamics.b2ContactListener;
		this.b2Distance = Box2D.Collision.b2Distance;
		this.b2Contact = Box2D.Dynamics.Contacts.b2Contact;
		this.b2FilterData = Box2D.Dynamics.b2FilterData;
		this.b2DistanceJointDef = Box2D.Dynamics.Joints.b2DistanceJointDef;

		// Extend the b2Contact class to allow the IGE entity accessor
		// and other helper methods
		this.b2Contact.prototype.igeEntityA = function () {
			var ent = this.m_fixtureA.m_body._entity;
			ent._box2dOurContactFixture = this.m_fixtureA;
			ent._box2dTheirContactFixture = this.m_fixtureB;
			return ent;
		};

		this.b2Contact.prototype.igeEntityB = function () {
			var ent = this.m_fixtureB.m_body._entity;
			ent._box2dOurContactFixture = this.m_fixtureB;
			ent._box2dTheirContactFixture = this.m_fixtureA;
			return ent;
		};

		this.b2Contact.prototype.igeEitherId = function (id1, id2) {
			if (!id2) {
				return this.m_fixtureA.m_body._entity._id === id1 || this.m_fixtureB.m_body._entity._id === id1;
			} else {
				return (this.m_fixtureA.m_body._entity._id === id1 || this.m_fixtureB.m_body._entity._id === id1) &&
					(this.m_fixtureA.m_body._entity._id === id2 || this.m_fixtureB.m_body._entity._id === id2);
			}
		};

		this.b2Contact.prototype.igeEitherCategory = function (category1, category2) {
			if (!category2) {
				return this.m_fixtureA.m_body._entity._category === category1 || this.m_fixtureB.m_body._entity._category === category1;
			} else {
				return (this.m_fixtureA.m_body._entity._category === category1 || this.m_fixtureB.m_body._entity._category === category1) &&
					(this.m_fixtureA.m_body._entity._category === category2 || this.m_fixtureB.m_body._entity._category === category2);
			}
		};

		this.b2Contact.prototype.igeBothCategories = function (category1) {
			return (this.m_fixtureA.m_body._entity._category === category1 && this.m_fixtureB.m_body._entity._category === category1);
		};

		this.b2Contact.prototype.igeEntityByCategory = function (category) {
			if (this.m_fixtureA.m_body._entity._category === category) {
				return this.igeEntityA();
			}

			if (this.m_fixtureB.m_body._entity._category === category) {
				return this.igeEntityB();
			}
		};

		this.b2Contact.prototype.igeEntityById = function (id) {
			if (this.m_fixtureA.m_body._entity._id === id) {
				return this.igeEntityA();
			}

			if (this.m_fixtureB.m_body._entity._id === id) {
				return this.igeEntityB();
			}
		};

		this.b2Contact.prototype.igeEntityByFixtureId = function (id) {
			if (this.m_fixtureA.igeId === id) {
				return this.igeEntityA();
			}

			if (this.m_fixtureB.igeId === id) {
				return this.igeEntityB();
			}
		};

		this.b2Contact.prototype.igeOtherEntity = function (entity) {
			if (this.m_fixtureA.m_body._entity === entity) {
				return this.igeEntityB();
			} else {
				return this.igeEntityA();
			}
		};

		this.log('Physics component initiated!');
	},

	/**
	 * Gets the Box2d world object by it's id.
	 * @return {b2World}
	 */
	world: function (id) {
		return this._worlds[id];
	},

	/**
	 * Creates the Box2d world.
	 * @param {String} id
	 * @param {Object=} options
	 * @return {*}
	 */
	createWorld: function (options) {
		var world;
		
		options = options || {};
		options.id = options.id || ige.newIdHex();
		options.gravity = options.gravity || new this.b2Vec2(0, 0);
		options.sleep = options.sleep !== undefined ? options.sleep : true;
		
		// Create world instance
		this._worlds[options.id] = world = new IgeBox2dWorld(this, options);
		
		return world;
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = IgeBox2dMultiWorldComponent; }
var IgeBox2dWorld = IgeEventingClass.extend({
	classId: 'IgeBox2dWorld',
	
	init: function (entity, options) {
		this.b2Color = Box2D.Common.b2Color;
		this.b2Vec2 = Box2D.Common.Math.b2Vec2;
		this.b2Math = Box2D.Common.Math.b2Math;
		this.b2Shape = Box2D.Collision.Shapes.b2Shape;
		this.b2BodyDef = Box2D.Dynamics.b2BodyDef;
		this.b2Body = Box2D.Dynamics.b2Body;
		this.b2FixtureDef = Box2D.Dynamics.b2FixtureDef;
		this.b2Fixture = Box2D.Dynamics.b2Fixture;
		this.b2World = Box2D.Dynamics.b2World;
		this.b2MassData = Box2D.Collision.Shapes.b2MassData;
		this.b2PolygonShape = Box2D.Collision.Shapes.b2PolygonShape;
		this.b2CircleShape = Box2D.Collision.Shapes.b2CircleShape;
		this.b2DebugDraw = Box2D.Dynamics.b2DebugDraw;
		this.b2ContactListener = Box2D.Dynamics.b2ContactListener;
		this.b2Distance = Box2D.Collision.b2Distance;
		this.b2Contact = Box2D.Dynamics.Contacts.b2Contact;
		this.b2FilterData = Box2D.Dynamics.b2FilterData;
		this.b2DistanceJointDef = Box2D.Dynamics.Joints.b2DistanceJointDef;
		
		this._entity = entity;
		
		options = options || {
			id: ige.newIdHex(),
			gravity: new this.b2Vec2(0, 0),
			sleep: true
		};
		
		this._id = options.id;
		this._sleep = options.sleep;
		this._scaleRatio = options.scaleRatio !== undefined ? options.scaleRatio : 30;
		this._gravity = options.gravity;
		this._mode = 0;

		this._removeWhenReady = [];
		
		this._world = new this.b2World(
			options.gravity,
			options.sleep
		);
	},
	
	/**
	 * Creates a Box2d fixture and returns it.
	 * @param params
	 * @return {b2FixtureDef}
	 */
	createFixture: function (params) {
		var tempDef = new this.b2FixtureDef(),
			param;

		for (param in params) {
			if (params.hasOwnProperty(param)) {
				if (param !== 'shape' && param !== 'filter') {
					tempDef[param] = params[param];
				}
			}
		}

		return tempDef;
	},

	/**
	 * Creates a Box2d body and attaches it to an IGE entity
	 * based on the supplied body definition.
	 * @param {IgeEntityBox2d} entity
	 * @param {Object} body
	 * @return {b2Body}
	 */
	createBody: function (entity, body) {
		var tempDef = new this.b2BodyDef(),
			param,
			tempBod,
			fixtureDef,
			tempFixture,
			finalFixture,
			tempShape,
			tempFilterData,
			i,
			finalX, finalY,
			finalWidth, finalHeight;

		// Process body definition and create a box2d body for it
		switch (body.type) {
			case 'static':
				tempDef.type = this.b2Body.b2_staticBody;
				break;

			case 'dynamic':
				tempDef.type = this.b2Body.b2_dynamicBody;
				break;
			
			case 'kinematic':
                tempDef.type = this.b2Body.b2_kinematicBody;
                break;
		}

		// Add the parameters of the body to the new body instance
		for (param in body) {
			if (body.hasOwnProperty(param)) {
				switch (param) {
					case 'type':
					case 'gravitic':
					case 'fixedRotation':
					case 'fixtures':
						// Ignore these for now, we process them
						// below as post-creation attributes
						break;

					default:
						tempDef[param] = body[param];
						break;
				}
			}
		}

		// Set the position
		tempDef.position = new this.b2Vec2(entity._translate.x / this._scaleRatio, entity._translate.y / this._scaleRatio);
		
		// Create the new body
		tempBod = this._world.CreateBody(tempDef);

		// Now apply any post-creation attributes we need to
		for (param in body) {
			if (body.hasOwnProperty(param)) {
				switch (param) {
					case 'gravitic':
						if (!body.gravitic) {
							tempBod.m_nonGravitic = true;
						}
						break;

					case 'fixedRotation':
						if (body.fixedRotation) {
							tempBod.SetFixedRotation(true);
						}
						break;

					case 'fixtures':
						if (body.fixtures && body.fixtures.length) {
							for (i = 0; i < body.fixtures.length; i++) {
								// Grab the fixture definition
								fixtureDef = body.fixtures[i];
	
								// Create the fixture
								tempFixture = this.createFixture(fixtureDef);
								tempFixture.igeId = fixtureDef.igeId;
	
								// Check for a shape definition for the fixture
								if (fixtureDef.shape) {
									// Create based on the shape type
									switch (fixtureDef.shape.type) {
										case 'circle':
											tempShape = new this.b2CircleShape();
											if (fixtureDef.shape.data && typeof(fixtureDef.shape.data.radius) !== 'undefined') {
												tempShape.SetRadius(fixtureDef.shape.data.radius / this._scaleRatio);
											} else {
												tempShape.SetRadius((entity._bounds2d.x / this._scaleRatio) / 2);
											}
											
											if (fixtureDef.shape.data) {
												finalX = fixtureDef.shape.data.x !== undefined ? fixtureDef.shape.data.x : 0;
												finalY = fixtureDef.shape.data.y !== undefined ? fixtureDef.shape.data.y : 0;
												
												tempShape.SetLocalPosition(new this.b2Vec2(finalX / this._scaleRatio, finalY / this._scaleRatio));
											}
											break;
	
										case 'polygon':
											tempShape = new this.b2PolygonShape();
											tempShape.SetAsArray(fixtureDef.shape.data._poly, fixtureDef.shape.data.length());
											break;
	
										case 'rectangle':
											tempShape = new this.b2PolygonShape();
	
											if (fixtureDef.shape.data) {
												finalX = fixtureDef.shape.data.x !== undefined ? fixtureDef.shape.data.x : 0;
												finalY = fixtureDef.shape.data.y !== undefined ? fixtureDef.shape.data.y : 0;
												finalWidth = fixtureDef.shape.data.width !== undefined ? fixtureDef.shape.data.width : (entity._bounds2d.x / 2);
												finalHeight = fixtureDef.shape.data.height !== undefined ? fixtureDef.shape.data.height : (entity._bounds2d.y / 2);
											} else {
												finalX = 0;
												finalY = 0;
												finalWidth = (entity._bounds2d.x / 2);
												finalHeight = (entity._bounds2d.y / 2);
											}
	
											// Set the polygon as a box
											tempShape.SetAsOrientedBox(
												(finalWidth / this._scaleRatio),
												(finalHeight / this._scaleRatio),
												new this.b2Vec2(finalX / this._scaleRatio, finalY / this._scaleRatio),
												0
											);
											break;
									}
	
									if (tempShape) {
										tempFixture.shape = tempShape;
										finalFixture = tempBod.CreateFixture(tempFixture);
										finalFixture.igeId = tempFixture.igeId;
									}
								}
	
								if (fixtureDef.filter && finalFixture) {
									tempFilterData = new this.b2FilterData();
	
									if (fixtureDef.filter.categoryBits !== undefined) { tempFilterData.categoryBits = fixtureDef.filter.categoryBits; }
									if (fixtureDef.filter.maskBits !== undefined) { tempFilterData.maskBits = fixtureDef.filter.maskBits; }
									if (fixtureDef.filter.categoryIndex !== undefined) { tempFilterData.categoryIndex = fixtureDef.filter.categoryIndex; }
	
									finalFixture.SetFilterData(tempFilterData);
								}
	
								if (fixtureDef.density !== undefined && finalFixture) {
									finalFixture.SetDensity(fixtureDef.density);
								}
							}
						} else {
							this.log('Box2D body has no fixtures, have you specified fixtures correctly? They are supposed to be an array of fixture objects.', 'warning');
						}
						break;
				}
			}
		}

		// Store the entity that is linked to this body
		tempBod._entity = entity;

		// Add the body to the world with the passed fixture
		return tempBod;
	},

	/**
	 * Produces static box2d bodies from passed map data.
	 * @param {IgeTileMap2d} mapLayer
	 * @param {Function=} callback Returns true or false depending
	 * on if the passed map data should be included as part of the
	 * box2d static object data. This allows you to control what
	 * parts of the map data are to be considered for box2d static
	 * objects and which parts are to be ignored. If not passed then
	 * any tile with any map data is considered part of the static
	 * object data.
	 */
	staticsFromMap: function (mapLayer, callback) {
		if (mapLayer.map) {
			var tileWidth = mapLayer.tileWidth(),
				tileHeight = mapLayer.tileHeight(),
				posX, posY,
				rectArray, rectCount, rect;

			// Get the array of rectangle bounds based on
			// the map's data
			rectArray = mapLayer.scanRects(callback);
			rectCount = rectArray.length;

			while (rectCount--) {
				rect = rectArray[rectCount];

				posX = (tileWidth * (rect.width / 2));
				posY = (tileHeight * (rect.height / 2));

				new IgeEntityBox2d()
					.translateTo(rect.x * tileWidth + posX, rect.y * tileHeight + posY, 0)
					.width(rect.width * tileWidth)
					.height(rect.height * tileHeight)
					.drawBounds(true)
					.drawBoundsData(false)
					.box2dBody({
						type: 'static',
						allowSleep: true,
						fixtures: [{
							shape: {
								type: 'rectangle'
							}
						}]
					});
			}
		} else {
			this.log('Cannot extract box2d static bodies from map data because passed map does not have a .map property!', 'error');
		}
	},

	/**
	 * Creates a contact listener with the specified callbacks. When
	 * contacts begin and end inside the box2d simulation the specified
	 * callbacks are fired.
	 * @param {Function} beginContactCallback The method to call when the contact listener detects contact has started.
	 * @param {Function} endContactCallback The method to call when the contact listener detects contact has ended.
	 * @param {Function} preSolve
	 * @param {Function} postSolve
	 */
	contactListener: function (beginContactCallback, endContactCallback, preSolve, postSolve) {
		var contactListener = new this.b2ContactListener();
		if (beginContactCallback !== undefined) {
			contactListener.BeginContact = beginContactCallback;
		}

		if (endContactCallback !== undefined) {
			contactListener.EndContact = endContactCallback;
		}

		if (preSolve !== undefined) {
			contactListener.PreSolve = preSolve;
		}

		if (postSolve !== undefined) {
			contactListener.PostSolve = postSolve;
		}
		this._world.SetContactListener(contactListener);
	},
	
	/**
	 * If enabled, sets the physics world into network debug mode which
	 * will stop the world from generating collisions but still allow us
	 * to see shape outlines as they are attached to bodies. Useful when
	 * your physics system is server-side but seeing client-side shape
	 * data is useful for debugging collisions.
	 * @param {Boolean} val
	 */
	networkDebugMode: function (val) {
		if (val !== undefined) {
			this._networkDebugMode = val;
			
			if (val === true) {
				// We are enabled so disable all physics contacts
				this.contactListener(
					// Begin contact
					function (contact) {},
					// End contact
					function (contact) {},
					// Pre-solve
					function (contact) {
						// Cancel the contact
						contact.SetEnabled(false);
					},
					// Post-solve
					function (contact) {}
				);
			} else {
				// Re-enable contacts
				this.contactListener();
			}
			
			return this;
		}
		
		return this._networkDebugMode;
	},

	/**
	 * Creates a debug entity that outputs the bounds of each box2d
	 * body during standard engine ticks.
	 * @param {IgeEntity} mountScene
	 */
	enableDebug: function (mountScene) {
		if (mountScene) {
			// Define the debug drawing instance
			var debugDraw = new this.b2DebugDraw();
			this._box2dDebug = true;

			debugDraw.SetSprite(ige._ctx);
			debugDraw.SetDrawScale(this._scaleRatio);
			debugDraw.SetFillAlpha(0.3);
			debugDraw.SetLineThickness(1.0);
			debugDraw.SetFlags(
				this.b2DebugDraw.e_controllerBit
				| this.b2DebugDraw.e_jointBit
				| this.b2DebugDraw.e_pairBit
				| this.b2DebugDraw.e_shapeBit
				//| this.b2DebugDraw.e_aabbBit
				//| this.b2DebugDraw.e_centerOfMassBit
			);

			// Set the debug draw for the world
			this._world.SetDebugDraw(debugDraw);

			// Create the debug painter entity and mount
			// it to the passed scene
			new igeClassStore.IgeBox2dDebugPainter()
				.depth(40000) // Set a really high depth
				.drawBounds(false)
				.mount(mountScene);
		} else {
			this.log('Cannot enable box2d debug drawing because the passed argument is not an object on the scenegraph.', 'error');
		}
	},

	/**
	 * Queues a body for removal from the physics world.
	 * @param body
	 */
	destroyBody: function (body) {
		this._removeWhenReady.push(body);
	},

	/**
	 * Gets / sets the callback method that will be called after
	 * every physics world step.
	 * @param method
	 * @return {*}
	 */
	updateCallback: function (method) {
		if (method !== undefined) {
			this._updateCallback = method;
			return this;
		}

		return this._updateCallback;
	},

	start: function () {
		var self = this;
		if (!this._active) {
			this._active = true;
			
			if (!this._networkDebugMode) {
				if (this._mode === 0) {
					// Add the box2d behaviour to the ige
					ige.addBehaviour('box2dStep_' + self._id, function () { self._behaviour.apply(self, arguments); });
				} else {
					this._intervalTimer = setInterval(function () { self._behaviour.apply(self, arguments); }, 1000 / 60);
				}
			}
		}
	},

	stop: function () {
		if (this._active) {
			this._active = false;

			if (this._mode === 0) {
				// Add the box2d behaviour to the ige
				ige.removeBehaviour('box2dStep_' + this._id);
			} else {
				clearInterval(this._intervalTimer);
			}
		}
	},

	/**
	 * Steps the physics simulation forward.
	 * @param ctx
	 * @private
	 */
	_behaviour: function (ctx) {
		var self = this,
			tempBod,
			entity,
			entityBox2dBody,
			removeWhenReady,
			count,
			destroyBody;

		if (self._active && self._world) {
			if (!self._world.IsLocked()) {
				// Remove any bodies that were queued for removal
				removeWhenReady = self._removeWhenReady;
				count = removeWhenReady.length;

				if (count) {
					destroyBody = self._world.DestroyBody;
					while (count--) {
						destroyBody.apply(self._world, [removeWhenReady[count]]);
					}
					self._removeWhenReady = [];
					removeWhenReady = null;
				}
			}

			// Call the world step; frame-rate, velocity iterations, position iterations
			if (self._mode === 0) {
				self._world.Step(ige._tickDelta / 1000, 8, 3);
			} else {
				self._world.Step(1 / 60, 8, 3);
			}

			// Loop the physics objects and move the entities they are assigned to
			tempBod = self._world.GetBodyList();
			while (tempBod) {
				if (tempBod._entity) {
					// Body has an entity assigned to it
					entity = tempBod._entity; //self.ige.entities.read(tempBod.m_userData);
					entityBox2dBody = entity._box2dBody;

					// Check if the body is awake and is dynamic (we don't transform static bodies)
					if (tempBod.IsAwake() && tempBod.m_type !== 0) {
						// Update the entity data to match the body data
						entityBox2dBody.updating = true;
						entity.translateTo(tempBod.m_xf.position.x * entity._b2dRef._scaleRatio, tempBod.m_xf.position.y * entity._b2dRef._scaleRatio, entity._translate.z);
						entity.rotateTo(entity._rotate.x, entity._rotate.y, tempBod.GetAngle());
						entityBox2dBody.updating = false;

						if (entityBox2dBody.asleep) {
							// The body was asleep last frame, fire an awake event
							entityBox2dBody.asleep = false;
							self.emit('afterAwake', entity);
						}
					} else {
						if (!entityBox2dBody.asleep) {
							// The body was awake last frame, fire an asleep event
							entityBox2dBody.asleep = true;
							self.emit('afterAsleep', entity);
						}
					}
				}

				tempBod = tempBod.GetNext();
			}

			// Clear forces because we have ended our physics simulation frame
			self._world.ClearForces();

			tempBod = null;
			entity = null;

			if (typeof(self._updateCallback) === 'function') {
				self._updateCallback();
			}
		}
	},

	destroy: function () {
		// Stop processing box2d steps
		this.removeBehaviour('box2dStep');

		// Destroy all box2d world bodies

	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = IgeBox2dWorld; }
var IgeBox2dDebugPainter = IgeObject.extend({
	classId: 'IgeBox2dDebugPainter',
	
	init: function (entity, options) {
		IgeObject.prototype.init.call(this);
		
		this._entity = entity;
		this._options = options;
	},

	tick: function (ctx) {
		if (this._parent && this._parent.isometricMounts() === 1) {
			ctx.scale(1.414, 0.707); // This should be super-accurate now
			ctx.rotate(45  * Math.PI / 180);
		}
		
		this._entity.box2d._world.DrawDebugData();

		IgeObject.prototype.tick.call(this, ctx);
	}
});
/**
 * Creates a new entity with box2d integration.
 */
var IgeEntityBox2d = IgeEntity.extend({
	classId: 'IgeEntityBox2d',

	init: function (world) {
		IgeEntity.prototype.init.call(this);
		
		if (world) {
			if (typeof(world) === 'string') {
				// Get world reference
				world = ige.box2d.world(world);
			}
			
			this._box2dWorld = world;
			this._b2dRef = world;
		} else {
			this._b2dRef = ige.box2d;
		}
		
		// Check if box2d is enabled in the engine
		if (ige.box2d) {
			if (!this._b2dRef._networkDebugMode) {
				// Store the existing transform methods
				this._translateToProto = this.translateTo;
				this._translateByProto = this.translateBy;
		
				this._rotateToProto = this.rotateTo;
				this._rotateByProto = this.rotateBy;
		
				// Take over the transform methods
				this.translateTo = this._translateTo;
				this.translateBy = this._translateBy;
		
				this.rotateTo = this._rotateTo;
				this.rotateBy = this._rotateBy;
			} else {
				this._translateToProto = function () {};
				this._translateByProto = function () {};
		
				this._rotateToProto = function () {};
				this._rotateByProto = function () {};
				
				this._updateProto = this.update;
				
				// Make sure box2d is kept up to date by the engine
				this.update = this._update;
			}
		}
	},

	/**
	 * Gets / sets the box2d body's active flag which determines
	 * if it will be included as part of the physics simulation
	 * or not.
	 * @param {Boolean=} val Set to true to include the body in
	 * the physics simulation or false for it to be ignored.
	 * @return {*}
	 */
	box2dActive: function (val) {
		if (this._box2dBody) {
			if (val !== undefined) {
				this._box2dBody.SetActive(val);
				return this;
			}

			return this._box2dBody.IsActive();
		}

		return this;
	},

	/**
	 * Gets / sets the physics body definition. When setting the
	 * definition the physics body will also be created automatically
	 * from the supplied definition.
	 * @param def
	 * @return {*}
	 */
	box2dBody: function (def) {
		if (def !== undefined) {
			this._box2dBodyDef = def;

			// Check that the box2d component exists
			if (ige.box2d) {
				// Ask the box2d component to create a new body for us
				this._box2dBody = this._b2dRef.createBody(this, def);
			} else {
				this.log('You are trying to create a box2d entity but you have not added the box2d component to the ige instance!', 'error');
			}

			return this;
		}

		return this._box2dBodyDef;
	},

	/**
	 * Gets / sets the box2d body's gravitic value. If set to false,
	 * this entity will not be affected by gravity. If set to true it
	 * will be affected by gravity.
	 * @param {Boolean=} val True to allow gravity to affect this entity.
	 * @returns {*}
	 */
	gravitic: function (val) {
		if (this._box2dBody) {
			if (val !== undefined) {
				this._box2dBody.m_nonGravitic = !val;
				this._box2dBodyDef.gravitic = val;
				
				// Wake up the body
				this._box2dBody.SetAwake(true);
				return this;
			}
			
			return !this._box2dBody.m_nonGravitic;
		}
	},
	
	on: function () {
		if (arguments.length === 3) {
			var evName = arguments[0],
				target = arguments[1],
				callback = arguments[2],
				type;

			switch (target.substr(0, 1)) {
				case '#':
					type = 0;
					break;

				case '.':
					type = 1;
					break;
			}

			target = target.substr(1, target.length - 1);
			
			switch (evName) {
				case 'collisionStart':
					this._collisionStartListeners = this._collisionStartListeners || [];
					this._collisionStartListeners.push({
						type: type,
						target: target,
						callback: callback
					});
					
					if (!this._contactListener) {
						// Setup contact listener
						this._contactListener = this._setupContactListeners();
					}
					break;
				
				case 'collisionEnd':
					this._collisionEndListeners = this._collisionEndListeners || [];
					this._collisionEndListeners.push({
						type: type,
						target: target,
						callback: callback
					});
					
					if (!this._contactListener) {
						// Setup contact listener
						this._contactListener = this._setupContactListeners();
					}
					break;
				
				default:
					this.log('Cannot add event listener, event type ' + evName + ' not recognised', 'error');
					break;
			}
		} else {
			IgeEntity.prototype.on.apply(this, arguments);
		}
	},
	
	off: function () {
		if (arguments.length === 3) {
			
		} else {
			IgeEntity.prototype.off.apply(this, arguments);
		}
	},
	
	_setupContactListeners: function () {
		var self = this;
		
		ige.box2d.contactListener(
			// Listen for when contact's begin
			function (contact) {
				//console.log('Contact begins between', contact.igeEntityA()._id, 'and', contact.igeEntityB()._id);
				
				// Loop the collision listeners and check for a match
				var arr = self._collisionStartListeners;
				
				if (arr) {
					self._checkContact(contact, arr);
				}
			},
			// Listen for when contact's end
			function (contact) {
				//console.log('Contact ends between', contact.igeEntityA()._id, 'and', contact.igeEntityB()._id);
				// Loop the collision listeners and check for a match
				var arr = self._collisionEndListeners;
				
				if (arr) {
					self._checkContact(contact, arr);
				}
			}/*,
			// Handle pre-solver events
			function (contact) {
				// If player ship collides with lunar surface, crash!
				if (contact.igeEitherCategory('orb') && contact.igeEitherCategory('ship')) {
					// Cancel the contact
					contact.SetEnabled(false);
				}

				// You can also check an entity by it's category using igeEitherCategory('categoryName')
			}*/
		);
	},
	
	_checkContact: function (contact, arr) {
		var self = this,
			arrCount = arr.length,
			otherEntity,
			listener,
			i;
					
		if (contact.igeEntityA()._id === self._id) {
			otherEntity = contact.igeEntityB();
		} else if (contact.igeEntityB()._id === self._id) {
			otherEntity = contact.igeEntityA();
		} else {
			// This contact has nothing to do with us
			return;
		}
		
		for (i = 0; i < arrCount; i++) {
			listener = arr[i];
			
			if (listener.type === 0) {
				// Listener target is an id
				if (otherEntity._id === listener.target) {
					// Contact with target established, fire callback
					listener.callback(contact);
				}
			}
			
			if (arr[i].type === 1) {
				// Listener target is a category
				if (otherEntity._category === listener.target) {
					// Contact with target established, fire callback
					listener.callback(contact);
				}
			}
		}
	},

	/**
	 * Takes over translateTo calls and processes box2d movement as well.
	 * @param x
	 * @param y
	 * @param z
	 * @return {*}
	 * @private
	 */
	_translateTo: function (x, y, z) {
		var entBox2d = this._box2dBody;

		// Call the original method
		this._translateToProto(x, y, z);

		// Check if the entity has a box2d body attached
		// and if so, is it updating or not
		if (entBox2d && !entBox2d.updating) {
			// We have an entity with a box2d definition that is
			// not currently updating so let's override the standard
			// transform op and take over

			// Translate the body
			entBox2d.SetPosition({x: x / this._b2dRef._scaleRatio, y: y / this._b2dRef._scaleRatio});
			entBox2d.SetAwake(true);
		}

		return this;
	},

	/**
	 * Takes over translateBy calls and processes box2d movement as well.
	 * @param x
	 * @param y
	 * @param z
	 * @private
	 */
	_translateBy: function (x, y, z) {
		this._translateTo(this._translate.x + x, this._translate.y + y, this._translate.z + z);
	},

	/**
	 * Takes over translateTo calls and processes box2d movement as well.
	 * @param x
	 * @param y
	 * @param z
	 * @return {*}
	 * @private
	 */
	_rotateTo: function (x, y, z) {
		var entBox2d = this._box2dBody;

		// Call the original method
		this._rotateToProto(x, y, z);

		// Check if the entity has a box2d body attached
		// and if so, is it updating or not
		if (entBox2d && !entBox2d.updating) {
			// We have an entity with a box2d definition that is
			// not currently updating so let's override the standard
			// transform op and take over

			// Translate the body
			entBox2d.SetAngle(z);
			entBox2d.SetAwake(true);
		}

		return this;
	},

	/**
	 * Takes over translateBy calls and processes box2d movement as well.
	 * @param x
	 * @param y
	 * @param z
	 * @private
	 */
	_rotateBy: function (x, y, z) {
		this._rotateTo(this._rotate.x + x, this._rotate.y + y, this._rotate.z + z);
	},

	/**
	 * Purely for networkDebugMode handling, ensures that an entity's transform is
	 * not taken over by the physics simulation and is instead handled by the engine.
	 * @param ctx
	 * @private
	 */
	_update: function (ctx) {
		// Call the original method
		this._updateProto(ctx);
		
		// Update the box2d body transform
		this._translateTo(this._translate.x, this._translate.y, this._translate.z);
		this._rotateTo(this._rotate.x, this._rotate.y, this._rotate.z);
		
		//IgeEntity.prototype.update.call(this, ctx);
	},

	/**
	 * If true, disabled box2d debug shape drawing for this entity.
	 * @param {Boolean} val
	 */
	box2dNoDebug: function (val) {
		if (val !== undefined) {
			this._box2dNoDebug = val;
			return this;
		}
		
		return this._box2dNoDebug;
	},

	/**
	 * Destroys the physics entity and the box2d body that
	 * is attached to it.
	 */
	destroy: function () {
		if (this._box2dBody) {
			this._b2dRef.destroyBody(this._box2dBody);
		}
		IgeEntity.prototype.destroy.call(this);
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = IgeEntityBox2d; }
/**
 * Creates a new entity with CANNON 3d physics integration.
 */
var IgeEntityCannon = IgeEntity.extend({
	classId: 'IgeEntityCannon',

	init: function () {
		IgeEntity.prototype.init.call(this);

		// Store the existing translate methods
		this._translateToProto = this.translateTo;
		this._translateByProto = this.translateBy;

		// Take over the translate methods
		this.translateTo = this._translateTo;
		this.translateBy = this._translateBy;
	},

	cannonBody: function (def) {
		if (def !== undefined) {
			this._cannonBodyDef = def;

			// Ask the cannon component to create a new body for us
			this._cannonBody = ige.cannon.createBody(this, def);

			return this;
		}

		return this._cannonBodyDef;
	},

	_translateTo: function (x, y, z) {
		var entCannon = this._cannonBody,
			scaleRatio = ige.cannon._scaleRatio;

		// Check if the entity has a cannon body attached
		// and if so, is it updating or not
		if (entCannon && !entCannon._igeUpdating) {
			// We have an entity with a cannon definition that is
			// not currently updating so let's override the standard
			// transform op and take over

			// Translate the body
			entCannon.position.x = x / scaleRatio;
			entCannon.position.y = y / scaleRatio;
			entCannon.position.z = (z + this._bounds3d.z2) / scaleRatio;
		}

		// Now call the original translate method
		this._translateToProto(x, y, z);

		return this;
	},

	_translateBy: function (x, y, z) {
		this._translateTo(this._translate.x + x, this._translate.y + y, this._translate.z + z);
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = IgeEntityCannon; }
var IgeUiDropDown = IgeUiElement.extend({
	classId: 'IgeUiDropDown',
	
	init: function () {
		var self = this;
		
		IgeUiElement.prototype.init.call(this);
		
		// Define some default styles
		if (!ige.ui.style('.IgeUiDropDownOption')) {
			ige.ui.style('.IgeUiDropDownOption', {
				backgroundColor: null
			});
			
			ige.ui.style('.IgeUiDropDownOption:hover', {
				backgroundColor: '#00b4ff',
				color: '#ffffff'
			});
		}
		
		// Set defaults
		this.borderColor('#000000');
		this.borderWidth(1);
		this.backgroundColor('#ffffff');
		this.color('#000000');
		this.width(200);
		this.height(30);
		
		this._options = [];
		this._toggleState = false;
		
		this._label = new IgeUiLabel()
			.left(0)
			.right(30)
			.top(0)
			.bottom(0)
			.mount(this);
		
		this.on('mouseUp', function () {
			// Toggle the list drop-down
			self.toggle();
		});
	},
	
	options: function (ops) {
		if (ops !== undefined) {
			this._options = ops;
			
			// Loop the options and check for a selected one
			var arrCount = ops.length;
			
			while (arrCount--) {
				if (ops[arrCount].selected) {
					// Set this option as selected
					this.selectIndex(arrCount);
					return this;
				}
			}
			
			// No item selected, select the first option
			this.selectIndex(0);
			
			return this;
		}
		
		return this;
	},
	
	addOption: function (op) {
		if (op !== undefined) {
			this._options.push(op);
			
			if (op.selected) {
				// Set this option as selected
				this.selectIndex(this._options.length - 1);
				return this;
			}
			
			// No item selected, select the first option
			this.selectIndex(0);
			
			return this;
		}
		
		return this;
	},
	
	removeAllOptions: function () {
		this._options = [];
		this.value({
			text: '',
			value: ''
		});
	},
	
	blur: function () {
		IgeUiElement.prototype.blur.call(this);
		if (this._toggleState) {
			this.toggle();
		}
	},
	
	selectIndex: function (index) {
		if (this._options[index]) {
			this.value(this._options[index]);
			this.emit('change', this.value());
		}
	},
	
	value: function (val) {
		if (val !== undefined) {
			IgeUiElement.prototype.value.call(this, val);
			this._label.value(val.text);
			return this;
		}
		
		return this._value.value;
	},

	toggle: function () {
		this._toggleState = !this._toggleState;
		
		if (this._toggleState) {
			var self = this,
				optionContainer,
				mainTop = this._bounds2d.y + 5,
				mainHeight = this._options.length * 30,
				optionTop = 0,
				i;
			
			optionContainer =new IgeUiElement()
				.id(this._id + '_options')
				.backgroundColor(this._backgroundColor)
				.borderColor(this._borderColor)
				.borderWidth(this._borderWidth)
				.top(mainTop)
				.width(this._bounds2d.x)
				.height(mainHeight)
				.mount(this);
			
			for (i = 0; i < this._options.length; i++) {
				ige.ui.style('#' + this._id + '_options_' + i, {
					color: this._color
				});
				
				new IgeUiLabel()
					.id(this._id + '_options_' + i)
					.data('optionIndex', i)
					.styleClass('IgeUiDropDownOption')
					.value(this._options[i].text)
					.top((this._bounds2d.y * i) + 1)
					.left(1)
					.width(this._bounds2d.x - 2)
					.height(this._bounds2d.y - 2)
					.allowFocus(true)
					.allowActive(true)
					.allowHover(true)
					.mouseUp(function () {
						self.selectIndex(this.data('optionIndex'));
					})
					.mount(optionContainer);
			} 
		} else {
			ige.$(this._id + '_options').destroy();
		}
	},
	
	tick: function (ctx) {
		IgeUiElement.prototype.tick.call(this, ctx);
		
		// Draw drop-down box
		ctx.fillStyle = '#cccccc';
		ctx.fillRect(Math.floor(this._bounds2d.x2) - 30, -this._bounds2d.y2 + 1, 30, this._bounds2d.y - 2);
		
		// Chevron
		ctx.strokeStyle = this._color;
		ctx.beginPath();
		ctx.moveTo(this._bounds2d.x2 - 18.5, -this._bounds2d.y2 + 14.5);
		ctx.lineTo(this._bounds2d.x2 - 14.5, 2.5);
		ctx.lineTo(this._bounds2d.x2 - 10.5, -this._bounds2d.y2 + 14.5);
		ctx.stroke();
		
		this._renderBorder(ctx);
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = IgeUiDropDown; }
var IgeUiButton = IgeUiElement.extend({
	classId: 'IgeUiButton',
	
	init: function () {
		var self = this;
		
		IgeUiElement.prototype.init.call(this);
		
		this.on('mouseDown', function () {
			if (self._autoCell) {
				// React to the mouse events
				self.cell(this._cell + 1);
				self.cacheDirty(true);
			}
		});
		
		this.on('mouseUp', function () {
			if (self._autoCell) {
				// React to the mouse events
				self.cell(this._cell - 1);
				self.cacheDirty(true);
			}
		});
	},

	/**
	 * Gets / sets the auto cell flag. If true the button will automatically
	 * react to being clicked on and update the texture cell to +1 when mousedown
	 * and -1 when mouseup allowing you to define cell sheets of button graphics
	 * with the up-state on cell 1 and the down-state on cell 2.
	 * @param {Boolean=} val Either true or false.
	 * @returns {*}
	 */
	autoCell: function (val) {
		if (val !== undefined) {
			this._autoCell = val;
			
			if (val) {
				this.mouseEventsActive(true);
			}
			return this;
		}
		
		return this._autoCell;
	},
	
	/**
	 * Fires a mouse-down and a mouse-up event for the entity.
	 * @returns {*}
	 */
	click: function () {
		if (this._mouseDown) { this._mouseDown(); }
		if (this._mouseUp) { this._mouseUp(); }

		return this;
	},
	
	tick: function (ctx) {
		IgeUiElement.prototype.tick.call(this, ctx);
		
		// Now draw any ui overlays
		
		// Check for the old way to assign text to the button
		var uiData = this.data('ui');
		if (uiData) {
			// Draw text
			if (uiData['text']) {
				ctx.font = uiData['text'].font || "normal 12px Verdana";
				ctx.textAlign = uiData['text'].align || 'center';
				ctx.textBaseline = uiData['text'].baseline || 'middle';
				ctx.fillStyle = uiData['text'].color || '#ffffff';
				ctx.fillText(uiData['text'].value, 0, 0);
			}
		}
		
		// Check for the new way to assign text to the button
		if (this._value) {
			// Draw text
			ctx.textAlign = 'center';
			ctx.textBaseline = 'middle';
			ctx.fillStyle = this._color;
			ctx.fillText(this._value, 0, 0);
		}
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = IgeUiButton; }
var IgeUiRadioButton = IgeUiButton.extend({
	classId: 'IgeUiRadioButton',

	radioGroup: function (val) {
		if (val !== undefined) {
			this._uiRadioGroup = val;
			return this;
		}

		return this._uiRadioGroup;
	},

	select: function (val) {
		if (val !== undefined) {
			this._uiOnSelect = val;
			return this;
		}

		if (this._parent) {
			// Loop the parent object's children, find any
			// radio buttons that belong to this radio group
			// and then deselect them
			var arr = this._parent._children,
				arrCount = arr.length,
				item;

			while (arrCount--) {
				item = arr[arrCount];
				if (item !== this) {
					if (item._uiRadioGroup === this._uiRadioGroup) {
						// The item is part of the same radio group!
						if (item._uiSelected) {
							// The item is selected so un-select it!
							item._uiSelected = false;

							// Fire the item's onDeSelect method
							if (item._uiOnDeSelect) {
								item._uiOnDeSelect();
							}
						}
					}
				}
			}
		}

		// Now set this item as selected
		this._uiSelected = true;

		// Fire this item's onSelect method
		if (this._uiOnSelect) {
			this._uiOnSelect();
		}

		return this;
	},

	deSelect: function (val) {
		if (val !== undefined) {
			this._uiOnDeSelect = val;
			return this;
		}

		this._uiSelected = false;

		if (this._uiOnDeSelect) {
			this._uiOnDeSelect();
		}

		return this;
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = IgeUiRadioButton; }
// TODO: Document this class
var IgeUiProgressBar = IgeUiElement.extend({
	classId: 'IgeUiProgressBar',

	init: function () {
		IgeUiElement.prototype.init.call(this);

		// Set some defaults
		this._min = 0;
		this._max = 100;
		this._progress = 0;
		this._barColor = '#fff600';
		this._barText = {
			pre: '',
			post: '',
			color: ''
		};
	},

	barBackColor: function (val) {
		if (val !== undefined) {
			this._barBackColor = val;
			return this;
		}

		return this._barBackColor;
	},

	barColor: function (val) {
		if (val !== undefined) {
			this._barColor = val;
			return this;
		}

		return this._barColor;
	},

	barBorderColor: function (val) {
		if (val !== undefined) {
			this._barBorderColor = val;
			return this;
		}

		return this._barBorderColor;
	},

	barText: function (pre, post, color) {
		if (pre !== undefined && post !== undefined && color !== undefined) {
			this._barText = {
				pre: pre,
				post: post,
				color: color
			};
			return this;
		}

		return this._barText;
	},
	
	min: function (val) {
		if (val !== undefined) {
			this._min = val;
			return this;
		}

		return this._min;
	},

	max: function (val) {
		if (val !== undefined) {
			this._max = val;
			return this;
		}

		return this._max;
	},

	progress: function (val) {
		if (val !== undefined) {
			if (val < this._min) {
				val = this._min;
			}

			if (val > this._max) {
				val = this._max;
			}

			this._progress = val;
			return this;
		}

		return this._progress;
	},

	bindData: function (obj, propName) {
		if (obj !== undefined && propName !== undefined) {
			// Set the object and property to automatically
			// track progress from
			this._bindDataObject = obj;
			this._bindDataProperty = propName;
		}

		return this;
	},

	render: function (ctx) {
		// Check for an auto-progress update
		if (this._bindDataObject && this._bindDataProperty) {
			if (this._bindDataObject._alive === false) {
				// The object we have bind data from has been
				// destroyed so release our reference to it!
				delete this._bindDataObject;
			} else {
				this.progress(parseInt(this._bindDataObject[this._bindDataProperty]));
			}
		}

		var min = this._min,
			max = this._max,
			progress = this._progress,
			interval = this._bounds2d.x / (max - min),
			barWidth = (progress - min) * interval;

		// Check the value is not out of range
		if (progress > max) {
			progress = max;
		}

		if (progress < min) {
			progress = min;
		}

		// Draw bar fill
		if (this._barBackColor) {
			ctx.fillStyle = this._barBackColor;
			ctx.fillRect(-this._bounds2d.x2, -this._bounds2d.y2, this._bounds2d.x, this._bounds2d.y);
		}

		// Draw bar
		if (this._barColor) {
			ctx.fillStyle = this._barColor;
			ctx.fillRect(-this._bounds2d.x2, -this._bounds2d.y2, barWidth, this._bounds2d.y);
		}

		// Draw bar border
		if (this._barBorderColor) {
			ctx.strokeStyle = this._barBorderColor;
			ctx.strokeRect(-this._bounds2d.x2, -this._bounds2d.y2, this._bounds2d.x, this._bounds2d.y);
		}

		// Draw bar text centered
		if (this._barText && (this._barText.pre || this._barText.post)) {
			ctx.textAlign = 'center';
			ctx.textBaseline = 'middle';

			ctx.fillStyle = this._barText.color;
			ctx.fillText(this._barText.pre + String(Math.floor(progress)) + this._barText.post, 0, 0);
		}
	},

	tick: function (ctx) {
		this._transformContext(ctx);
		this.render(ctx);
		IgeUiElement.prototype.tick.call(this, ctx, true);
	}
});
/**
 * Provides a UI text entry box. When provided with focus this UI entity will
 * capture keyboard input and display it, similar in usage to the HTML input
 * text element.
 */
//TODO: Make cursor a text entry cursor on hover
var IgeUiTextBox = IgeUiElement.extend({
	classId: 'IgeUiTextBox',

	/**
	 * @constructor
	 */
	init: function () {
		IgeUiElement.prototype.init.call(this);

		var self = this;

		this._value = '';
		this._caretStart = 0;
		this._caretEnd = 0;

		this._fontEntity = new IgeFontEntity()
			.left(5)
			.middle(0)
			.textAlignX(0)
			.textAlignY(0)
			.mount(this);
		
		var blurFunc = function () {
			if (self._domElement) {
				self._domElement.parentNode.removeChild(self._domElement);
				delete self._domElement;
			}
		};
		
		var focusFunc = function () {
			ige.input.stopPropagation();
			blurFunc();
			
			var input,
				body,
				entScreenPos = self.screenPosition();
			
			input = document.createElement('input');
			input.setAttribute('type', 'text');
			
			// Position the infobox and set content
			input.style.position = 'absolute';
			input.style.top = (entScreenPos.y - self._bounds2d.y2) + 'px';
			input.style.left = (entScreenPos.x - self._bounds2d.x2) + 'px';
			input.style.width = self._bounds2d.x + 'px';
			input.style.zIndex = -1;
			input.style.opacity = '0';
			
			body = document.getElementsByTagName('body')[0];
			
			body.appendChild(input);
			input.focus();
			
			// Now add the existing text to the box
			input.setAttribute('value', self._value);
			
			// Set the caret position
			input.selectionStart = self._value.length;
			input.selectionEnd = self._value.length;
			
			self._caretStart = self._value.length;
			self._caretEnd = self._value.length;
			
			// Listen for events from the temp input element
			input.addEventListener('keyup', function (event) {
				self.value(this.value);
				
				if (event.keyCode === 13) {
					// Enter pressed
					self.emit('enter', self._value);
				}
			});
			
			input.addEventListener('keydown', function (event) {
				self.value(this.value);
			});
			
			input.addEventListener('mouseup', function (event) {
				self._caretStart = this.selectionStart;
				self._caretEnd = this.selectionEnd;
			});
			
			input.addEventListener('blur', function (event) {
				this.focus();
			});
			
			self._domElement = input;
		};
		
		// On focus, create a temp input element in the DOM and focus to it
		this.on('focus', focusFunc);
		this.on('mouseUp', focusFunc);
		this.on('mouseDown', function () { ige.input.stopPropagation(); });
		
		this.on('uiUpdate', function () {
			if (self._domElement) {
				// Update the transformation matrix
				self.updateTransform();
				
				var input = self._domElement,
					entScreenPos = self.screenPosition();
				
				// Reposition the dom element
				input.style.top = (entScreenPos.y - self._bounds2d.y2) + 'px';
				input.style.left = (entScreenPos.x - self._bounds2d.x2) + 'px';
			}
		});
		
		this.on('blur', blurFunc);
	},

	/**
	 * Extended method to auto-update the width of the child
	 * font entity automatically to fill the text box.
	 * @param px
	 * @param lockAspect
	 * @param modifier
	 * @param noUpdate
	 * @return {*}
	 */
	width: function (px, lockAspect, modifier, noUpdate) {
		var val;

		// Call the main super class method
		val = IgeUiElement.prototype.width.call(this, px, lockAspect, modifier, noUpdate);

		// Update the font entity width - 10px for margin
		this._fontEntity.width(px - 10, lockAspect, modifier, noUpdate);

		return val;
	},

	/**
	 * Extended method to auto-update the height of the child
	 * font entity automatically to fill the text box.
	 * @param px
	 * @param lockAspect
	 * @param modifier
	 * @param noUpdate
	 * @return {*}
	 */
	height: function (px, lockAspect, modifier, noUpdate) {
		var val;

		// Call the main super class method
		val = IgeUiElement.prototype.height.call(this, px, lockAspect, modifier, noUpdate);

		// Update the font entity height
		this._fontEntity.height(px, lockAspect, modifier, noUpdate);

		return val;
	},

	/**
	 * Gets / sets the text value of the input box.
	 * @param {String=} val The text value.
	 * @return {*}
	 */
	value: function (val) {
		if (val !== undefined) {
			if (this._value !== val) {
				this._value = val;
	
				if (!val && this._placeHolder) {
					// Assign placeholder text and color
					this._fontEntity.text(this._placeHolder);
					this._fontEntity.color(this._placeHolderColor);
				} else {
					// Set the text of the font entity to the value
					if (!this._mask) {
						// Assign text directly
						this._fontEntity.text(this._value);
					} else {
						// Assign a mask value instead
						this._fontEntity.text(new Array(this._value.length + 1).join(this._mask))
					}
					this._fontEntity.color(this._color);
				}
				
				this.emit('change', this._value);
			}
			return this;
		}

		return this._value;
	},
	
	placeHolder: function (val) {
		if (val !== undefined) {
			this._placeHolder = val;
			return this;
		}
		
		return this._placeHolder;
	},
	
	placeHolderColor: function (val) {
		if (val !== undefined) {
			this._placeHolderColor = val;
			return this;
		}
		
		return this._placeHolderColor;
	},
	
	mask: function (val) {
		if (val !== undefined) {
			this._mask = val;
			return this;
		}
		
		return this._mask;
	},

	/**
	 * Gets / sets the font sheet (texture) that the text box will
	 * use when rendering text inside the box.
	 * @param fontSheet
	 * @return {*}
	 */
	fontSheet: function (fontSheet) {
		if (fontSheet !== undefined) {
			this._fontSheet = fontSheet;

			// Set the font sheet as the texture for our font entity
			this._fontEntity.texture(this._fontSheet);
			return this;
		}

		return this._fontSheet;
	},
	
	font: function (val) {
		if (val !== undefined) {
			if (typeof(val) === 'string') {
				// Native font name
				return this.nativeFont(val);
			} else {
				// Font sheet
				return this.fontSheet(val);
			}
		}
		
		if (this._fontEntity._nativeMode) {
			// Return native font
			return this.nativeFont();
		} else {
			// Return font sheet
			return this.fontSheet();
		}
	},
	
	nativeFont: function (val) {
		if (val !== undefined) {
			this._fontEntity.nativeFont(val);
			return this;
		}
		
		return this._fontEntity.nativeFont();
	},
	
	nativeStroke: function (val) {
		if (val !== undefined) {
			this._fontEntity.nativeStroke(val);
			return this;
		}
		
		return this._fontEntity.nativeStroke();
	},
	
	nativeStrokeColor: function (val) {
		if (val !== undefined) {
			this._fontEntity.nativeStrokeColor(val);
			return this;
		}
		
		return this._fontEntity.nativeStrokeColor();
	},
	
	color: function (val) {
		if (val !== undefined) {
			this._color = val;
			
			if (!this._value && this._placeHolder && this._placeHolderColor) {
				this._fontEntity.color(this._placeHolderColor);
			} else {
				this._fontEntity.color(val);
			}
			return this;
		}
		
		return this._color;
	},
	
	_mounted: function () {
		// Check if we have a text value
		if (!this._value && this._placeHolder) {
			// Assign placeholder text and color
			this._fontEntity.text(this._placeHolder);
			this._fontEntity.color(this._placeHolderColor);
		}
		
		IgeUiElement.prototype._mounted.call(this);
	},

	destroy: function () {
		/* The 'blur' function is called to destroy the DOM textbox. */
		this.blur();
		IgeUiElement.prototype.destroy.call(this);
	}
});
/**
 * Provides a UI label entity. Basic on-screen text label.
 */
var IgeUiLabel = IgeUiElement.extend({
	classId: 'IgeUiLabel',

	/**
	 * @constructor
	 */
	init: function () {
		IgeUiElement.prototype.init.call(this);

		var self = this;

		this._value = '';

		this._fontEntity = new IgeFontEntity()
			.left(0)
			.middle(0)
			.textAlignX(0)
			.textAlignY(0)
			.mount(this);
		
		// Set defaults
		this.font('10px Verdana');
		this.paddingLeft(5);
		this.allowActive(false);
		this.allowFocus(false);
		this.allowHover(false);
	},

	/**
	 * Extended method to auto-update the width of the child
	 * font entity automatically to fill the text box.
	 * @param px
	 * @param lockAspect
	 * @param modifier
	 * @param noUpdate
	 * @return {*}
	 */
	width: function (px, lockAspect, modifier, noUpdate) {
		var val;

		// Call the main super class method
		val = IgeUiElement.prototype.width.call(this, px, lockAspect, modifier, noUpdate);

		// Update the font entity width - 10px for margin
		this._fontEntity.width(px - 10, lockAspect, modifier, noUpdate);

		return val;
	},

	/**
	 * Extended method to auto-update the height of the child
	 * font entity automatically to fill the text box.
	 * @param px
	 * @param lockAspect
	 * @param modifier
	 * @param noUpdate
	 * @return {*}
	 */
	height: function (px, lockAspect, modifier, noUpdate) {
		var val;

		// Call the main super class method
		val = IgeUiElement.prototype.height.call(this, px, lockAspect, modifier, noUpdate);

		// Update the font entity height
		this._fontEntity.height(px, lockAspect, modifier, noUpdate);

		return val;
	},

	/**
	 * Gets / sets the text value of the input box.
	 * @param {String=} val The text value.
	 * @return {*}
	 */
	value: function (val) {
		if (val !== undefined) {
			if (this._value !== val) {
				this._value = val;
	
				if (!val && this._placeHolder) {
					// Assign placeholder text and color
					this._fontEntity.text(this._placeHolder);
					this._fontEntity.color(this._placeHolderColor);
				} else {
					// Set the text of the font entity to the value
					if (!this._mask) {
						// Assign text directly
						this._fontEntity.text(this._value);
					} else {
						// Assign a mask value instead
						this._fontEntity.text(new Array(this._value.length + 1).join(this._mask))
					}
					this._fontEntity.color(this._color);
				}
				
				this.emit('change', this._value);
			}
			return this;
		}

		return this._value;
	},
	
	/**
	 * Gets / sets the font sheet (texture) that the text box will
	 * use when rendering text inside the box.
	 * @param fontSheet
	 * @return {*}
	 */
	fontSheet: function (fontSheet) {
		if (fontSheet !== undefined) {
			this._fontSheet = fontSheet;

			// Set the font sheet as the texture for our font entity
			this._fontEntity.texture(this._fontSheet);
			return this;
		}

		return this._fontSheet;
	},
	
	font: function (val) {
		if (val !== undefined) {
			if (typeof(val) === 'string') {
				// Native font name
				return this.nativeFont(val);
			} else {
				// Font sheet
				return this.fontSheet(val);
			}
		}
		
		if (this._fontEntity._nativeMode) {
			// Return native font
			return this.nativeFont();
		} else {
			// Return font sheet
			return this.fontSheet();
		}
	},
	
	nativeFont: function (val) {
		if (val !== undefined) {
			this._fontEntity.nativeFont(val);
			return this;
		}
		
		return this._fontEntity.nativeFont();
	},
	
	nativeStroke: function (val) {
		if (val !== undefined) {
			this._fontEntity.nativeStroke(val);
			return this;
		}
		
		return this._fontEntity.nativeStroke();
	},
	
	nativeStrokeColor: function (val) {
		if (val !== undefined) {
			this._fontEntity.nativeStrokeColor(val);
			return this;
		}
		
		return this._fontEntity.nativeStrokeColor();
	},
	
	color: function (val) {
		if (val !== undefined) {
			this._color = val;
			
			if (!this._value && this._placeHolder && this._placeHolderColor) {
				this._fontEntity.color(this._placeHolderColor);
			} else {
				this._fontEntity.color(val);
			}
			return this;
		}
		
		return this._color;
	},
	
	_mounted: function () {
		// Check if we have a text value
		if (!this._value && this._placeHolder) {
			// Assign placeholder text and color
			this._fontEntity.text(this._placeHolder);
			this._fontEntity.color(this._placeHolderColor);
		}
		
		IgeUiElement.prototype._mounted.call(this);
	}
});
/**
 * Provides a UI tooltip. Change properties (textBox, fonts, backgroundcolor)
 * at free will.
 */
var IgeUiTooltip = IgeUiElement.extend({
	classId: 'IgeUiTooltip',

	/**
	 * @constructor
	 * @param parent Where the mousemove is captured i.e. on which element the tooltip should appear
	 * @param mountEntity Where the tooltip should be mounted. A scene is suggested.
	 * @param width Width of the tooltip
	 * @param height Height of the tooltip
	 * @param content The content which is set with public method "setContent". Can be string, array(2) or an entity
	 */
	init: function (parent, mountEntity, width, height, content) {
		IgeUiElement.prototype.init.call(this);

		var self = this;
		this.titleBox = new IgeUiElement()
			.left(0)
			.top(0)
			.width(width)
			.height(30)
			.mount(this);
		this.titleBox.borderBottomColor('#ffffff');
		this.titleBox.borderBottomWidth(1);
		
		this.textBox = new IgeUiElement()
			.left(0)
			.top(30)
			.width(width)
			.height(height - 30)
			.mount(this);
		
		this.fontEntityTitle = new IgeFontEntity()
			.left(5)
			.top(-4)
			.textAlignX(0)
			.textAlignY(0)
			.nativeFont('10pt Arial')
			.textLineSpacing(-5)
			.mount(this.titleBox);
			
		this.fontEntityText = new IgeFontEntity()
			.left(5)
			.top(0)
			.textAlignX(0)
			.textAlignY(0)
			.nativeFont('10pt Arial')
			.textLineSpacing(-5)
			.mount(this.textBox);
			
		this.setContent(content);
		this.hide();
		this._mountEntity = mountEntity;
		this.mount(mountEntity);
		this.backgroundColor('#53B2F3');
		this.depth(10000);
		this.translateTo(parent._translate.x, parent._translate.y, parent._translate.z);
		this.width(width);
		this.height(height);
		
		parent._tooltip = this;

		// Listen for keyboard events to capture text input
		parent._mouseEventsActive = true;
		parent.on('mouseMove', self._mousemove);
		parent.on('mouseOut', self._mouseout);
		
		return this;
	},

	/**
	 * Extended method to auto-update the width of the child
	 * font entity automatically to fill the text box.
	 * @param px
	 * @param lockAspect
	 * @param modifier
	 * @param noUpdate
	 * @return {*}
	 */
	width: function (px, lockAspect, modifier, noUpdate) {
		var val;

		// Call the main super class method
		val = IgeUiElement.prototype.width.call(this, px, lockAspect, modifier, noUpdate);

		// Update the font entity width
		this.fontEntityTitle.width(px, lockAspect, modifier, noUpdate);
		this.fontEntityText.width(px, lockAspect, modifier, noUpdate);

		return val;
	},

	/**
	 * Extended method to auto-update the height of the child
	 * font entity automatically to fill the text box.
	 * @param px
	 * @param lockAspect
	 * @param modifier
	 * @param noUpdate
	 * @return {*}
	 */
	height: function (px, lockAspect, modifier, noUpdate) {
		var val;

		// Call the main super class method
		val = IgeUiElement.prototype.height.call(this, px, lockAspect, modifier, noUpdate);

		// Update the font entity height
		this.fontEntityTitle.width(px, lockAspect, modifier, noUpdate);
		this.fontEntityText.width(px, lockAspect, modifier, noUpdate);

		return val;
	},

	/**
	 * Sets the content of the tooltip. Can be a string for
	 * simple text, an array with two strings for text and title
	 * or a whole entity
	 * @param val The content, be it string, array(2) or an entity
	 * @return {*}
	 */
	setContent: function (val) {
		if (val !== undefined) {
			this.titleBox.unMount();
			this.textBox.unMount();
			this._children.forEach(function(child) {
				child.unMount();
				child.destroy();
			});
			if (typeof(val) == 'string') {
				this.textBox.mount(this);
				this.textBox.height(this._bounds2d.y);
				this.textBox.top(0);
				// Set the text of the font entity to the value
				this.fontEntityText.text(this._value);
			}
			else if (typeof(val) == 'object' && typeof(val[0] == 'string') && typeof(val[1] == 'string')) {
				this.titleBox.mount(this);
				this.textBox.mount(this);
				this.textBox.height(this._bounds2d.y - this.titleBox._bounds2d.y);
				this.textBox.top(this.titleBox._bounds2d.y);
				//title + text
				this.fontEntityTitle.text(val[0]);
				this.fontEntityText.text(val[1]);
			}
			else if (typeof(val) == 'object') {
				val.mount(this);
			}
			this.updateUiChildren();
		}

		return this;
	},

	/**
	 * Gets / sets the font sheet (texture) that the text box will
	 * use when rendering text inside the box.
	 * @param fontSheet
	 * @return {*}
	 */
	fontSheet: function (fontSheet) {
		if (fontSheet !== undefined) {
			// Set the font sheet as the texture for our font entity
			this.fontEntityTitle.texture(fontSheet);
			this.fontEntityText.texture(fontSheet);
		}
		return this;
	},

	/**
	 * Handles mousemove event to show the textbox and adjust its
	 * position according to the mouse position
	 * @param event
	 * @private
	 */
	_mousemove: function (event) {
		var tt = this._tooltip;
		if (tt._hidden) tt.show();
		var mountPos = tt._mountEntity.worldPosition();
		tt.translateTo(event.igeX - mountPos.x + tt._bounds2d.x2 + 10, event.igeY - mountPos.y + tt._bounds2d.y2, 0);
		tt.updateUiChildren();
	},

	/**
	 * Handles mouseout event to hide the tooltip
	 * @param event
	 * @private
	 */
	_mouseout: function (event) {
		this._tooltip.hide();
	}
});
/**
 * Provides a UI drop-down menu entity.
 */
var IgeUiMenu = IgeUiElement.extend({
	classId: 'IgeUiMenu',

	/**
	 * Gets / sets the menu definition.
	 * @param {Object=} val The menu definition object.
	 * @return {*}
	 */
	menuData: function (val) {
		if (val !== undefined) {
			this._menuData = val;

			// Remove all existing children from the menu
			this.destroyChildren();

			// Build the new menu
			this._buildMenu(this._menuData, this);
			return this;
		}

		return this._menuData;
	},

	menuMode: function (mode) {
		if (mode !== undefined) {
			this._menuMode = mode;
			return this;
		}

		return this._menuMode;
	},

	/**
	 * Gets / sets the font sheet (texture) that the text box will
	 * use when rendering text inside the box.
	 * @param fontSheet
	 * @return {*}
	 */
	fontSheet: function (fontSheet) {
		if (fontSheet !== undefined) {
			this._fontSheet = fontSheet;
			return this;
		}

		return this._fontSheet;
	},

	addItem: function (item) {
		if (item !== undefined) {
			
		}
	},

	_buildMenu: function (data, parent) {
		var arrCount = data.length, i,
			item, ent, left = 0, top = 0;

		for (i = 0; i < arrCount; i++) {
			item = data[i];

			if (this._menuMode) {
				top += this.height();
			}

			ent = new IgeUiMenuItem()
				.backgroundColor('#666666')
				.left(left)
				.middle(top)
				.height(this.height())
				.fontSheet(this._fontSheet)
				.menuData(item)
				.mount(parent);

			if (!this._menuMode) {
				left += item.width;
			}
		}
	}
});

var IgeUiMenuItem = IgeUiElement.extend({
	classId: 'IgeUiMenuItem',

	menuData: function (menuData) {
		if (menuData !== undefined) {
			this._menuData = menuData;

			if (menuData.width) { this.width(menuData.width); }
			if (menuData.id) { this.id(menuData.id); }
			if (menuData.mouseUp) { this.mouseUp(menuData.mouseUp); }
			if (menuData.mouseOver) { this.mouseOver(menuData.mouseOver); }
			if (menuData.mouseOut) { this.mouseOut(menuData.mouseOut); }

			this._labelEntity = new IgeFontEntity()
				.id(this.id() + '_label')
				.texture(this._fontSheet)
				.left(5)
				.middle(0)
				.width(menuData.width)
				.height(this.height())
				.textAlignX(0)
				.textAlignY(1)
				.text(menuData.text)
				.mount(this);

			return this;
		}

		return this._menuData;
	},

	/**
	 * Gets / sets the font sheet (texture) that the menu item will
	 * use when rendering text.
	 * @param fontSheet
	 * @return {*}
	 */
	fontSheet: function (fontSheet) {
		if (fontSheet !== undefined) {
			this._fontSheet = fontSheet;
			return this;
		}

		return this._fontSheet;
	},

	/**
	 * Opens the menu item so it's child items are visible.
	 */
	open: function () {
		if (this._menuData.items) {
			this._childMenu = new IgeUiMenu()
				.id(this.id() + '_childMenu')
				.depth(this.depth() + 1)
				.fontSheet(this._fontSheet)
				.left(0)
				.top(this.height())
				.width(100)
				.height(30)
				.menuMode(1)
				.menuData(this._menuData.items)
				.mount(this);
		}
	},

	/**
	 * Closes the menu item so it's child items are hidden.
	 */
	close: function () {
		if (this._childMenu) {
			this._childMenu.destroy();
		}
	}
});
var IgeUiTimeStream = IgeUiElement.extend({
	classId: 'IgeUiTimeStream',

	monitor: function (entity) {
		this._entity = entity;
	},

	tick: function (ctx) {
		// Draw timeline
		var i, text, xAdjust,
			arr, arrCount, arrItem,
			renderTime = ige._tickStart - ige.network.stream._renderLatency,
			deltaTime;

		IgeUiElement.prototype.tick.call(this, ctx);

		ctx.strokeStyle = '#fffc00';
		ctx.beginPath();
		ctx.moveTo(-200, -25.5);
		ctx.lineTo(200, -25.5);
		ctx.stroke();

		ctx.font = 'normal 10px Verdana';

		for (i = 0; i < 9; i++) {
			ctx.beginPath();
			if (((i - 2) * 10) === 0) {
				// This is the render point, change colour for this one
				ctx.strokeStyle = '#ff6600';
			} else {
				ctx.strokeStyle = '#ffffff';
			}
			ctx.moveTo(-200.5 + (i * 50), -30);
			ctx.lineTo(-200.5 + (i * 50), 30);
			ctx.stroke();

			text = -ige.network.stream._renderLatency + ((i - 2) * 10) + 'ms';
			xAdjust = ctx.measureText(text);
			ctx.strokeText(text, -200 + (i * 50) - (xAdjust.width / 2), -38);

			if (((i - 2) * 10) === 0) {
				text = 'Render Point';
				xAdjust = ctx.measureText(text);
				ctx.strokeText(text, -200 + (i * 50) - (xAdjust.width / 2), -52);
			}
		}

		if (this._entity) {
			arr = this._entity._timeStream;

			// Check if we have a time stream and data
			if (arr && arr.length) {
				arrCount = arr.length;

				for (i = 0; i < arrCount; i++) {
					arrItem = arr[i];

					deltaTime = arrItem[0] - renderTime;

					ctx.strokeRect(-105 + ((deltaTime / 10) * 50), -5, 10, 10);
				}
			}

			ige.client.custom2.value = this._entity._timeStreamDataDelta;
			ige.client.custom3.value = this._entity._timeStreamOffsetDelta;
			ige.client.custom4.value = this._entity._timeStreamCurrentInterpolateTime;
		}
	}
});

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = IgeUiTimeStream; }
// See the ige/engine/filters folder for the individual filter source
var IgeFilters = {};

if (typeof(window) !== 'undefined') {
	// Create a temporary canvas for the filter system to use
	IgeFilters.tmpCanvas = document.createElement('canvas');
	IgeFilters.tmpCtx = IgeFilters.tmpCanvas.getContext('2d');
}

if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = IgeFilters; }
IgeFilters.createImageData = function(w,h) {
	return IgeFilters.tmpCtx.createImageData(w,h);
};

IgeFilters._convolute = function(pixels, weights, opaque) {
	var side = Math.round(Math.sqrt(weights.length));
	var halfSide = Math.floor(side/2);
	var src = pixels.data;
	var sw = pixels.width;
	var sh = pixels.height;
	// pad output by the convolution matrix
	var w = sw;
	var h = sh;
	var output = IgeFilters.createImageData(w, h);
	var dst = output.data;
	// go through the destination image pixels
	var alphaFac = opaque ? 1 : 0;
	for (var y=0; y<h; y++) {
		for (var x=0; x<w; x++) {
			var sy = y;
			var sx = x;
			var dstOff = (y*w+x)*4;
			// calculate the weighed sum of the source image pixels that
			// fall under the convolution matrix
			var r=0, g=0, b=0, a=0;
			for (var cy=0; cy<side; cy++) {
				for (var cx=0; cx<side; cx++) {
					var scy = sy + cy - halfSide;
					var scx = sx + cx - halfSide;
					if (scy >= 0 && scy < sh && scx >= 0 && scx < sw) {
						var srcOff = (scy*sw+scx)*4;
						var wt = weights[cy*side+cx];
						r += src[srcOff] * wt;
						g += src[srcOff+1] * wt;
						b += src[srcOff+2] * wt;
						a += src[srcOff+3] * wt;
					}
				}
			}
			dst[dstOff] = r;
			dst[dstOff+1] = g;
			dst[dstOff+2] = b;
			dst[dstOff+3] = a + alphaFac*(255-a);
		}
	}
	return output;
};
IgeFilters.greyScale = function (canvas, ctx, originalImage, texture, data) {
	// Apply the filter and then put the new pixel data
	ctx.putImageData(
		IgeFilters._greyScale(
			ctx.getImageData(
				0,
				0,
				canvas.width,
				canvas.height
			)
		),
		0,
		0
	);
};

IgeFilters._greyScale = function (imageData) {
	var arr,
		arrCount,
		i, r, g, b, v;

	arr = imageData.data;
	arrCount = arr.length;

	for (i = 0; i < arrCount; i += 4) {
		// Extract pixel colour values
		r = arr[i];
		g = arr[i + 1];
		b = arr[i + 2];

		// CIE luminance for the RGB
		// The human eye is bad at seeing red and blue, so we de-emphasize them.
		v = 0.2126*r + 0.7152*g + 0.0722*b;

		// Set the new pixel colour value
		arr[i] = arr[i + 1] = arr[i + 2] = v;
	}

	return imageData;
};
IgeFilters.brighten = function (canvas, ctx, originalImage, texture, data) {
	// Apply the filter and then put the new pixel data
	ctx.putImageData(
		IgeFilters._brighten(
			ctx.getImageData(
				0,
				0,
				canvas.width,
				canvas.height
			),
			texture,
			data
		),
		0,
		0
	);
};

IgeFilters._brighten = function (imageData, texture, data) {
	var arr,
		arrCount,
		i, adjustment = texture.data('IgeFilters.brighten.value') || data.value;

	arr = imageData.data;
	arrCount = arr.length;

	for (i = 0; i < arrCount; i += 4) {
		arr[i] += adjustment;
		arr[i + 1] += adjustment;
		arr[i + 2] += adjustment;
	}

	return imageData;
};
IgeFilters.threshold = function (canvas, ctx, originalImage, texture, data) {
	// Apply the filter and then put the new pixel data
	ctx.putImageData(
		IgeFilters._threshold(
			ctx.getImageData(
				0,
				0,
				canvas.width,
				canvas.height
			),
			texture,
			data
		),
		0,
		0
	);
};

IgeFilters._threshold = function (imageData, texture, data) {
	var arr,
		arrCount,
		i, r, g, b, v,
		threshold = texture.data('IgeFilters.threshold.value') || data.value;

	arr = imageData.data;
	arrCount = arr.length;

	for (i = 0; i < arrCount; i += 4) {
		r = arr[i];
		g = arr[i+1];
		b = arr[i+2];
		v = (0.2126*r + 0.7152*g + 0.0722*b >= threshold) ? 255 : 0;
		arr[i] = arr[i+1] = arr[i+2] = v;
	}

	return imageData;
};
IgeFilters.sharpen = function (canvas, ctx, originalImage, texture, data) {		
	var strength = 1,
		loop;

	if (data && data.value) {
		strength = data.value;
	}

	for (loop = 0; loop < strength; loop++) {
		// Apply the filter and then put the new pixel data
		ctx.putImageData(
			IgeFilters._convolute(
				ctx.getImageData(
					0,
					0,
					canvas.width,
					canvas.height
				),
				[  0, -1,  0,
					-1,  5, -1,
					0, -1,  0 ]
			),
			0,
			0
		);
	}
};
IgeFilters.blur = function (canvas, ctx, originalImage, texture, data) {
	var strength = 1,
		loop,
		oneNinth = 1 / 9,
		pixelData;

	pixelData = ctx.getImageData(
		0,
		0,
		canvas.width,
		canvas.height
	);

	if (data && data.value) {
		strength = data.value;
	}

	for (loop = 0; loop < strength; loop++) {
		pixelData = IgeFilters._convolute(
			pixelData,
			[
				oneNinth, oneNinth, oneNinth,
				oneNinth, oneNinth, oneNinth,
				oneNinth, oneNinth, oneNinth
			]
		);
	}

	// Put the new pixel data
	ctx.putImageData(
		pixelData,
		0,
		0
	);
};
IgeFilters.emboss = function (canvas, ctx, originalImage, texture, data) {
	// Apply the filter and then put the new pixel data
	ctx.putImageData(
		IgeFilters._convolute(
			ctx.getImageData(
				0,
				0,
				canvas.width,
				canvas.height
			),
			[
				-2, -1, 0,
				-1,  1, 1,
				0, 1, 2
			]
		),
		0,
		0
	);
};
IgeFilters.edgeDetect = function (canvas, ctx, originalImage, texture, data) {
	if (!texture._filterImageDrawn || !data || !data.cumulative) {
		ctx.clearRect(0, 0, canvas.width, canvas.height);
		ctx.drawImage(originalImage, 0, 0);
		texture._filterImageDrawn = true;
	}

	var newData = IgeFilters._convolute(
			ctx.getImageData(
				0,
				0,
				canvas.width,
				canvas.height
			),
			[
				-1,	-1,	-1,	-1,	-1,
				-1,	2,	2,	2,	-1,
				-1,	2,	0,	2,	-1,
				-1,	2,	2,	2,	-1,
				-1,	-1,	-1,	-1,	-1
			],
			true
		),
		arr = newData.data,
		arrCount = arr.length,
		i, r, g, b, v;

	for (i = 0; i < arrCount; i += 4) {
		r = arr[i];
		g = arr[i+1];
		b = arr[i+2];

		v = (r + g + b) / 3;
		v *= 1.1;

		v = v >= data.value ? 255 : 0;

		arr[i] = arr[i+1] = arr[i+2] = v;
	}

	// Apply the filter and then put the new pixel data
	ctx.putImageData(
		newData,
		0,
		0
	);
};
IgeFilters.edgeEnhance = function (canvas, ctx, originalImage, texture, data) {
	if (!texture._filterImageDrawn || !data || !data.cumulative) {
		ctx.clearRect(0, 0, canvas.width, canvas.height);
		ctx.drawImage(originalImage, 0, 0);
		texture._filterImageDrawn = true;
	}

	// Apply the filter and then put the new pixel data
	ctx.putImageData(
		IgeFilters._convolute(
			ctx.getImageData(
				0,
				0,
				canvas.width,
				canvas.height
			),
			[
				0, 0, 0,
				-1,  1, 0,
				0, 0, 0
			],
			true
		),
		0,
		0
	);
};
IgeFilters.outlineDetect = function (canvas, ctx, originalImage, texture, data) {
	// Apply the filter and then put the new pixel data
	ctx.putImageData(
		IgeFilters._convolute(
			ctx.getImageData(
				0,
				0,
				canvas.width,
				canvas.height
			),
			[
				0, 1, 0,
				1,  -4, 1,
				0, 1, 0
			]
		),
		0,
		0
	);
};
IgeFilters.colorOverlay = function (canvas, ctx, originalImage, texture, data) {
	// Set the composite operation and draw the colour over the top
	ctx.globalCompositeOperation = 'source-atop';

	ctx.fillStyle = data.color;
	ctx.fillRect(0, 0, canvas.width, canvas.height);
};
IgeFilters.sobel = function (canvas, ctx, originalImage, texture, data) {
	var strength = 1,
		loop;

	if (data && data.value) {
		strength = data.value;
	}

	for (loop = 0; loop < strength; loop++) {
		// Apply the filter and then put the new pixel data
		ctx.putImageData(
			IgeFilters._convolute(
				ctx.getImageData(
					0,
					0,
					canvas.width,
					canvas.height
				),
				[
					-1, -1,  1,
					-2,  0, 2,
					-1, 1,  1
				],
				true
			),
			0,
			0
		);
	}

	//IgeFilters._invert(canvas, ctx);
};

IgeFilters._invert = function (canvas, ctx) {
	var w, h, canvasData, i;
	w = canvas.width;
	h = canvas.height;

	canvasData = ctx.getImageData(0, 0, w, h);

	for (i = 0; i < w * h * 4; i += 4)  {
		canvasData.data[i] = 255 - canvasData.data[i];
		canvasData.data[i+1] = 255 - canvasData.data[i+1];
		canvasData.data[i+2] = 255 - canvasData.data[i+2];
	}

	ctx.putImageData(canvasData, 0, 0);
};
IgeFilters.invert = function (canvas, ctx, originalImage, texture, data) {
	var w, h, canvasData, i;
	w = canvas.width;
	h = canvas.height;

	canvasData = ctx.getImageData(0, 0, w, h);

	for (i = 0; i < w * h * 4; i += 4)  {
		canvasData.data[i] = 255 - canvasData.data[i];
		canvasData.data[i+1] = 255 - canvasData.data[i+1];
		canvasData.data[i+2] = 255 - canvasData.data[i+2];
	}

	ctx.putImageData(canvasData, 0, 0);
};
IgeFilters.glowMask = function (canvas, ctx, originalImage, texture, data) {
	var oneNinth = 1 / 9,
		pixelData,
		tempCanvas,
		tempCtx,
		i;

	ctx.clearRect(0, 0, canvas.width, canvas.height);

	if (data.blurPasses) {
		ctx.drawImage(data.glowMask.image, 0, 0);

		pixelData = ctx.getImageData(
			0,
			0,
			canvas.width,
			canvas.height
		);

		ctx.clearRect(0, 0, canvas.width, canvas.height);

		for (i = 0; i < data.blurPasses; i++) {
			pixelData = IgeFilters._convolute(
				pixelData,
				[
					oneNinth, oneNinth,  oneNinth,
					oneNinth, oneNinth,  oneNinth,
					oneNinth, oneNinth,  oneNinth
				],
				false
			);
		}

		tempCanvas = document.createElement("canvas");
		tempCtx = tempCanvas.getContext('2d');

		tempCanvas.width = canvas.width;
		tempCanvas.height = canvas.height;

		tempCtx.putImageData(pixelData, 0, 0);
	} else {
		tempCanvas = data.glowMask.image;
	}

	ctx.drawImage(originalImage, 0, 0);

	ctx.globalCompositeOperation = "lighter";

	for (i = 0; i < data.glowPasses; i++) {
		// Apply the filter and then put the new pixel data
		ctx.drawImage(tempCanvas, 0, 0);
	}
};
// three.min.js - http://github.com/mrdoob/three.js
'use strict';var THREE=THREE||{REVISION:"52"};self.console=self.console||{info:function(){},log:function(){},debug:function(){},warn:function(){},error:function(){}};self.Int32Array=self.Int32Array||Array;self.Float32Array=self.Float32Array||Array;String.prototype.startsWith=String.prototype.startsWith||function(a){return this.slice(0,a.length)===a};String.prototype.endsWith=String.prototype.endsWith||function(a){var a=String(a),b=this.lastIndexOf(a);return(-1<b&&b)===this.length-a.length};
String.prototype.trim=String.prototype.trim||function(){return this.replace(/^\s+|\s+$/g,"")};
(function(){for(var a=0,b=["ms","moz","webkit","o"],c=0;c<b.length&&!window.requestAnimationFrame;++c)window.requestAnimationFrame=window[b[c]+"RequestAnimationFrame"],window.cancelAnimationFrame=window[b[c]+"CancelAnimationFrame"]||window[b[c]+"CancelRequestAnimationFrame"];void 0===window.requestAnimationFrame&&(window.requestAnimationFrame=function(b){var c=Date.now(),f=Math.max(0,16-(c-a)),g=window.setTimeout(function(){b(c+f)},f);a=c+f;return g});window.cancelAnimationFrame=window.cancelAnimationFrame||
function(a){window.clearTimeout(a)}})();THREE.FrontSide=0;THREE.BackSide=1;THREE.DoubleSide=2;THREE.NoShading=0;THREE.FlatShading=1;THREE.SmoothShading=2;THREE.NoColors=0;THREE.FaceColors=1;THREE.VertexColors=2;THREE.NoBlending=0;THREE.NormalBlending=1;THREE.AdditiveBlending=2;THREE.SubtractiveBlending=3;THREE.MultiplyBlending=4;THREE.CustomBlending=5;THREE.AddEquation=100;THREE.SubtractEquation=101;THREE.ReverseSubtractEquation=102;THREE.ZeroFactor=200;THREE.OneFactor=201;THREE.SrcColorFactor=202;
THREE.OneMinusSrcColorFactor=203;THREE.SrcAlphaFactor=204;THREE.OneMinusSrcAlphaFactor=205;THREE.DstAlphaFactor=206;THREE.OneMinusDstAlphaFactor=207;THREE.DstColorFactor=208;THREE.OneMinusDstColorFactor=209;THREE.SrcAlphaSaturateFactor=210;THREE.MultiplyOperation=0;THREE.MixOperation=1;THREE.UVMapping=function(){};THREE.CubeReflectionMapping=function(){};THREE.CubeRefractionMapping=function(){};THREE.SphericalReflectionMapping=function(){};THREE.SphericalRefractionMapping=function(){};
THREE.RepeatWrapping=1E3;THREE.ClampToEdgeWrapping=1001;THREE.MirroredRepeatWrapping=1002;THREE.NearestFilter=1003;THREE.NearestMipMapNearestFilter=1004;THREE.NearestMipMapLinearFilter=1005;THREE.LinearFilter=1006;THREE.LinearMipMapNearestFilter=1007;THREE.LinearMipMapLinearFilter=1008;THREE.UnsignedByteType=1009;THREE.ByteType=1010;THREE.ShortType=1011;THREE.UnsignedShortType=1012;THREE.IntType=1013;THREE.UnsignedIntType=1014;THREE.FloatType=1015;THREE.UnsignedShort4444Type=1016;
THREE.UnsignedShort5551Type=1017;THREE.UnsignedShort565Type=1018;THREE.AlphaFormat=1019;THREE.RGBFormat=1020;THREE.RGBAFormat=1021;THREE.LuminanceFormat=1022;THREE.LuminanceAlphaFormat=1023;THREE.RGB_S3TC_DXT1_Format=2001;THREE.RGBA_S3TC_DXT1_Format=2002;THREE.RGBA_S3TC_DXT3_Format=2003;THREE.RGBA_S3TC_DXT5_Format=2004;THREE.Clock=function(a){this.autoStart=void 0!==a?a:!0;this.elapsedTime=this.oldTime=this.startTime=0;this.running=!1};
THREE.Clock.prototype.start=function(){this.oldTime=this.startTime=Date.now();this.running=!0};THREE.Clock.prototype.stop=function(){this.getElapsedTime();this.running=!1};THREE.Clock.prototype.getElapsedTime=function(){return this.elapsedTime+=this.getDelta()};THREE.Clock.prototype.getDelta=function(){var a=0;this.autoStart&&!this.running&&this.start();if(this.running){var b=Date.now(),a=0.001*(b-this.oldTime);this.oldTime=b;this.elapsedTime+=a}return a};
THREE.Color=function(a){void 0!==a&&this.setHex(a);return this};
THREE.Color.prototype={constructor:THREE.Color,r:1,g:1,b:1,copy:function(a){this.r=a.r;this.g=a.g;this.b=a.b;return this},copyGammaToLinear:function(a){this.r=a.r*a.r;this.g=a.g*a.g;this.b=a.b*a.b;return this},copyLinearToGamma:function(a){this.r=Math.sqrt(a.r);this.g=Math.sqrt(a.g);this.b=Math.sqrt(a.b);return this},convertGammaToLinear:function(){var a=this.r,b=this.g,c=this.b;this.r=a*a;this.g=b*b;this.b=c*c;return this},convertLinearToGamma:function(){this.r=Math.sqrt(this.r);this.g=Math.sqrt(this.g);
this.b=Math.sqrt(this.b);return this},setRGB:function(a,b,c){this.r=a;this.g=b;this.b=c;return this},setHSV:function(a,b,c){var d,e,f;0===c?this.r=this.g=this.b=0:(d=Math.floor(6*a),e=6*a-d,a=c*(1-b),f=c*(1-b*e),b=c*(1-b*(1-e)),0===d?(this.r=c,this.g=b,this.b=a):1===d?(this.r=f,this.g=c,this.b=a):2===d?(this.r=a,this.g=c,this.b=b):3===d?(this.r=a,this.g=f,this.b=c):4===d?(this.r=b,this.g=a,this.b=c):5===d&&(this.r=c,this.g=a,this.b=f));return this},setHex:function(a){a=Math.floor(a);this.r=(a>>16&
255)/255;this.g=(a>>8&255)/255;this.b=(a&255)/255;return this},lerpSelf:function(a,b){this.r+=(a.r-this.r)*b;this.g+=(a.g-this.g)*b;this.b+=(a.b-this.b)*b;return this},getHex:function(){return 255*this.r<<16^255*this.g<<8^255*this.b<<0},getContextStyle:function(){return"rgb("+(255*this.r|0)+","+(255*this.g|0)+","+(255*this.b|0)+")"},clone:function(){return(new THREE.Color).setRGB(this.r,this.g,this.b)}};THREE.Vector2=function(a,b){this.x=a||0;this.y=b||0};
THREE.Vector2.prototype={constructor:THREE.Vector2,set:function(a,b){this.x=a;this.y=b;return this},copy:function(a){this.x=a.x;this.y=a.y;return this},add:function(a,b){this.x=a.x+b.x;this.y=a.y+b.y;return this},addSelf:function(a){this.x+=a.x;this.y+=a.y;return this},sub:function(a,b){this.x=a.x-b.x;this.y=a.y-b.y;return this},subSelf:function(a){this.x-=a.x;this.y-=a.y;return this},multiplyScalar:function(a){this.x*=a;this.y*=a;return this},divideScalar:function(a){a?(this.x/=a,this.y/=a):this.set(0,
0);return this},negate:function(){return this.multiplyScalar(-1)},dot:function(a){return this.x*a.x+this.y*a.y},lengthSq:function(){return this.x*this.x+this.y*this.y},length:function(){return Math.sqrt(this.lengthSq())},normalize:function(){return this.divideScalar(this.length())},distanceTo:function(a){return Math.sqrt(this.distanceToSquared(a))},distanceToSquared:function(a){var b=this.x-a.x,a=this.y-a.y;return b*b+a*a},setLength:function(a){return this.normalize().multiplyScalar(a)},lerpSelf:function(a,
b){this.x+=(a.x-this.x)*b;this.y+=(a.y-this.y)*b;return this},equals:function(a){return a.x===this.x&&a.y===this.y},isZero:function(a){return this.lengthSq()<(void 0!==a?a:1E-4)},clone:function(){return new THREE.Vector2(this.x,this.y)}};THREE.Vector3=function(a,b,c){this.x=a||0;this.y=b||0;this.z=c||0};
THREE.Vector3.prototype={constructor:THREE.Vector3,set:function(a,b,c){this.x=a;this.y=b;this.z=c;return this},setX:function(a){this.x=a;return this},setY:function(a){this.y=a;return this},setZ:function(a){this.z=a;return this},copy:function(a){this.x=a.x;this.y=a.y;this.z=a.z;return this},add:function(a,b){this.x=a.x+b.x;this.y=a.y+b.y;this.z=a.z+b.z;return this},addSelf:function(a){this.x+=a.x;this.y+=a.y;this.z+=a.z;return this},addScalar:function(a){this.x+=a;this.y+=a;this.z+=a;return this},
sub:function(a,b){this.x=a.x-b.x;this.y=a.y-b.y;this.z=a.z-b.z;return this},subSelf:function(a){this.x-=a.x;this.y-=a.y;this.z-=a.z;return this},multiply:function(a,b){this.x=a.x*b.x;this.y=a.y*b.y;this.z=a.z*b.z;return this},multiplySelf:function(a){this.x*=a.x;this.y*=a.y;this.z*=a.z;return this},multiplyScalar:function(a){this.x*=a;this.y*=a;this.z*=a;return this},divideSelf:function(a){this.x/=a.x;this.y/=a.y;this.z/=a.z;return this},divideScalar:function(a){a?(this.x/=a,this.y/=a,this.z/=a):
this.z=this.y=this.x=0;return this},negate:function(){return this.multiplyScalar(-1)},dot:function(a){return this.x*a.x+this.y*a.y+this.z*a.z},lengthSq:function(){return this.x*this.x+this.y*this.y+this.z*this.z},length:function(){return Math.sqrt(this.lengthSq())},lengthManhattan:function(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)},normalize:function(){return this.divideScalar(this.length())},setLength:function(a){return this.normalize().multiplyScalar(a)},lerpSelf:function(a,b){this.x+=
(a.x-this.x)*b;this.y+=(a.y-this.y)*b;this.z+=(a.z-this.z)*b;return this},cross:function(a,b){this.x=a.y*b.z-a.z*b.y;this.y=a.z*b.x-a.x*b.z;this.z=a.x*b.y-a.y*b.x;return this},crossSelf:function(a){var b=this.x,c=this.y,d=this.z;this.x=c*a.z-d*a.y;this.y=d*a.x-b*a.z;this.z=b*a.y-c*a.x;return this},angleTo:function(a){return Math.acos(this.dot(a)/this.length()/a.length())},distanceTo:function(a){return Math.sqrt(this.distanceToSquared(a))},distanceToSquared:function(a){return(new THREE.Vector3).sub(this,
a).lengthSq()},getPositionFromMatrix:function(a){this.x=a.elements[12];this.y=a.elements[13];this.z=a.elements[14];return this},setEulerFromRotationMatrix:function(a,b){function c(a){return Math.min(Math.max(a,-1),1)}var d=a.elements,e=d[0],f=d[4],g=d[8],h=d[1],i=d[5],j=d[9],l=d[2],m=d[6],d=d[10];void 0===b||"XYZ"===b?(this.y=Math.asin(c(g)),0.99999>Math.abs(g)?(this.x=Math.atan2(-j,d),this.z=Math.atan2(-f,e)):(this.x=Math.atan2(m,i),this.z=0)):"YXZ"===b?(this.x=Math.asin(-c(j)),0.99999>Math.abs(j)?
(this.y=Math.atan2(g,d),this.z=Math.atan2(h,i)):(this.y=Math.atan2(-l,e),this.z=0)):"ZXY"===b?(this.x=Math.asin(c(m)),0.99999>Math.abs(m)?(this.y=Math.atan2(-l,d),this.z=Math.atan2(-f,i)):(this.y=0,this.z=Math.atan2(h,e))):"ZYX"===b?(this.y=Math.asin(-c(l)),0.99999>Math.abs(l)?(this.x=Math.atan2(m,d),this.z=Math.atan2(h,e)):(this.x=0,this.z=Math.atan2(-f,i))):"YZX"===b?(this.z=Math.asin(c(h)),0.99999>Math.abs(h)?(this.x=Math.atan2(-j,i),this.y=Math.atan2(-l,e)):(this.x=0,this.y=Math.atan2(g,d))):
"XZY"===b&&(this.z=Math.asin(-c(f)),0.99999>Math.abs(f)?(this.x=Math.atan2(m,i),this.y=Math.atan2(g,e)):(this.x=Math.atan2(-j,d),this.y=0));return this},setEulerFromQuaternion:function(a,b){function c(a){return Math.min(Math.max(a,-1),1)}var d=a.x*a.x,e=a.y*a.y,f=a.z*a.z,g=a.w*a.w;void 0===b||"XYZ"===b?(this.x=Math.atan2(2*(a.x*a.w-a.y*a.z),g-d-e+f),this.y=Math.asin(c(2*(a.x*a.z+a.y*a.w))),this.z=Math.atan2(2*(a.z*a.w-a.x*a.y),g+d-e-f)):"YXZ"===b?(this.x=Math.asin(c(2*(a.x*a.w-a.y*a.z))),this.y=Math.atan2(2*
(a.x*a.z+a.y*a.w),g-d-e+f),this.z=Math.atan2(2*(a.x*a.y+a.z*a.w),g-d+e-f)):"ZXY"===b?(this.x=Math.asin(c(2*(a.x*a.w+a.y*a.z))),this.y=Math.atan2(2*(a.y*a.w-a.z*a.x),g-d-e+f),this.z=Math.atan2(2*(a.z*a.w-a.x*a.y),g-d+e-f)):"ZYX"===b?(this.x=Math.atan2(2*(a.x*a.w+a.z*a.y),g-d-e+f),this.y=Math.asin(c(2*(a.y*a.w-a.x*a.z))),this.z=Math.atan2(2*(a.x*a.y+a.z*a.w),g+d-e-f)):"YZX"===b?(this.x=Math.atan2(2*(a.x*a.w-a.z*a.y),g-d+e-f),this.y=Math.atan2(2*(a.y*a.w-a.x*a.z),g+d-e-f),this.z=Math.asin(c(2*(a.x*a.y+
a.z*a.w)))):"XZY"===b&&(this.x=Math.atan2(2*(a.x*a.w+a.y*a.z),g-d+e-f),this.y=Math.atan2(2*(a.x*a.z+a.y*a.w),g+d-e-f),this.z=Math.asin(c(2*(a.z*a.w-a.x*a.y))));return this},getScaleFromMatrix:function(a){var b=this.set(a.elements[0],a.elements[1],a.elements[2]).length(),c=this.set(a.elements[4],a.elements[5],a.elements[6]).length(),a=this.set(a.elements[8],a.elements[9],a.elements[10]).length();this.x=b;this.y=c;this.z=a;return this},equals:function(a){return a.x===this.x&&a.y===this.y&&a.z===this.z},
isZero:function(a){return this.lengthSq()<(void 0!==a?a:1E-4)},clone:function(){return new THREE.Vector3(this.x,this.y,this.z)}};THREE.Vector4=function(a,b,c,d){this.x=a||0;this.y=b||0;this.z=c||0;this.w=void 0!==d?d:1};
THREE.Vector4.prototype={constructor:THREE.Vector4,set:function(a,b,c,d){this.x=a;this.y=b;this.z=c;this.w=d;return this},copy:function(a){this.x=a.x;this.y=a.y;this.z=a.z;this.w=void 0!==a.w?a.w:1;return this},add:function(a,b){this.x=a.x+b.x;this.y=a.y+b.y;this.z=a.z+b.z;this.w=a.w+b.w;return this},addSelf:function(a){this.x+=a.x;this.y+=a.y;this.z+=a.z;this.w+=a.w;return this},sub:function(a,b){this.x=a.x-b.x;this.y=a.y-b.y;this.z=a.z-b.z;this.w=a.w-b.w;return this},subSelf:function(a){this.x-=
a.x;this.y-=a.y;this.z-=a.z;this.w-=a.w;return this},multiplyScalar:function(a){this.x*=a;this.y*=a;this.z*=a;this.w*=a;return this},divideScalar:function(a){a?(this.x/=a,this.y/=a,this.z/=a,this.w/=a):(this.z=this.y=this.x=0,this.w=1);return this},negate:function(){return this.multiplyScalar(-1)},dot:function(a){return this.x*a.x+this.y*a.y+this.z*a.z+this.w*a.w},lengthSq:function(){return this.dot(this)},length:function(){return Math.sqrt(this.lengthSq())},lengthManhattan:function(){return Math.abs(this.x)+
Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)},normalize:function(){return this.divideScalar(this.length())},setLength:function(a){return this.normalize().multiplyScalar(a)},lerpSelf:function(a,b){this.x+=(a.x-this.x)*b;this.y+=(a.y-this.y)*b;this.z+=(a.z-this.z)*b;this.w+=(a.w-this.w)*b;return this},clone:function(){return new THREE.Vector4(this.x,this.y,this.z,this.w)},setAxisAngleFromQuaternion:function(a){this.w=2*Math.acos(a.w);var b=Math.sqrt(1-a.w*a.w);1E-4>b?(this.x=1,this.z=this.y=0):
(this.x=a.x/b,this.y=a.y/b,this.z=a.z/b);return this},setAxisAngleFromRotationMatrix:function(a){var b,c,d,a=a.elements,e=a[0];d=a[4];var f=a[8],g=a[1],h=a[5],i=a[9];c=a[2];b=a[6];var j=a[10];if(0.01>Math.abs(d-g)&&0.01>Math.abs(f-c)&&0.01>Math.abs(i-b)){if(0.1>Math.abs(d+g)&&0.1>Math.abs(f+c)&&0.1>Math.abs(i+b)&&0.1>Math.abs(e+h+j-3))return this.set(1,0,0,0),this;a=Math.PI;e=(e+1)/2;h=(h+1)/2;j=(j+1)/2;d=(d+g)/4;f=(f+c)/4;i=(i+b)/4;e>h&&e>j?0.01>e?(b=0,d=c=0.707106781):(b=Math.sqrt(e),c=d/b,d=f/
b):h>j?0.01>h?(b=0.707106781,c=0,d=0.707106781):(c=Math.sqrt(h),b=d/c,d=i/c):0.01>j?(c=b=0.707106781,d=0):(d=Math.sqrt(j),b=f/d,c=i/d);this.set(b,c,d,a);return this}a=Math.sqrt((b-i)*(b-i)+(f-c)*(f-c)+(g-d)*(g-d));0.001>Math.abs(a)&&(a=1);this.x=(b-i)/a;this.y=(f-c)/a;this.z=(g-d)/a;this.w=Math.acos((e+h+j-1)/2);return this}};THREE.Matrix3=function(){this.elements=new Float32Array(9)};
THREE.Matrix3.prototype={constructor:THREE.Matrix3,getInverse:function(a){var b=a.elements,a=b[10]*b[5]-b[6]*b[9],c=-b[10]*b[1]+b[2]*b[9],d=b[6]*b[1]-b[2]*b[5],e=-b[10]*b[4]+b[6]*b[8],f=b[10]*b[0]-b[2]*b[8],g=-b[6]*b[0]+b[2]*b[4],h=b[9]*b[4]-b[5]*b[8],i=-b[9]*b[0]+b[1]*b[8],j=b[5]*b[0]-b[1]*b[4],b=b[0]*a+b[1]*e+b[2]*h;0===b&&console.warn("Matrix3.getInverse(): determinant == 0");var b=1/b,l=this.elements;l[0]=b*a;l[1]=b*c;l[2]=b*d;l[3]=b*e;l[4]=b*f;l[5]=b*g;l[6]=b*h;l[7]=b*i;l[8]=b*j;return this},
transpose:function(){var a,b=this.elements;a=b[1];b[1]=b[3];b[3]=a;a=b[2];b[2]=b[6];b[6]=a;a=b[5];b[5]=b[7];b[7]=a;return this},transposeIntoArray:function(a){var b=this.m;a[0]=b[0];a[1]=b[3];a[2]=b[6];a[3]=b[1];a[4]=b[4];a[5]=b[7];a[6]=b[2];a[7]=b[5];a[8]=b[8];return this}};THREE.Matrix4=function(a,b,c,d,e,f,g,h,i,j,l,m,n,p,o,q){this.elements=new Float32Array(16);this.set(void 0!==a?a:1,b||0,c||0,d||0,e||0,void 0!==f?f:1,g||0,h||0,i||0,j||0,void 0!==l?l:1,m||0,n||0,p||0,o||0,void 0!==q?q:1)};
THREE.Matrix4.prototype={constructor:THREE.Matrix4,set:function(a,b,c,d,e,f,g,h,i,j,l,m,n,p,o,q){var r=this.elements;r[0]=a;r[4]=b;r[8]=c;r[12]=d;r[1]=e;r[5]=f;r[9]=g;r[13]=h;r[2]=i;r[6]=j;r[10]=l;r[14]=m;r[3]=n;r[7]=p;r[11]=o;r[15]=q;return this},identity:function(){this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);return this},copy:function(a){a=a.elements;this.set(a[0],a[4],a[8],a[12],a[1],a[5],a[9],a[13],a[2],a[6],a[10],a[14],a[3],a[7],a[11],a[15]);return this},lookAt:function(a,b,c){var d=this.elements,
e=THREE.Matrix4.__v1,f=THREE.Matrix4.__v2,g=THREE.Matrix4.__v3;g.sub(a,b).normalize();0===g.length()&&(g.z=1);e.cross(c,g).normalize();0===e.length()&&(g.x+=1E-4,e.cross(c,g).normalize());f.cross(g,e);d[0]=e.x;d[4]=f.x;d[8]=g.x;d[1]=e.y;d[5]=f.y;d[9]=g.y;d[2]=e.z;d[6]=f.z;d[10]=g.z;return this},multiply:function(a,b){var c=a.elements,d=b.elements,e=this.elements,f=c[0],g=c[4],h=c[8],i=c[12],j=c[1],l=c[5],m=c[9],n=c[13],p=c[2],o=c[6],q=c[10],r=c[14],t=c[3],B=c[7],u=c[11],c=c[15],s=d[0],z=d[4],A=d[8],
v=d[12],y=d[1],C=d[5],G=d[9],H=d[13],J=d[2],E=d[6],M=d[10],K=d[14],F=d[3],I=d[7],L=d[11],d=d[15];e[0]=f*s+g*y+h*J+i*F;e[4]=f*z+g*C+h*E+i*I;e[8]=f*A+g*G+h*M+i*L;e[12]=f*v+g*H+h*K+i*d;e[1]=j*s+l*y+m*J+n*F;e[5]=j*z+l*C+m*E+n*I;e[9]=j*A+l*G+m*M+n*L;e[13]=j*v+l*H+m*K+n*d;e[2]=p*s+o*y+q*J+r*F;e[6]=p*z+o*C+q*E+r*I;e[10]=p*A+o*G+q*M+r*L;e[14]=p*v+o*H+q*K+r*d;e[3]=t*s+B*y+u*J+c*F;e[7]=t*z+B*C+u*E+c*I;e[11]=t*A+B*G+u*M+c*L;e[15]=t*v+B*H+u*K+c*d;return this},multiplySelf:function(a){return this.multiply(this,
a)},multiplyToArray:function(a,b,c){var d=this.elements;this.multiply(a,b);c[0]=d[0];c[1]=d[1];c[2]=d[2];c[3]=d[3];c[4]=d[4];c[5]=d[5];c[6]=d[6];c[7]=d[7];c[8]=d[8];c[9]=d[9];c[10]=d[10];c[11]=d[11];c[12]=d[12];c[13]=d[13];c[14]=d[14];c[15]=d[15];return this},multiplyScalar:function(a){var b=this.elements;b[0]*=a;b[4]*=a;b[8]*=a;b[12]*=a;b[1]*=a;b[5]*=a;b[9]*=a;b[13]*=a;b[2]*=a;b[6]*=a;b[10]*=a;b[14]*=a;b[3]*=a;b[7]*=a;b[11]*=a;b[15]*=a;return this},multiplyVector3:function(a){var b=this.elements,
c=a.x,d=a.y,e=a.z,f=1/(b[3]*c+b[7]*d+b[11]*e+b[15]);a.x=(b[0]*c+b[4]*d+b[8]*e+b[12])*f;a.y=(b[1]*c+b[5]*d+b[9]*e+b[13])*f;a.z=(b[2]*c+b[6]*d+b[10]*e+b[14])*f;return a},multiplyVector4:function(a){var b=this.elements,c=a.x,d=a.y,e=a.z,f=a.w;a.x=b[0]*c+b[4]*d+b[8]*e+b[12]*f;a.y=b[1]*c+b[5]*d+b[9]*e+b[13]*f;a.z=b[2]*c+b[6]*d+b[10]*e+b[14]*f;a.w=b[3]*c+b[7]*d+b[11]*e+b[15]*f;return a},multiplyVector3Array:function(a){for(var b=THREE.Matrix4.__v1,c=0,d=a.length;c<d;c+=3)b.x=a[c],b.y=a[c+1],b.z=a[c+2],
this.multiplyVector3(b),a[c]=b.x,a[c+1]=b.y,a[c+2]=b.z;return a},rotateAxis:function(a){var b=this.elements,c=a.x,d=a.y,e=a.z;a.x=c*b[0]+d*b[4]+e*b[8];a.y=c*b[1]+d*b[5]+e*b[9];a.z=c*b[2]+d*b[6]+e*b[10];a.normalize();return a},crossVector:function(a){var b=this.elements,c=new THREE.Vector4;c.x=b[0]*a.x+b[4]*a.y+b[8]*a.z+b[12]*a.w;c.y=b[1]*a.x+b[5]*a.y+b[9]*a.z+b[13]*a.w;c.z=b[2]*a.x+b[6]*a.y+b[10]*a.z+b[14]*a.w;c.w=a.w?b[3]*a.x+b[7]*a.y+b[11]*a.z+b[15]*a.w:1;return c},determinant:function(){var a=
this.elements,b=a[0],c=a[4],d=a[8],e=a[12],f=a[1],g=a[5],h=a[9],i=a[13],j=a[2],l=a[6],m=a[10],n=a[14],p=a[3],o=a[7],q=a[11],a=a[15];return e*h*l*p-d*i*l*p-e*g*m*p+c*i*m*p+d*g*n*p-c*h*n*p-e*h*j*o+d*i*j*o+e*f*m*o-b*i*m*o-d*f*n*o+b*h*n*o+e*g*j*q-c*i*j*q-e*f*l*q+b*i*l*q+c*f*n*q-b*g*n*q-d*g*j*a+c*h*j*a+d*f*l*a-b*h*l*a-c*f*m*a+b*g*m*a},transpose:function(){var a=this.elements,b;b=a[1];a[1]=a[4];a[4]=b;b=a[2];a[2]=a[8];a[8]=b;b=a[6];a[6]=a[9];a[9]=b;b=a[3];a[3]=a[12];a[12]=b;b=a[7];a[7]=a[13];a[13]=b;b=
a[11];a[11]=a[14];a[14]=b;return this},flattenToArray:function(a){var b=this.elements;a[0]=b[0];a[1]=b[1];a[2]=b[2];a[3]=b[3];a[4]=b[4];a[5]=b[5];a[6]=b[6];a[7]=b[7];a[8]=b[8];a[9]=b[9];a[10]=b[10];a[11]=b[11];a[12]=b[12];a[13]=b[13];a[14]=b[14];a[15]=b[15];return a},flattenToArrayOffset:function(a,b){var c=this.elements;a[b]=c[0];a[b+1]=c[1];a[b+2]=c[2];a[b+3]=c[3];a[b+4]=c[4];a[b+5]=c[5];a[b+6]=c[6];a[b+7]=c[7];a[b+8]=c[8];a[b+9]=c[9];a[b+10]=c[10];a[b+11]=c[11];a[b+12]=c[12];a[b+13]=c[13];a[b+
14]=c[14];a[b+15]=c[15];return a},getPosition:function(){var a=this.elements;return THREE.Matrix4.__v1.set(a[12],a[13],a[14])},setPosition:function(a){var b=this.elements;b[12]=a.x;b[13]=a.y;b[14]=a.z;return this},getColumnX:function(){var a=this.elements;return THREE.Matrix4.__v1.set(a[0],a[1],a[2])},getColumnY:function(){var a=this.elements;return THREE.Matrix4.__v1.set(a[4],a[5],a[6])},getColumnZ:function(){var a=this.elements;return THREE.Matrix4.__v1.set(a[8],a[9],a[10])},getInverse:function(a){var b=
this.elements,c=a.elements,d=c[0],e=c[4],f=c[8],g=c[12],h=c[1],i=c[5],j=c[9],l=c[13],m=c[2],n=c[6],p=c[10],o=c[14],q=c[3],r=c[7],t=c[11],c=c[15];b[0]=j*o*r-l*p*r+l*n*t-i*o*t-j*n*c+i*p*c;b[4]=g*p*r-f*o*r-g*n*t+e*o*t+f*n*c-e*p*c;b[8]=f*l*r-g*j*r+g*i*t-e*l*t-f*i*c+e*j*c;b[12]=g*j*n-f*l*n-g*i*p+e*l*p+f*i*o-e*j*o;b[1]=l*p*q-j*o*q-l*m*t+h*o*t+j*m*c-h*p*c;b[5]=f*o*q-g*p*q+g*m*t-d*o*t-f*m*c+d*p*c;b[9]=g*j*q-f*l*q-g*h*t+d*l*t+f*h*c-d*j*c;b[13]=f*l*m-g*j*m+g*h*p-d*l*p-f*h*o+d*j*o;b[2]=i*o*q-l*n*q+l*m*r-h*o*
r-i*m*c+h*n*c;b[6]=g*n*q-e*o*q-g*m*r+d*o*r+e*m*c-d*n*c;b[10]=e*l*q-g*i*q+g*h*r-d*l*r-e*h*c+d*i*c;b[14]=g*i*m-e*l*m-g*h*n+d*l*n+e*h*o-d*i*o;b[3]=j*n*q-i*p*q-j*m*r+h*p*r+i*m*t-h*n*t;b[7]=e*p*q-f*n*q+f*m*r-d*p*r-e*m*t+d*n*t;b[11]=f*i*q-e*j*q-f*h*r+d*j*r+e*h*t-d*i*t;b[15]=e*j*m-f*i*m+f*h*n-d*j*n-e*h*p+d*i*p;this.multiplyScalar(1/a.determinant());return this},setRotationFromEuler:function(a,b){var c=this.elements,d=a.x,e=a.y,f=a.z,g=Math.cos(d),d=Math.sin(d),h=Math.cos(e),e=Math.sin(e),i=Math.cos(f),f=
Math.sin(f);if(void 0===b||"XYZ"===b){var j=g*i,l=g*f,m=d*i,n=d*f;c[0]=h*i;c[4]=-h*f;c[8]=e;c[1]=l+m*e;c[5]=j-n*e;c[9]=-d*h;c[2]=n-j*e;c[6]=m+l*e;c[10]=g*h}else"YXZ"===b?(j=h*i,l=h*f,m=e*i,n=e*f,c[0]=j+n*d,c[4]=m*d-l,c[8]=g*e,c[1]=g*f,c[5]=g*i,c[9]=-d,c[2]=l*d-m,c[6]=n+j*d,c[10]=g*h):"ZXY"===b?(j=h*i,l=h*f,m=e*i,n=e*f,c[0]=j-n*d,c[4]=-g*f,c[8]=m+l*d,c[1]=l+m*d,c[5]=g*i,c[9]=n-j*d,c[2]=-g*e,c[6]=d,c[10]=g*h):"ZYX"===b?(j=g*i,l=g*f,m=d*i,n=d*f,c[0]=h*i,c[4]=m*e-l,c[8]=j*e+n,c[1]=h*f,c[5]=n*e+j,c[9]=
l*e-m,c[2]=-e,c[6]=d*h,c[10]=g*h):"YZX"===b?(j=g*h,l=g*e,m=d*h,n=d*e,c[0]=h*i,c[4]=n-j*f,c[8]=m*f+l,c[1]=f,c[5]=g*i,c[9]=-d*i,c[2]=-e*i,c[6]=l*f+m,c[10]=j-n*f):"XZY"===b&&(j=g*h,l=g*e,m=d*h,n=d*e,c[0]=h*i,c[4]=-f,c[8]=e*i,c[1]=j*f+n,c[5]=g*i,c[9]=l*f-m,c[2]=m*f-l,c[6]=d*i,c[10]=n*f+j);return this},setRotationFromQuaternion:function(a){var b=this.elements,c=a.x,d=a.y,e=a.z,f=a.w,g=c+c,h=d+d,i=e+e,a=c*g,j=c*h,c=c*i,l=d*h,d=d*i,e=e*i,g=f*g,h=f*h,f=f*i;b[0]=1-(l+e);b[4]=j-f;b[8]=c+h;b[1]=j+f;b[5]=1-(a+
e);b[9]=d-g;b[2]=c-h;b[6]=d+g;b[10]=1-(a+l);return this},compose:function(a,b,c){var d=this.elements,e=THREE.Matrix4.__m1,f=THREE.Matrix4.__m2;e.identity();e.setRotationFromQuaternion(b);f.makeScale(c.x,c.y,c.z);this.multiply(e,f);d[12]=a.x;d[13]=a.y;d[14]=a.z;return this},decompose:function(a,b,c){var d=this.elements,e=THREE.Matrix4.__v1,f=THREE.Matrix4.__v2,g=THREE.Matrix4.__v3;e.set(d[0],d[1],d[2]);f.set(d[4],d[5],d[6]);g.set(d[8],d[9],d[10]);a=a instanceof THREE.Vector3?a:new THREE.Vector3;b=
b instanceof THREE.Quaternion?b:new THREE.Quaternion;c=c instanceof THREE.Vector3?c:new THREE.Vector3;c.x=e.length();c.y=f.length();c.z=g.length();a.x=d[12];a.y=d[13];a.z=d[14];d=THREE.Matrix4.__m1;d.copy(this);d.elements[0]/=c.x;d.elements[1]/=c.x;d.elements[2]/=c.x;d.elements[4]/=c.y;d.elements[5]/=c.y;d.elements[6]/=c.y;d.elements[8]/=c.z;d.elements[9]/=c.z;d.elements[10]/=c.z;b.setFromRotationMatrix(d);return[a,b,c]},extractPosition:function(a){var b=this.elements,a=a.elements;b[12]=a[12];b[13]=
a[13];b[14]=a[14];return this},extractRotation:function(a){var b=this.elements,a=a.elements,c=THREE.Matrix4.__v1,d=1/c.set(a[0],a[1],a[2]).length(),e=1/c.set(a[4],a[5],a[6]).length(),c=1/c.set(a[8],a[9],a[10]).length();b[0]=a[0]*d;b[1]=a[1]*d;b[2]=a[2]*d;b[4]=a[4]*e;b[5]=a[5]*e;b[6]=a[6]*e;b[8]=a[8]*c;b[9]=a[9]*c;b[10]=a[10]*c;return this},translate:function(a){var b=this.elements,c=a.x,d=a.y,a=a.z;b[12]=b[0]*c+b[4]*d+b[8]*a+b[12];b[13]=b[1]*c+b[5]*d+b[9]*a+b[13];b[14]=b[2]*c+b[6]*d+b[10]*a+b[14];
b[15]=b[3]*c+b[7]*d+b[11]*a+b[15];return this},rotateX:function(a){var b=this.elements,c=b[4],d=b[5],e=b[6],f=b[7],g=b[8],h=b[9],i=b[10],j=b[11],l=Math.cos(a),a=Math.sin(a);b[4]=l*c+a*g;b[5]=l*d+a*h;b[6]=l*e+a*i;b[7]=l*f+a*j;b[8]=l*g-a*c;b[9]=l*h-a*d;b[10]=l*i-a*e;b[11]=l*j-a*f;return this},rotateY:function(a){var b=this.elements,c=b[0],d=b[1],e=b[2],f=b[3],g=b[8],h=b[9],i=b[10],j=b[11],l=Math.cos(a),a=Math.sin(a);b[0]=l*c-a*g;b[1]=l*d-a*h;b[2]=l*e-a*i;b[3]=l*f-a*j;b[8]=l*g+a*c;b[9]=l*h+a*d;b[10]=
l*i+a*e;b[11]=l*j+a*f;return this},rotateZ:function(a){var b=this.elements,c=b[0],d=b[1],e=b[2],f=b[3],g=b[4],h=b[5],i=b[6],j=b[7],l=Math.cos(a),a=Math.sin(a);b[0]=l*c+a*g;b[1]=l*d+a*h;b[2]=l*e+a*i;b[3]=l*f+a*j;b[4]=l*g-a*c;b[5]=l*h-a*d;b[6]=l*i-a*e;b[7]=l*j-a*f;return this},rotateByAxis:function(a,b){var c=this.elements;if(1===a.x&&0===a.y&&0===a.z)return this.rotateX(b);if(0===a.x&&1===a.y&&0===a.z)return this.rotateY(b);if(0===a.x&&0===a.y&&1===a.z)return this.rotateZ(b);var d=a.x,e=a.y,f=a.z,
g=Math.sqrt(d*d+e*e+f*f),d=d/g,e=e/g,f=f/g,g=d*d,h=e*e,i=f*f,j=Math.cos(b),l=Math.sin(b),m=1-j,n=d*e*m,p=d*f*m,m=e*f*m,d=d*l,o=e*l,l=f*l,f=g+(1-g)*j,g=n+l,e=p-o,n=n-l,h=h+(1-h)*j,l=m+d,p=p+o,m=m-d,i=i+(1-i)*j,j=c[0],d=c[1],o=c[2],q=c[3],r=c[4],t=c[5],B=c[6],u=c[7],s=c[8],z=c[9],A=c[10],v=c[11];c[0]=f*j+g*r+e*s;c[1]=f*d+g*t+e*z;c[2]=f*o+g*B+e*A;c[3]=f*q+g*u+e*v;c[4]=n*j+h*r+l*s;c[5]=n*d+h*t+l*z;c[6]=n*o+h*B+l*A;c[7]=n*q+h*u+l*v;c[8]=p*j+m*r+i*s;c[9]=p*d+m*t+i*z;c[10]=p*o+m*B+i*A;c[11]=p*q+m*u+i*v;
return this},scale:function(a){var b=this.elements,c=a.x,d=a.y,a=a.z;b[0]*=c;b[4]*=d;b[8]*=a;b[1]*=c;b[5]*=d;b[9]*=a;b[2]*=c;b[6]*=d;b[10]*=a;b[3]*=c;b[7]*=d;b[11]*=a;return this},getMaxScaleOnAxis:function(){var a=this.elements;return Math.sqrt(Math.max(a[0]*a[0]+a[1]*a[1]+a[2]*a[2],Math.max(a[4]*a[4]+a[5]*a[5]+a[6]*a[6],a[8]*a[8]+a[9]*a[9]+a[10]*a[10])))},makeTranslation:function(a,b,c){this.set(1,0,0,a,0,1,0,b,0,0,1,c,0,0,0,1);return this},makeRotationX:function(a){var b=Math.cos(a),a=Math.sin(a);
this.set(1,0,0,0,0,b,-a,0,0,a,b,0,0,0,0,1);return this},makeRotationY:function(a){var b=Math.cos(a),a=Math.sin(a);this.set(b,0,a,0,0,1,0,0,-a,0,b,0,0,0,0,1);return this},makeRotationZ:function(a){var b=Math.cos(a),a=Math.sin(a);this.set(b,-a,0,0,a,b,0,0,0,0,1,0,0,0,0,1);return this},makeRotationAxis:function(a,b){var c=Math.cos(b),d=Math.sin(b),e=1-c,f=a.x,g=a.y,h=a.z,i=e*f,j=e*g;this.set(i*f+c,i*g-d*h,i*h+d*g,0,i*g+d*h,j*g+c,j*h-d*f,0,i*h-d*g,j*h+d*f,e*h*h+c,0,0,0,0,1);return this},makeScale:function(a,
b,c){this.set(a,0,0,0,0,b,0,0,0,0,c,0,0,0,0,1);return this},makeFrustum:function(a,b,c,d,e,f){var g=this.elements;g[0]=2*e/(b-a);g[4]=0;g[8]=(b+a)/(b-a);g[12]=0;g[1]=0;g[5]=2*e/(d-c);g[9]=(d+c)/(d-c);g[13]=0;g[2]=0;g[6]=0;g[10]=-(f+e)/(f-e);g[14]=-2*f*e/(f-e);g[3]=0;g[7]=0;g[11]=-1;g[15]=0;return this},makePerspective:function(a,b,c,d){var a=c*Math.tan(a*Math.PI/360),e=-a;return this.makeFrustum(e*b,a*b,e,a,c,d)},makeOrthographic:function(a,b,c,d,e,f){var g=this.elements,h=b-a,i=c-d,j=f-e;g[0]=2/
h;g[4]=0;g[8]=0;g[12]=-((b+a)/h);g[1]=0;g[5]=2/i;g[9]=0;g[13]=-((c+d)/i);g[2]=0;g[6]=0;g[10]=-2/j;g[14]=-((f+e)/j);g[3]=0;g[7]=0;g[11]=0;g[15]=1;return this},clone:function(){var a=this.elements;return new THREE.Matrix4(a[0],a[4],a[8],a[12],a[1],a[5],a[9],a[13],a[2],a[6],a[10],a[14],a[3],a[7],a[11],a[15])}};THREE.Matrix4.__v1=new THREE.Vector3;THREE.Matrix4.__v2=new THREE.Vector3;THREE.Matrix4.__v3=new THREE.Vector3;THREE.Matrix4.__m1=new THREE.Matrix4;THREE.Matrix4.__m2=new THREE.Matrix4;
THREE.EventTarget=function(){var a={};this.addEventListener=function(b,c){void 0===a[b]&&(a[b]=[]);-1===a[b].indexOf(c)&&a[b].push(c)};this.dispatchEvent=function(b){for(var c in a[b.type])a[b.type][c](b)};this.removeEventListener=function(b,c){var d=a[b].indexOf(c);-1!==d&&a[b].splice(d,1)}};THREE.Frustum=function(){this.planes=[new THREE.Vector4,new THREE.Vector4,new THREE.Vector4,new THREE.Vector4,new THREE.Vector4,new THREE.Vector4]};
THREE.Frustum.prototype.setFromMatrix=function(a){var b=this.planes,c=a.elements,a=c[0],d=c[1],e=c[2],f=c[3],g=c[4],h=c[5],i=c[6],j=c[7],l=c[8],m=c[9],n=c[10],p=c[11],o=c[12],q=c[13],r=c[14],c=c[15];b[0].set(f-a,j-g,p-l,c-o);b[1].set(f+a,j+g,p+l,c+o);b[2].set(f+d,j+h,p+m,c+q);b[3].set(f-d,j-h,p-m,c-q);b[4].set(f-e,j-i,p-n,c-r);b[5].set(f+e,j+i,p+n,c+r);for(d=0;6>d;d++)a=b[d],a.divideScalar(Math.sqrt(a.x*a.x+a.y*a.y+a.z*a.z))};
THREE.Frustum.prototype.contains=function(a){for(var b=0,c=this.planes,b=a.matrixWorld,d=b.elements,a=-a.geometry.boundingSphere.radius*b.getMaxScaleOnAxis(),e=0;6>e;e++)if(b=c[e].x*d[12]+c[e].y*d[13]+c[e].z*d[14]+c[e].w,b<=a)return!1;return!0};THREE.Frustum.__v1=new THREE.Vector3;
(function(a){a.Ray=function(b,c,d,e){this.origin=b||new a.Vector3;this.direction=c||new a.Vector3;this.near=d||0;this.far=e||Infinity};var b=new a.Vector3,c=new a.Vector3,d=new a.Vector3,e=new a.Vector3,f=new a.Vector3,g=new a.Vector3,h=new a.Matrix4,i=function(a,b){return a.distance-b.distance},j=new a.Vector3,l=new a.Vector3,m=new a.Vector3,n=function(a,b,c){j.sub(c,a);var d=j.dot(b),a=l.add(a,m.copy(b).multiplyScalar(d));return c.distanceTo(a)},p=function(a,b,c,d){j.sub(d,b);l.sub(c,b);m.sub(a,
b);var a=j.dot(j),b=j.dot(l),c=j.dot(m),e=l.dot(l),d=l.dot(m),f=1/(a*e-b*b),e=(e*c-b*d)*f,a=(a*d-b*c)*f;return 0<=e&&0<=a&&1>e+a},o=function(i,l,j){var m,o;if(i instanceof a.Particle){m=n(l.origin,l.direction,i.matrixWorld.getPosition());if(m>i.scale.x)return j;o={distance:m,point:i.position,face:null,object:i};j.push(o)}else if(i instanceof a.Mesh){var q=i.geometry.boundingSphere.radius*i.matrixWorld.getMaxScaleOnAxis();m=n(l.origin,l.direction,i.matrixWorld.getPosition());if(m>q)return j;var A,
v,y=i.geometry,C=y.vertices,G,H,J;G=i.geometry.materials;H=i.material instanceof a.MeshFaceMaterial;var E,M=l.precision;i.matrixRotationWorld.extractRotation(i.matrixWorld);b.copy(l.origin);h.getInverse(i.matrixWorld);c.copy(b);h.multiplyVector3(c);d.copy(l.direction);h.rotateAxis(d).normalize();q=0;for(A=y.faces.length;q<A;q++)if(o=y.faces[q],m=!0===H?G[o.materialIndex]:i.material,void 0!==m&&(J=m.side,e.sub(o.centroid,c),f=o.normal,m=d.dot(f),!(Math.abs(m)<M)&&(v=f.dot(e)/m,!(0>v)&&(J===a.DoubleSide||
(J===a.FrontSide?0>m:0<m)))))if(g.add(c,d.multiplyScalar(v)),o instanceof a.Face3)m=C[o.a],v=C[o.b],J=C[o.c],p(g,m,v,J)&&(v=i.matrixWorld.multiplyVector3(g.clone()),m=b.distanceTo(v),m<l.near||m>l.far||(o={distance:m,point:v,face:o,faceIndex:q,object:i},j.push(o)));else if(o instanceof a.Face4&&(m=C[o.a],v=C[o.b],J=C[o.c],E=C[o.d],p(g,m,v,E)||p(g,v,J,E)))v=i.matrixWorld.multiplyVector3(g.clone()),m=b.distanceTo(v),m<l.near||m>l.far||(o={distance:m,point:v,face:o,faceIndex:q,object:i},j.push(o))}},
q=function(a,b,c){for(var a=a.getDescendants(),d=0,e=a.length;d<e;d++)o(a[d],b,c)};a.Ray.prototype.precision=1E-4;a.Ray.prototype.set=function(a,b){this.origin=a;this.direction=b};a.Ray.prototype.intersectObject=function(a,b){var c=[];!0===b&&q(a,this,c);o(a,this,c);c.sort(i);return c};a.Ray.prototype.intersectObjects=function(a,b){for(var c=[],d=0,e=a.length;d<e;d++)o(a[d],this,c),!0===b&&q(a[d],this,c);c.sort(i);return c}})(THREE);
THREE.Rectangle=function(){function a(){f=d-b;g=e-c}var b=0,c=0,d=0,e=0,f=0,g=0,h=!0;this.getX=function(){return b};this.getY=function(){return c};this.getWidth=function(){return f};this.getHeight=function(){return g};this.getLeft=function(){return b};this.getTop=function(){return c};this.getRight=function(){return d};this.getBottom=function(){return e};this.set=function(f,g,l,m){h=!1;b=f;c=g;d=l;e=m;a()};this.addPoint=function(f,g){!0===h?(h=!1,b=f,c=g,d=f,e=g):(b=b<f?b:f,c=c<g?c:g,d=d>f?d:f,e=e>
g?e:g);a()};this.add3Points=function(f,g,l,m,n,p){!0===h?(h=!1,b=f<l?f<n?f:n:l<n?l:n,c=g<m?g<p?g:p:m<p?m:p,d=f>l?f>n?f:n:l>n?l:n,e=g>m?g>p?g:p:m>p?m:p):(b=f<l?f<n?f<b?f:b:n<b?n:b:l<n?l<b?l:b:n<b?n:b,c=g<m?g<p?g<c?g:c:p<c?p:c:m<p?m<c?m:c:p<c?p:c,d=f>l?f>n?f>d?f:d:n>d?n:d:l>n?l>d?l:d:n>d?n:d,e=g>m?g>p?g>e?g:e:p>e?p:e:m>p?m>e?m:e:p>e?p:e);a()};this.addRectangle=function(f){!0===h?(h=!1,b=f.getLeft(),c=f.getTop(),d=f.getRight(),e=f.getBottom()):(b=b<f.getLeft()?b:f.getLeft(),c=c<f.getTop()?c:f.getTop(),
d=d>f.getRight()?d:f.getRight(),e=e>f.getBottom()?e:f.getBottom());a()};this.inflate=function(f){b-=f;c-=f;d+=f;e+=f;a()};this.minSelf=function(f){b=b>f.getLeft()?b:f.getLeft();c=c>f.getTop()?c:f.getTop();d=d<f.getRight()?d:f.getRight();e=e<f.getBottom()?e:f.getBottom();a()};this.intersects=function(a){return d<a.getLeft()||b>a.getRight()||e<a.getTop()||c>a.getBottom()?!1:!0};this.empty=function(){h=!0;e=d=c=b=0;a()};this.isEmpty=function(){return h}};
THREE.Math={clamp:function(a,b,c){return a<b?b:a>c?c:a},clampBottom:function(a,b){return a<b?b:a},mapLinear:function(a,b,c,d,e){return d+(a-b)*(e-d)/(c-b)},random16:function(){return(65280*Math.random()+255*Math.random())/65535},randInt:function(a,b){return a+Math.floor(Math.random()*(b-a+1))},randFloat:function(a,b){return a+Math.random()*(b-a)},randFloatSpread:function(a){return a*(0.5-Math.random())},sign:function(a){return 0>a?-1:0<a?1:0}};
THREE.Object3D=function(){THREE.Object3DLibrary.push(this);this.id=THREE.Object3DIdCount++;this.name="";this.properties={};this.parent=void 0;this.children=[];this.up=new THREE.Vector3(0,1,0);this.position=new THREE.Vector3;this.rotation=new THREE.Vector3;this.eulerOrder=THREE.Object3D.defaultEulerOrder;this.scale=new THREE.Vector3(1,1,1);this.renderDepth=null;this.rotationAutoUpdate=!0;this.matrix=new THREE.Matrix4;this.matrixWorld=new THREE.Matrix4;this.matrixRotationWorld=new THREE.Matrix4;this.matrixWorldNeedsUpdate=
this.matrixAutoUpdate=!0;this.quaternion=new THREE.Quaternion;this.useQuaternion=!1;this.boundRadius=0;this.boundRadiusScale=1;this.visible=!0;this.receiveShadow=this.castShadow=!1;this.frustumCulled=!0;this._vector=new THREE.Vector3};
THREE.Object3D.prototype={constructor:THREE.Object3D,applyMatrix:function(a){this.matrix.multiply(a,this.matrix);this.scale.getScaleFromMatrix(this.matrix);a=(new THREE.Matrix4).extractRotation(this.matrix);this.rotation.setEulerFromRotationMatrix(a,this.eulerOrder);this.position.getPositionFromMatrix(this.matrix)},translate:function(a,b){this.matrix.rotateAxis(b);this.position.addSelf(b.multiplyScalar(a))},translateX:function(a){this.translate(a,this._vector.set(1,0,0))},translateY:function(a){this.translate(a,
this._vector.set(0,1,0))},translateZ:function(a){this.translate(a,this._vector.set(0,0,1))},localToWorld:function(a){return this.matrixWorld.multiplyVector3(a)},worldToLocal:function(a){return THREE.Object3D.__m1.getInverse(this.matrixWorld).multiplyVector3(a)},lookAt:function(a){this.matrix.lookAt(a,this.position,this.up);this.rotationAutoUpdate&&this.rotation.setEulerFromRotationMatrix(this.matrix,this.eulerOrder)},add:function(a){if(a===this)console.warn("THREE.Object3D.add: An object can't be added as a child of itself.");
else if(a instanceof THREE.Object3D){void 0!==a.parent&&a.parent.remove(a);a.parent=this;this.children.push(a);for(var b=this;void 0!==b.parent;)b=b.parent;void 0!==b&&b instanceof THREE.Scene&&b.__addObject(a)}},remove:function(a){var b=this.children.indexOf(a);if(-1!==b){a.parent=void 0;this.children.splice(b,1);for(b=this;void 0!==b.parent;)b=b.parent;void 0!==b&&b instanceof THREE.Scene&&b.__removeObject(a)}},traverse:function(a){a(this);for(var b=0,c=this.children.length;b<c;b++)this.children[b].traverse(a)},
getChildByName:function(a,b){for(var c=0,d=this.children.length;c<d;c++){var e=this.children[c];if(e.name===a||!0===b&&(e=e.getChildByName(a,b),void 0!==e))return e}},getDescendants:function(a){void 0===a&&(a=[]);Array.prototype.push.apply(a,this.children);for(var b=0,c=this.children.length;b<c;b++)this.children[b].getDescendants(a);return a},updateMatrix:function(){this.matrix.setPosition(this.position);!1===this.useQuaternion?this.matrix.setRotationFromEuler(this.rotation,this.eulerOrder):this.matrix.setRotationFromQuaternion(this.quaternion);
if(1!==this.scale.x||1!==this.scale.y||1!==this.scale.z)this.matrix.scale(this.scale),this.boundRadiusScale=Math.max(this.scale.x,Math.max(this.scale.y,this.scale.z));this.matrixWorldNeedsUpdate=!0},updateMatrixWorld:function(a){!0===this.matrixAutoUpdate&&this.updateMatrix();if(!0===this.matrixWorldNeedsUpdate||!0===a)void 0===this.parent?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiply(this.parent.matrixWorld,this.matrix),this.matrixWorldNeedsUpdate=!1,a=!0;for(var b=0,c=this.children.length;b<
c;b++)this.children[b].updateMatrixWorld(a)},clone:function(a){void 0===a&&(a=new THREE.Object3D);a.name=this.name;a.up.copy(this.up);a.position.copy(this.position);a.rotation instanceof THREE.Vector3&&a.rotation.copy(this.rotation);a.eulerOrder=this.eulerOrder;a.scale.copy(this.scale);a.renderDepth=this.renderDepth;a.rotationAutoUpdate=this.rotationAutoUpdate;a.matrix.copy(this.matrix);a.matrixWorld.copy(this.matrixWorld);a.matrixRotationWorld.copy(this.matrixRotationWorld);a.matrixAutoUpdate=this.matrixAutoUpdate;
a.matrixWorldNeedsUpdate=this.matrixWorldNeedsUpdate;a.quaternion.copy(this.quaternion);a.useQuaternion=this.useQuaternion;a.boundRadius=this.boundRadius;a.boundRadiusScale=this.boundRadiusScale;a.visible=this.visible;a.castShadow=this.castShadow;a.receiveShadow=this.receiveShadow;a.frustumCulled=this.frustumCulled;return a},deallocate:function(){var a=THREE.Object3DLibrary.indexOf(this);-1!==a&&THREE.Object3DLibrary.splice(a,1)}};THREE.Object3D.__m1=new THREE.Matrix4;
THREE.Object3D.defaultEulerOrder="XYZ";THREE.Object3DIdCount=0;THREE.Object3DLibrary=[];
THREE.Projector=function(){function a(){if(f===h){var a=new THREE.RenderableObject;g.push(a);h++;f++;return a}return g[f++]}function b(){if(j===m){var a=new THREE.RenderableVertex;l.push(a);m++;j++;return a}return l[j++]}function c(a,b){return b.z-a.z}function d(a,b){var c=0,d=1,e=a.z+a.w,f=b.z+b.w,g=-a.z+a.w,h=-b.z+b.w;if(0<=e&&0<=f&&0<=g&&0<=h)return!0;if(0>e&&0>f||0>g&&0>h)return!1;0>e?c=Math.max(c,e/(e-f)):0>f&&(d=Math.min(d,e/(e-f)));0>g?c=Math.max(c,g/(g-h)):0>h&&(d=Math.min(d,g/(g-h)));if(d<
c)return!1;a.lerpSelf(b,c);b.lerpSelf(a,1-d);return!0}var e,f,g=[],h=0,i,j,l=[],m=0,n,p,o=[],q=0,r,t=[],B=0,u,s,z=[],A=0,v,y,C=[],G=0,H={objects:[],sprites:[],lights:[],elements:[]},J=new THREE.Vector3,E=new THREE.Vector4,M=new THREE.Matrix4,K=new THREE.Matrix4,F=new THREE.Frustum,I=new THREE.Vector4,L=new THREE.Vector4;this.projectVector=function(a,b){b.matrixWorldInverse.getInverse(b.matrixWorld);M.multiply(b.projectionMatrix,b.matrixWorldInverse);M.multiplyVector3(a);return a};this.unprojectVector=
function(a,b){b.projectionMatrixInverse.getInverse(b.projectionMatrix);M.multiply(b.matrixWorld,b.projectionMatrixInverse);M.multiplyVector3(a);return a};this.pickingRay=function(a,b){var c;a.z=-1;c=new THREE.Vector3(a.x,a.y,1);this.unprojectVector(a,b);this.unprojectVector(c,b);c.subSelf(a).normalize();return new THREE.Ray(a,c)};this.projectScene=function(g,h,m,N){var ea=h.near,Q=h.far,qa=!1,la,O,fa,W,V,ia,Z,ca,Ga,Pa,Ia,Ua,na,Va,ib,Ra;y=s=r=p=0;H.elements.length=0;g.updateMatrixWorld();void 0===
h.parent&&h.updateMatrixWorld();h.matrixWorldInverse.getInverse(h.matrixWorld);M.multiply(h.projectionMatrix,h.matrixWorldInverse);F.setFromMatrix(M);f=0;H.objects.length=0;H.sprites.length=0;H.lights.length=0;var eb=function(b){for(var c=0,d=b.children.length;c<d;c++){var f=b.children[c];if(!1!==f.visible){if(f instanceof THREE.Light)H.lights.push(f);else if(f instanceof THREE.Mesh||f instanceof THREE.Line){if(!1===f.frustumCulled||!0===F.contains(f))e=a(),e.object=f,null!==f.renderDepth?e.z=f.renderDepth:
(J.copy(f.matrixWorld.getPosition()),M.multiplyVector3(J),e.z=J.z),H.objects.push(e)}else f instanceof THREE.Sprite||f instanceof THREE.Particle?(e=a(),e.object=f,null!==f.renderDepth?e.z=f.renderDepth:(J.copy(f.matrixWorld.getPosition()),M.multiplyVector3(J),e.z=J.z),H.sprites.push(e)):(e=a(),e.object=f,null!==f.renderDepth?e.z=f.renderDepth:(J.copy(f.matrixWorld.getPosition()),M.multiplyVector3(J),e.z=J.z),H.objects.push(e));eb(f)}}};eb(g);!0===m&&H.objects.sort(c);g=0;for(m=H.objects.length;g<
m;g++)if(ca=H.objects[g].object,Ga=ca.matrixWorld,j=0,ca instanceof THREE.Mesh){Pa=ca.geometry;Ia=ca.geometry.materials;fa=Pa.vertices;Ua=Pa.faces;Va=Pa.faceVertexUvs;Pa=ca.matrixRotationWorld.extractRotation(Ga);ib=ca.material instanceof THREE.MeshFaceMaterial;la=0;for(O=fa.length;la<O;la++)i=b(),i.positionWorld.copy(fa[la]),Ga.multiplyVector3(i.positionWorld),i.positionScreen.copy(i.positionWorld),M.multiplyVector4(i.positionScreen),i.positionScreen.x/=i.positionScreen.w,i.positionScreen.y/=i.positionScreen.w,
i.visible=i.positionScreen.z>ea&&i.positionScreen.z<Q;fa=0;for(la=Ua.length;fa<la;fa++)if(O=Ua[fa],Ra=!0===ib?Ia[O.materialIndex]:ca.material,void 0!==Ra){ia=Ra.side;if(O instanceof THREE.Face3)if(W=l[O.a],V=l[O.b],Z=l[O.c],!0===W.visible&&!0===V.visible&&!0===Z.visible)if(qa=0>(Z.positionScreen.x-W.positionScreen.x)*(V.positionScreen.y-W.positionScreen.y)-(Z.positionScreen.y-W.positionScreen.y)*(V.positionScreen.x-W.positionScreen.x),ia===THREE.DoubleSide||qa===(ia===THREE.FrontSide))p===q?(na=new THREE.RenderableFace3,
o.push(na),q++,p++,n=na):n=o[p++],n.v1.copy(W),n.v2.copy(V),n.v3.copy(Z);else continue;else continue;else if(O instanceof THREE.Face4)if(W=l[O.a],V=l[O.b],Z=l[O.c],na=l[O.d],!0===W.visible&&!0===V.visible&&!0===Z.visible&&!0===na.visible)if(qa=0>(na.positionScreen.x-W.positionScreen.x)*(V.positionScreen.y-W.positionScreen.y)-(na.positionScreen.y-W.positionScreen.y)*(V.positionScreen.x-W.positionScreen.x)||0>(V.positionScreen.x-Z.positionScreen.x)*(na.positionScreen.y-Z.positionScreen.y)-(V.positionScreen.y-
Z.positionScreen.y)*(na.positionScreen.x-Z.positionScreen.x),ia===THREE.DoubleSide||qa===(ia===THREE.FrontSide)){if(r===B){var pb=new THREE.RenderableFace4;t.push(pb);B++;r++;n=pb}else n=t[r++];n.v1.copy(W);n.v2.copy(V);n.v3.copy(Z);n.v4.copy(na)}else continue;else continue;n.normalWorld.copy(O.normal);!1===qa&&(ia===THREE.BackSide||ia===THREE.DoubleSide)&&n.normalWorld.negate();Pa.multiplyVector3(n.normalWorld);n.centroidWorld.copy(O.centroid);Ga.multiplyVector3(n.centroidWorld);n.centroidScreen.copy(n.centroidWorld);
M.multiplyVector3(n.centroidScreen);Z=O.vertexNormals;W=0;for(V=Z.length;W<V;W++)na=n.vertexNormalsWorld[W],na.copy(Z[W]),!1===qa&&(ia===THREE.BackSide||ia===THREE.DoubleSide)&&na.negate(),Pa.multiplyVector3(na);n.vertexNormalsLength=Z.length;W=0;for(V=Va.length;W<V;W++)if(na=Va[W][fa],void 0!==na){ia=0;for(Z=na.length;ia<Z;ia++)n.uvs[W][ia]=na[ia]}n.color=O.color;n.material=Ra;n.z=n.centroidScreen.z;H.elements.push(n)}}else if(ca instanceof THREE.Line){K.multiply(M,Ga);fa=ca.geometry.vertices;W=
b();W.positionScreen.copy(fa[0]);K.multiplyVector4(W.positionScreen);Ga=ca.type===THREE.LinePieces?2:1;la=1;for(O=fa.length;la<O;la++)W=b(),W.positionScreen.copy(fa[la]),K.multiplyVector4(W.positionScreen),0<(la+1)%Ga||(V=l[j-2],I.copy(W.positionScreen),L.copy(V.positionScreen),!0===d(I,L)&&(I.multiplyScalar(1/I.w),L.multiplyScalar(1/L.w),s===A?(Ia=new THREE.RenderableLine,z.push(Ia),A++,s++,u=Ia):u=z[s++],u.v1.positionScreen.copy(I),u.v2.positionScreen.copy(L),u.z=Math.max(I.z,L.z),u.material=ca.material,
H.elements.push(u)))}g=0;for(m=H.sprites.length;g<m;g++)ca=H.sprites[g].object,Ga=ca.matrixWorld,ca instanceof THREE.Particle&&(E.set(Ga.elements[12],Ga.elements[13],Ga.elements[14],1),M.multiplyVector4(E),E.z/=E.w,0<E.z&&1>E.z&&(y===G?(ea=new THREE.RenderableParticle,C.push(ea),G++,y++,v=ea):v=C[y++],v.object=ca,v.x=E.x/E.w,v.y=E.y/E.w,v.z=E.z,v.rotation=ca.rotation.z,v.scale.x=ca.scale.x*Math.abs(v.x-(E.x+h.projectionMatrix.elements[0])/(E.w+h.projectionMatrix.elements[12])),v.scale.y=ca.scale.y*
Math.abs(v.y-(E.y+h.projectionMatrix.elements[5])/(E.w+h.projectionMatrix.elements[13])),v.material=ca.material,H.elements.push(v)));!0===N&&H.elements.sort(c);return H}};THREE.Quaternion=function(a,b,c,d){this.x=a||0;this.y=b||0;this.z=c||0;this.w=void 0!==d?d:1};
THREE.Quaternion.prototype={constructor:THREE.Quaternion,set:function(a,b,c,d){this.x=a;this.y=b;this.z=c;this.w=d;return this},copy:function(a){this.x=a.x;this.y=a.y;this.z=a.z;this.w=a.w;return this},setFromEuler:function(a,b){var c=Math.cos(a.x/2),d=Math.cos(a.y/2),e=Math.cos(a.z/2),f=Math.sin(a.x/2),g=Math.sin(a.y/2),h=Math.sin(a.z/2);void 0===b||"XYZ"===b?(this.x=f*d*e+c*g*h,this.y=c*g*e-f*d*h,this.z=c*d*h+f*g*e,this.w=c*d*e-f*g*h):"YXZ"===b?(this.x=f*d*e+c*g*h,this.y=c*g*e-f*d*h,this.z=c*d*
h-f*g*e,this.w=c*d*e+f*g*h):"ZXY"===b?(this.x=f*d*e-c*g*h,this.y=c*g*e+f*d*h,this.z=c*d*h+f*g*e,this.w=c*d*e-f*g*h):"ZYX"===b?(this.x=f*d*e-c*g*h,this.y=c*g*e+f*d*h,this.z=c*d*h-f*g*e,this.w=c*d*e+f*g*h):"YZX"===b?(this.x=f*d*e+c*g*h,this.y=c*g*e+f*d*h,this.z=c*d*h-f*g*e,this.w=c*d*e-f*g*h):"XZY"===b&&(this.x=f*d*e-c*g*h,this.y=c*g*e-f*d*h,this.z=c*d*h+f*g*e,this.w=c*d*e+f*g*h);return this},setFromAxisAngle:function(a,b){var c=b/2,d=Math.sin(c);this.x=a.x*d;this.y=a.y*d;this.z=a.z*d;this.w=Math.cos(c);
return this},setFromRotationMatrix:function(a){var b=a.elements,c=b[0],a=b[4],d=b[8],e=b[1],f=b[5],g=b[9],h=b[2],i=b[6],b=b[10],j=c+f+b;0<j?(c=0.5/Math.sqrt(j+1),this.w=0.25/c,this.x=(i-g)*c,this.y=(d-h)*c,this.z=(e-a)*c):c>f&&c>b?(c=2*Math.sqrt(1+c-f-b),this.w=(i-g)/c,this.x=0.25*c,this.y=(a+e)/c,this.z=(d+h)/c):f>b?(c=2*Math.sqrt(1+f-c-b),this.w=(d-h)/c,this.x=(a+e)/c,this.y=0.25*c,this.z=(g+i)/c):(c=2*Math.sqrt(1+b-c-f),this.w=(e-a)/c,this.x=(d+h)/c,this.y=(g+i)/c,this.z=0.25*c);return this},calculateW:function(){this.w=
-Math.sqrt(Math.abs(1-this.x*this.x-this.y*this.y-this.z*this.z));return this},inverse:function(){this.x*=-1;this.y*=-1;this.z*=-1;return this},length:function(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)},normalize:function(){var a=Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w);0===a?this.w=this.z=this.y=this.x=0:(a=1/a,this.x*=a,this.y*=a,this.z*=a,this.w*=a);return this},multiply:function(a,b){var c=a.x,d=a.y,e=a.z,f=a.w,g=b.x,h=b.y,i=b.z,j=b.w;
this.x=c*j+d*i-e*h+f*g;this.y=-c*i+d*j+e*g+f*h;this.z=c*h-d*g+e*j+f*i;this.w=-c*g-d*h-e*i+f*j;return this},multiplySelf:function(a){var b=this.x,c=this.y,d=this.z,e=this.w,f=a.x,g=a.y,h=a.z,a=a.w;this.x=b*a+e*f+c*h-d*g;this.y=c*a+e*g+d*f-b*h;this.z=d*a+e*h+b*g-c*f;this.w=e*a-b*f-c*g-d*h;return this},multiplyVector3:function(a,b){b||(b=a);var c=a.x,d=a.y,e=a.z,f=this.x,g=this.y,h=this.z,i=this.w,j=i*c+g*e-h*d,l=i*d+h*c-f*e,m=i*e+f*d-g*c,c=-f*c-g*d-h*e;b.x=j*i+c*-f+l*-h-m*-g;b.y=l*i+c*-g+m*-f-j*-h;
b.z=m*i+c*-h+j*-g-l*-f;return b},slerpSelf:function(a,b){var c=this.x,d=this.y,e=this.z,f=this.w,g=f*a.w+c*a.x+d*a.y+e*a.z;0>g?(this.w=-a.w,this.x=-a.x,this.y=-a.y,this.z=-a.z,g=-g):this.copy(a);if(1<=g)return this.w=f,this.x=c,this.y=d,this.z=e,this;var h=Math.acos(g),i=Math.sqrt(1-g*g);if(0.001>Math.abs(i))return this.w=0.5*(f+this.w),this.x=0.5*(c+this.x),this.y=0.5*(d+this.y),this.z=0.5*(e+this.z),this;g=Math.sin((1-b)*h)/i;h=Math.sin(b*h)/i;this.w=f*g+this.w*h;this.x=c*g+this.x*h;this.y=d*g+
this.y*h;this.z=e*g+this.z*h;return this},clone:function(){return new THREE.Quaternion(this.x,this.y,this.z,this.w)}};
THREE.Quaternion.slerp=function(a,b,c,d){var e=a.w*b.w+a.x*b.x+a.y*b.y+a.z*b.z;0>e?(c.w=-b.w,c.x=-b.x,c.y=-b.y,c.z=-b.z,e=-e):c.copy(b);if(1<=Math.abs(e))return c.w=a.w,c.x=a.x,c.y=a.y,c.z=a.z,c;var b=Math.acos(e),f=Math.sqrt(1-e*e);if(0.001>Math.abs(f))return c.w=0.5*(a.w+c.w),c.x=0.5*(a.x+c.x),c.y=0.5*(a.y+c.y),c.z=0.5*(a.z+c.z),c;e=Math.sin((1-d)*b)/f;d=Math.sin(d*b)/f;c.w=a.w*e+c.w*d;c.x=a.x*e+c.x*d;c.y=a.y*e+c.y*d;c.z=a.z*e+c.z*d;return c};
THREE.Vertex=function(a){console.warn("THREE.Vertex has been DEPRECATED. Use THREE.Vector3 instead.");return a};THREE.Face3=function(a,b,c,d,e,f){this.a=a;this.b=b;this.c=c;this.normal=d instanceof THREE.Vector3?d:new THREE.Vector3;this.vertexNormals=d instanceof Array?d:[];this.color=e instanceof THREE.Color?e:new THREE.Color;this.vertexColors=e instanceof Array?e:[];this.vertexTangents=[];this.materialIndex=f;this.centroid=new THREE.Vector3};
THREE.Face3.prototype={constructor:THREE.Face3,clone:function(){var a=new THREE.Face3(this.a,this.b,this.c);a.normal.copy(this.normal);a.color.copy(this.color);a.centroid.copy(this.centroid);a.materialIndex=this.materialIndex;var b,c;b=0;for(c=this.vertexNormals.length;b<c;b++)a.vertexNormals[b]=this.vertexNormals[b].clone();b=0;for(c=this.vertexColors.length;b<c;b++)a.vertexColors[b]=this.vertexColors[b].clone();b=0;for(c=this.vertexTangents.length;b<c;b++)a.vertexTangents[b]=this.vertexTangents[b].clone();
return a}};THREE.Face4=function(a,b,c,d,e,f,g){this.a=a;this.b=b;this.c=c;this.d=d;this.normal=e instanceof THREE.Vector3?e:new THREE.Vector3;this.vertexNormals=e instanceof Array?e:[];this.color=f instanceof THREE.Color?f:new THREE.Color;this.vertexColors=f instanceof Array?f:[];this.vertexTangents=[];this.materialIndex=g;this.centroid=new THREE.Vector3};
THREE.Face4.prototype={constructor:THREE.Face4,clone:function(){var a=new THREE.Face4(this.a,this.b,this.c,this.d);a.normal.copy(this.normal);a.color.copy(this.color);a.centroid.copy(this.centroid);a.materialIndex=this.materialIndex;var b,c;b=0;for(c=this.vertexNormals.length;b<c;b++)a.vertexNormals[b]=this.vertexNormals[b].clone();b=0;for(c=this.vertexColors.length;b<c;b++)a.vertexColors[b]=this.vertexColors[b].clone();b=0;for(c=this.vertexTangents.length;b<c;b++)a.vertexTangents[b]=this.vertexTangents[b].clone();
return a}};THREE.UV=function(a,b){this.u=a||0;this.v=b||0};THREE.UV.prototype={constructor:THREE.UV,set:function(a,b){this.u=a;this.v=b;return this},copy:function(a){this.u=a.u;this.v=a.v;return this},lerpSelf:function(a,b){this.u+=(a.u-this.u)*b;this.v+=(a.v-this.v)*b;return this},clone:function(){return new THREE.UV(this.u,this.v)}};
THREE.Geometry=function(){THREE.GeometryLibrary.push(this);this.id=THREE.GeometryIdCount++;this.name="";this.vertices=[];this.colors=[];this.materials=[];this.faces=[];this.faceUvs=[[]];this.faceVertexUvs=[[]];this.morphTargets=[];this.morphColors=[];this.morphNormals=[];this.skinWeights=[];this.skinIndices=[];this.boundingSphere=this.boundingBox=null;this.hasTangents=!1;this.dynamic=!0;this.colorsNeedUpdate=this.tangentsNeedUpdate=this.normalsNeedUpdate=this.uvsNeedUpdate=this.elementsNeedUpdate=
this.verticesNeedUpdate=!1};
THREE.Geometry.prototype={constructor:THREE.Geometry,applyMatrix:function(a){var b=new THREE.Matrix4;b.extractRotation(a);for(var c=0,d=this.vertices.length;c<d;c++)a.multiplyVector3(this.vertices[c]);c=0;for(d=this.faces.length;c<d;c++){var e=this.faces[c];b.multiplyVector3(e.normal);for(var f=0,g=e.vertexNormals.length;f<g;f++)b.multiplyVector3(e.vertexNormals[f]);a.multiplyVector3(e.centroid)}},computeCentroids:function(){var a,b,c;a=0;for(b=this.faces.length;a<b;a++)c=this.faces[a],c.centroid.set(0,
0,0),c instanceof THREE.Face3?(c.centroid.addSelf(this.vertices[c.a]),c.centroid.addSelf(this.vertices[c.b]),c.centroid.addSelf(this.vertices[c.c]),c.centroid.divideScalar(3)):c instanceof THREE.Face4&&(c.centroid.addSelf(this.vertices[c.a]),c.centroid.addSelf(this.vertices[c.b]),c.centroid.addSelf(this.vertices[c.c]),c.centroid.addSelf(this.vertices[c.d]),c.centroid.divideScalar(4))},computeFaceNormals:function(){var a,b,c,d,e,f,g=new THREE.Vector3,h=new THREE.Vector3;a=0;for(b=this.faces.length;a<
b;a++)c=this.faces[a],d=this.vertices[c.a],e=this.vertices[c.b],f=this.vertices[c.c],g.sub(f,e),h.sub(d,e),g.crossSelf(h),g.isZero()||g.normalize(),c.normal.copy(g)},computeVertexNormals:function(){var a,b,c,d;if(void 0===this.__tmpVertices){d=this.__tmpVertices=Array(this.vertices.length);a=0;for(b=this.vertices.length;a<b;a++)d[a]=new THREE.Vector3;a=0;for(b=this.faces.length;a<b;a++)c=this.faces[a],c instanceof THREE.Face3?c.vertexNormals=[new THREE.Vector3,new THREE.Vector3,new THREE.Vector3]:
c instanceof THREE.Face4&&(c.vertexNormals=[new THREE.Vector3,new THREE.Vector3,new THREE.Vector3,new THREE.Vector3])}else{d=this.__tmpVertices;a=0;for(b=this.vertices.length;a<b;a++)d[a].set(0,0,0)}a=0;for(b=this.faces.length;a<b;a++)c=this.faces[a],c instanceof THREE.Face3?(d[c.a].addSelf(c.normal),d[c.b].addSelf(c.normal),d[c.c].addSelf(c.normal)):c instanceof THREE.Face4&&(d[c.a].addSelf(c.normal),d[c.b].addSelf(c.normal),d[c.c].addSelf(c.normal),d[c.d].addSelf(c.normal));a=0;for(b=this.vertices.length;a<
b;a++)d[a].normalize();a=0;for(b=this.faces.length;a<b;a++)c=this.faces[a],c instanceof THREE.Face3?(c.vertexNormals[0].copy(d[c.a]),c.vertexNormals[1].copy(d[c.b]),c.vertexNormals[2].copy(d[c.c])):c instanceof THREE.Face4&&(c.vertexNormals[0].copy(d[c.a]),c.vertexNormals[1].copy(d[c.b]),c.vertexNormals[2].copy(d[c.c]),c.vertexNormals[3].copy(d[c.d]))},computeMorphNormals:function(){var a,b,c,d,e;c=0;for(d=this.faces.length;c<d;c++){e=this.faces[c];e.__originalFaceNormal?e.__originalFaceNormal.copy(e.normal):
e.__originalFaceNormal=e.normal.clone();e.__originalVertexNormals||(e.__originalVertexNormals=[]);a=0;for(b=e.vertexNormals.length;a<b;a++)e.__originalVertexNormals[a]?e.__originalVertexNormals[a].copy(e.vertexNormals[a]):e.__originalVertexNormals[a]=e.vertexNormals[a].clone()}var f=new THREE.Geometry;f.faces=this.faces;a=0;for(b=this.morphTargets.length;a<b;a++){if(!this.morphNormals[a]){this.morphNormals[a]={};this.morphNormals[a].faceNormals=[];this.morphNormals[a].vertexNormals=[];var g=this.morphNormals[a].faceNormals,
h=this.morphNormals[a].vertexNormals,i,j;c=0;for(d=this.faces.length;c<d;c++)e=this.faces[c],i=new THREE.Vector3,j=e instanceof THREE.Face3?{a:new THREE.Vector3,b:new THREE.Vector3,c:new THREE.Vector3}:{a:new THREE.Vector3,b:new THREE.Vector3,c:new THREE.Vector3,d:new THREE.Vector3},g.push(i),h.push(j)}g=this.morphNormals[a];f.vertices=this.morphTargets[a].vertices;f.computeFaceNormals();f.computeVertexNormals();c=0;for(d=this.faces.length;c<d;c++)e=this.faces[c],i=g.faceNormals[c],j=g.vertexNormals[c],
i.copy(e.normal),e instanceof THREE.Face3?(j.a.copy(e.vertexNormals[0]),j.b.copy(e.vertexNormals[1]),j.c.copy(e.vertexNormals[2])):(j.a.copy(e.vertexNormals[0]),j.b.copy(e.vertexNormals[1]),j.c.copy(e.vertexNormals[2]),j.d.copy(e.vertexNormals[3]))}c=0;for(d=this.faces.length;c<d;c++)e=this.faces[c],e.normal=e.__originalFaceNormal,e.vertexNormals=e.__originalVertexNormals},computeTangents:function(){function a(a,b,c,d,e,f,y){h=a.vertices[b];i=a.vertices[c];j=a.vertices[d];l=g[e];m=g[f];n=g[y];p=i.x-
h.x;o=j.x-h.x;q=i.y-h.y;r=j.y-h.y;t=i.z-h.z;B=j.z-h.z;u=m.u-l.u;s=n.u-l.u;z=m.v-l.v;A=n.v-l.v;v=1/(u*A-s*z);H.set((A*p-z*o)*v,(A*q-z*r)*v,(A*t-z*B)*v);J.set((u*o-s*p)*v,(u*r-s*q)*v,(u*B-s*t)*v);C[b].addSelf(H);C[c].addSelf(H);C[d].addSelf(H);G[b].addSelf(J);G[c].addSelf(J);G[d].addSelf(J)}var b,c,d,e,f,g,h,i,j,l,m,n,p,o,q,r,t,B,u,s,z,A,v,y,C=[],G=[],H=new THREE.Vector3,J=new THREE.Vector3,E=new THREE.Vector3,M=new THREE.Vector3,K=new THREE.Vector3;b=0;for(c=this.vertices.length;b<c;b++)C[b]=new THREE.Vector3,
G[b]=new THREE.Vector3;b=0;for(c=this.faces.length;b<c;b++)f=this.faces[b],g=this.faceVertexUvs[0][b],f instanceof THREE.Face3?a(this,f.a,f.b,f.c,0,1,2):f instanceof THREE.Face4&&(a(this,f.a,f.b,f.d,0,1,3),a(this,f.b,f.c,f.d,1,2,3));var F=["a","b","c","d"];b=0;for(c=this.faces.length;b<c;b++){f=this.faces[b];for(d=0;d<f.vertexNormals.length;d++)K.copy(f.vertexNormals[d]),e=f[F[d]],y=C[e],E.copy(y),E.subSelf(K.multiplyScalar(K.dot(y))).normalize(),M.cross(f.vertexNormals[d],y),e=M.dot(G[e]),e=0>e?
-1:1,f.vertexTangents[d]=new THREE.Vector4(E.x,E.y,E.z,e)}this.hasTangents=!0},computeBoundingBox:function(){this.boundingBox||(this.boundingBox={min:new THREE.Vector3,max:new THREE.Vector3});if(0<this.vertices.length){var a;a=this.vertices[0];this.boundingBox.min.copy(a);this.boundingBox.max.copy(a);for(var b=this.boundingBox.min,c=this.boundingBox.max,d=1,e=this.vertices.length;d<e;d++)(a=this.vertices[d],a.x<b.x?b.x=a.x:a.x>c.x&&(c.x=a.x),a.y<b.y?b.y=a.y:a.y>c.y&&(c.y=a.y),a.z<b.z)?b.z=a.z:a.z>
c.z&&(c.z=a.z)}else this.boundingBox.min.set(0,0,0),this.boundingBox.max.set(0,0,0)},computeBoundingSphere:function(){var a=0;null===this.boundingSphere&&(this.boundingSphere={radius:0});for(var b=0,c=this.vertices.length;b<c;b++){var d=this.vertices[b].lengthSq();d>a&&(a=d)}this.boundingSphere.radius=Math.sqrt(a)},mergeVertices:function(){var a={},b=[],c=[],d,e=Math.pow(10,4),f,g,h,i;f=0;for(g=this.vertices.length;f<g;f++)d=this.vertices[f],d=[Math.round(d.x*e),Math.round(d.y*e),Math.round(d.z*e)].join("_"),
void 0===a[d]?(a[d]=f,b.push(this.vertices[f]),c[f]=b.length-1):c[f]=c[a[d]];f=0;for(g=this.faces.length;f<g;f++)if(a=this.faces[f],a instanceof THREE.Face3)a.a=c[a.a],a.b=c[a.b],a.c=c[a.c];else if(a instanceof THREE.Face4){a.a=c[a.a];a.b=c[a.b];a.c=c[a.c];a.d=c[a.d];d=[a.a,a.b,a.c,a.d];for(e=3;0<e;e--)if(d.indexOf(a["abcd"[e]])!==e){d.splice(e,1);this.faces[f]=new THREE.Face3(d[0],d[1],d[2],a.normal,a.color,a.materialIndex);d=0;for(h=this.faceVertexUvs.length;d<h;d++)(i=this.faceVertexUvs[d][f])&&
i.splice(e,1);this.faces[f].vertexColors=a.vertexColors;break}}c=this.vertices.length-b.length;this.vertices=b;return c},clone:function(){},deallocate:function(){var a=THREE.GeometryLibrary.indexOf(this);-1!==a&&THREE.GeometryLibrary.splice(a,1)}};THREE.GeometryIdCount=0;THREE.GeometryLibrary=[];THREE.BufferGeometry=function(){this.id=THREE.GeometryCount++;this.attributes={};this.dynamic=!1;this.boundingSphere=this.boundingBox=null;this.hasTangents=!1;this.morphTargets=[]};
THREE.BufferGeometry.prototype={constructor:THREE.BufferGeometry,applyMatrix:function(a){var b,c;this.attributes.position&&(b=this.attributes.position.array);this.attributes.normal&&(c=this.attributes.normal.array);void 0!==b&&(a.multiplyVector3Array(b),this.verticesNeedUpdate=!0);void 0!==c&&(b=new THREE.Matrix4,b.extractRotation(a),b.multiplyVector3Array(c),this.normalsNeedUpdate=!0)},computeBoundingBox:function(){this.boundingBox||(this.boundingBox={min:new THREE.Vector3(Infinity,Infinity,Infinity),
max:new THREE.Vector3(-Infinity,-Infinity,-Infinity)});var a=this.attributes.position.array;if(a)for(var b=this.boundingBox,c,d,e,f=0,g=a.length;f<g;f+=3)(c=a[f],d=a[f+1],e=a[f+2],c<b.min.x?b.min.x=c:c>b.max.x&&(b.max.x=c),d<b.min.y?b.min.y=d:d>b.max.y&&(b.max.y=d),e<b.min.z)?b.min.z=e:e>b.max.z&&(b.max.z=e);if(void 0===a||0===a.length)this.boundingBox.min.set(0,0,0),this.boundingBox.max.set(0,0,0)},computeBoundingSphere:function(){this.boundingSphere||(this.boundingSphere={radius:0});var a=this.attributes.position.array;
if(a){for(var b,c=0,d,e,f=0,g=a.length;f<g;f+=3)b=a[f],d=a[f+1],e=a[f+2],b=b*b+d*d+e*e,b>c&&(c=b);this.boundingSphere.radius=Math.sqrt(c)}},computeVertexNormals:function(){if(this.attributes.position&&this.attributes.index){var a,b,c,d;a=this.attributes.position.array.length;if(void 0===this.attributes.normal)this.attributes.normal={itemSize:3,array:new Float32Array(a),numItems:a};else{a=0;for(b=this.attributes.normal.array.length;a<b;a++)this.attributes.normal.array[a]=0}var e=this.offsets,f=this.attributes.index.array,
g=this.attributes.position.array,h=this.attributes.normal.array,i,j,l,m,n,p,o=new THREE.Vector3,q=new THREE.Vector3,r=new THREE.Vector3,t=new THREE.Vector3,B=new THREE.Vector3;c=0;for(d=e.length;c<d;++c){b=e[c].start;i=e[c].count;var u=e[c].index;a=b;for(b+=i;a<b;a+=3)i=u+f[a],j=u+f[a+1],l=u+f[a+2],m=g[3*i],n=g[3*i+1],p=g[3*i+2],o.set(m,n,p),m=g[3*j],n=g[3*j+1],p=g[3*j+2],q.set(m,n,p),m=g[3*l],n=g[3*l+1],p=g[3*l+2],r.set(m,n,p),t.sub(r,q),B.sub(o,q),t.crossSelf(B),h[3*i]+=t.x,h[3*i+1]+=t.y,h[3*i+
2]+=t.z,h[3*j]+=t.x,h[3*j+1]+=t.y,h[3*j+2]+=t.z,h[3*l]+=t.x,h[3*l+1]+=t.y,h[3*l+2]+=t.z}a=0;for(b=h.length;a<b;a+=3)m=h[a],n=h[a+1],p=h[a+2],c=1/Math.sqrt(m*m+n*n+p*p),h[a]*=c,h[a+1]*=c,h[a+2]*=c;this.normalsNeedUpdate=!0}},computeTangents:function(){function a(a){$.x=d[3*a];$.y=d[3*a+1];$.z=d[3*a+2];Y.copy($);ea=i[a];L.copy(ea);L.subSelf($.multiplyScalar($.dot(ea))).normalize();R.cross(Y,ea);Q=R.dot(j[a]);N=0>Q?-1:1;h[4*a]=L.x;h[4*a+1]=L.y;h[4*a+2]=L.z;h[4*a+3]=N}if(void 0===this.attributes.index||
void 0===this.attributes.position||void 0===this.attributes.normal||void 0===this.attributes.uv)console.warn("Missing required attributes (index, position, normal or uv) in BufferGeometry.computeTangents()");else{var b=this.attributes.index.array,c=this.attributes.position.array,d=this.attributes.normal.array,e=this.attributes.uv.array,f=c.length/3;if(void 0===this.attributes.tangent){var g=4*f;this.attributes.tangent={itemSize:4,array:new Float32Array(g),numItems:g}}for(var h=this.attributes.tangent.array,
i=[],j=[],g=0;g<f;g++)i[g]=new THREE.Vector3,j[g]=new THREE.Vector3;var l,m,n,p,o,q,r,t,B,u,s,z,A,v,y,f=new THREE.Vector3,g=new THREE.Vector3,C,G,H,J,E,M,K,F=this.offsets;H=0;for(J=F.length;H<J;++H){G=F[H].start;E=F[H].count;var I=F[H].index;C=G;for(G+=E;C<G;C+=3)E=I+b[C],M=I+b[C+1],K=I+b[C+2],l=c[3*E],m=c[3*E+1],n=c[3*E+2],p=c[3*M],o=c[3*M+1],q=c[3*M+2],r=c[3*K],t=c[3*K+1],B=c[3*K+2],u=e[2*E],s=e[2*E+1],z=e[2*M],A=e[2*M+1],v=e[2*K],y=e[2*K+1],p-=l,l=r-l,o-=m,m=t-m,q-=n,n=B-n,z-=u,u=v-u,A-=s,s=y-
s,y=1/(z*s-u*A),f.set((s*p-A*l)*y,(s*o-A*m)*y,(s*q-A*n)*y),g.set((z*l-u*p)*y,(z*m-u*o)*y,(z*n-u*q)*y),i[E].addSelf(f),i[M].addSelf(f),i[K].addSelf(f),j[E].addSelf(g),j[M].addSelf(g),j[K].addSelf(g)}var L=new THREE.Vector3,R=new THREE.Vector3,$=new THREE.Vector3,Y=new THREE.Vector3,N,ea,Q;H=0;for(J=F.length;H<J;++H){G=F[H].start;E=F[H].count;I=F[H].index;C=G;for(G+=E;C<G;C+=3)E=I+b[C],M=I+b[C+1],K=I+b[C+2],a(E),a(M),a(K)}this.tangentsNeedUpdate=this.hasTangents=!0}}};
THREE.Spline=function(a){function b(a,b,c,d,e,f,g){a=0.5*(c-a);d=0.5*(d-b);return(2*(b-c)+a+d)*g+(-3*(b-c)-2*a-d)*f+a*e+b}this.points=a;var c=[],d={x:0,y:0,z:0},e,f,g,h,i,j,l,m,n;this.initFromArray=function(a){this.points=[];for(var b=0;b<a.length;b++)this.points[b]={x:a[b][0],y:a[b][1],z:a[b][2]}};this.getPoint=function(a){e=(this.points.length-1)*a;f=Math.floor(e);g=e-f;c[0]=0===f?f:f-1;c[1]=f;c[2]=f>this.points.length-2?this.points.length-1:f+1;c[3]=f>this.points.length-3?this.points.length-1:
f+2;j=this.points[c[0]];l=this.points[c[1]];m=this.points[c[2]];n=this.points[c[3]];h=g*g;i=g*h;d.x=b(j.x,l.x,m.x,n.x,g,h,i);d.y=b(j.y,l.y,m.y,n.y,g,h,i);d.z=b(j.z,l.z,m.z,n.z,g,h,i);return d};this.getControlPointsArray=function(){var a,b,c=this.points.length,d=[];for(a=0;a<c;a++)b=this.points[a],d[a]=[b.x,b.y,b.z];return d};this.getLength=function(a){var b,c,d,e=b=b=0,f=new THREE.Vector3,g=new THREE.Vector3,h=[],i=0;h[0]=0;a||(a=100);c=this.points.length*a;f.copy(this.points[0]);for(a=1;a<c;a++)b=
a/c,d=this.getPoint(b),g.copy(d),i+=g.distanceTo(f),f.copy(d),b*=this.points.length-1,b=Math.floor(b),b!=e&&(h[b]=i,e=b);h[h.length]=i;return{chunks:h,total:i}};this.reparametrizeByArcLength=function(a){var b,c,d,e,f,g,h=[],i=new THREE.Vector3,l=this.getLength();h.push(i.copy(this.points[0]).clone());for(b=1;b<this.points.length;b++){c=l.chunks[b]-l.chunks[b-1];g=Math.ceil(a*c/l.total);e=(b-1)/(this.points.length-1);f=b/(this.points.length-1);for(c=1;c<g-1;c++)d=e+c*(1/g)*(f-e),d=this.getPoint(d),
h.push(i.copy(d).clone());h.push(i.copy(this.points[b]).clone())}this.points=h}};THREE.Camera=function(){THREE.Object3D.call(this);this.matrixWorldInverse=new THREE.Matrix4;this.projectionMatrix=new THREE.Matrix4;this.projectionMatrixInverse=new THREE.Matrix4};THREE.Camera.prototype=Object.create(THREE.Object3D.prototype);THREE.Camera.prototype.lookAt=function(a){this.matrix.lookAt(this.position,a,this.up);!0===this.rotationAutoUpdate&&this.rotation.setEulerFromRotationMatrix(this.matrix,this.eulerOrder)};
THREE.OrthographicCamera=function(a,b,c,d,e,f){THREE.Camera.call(this);this.left=a;this.right=b;this.top=c;this.bottom=d;this.near=void 0!==e?e:0.1;this.far=void 0!==f?f:2E3;this.updateProjectionMatrix()};THREE.OrthographicCamera.prototype=Object.create(THREE.Camera.prototype);THREE.OrthographicCamera.prototype.updateProjectionMatrix=function(){this.projectionMatrix.makeOrthographic(this.left,this.right,this.top,this.bottom,this.near,this.far)};
THREE.PerspectiveCamera=function(a,b,c,d){THREE.Camera.call(this);this.fov=void 0!==a?a:50;this.aspect=void 0!==b?b:1;this.near=void 0!==c?c:0.1;this.far=void 0!==d?d:2E3;this.updateProjectionMatrix()};THREE.PerspectiveCamera.prototype=Object.create(THREE.Camera.prototype);THREE.PerspectiveCamera.prototype.setLens=function(a,b){void 0===b&&(b=24);this.fov=2*Math.atan(b/(2*a))*(180/Math.PI);this.updateProjectionMatrix()};
THREE.PerspectiveCamera.prototype.setViewOffset=function(a,b,c,d,e,f){this.fullWidth=a;this.fullHeight=b;this.x=c;this.y=d;this.width=e;this.height=f;this.updateProjectionMatrix()};
THREE.PerspectiveCamera.prototype.updateProjectionMatrix=function(){if(this.fullWidth){var a=this.fullWidth/this.fullHeight,b=Math.tan(this.fov*Math.PI/360)*this.near,c=-b,d=a*c,a=Math.abs(a*b-d),c=Math.abs(b-c);this.projectionMatrix.makeFrustum(d+this.x*a/this.fullWidth,d+(this.x+this.width)*a/this.fullWidth,b-(this.y+this.height)*c/this.fullHeight,b-this.y*c/this.fullHeight,this.near,this.far)}else this.projectionMatrix.makePerspective(this.fov,this.aspect,this.near,this.far)};
THREE.Light=function(a){THREE.Object3D.call(this);this.color=new THREE.Color(a)};THREE.Light.prototype=Object.create(THREE.Object3D.prototype);THREE.AmbientLight=function(a){THREE.Light.call(this,a)};THREE.AmbientLight.prototype=Object.create(THREE.Light.prototype);
THREE.DirectionalLight=function(a,b,c){THREE.Light.call(this,a);this.position=new THREE.Vector3(0,1,0);this.target=new THREE.Object3D;this.intensity=void 0!==b?b:1;this.distance=void 0!==c?c:0;this.onlyShadow=this.castShadow=!1;this.shadowCameraNear=50;this.shadowCameraFar=5E3;this.shadowCameraLeft=-500;this.shadowCameraTop=this.shadowCameraRight=500;this.shadowCameraBottom=-500;this.shadowCameraVisible=!1;this.shadowBias=0;this.shadowDarkness=0.5;this.shadowMapHeight=this.shadowMapWidth=512;this.shadowCascade=
!1;this.shadowCascadeOffset=new THREE.Vector3(0,0,-1E3);this.shadowCascadeCount=2;this.shadowCascadeBias=[0,0,0];this.shadowCascadeWidth=[512,512,512];this.shadowCascadeHeight=[512,512,512];this.shadowCascadeNearZ=[-1,0.99,0.998];this.shadowCascadeFarZ=[0.99,0.998,1];this.shadowCascadeArray=[];this.shadowMatrix=this.shadowCamera=this.shadowMapSize=this.shadowMap=null};THREE.DirectionalLight.prototype=Object.create(THREE.Light.prototype);
THREE.HemisphereLight=function(a,b,c){THREE.Light.call(this,a);this.groundColor=new THREE.Color(b);this.position=new THREE.Vector3(0,100,0);this.intensity=void 0!==c?c:1};THREE.HemisphereLight.prototype=Object.create(THREE.Light.prototype);THREE.PointLight=function(a,b,c){THREE.Light.call(this,a);this.position=new THREE.Vector3(0,0,0);this.intensity=void 0!==b?b:1;this.distance=void 0!==c?c:0};THREE.PointLight.prototype=Object.create(THREE.Light.prototype);
THREE.SpotLight=function(a,b,c,d,e){THREE.Light.call(this,a);this.position=new THREE.Vector3(0,1,0);this.target=new THREE.Object3D;this.intensity=void 0!==b?b:1;this.distance=void 0!==c?c:0;this.angle=void 0!==d?d:Math.PI/2;this.exponent=void 0!==e?e:10;this.onlyShadow=this.castShadow=!1;this.shadowCameraNear=50;this.shadowCameraFar=5E3;this.shadowCameraFov=50;this.shadowCameraVisible=!1;this.shadowBias=0;this.shadowDarkness=0.5;this.shadowMapHeight=this.shadowMapWidth=512;this.shadowMatrix=this.shadowCamera=
this.shadowMapSize=this.shadowMap=null};THREE.SpotLight.prototype=Object.create(THREE.Light.prototype);THREE.Loader=function(a){this.statusDomElement=(this.showStatus=a)?THREE.Loader.prototype.addStatusElement():null;this.onLoadStart=function(){};this.onLoadProgress=function(){};this.onLoadComplete=function(){}};
THREE.Loader.prototype={constructor:THREE.Loader,crossOrigin:"anonymous",addStatusElement:function(){var a=document.createElement("div");a.style.position="absolute";a.style.right="0px";a.style.top="0px";a.style.fontSize="0.8em";a.style.textAlign="left";a.style.background="rgba(0,0,0,0.25)";a.style.color="#fff";a.style.width="120px";a.style.padding="0.5em 0.5em 0.5em 0.5em";a.style.zIndex=1E3;a.innerHTML="Loading ...";return a},updateProgress:function(a){var b="Loaded ",b=a.total?b+((100*a.loaded/
a.total).toFixed(0)+"%"):b+((a.loaded/1E3).toFixed(2)+" KB");this.statusDomElement.innerHTML=b},extractUrlBase:function(a){a=a.split("/");a.pop();return(1>a.length?".":a.join("/"))+"/"},initMaterials:function(a,b,c){a.materials=[];for(var d=0;d<b.length;++d)a.materials[d]=THREE.Loader.prototype.createMaterial(b[d],c)},hasNormals:function(a){var b,c,d=a.materials.length;for(c=0;c<d;c++)if(b=a.materials[c],b instanceof THREE.ShaderMaterial)return!0;return!1},createMaterial:function(a,b){function c(a){a=
Math.log(a)/Math.LN2;return Math.floor(a)==a}function d(a){a=Math.log(a)/Math.LN2;return Math.pow(2,Math.round(a))}function e(a,e,f,h,i,j,r){var t=f.toLowerCase().endsWith(".dds"),B=b+"/"+f;if(t){var u=THREE.ImageUtils.loadCompressedTexture(B);a[e]=u}else u=document.createElement("canvas"),a[e]=new THREE.Texture(u);a[e].sourceFile=f;if(h&&(a[e].repeat.set(h[0],h[1]),1!==h[0]&&(a[e].wrapS=THREE.RepeatWrapping),1!==h[1]))a[e].wrapT=THREE.RepeatWrapping;i&&a[e].offset.set(i[0],i[1]);if(j&&(f={repeat:THREE.RepeatWrapping,
mirror:THREE.MirroredRepeatWrapping},void 0!==f[j[0]]&&(a[e].wrapS=f[j[0]]),void 0!==f[j[1]]))a[e].wrapT=f[j[1]];r&&(a[e].anisotropy=r);if(!t){var s=a[e],a=new Image;a.onload=function(){if(!c(this.width)||!c(this.height)){var a=d(this.width),b=d(this.height);s.image.width=a;s.image.height=b;s.image.getContext("2d").drawImage(this,0,0,a,b)}else s.image=this;s.needsUpdate=true};a.crossOrigin=g.crossOrigin;a.src=B}}function f(a){return(255*a[0]<<16)+(255*a[1]<<8)+255*a[2]}var g=this,h="MeshLambertMaterial",
i={color:15658734,opacity:1,map:null,lightMap:null,normalMap:null,bumpMap:null,wireframe:!1};if(a.shading){var j=a.shading.toLowerCase();"phong"===j?h="MeshPhongMaterial":"basic"===j&&(h="MeshBasicMaterial")}void 0!==a.blending&&void 0!==THREE[a.blending]&&(i.blending=THREE[a.blending]);if(void 0!==a.transparent||1>a.opacity)i.transparent=a.transparent;void 0!==a.depthTest&&(i.depthTest=a.depthTest);void 0!==a.depthWrite&&(i.depthWrite=a.depthWrite);void 0!==a.visible&&(i.visible=a.visible);void 0!==
a.flipSided&&(i.side=THREE.BackSide);void 0!==a.doubleSided&&(i.side=THREE.DoubleSide);void 0!==a.wireframe&&(i.wireframe=a.wireframe);void 0!==a.vertexColors&&("face"===a.vertexColors?i.vertexColors=THREE.FaceColors:a.vertexColors&&(i.vertexColors=THREE.VertexColors));a.colorDiffuse?i.color=f(a.colorDiffuse):a.DbgColor&&(i.color=a.DbgColor);a.colorSpecular&&(i.specular=f(a.colorSpecular));a.colorAmbient&&(i.ambient=f(a.colorAmbient));a.transparency&&(i.opacity=a.transparency);a.specularCoef&&(i.shininess=
a.specularCoef);a.mapDiffuse&&b&&e(i,"map",a.mapDiffuse,a.mapDiffuseRepeat,a.mapDiffuseOffset,a.mapDiffuseWrap,a.mapDiffuseAnisotropy);a.mapLight&&b&&e(i,"lightMap",a.mapLight,a.mapLightRepeat,a.mapLightOffset,a.mapLightWrap,a.mapLightAnisotropy);a.mapBump&&b&&e(i,"bumpMap",a.mapBump,a.mapBumpRepeat,a.mapBumpOffset,a.mapBumpWrap,a.mapBumpAnisotropy);a.mapNormal&&b&&e(i,"normalMap",a.mapNormal,a.mapNormalRepeat,a.mapNormalOffset,a.mapNormalWrap,a.mapNormalAnisotropy);a.mapSpecular&&b&&e(i,"specularMap",
a.mapSpecular,a.mapSpecularRepeat,a.mapSpecularOffset,a.mapSpecularWrap,a.mapSpecularAnisotropy);a.mapBumpScale&&(i.bumpScale=a.mapBumpScale);a.mapNormal?(h=THREE.ShaderUtils.lib.normal,j=THREE.UniformsUtils.clone(h.uniforms),j.tNormal.value=i.normalMap,a.mapNormalFactor&&j.uNormalScale.value.set(a.mapNormalFactor,a.mapNormalFactor),i.map&&(j.tDiffuse.value=i.map,j.enableDiffuse.value=!0),i.specularMap&&(j.tSpecular.value=i.specularMap,j.enableSpecular.value=!0),i.lightMap&&(j.tAO.value=i.lightMap,
j.enableAO.value=!0),j.uDiffuseColor.value.setHex(i.color),j.uSpecularColor.value.setHex(i.specular),j.uAmbientColor.value.setHex(i.ambient),j.uShininess.value=i.shininess,void 0!==i.opacity&&(j.uOpacity.value=i.opacity),i=new THREE.ShaderMaterial({fragmentShader:h.fragmentShader,vertexShader:h.vertexShader,uniforms:j,lights:!0,fog:!0})):i=new THREE[h](i);void 0!==a.DbgName&&(i.name=a.DbgName);return i}};THREE.BinaryLoader=function(a){THREE.Loader.call(this,a)};THREE.BinaryLoader.prototype=Object.create(THREE.Loader.prototype);
THREE.BinaryLoader.prototype.load=function(a,b,c,d){var c=c?c:this.extractUrlBase(a),d=d?d:this.extractUrlBase(a),e=this.showProgress?THREE.Loader.prototype.updateProgress:null;this.onLoadStart();this.loadAjaxJSON(this,a,b,c,d,e)};
THREE.BinaryLoader.prototype.loadAjaxJSON=function(a,b,c,d,e,f){var g=new XMLHttpRequest;g.onreadystatechange=function(){if(4==g.readyState)if(200==g.status||0==g.status){var h=JSON.parse(g.responseText);a.loadAjaxBuffers(h,c,e,d,f)}else console.error("THREE.BinaryLoader: Couldn't load ["+b+"] ["+g.status+"]")};g.open("GET",b,!0);g.send(null)};
THREE.BinaryLoader.prototype.loadAjaxBuffers=function(a,b,c,d,e){var f=new XMLHttpRequest,g=c+"/"+a.buffers,h=0;f.onreadystatechange=function(){if(4==f.readyState)if(200==f.status||0==f.status){var c=f.response;void 0===c&&(c=(new Uint8Array(f.responseBody)).buffer);THREE.BinaryLoader.prototype.createBinModel(c,b,d,a.materials)}else console.error("THREE.BinaryLoader: Couldn't load ["+g+"] ["+f.status+"]");else 3==f.readyState?e&&(0==h&&(h=f.getResponseHeader("Content-Length")),e({total:h,loaded:f.responseText.length})):
2==f.readyState&&(h=f.getResponseHeader("Content-Length"))};f.open("GET",g,!0);f.responseType="arraybuffer";f.send(null)};
THREE.BinaryLoader.prototype.createBinModel=function(a,b,c,d){var e=function(b){var c,e,i,j,l,m,n,p,o,q,r,t,B,u,s;function z(a){return a%4?4-a%4:0}function A(a,b){return(new Uint8Array(a,b,1))[0]}function v(a,b){return(new Uint32Array(a,b,1))[0]}function y(b,c){var d,e,f,g,h,i,j,l,m=new Uint32Array(a,c,3*b);for(d=0;d<b;d++){e=m[3*d];f=m[3*d+1];g=m[3*d+2];h=I[2*e];e=I[2*e+1];i=I[2*f];j=I[2*f+1];f=I[2*g];l=I[2*g+1];g=M.faceVertexUvs[0];var n=[];n.push(new THREE.UV(h,e));n.push(new THREE.UV(i,j));n.push(new THREE.UV(f,
l));g.push(n)}}function C(b,c){var d,e,f,g,h,i,j,l,m,n,o=new Uint32Array(a,c,4*b);for(d=0;d<b;d++){e=o[4*d];f=o[4*d+1];g=o[4*d+2];h=o[4*d+3];i=I[2*e];e=I[2*e+1];j=I[2*f];m=I[2*f+1];l=I[2*g];n=I[2*g+1];g=I[2*h];f=I[2*h+1];h=M.faceVertexUvs[0];var p=[];p.push(new THREE.UV(i,e));p.push(new THREE.UV(j,m));p.push(new THREE.UV(l,n));p.push(new THREE.UV(g,f));h.push(p)}}function G(b,c,d){for(var e,f,g,h,c=new Uint32Array(a,c,3*b),i=new Uint16Array(a,d,b),d=0;d<b;d++)e=c[3*d],f=c[3*d+1],g=c[3*d+2],h=i[d],
M.faces.push(new THREE.Face3(e,f,g,null,null,h))}function H(b,c,d){for(var e,f,g,h,i,c=new Uint32Array(a,c,4*b),j=new Uint16Array(a,d,b),d=0;d<b;d++)e=c[4*d],f=c[4*d+1],g=c[4*d+2],h=c[4*d+3],i=j[d],M.faces.push(new THREE.Face4(e,f,g,h,null,null,i))}function J(b,c,d,e){for(var f,g,h,i,j,l,m,c=new Uint32Array(a,c,3*b),d=new Uint32Array(a,d,3*b),n=new Uint16Array(a,e,b),e=0;e<b;e++){f=c[3*e];g=c[3*e+1];h=c[3*e+2];j=d[3*e];l=d[3*e+1];m=d[3*e+2];i=n[e];var o=F[3*l],p=F[3*l+1];l=F[3*l+2];var q=F[3*m],r=
F[3*m+1];m=F[3*m+2];M.faces.push(new THREE.Face3(f,g,h,[new THREE.Vector3(F[3*j],F[3*j+1],F[3*j+2]),new THREE.Vector3(o,p,l),new THREE.Vector3(q,r,m)],null,i))}}function E(b,c,d,e){for(var f,g,h,i,j,l,m,n,o,c=new Uint32Array(a,c,4*b),d=new Uint32Array(a,d,4*b),p=new Uint16Array(a,e,b),e=0;e<b;e++){f=c[4*e];g=c[4*e+1];h=c[4*e+2];i=c[4*e+3];l=d[4*e];m=d[4*e+1];n=d[4*e+2];o=d[4*e+3];j=p[e];var q=F[3*m],r=F[3*m+1];m=F[3*m+2];var s=F[3*n],t=F[3*n+1];n=F[3*n+2];var u=F[3*o],v=F[3*o+1];o=F[3*o+2];M.faces.push(new THREE.Face4(f,
g,h,i,[new THREE.Vector3(F[3*l],F[3*l+1],F[3*l+2]),new THREE.Vector3(q,r,m),new THREE.Vector3(s,t,n),new THREE.Vector3(u,v,o)],null,j))}}var M=this,K=0,F=[],I=[],L,R,$;THREE.Geometry.call(this);THREE.Loader.prototype.initMaterials(M,d,b);s=a;R=K;b=new Uint8Array(s,R,12);q="";for(B=0;12>B;B++)q+=String.fromCharCode(b[R+B]);c=A(s,R+12);A(s,R+13);A(s,R+14);A(s,R+15);e=A(s,R+16);i=A(s,R+17);j=A(s,R+18);l=A(s,R+19);m=v(s,R+20);n=v(s,R+20+4);p=v(s,R+20+8);o=v(s,R+20+12);q=v(s,R+20+16);r=v(s,R+20+20);t=
v(s,R+20+24);B=v(s,R+20+28);b=v(s,R+20+32);u=v(s,R+20+36);s=v(s,R+20+40);K+=c;R=3*e+l;$=4*e+l;L=o*R;c=q*(R+3*i);e=r*(R+3*j);l=t*(R+3*i+3*j);R=B*$;i=b*($+4*i);j=u*($+4*j);$=K;var K=new Float32Array(a,K,3*m),Y,N,ea,Q;for(Y=0;Y<m;Y++)N=K[3*Y],ea=K[3*Y+1],Q=K[3*Y+2],M.vertices.push(new THREE.Vector3(N,ea,Q));m=K=$+3*m*Float32Array.BYTES_PER_ELEMENT;if(n){K=new Int8Array(a,K,3*n);for($=0;$<n;$++)Y=K[3*$],N=K[3*$+1],ea=K[3*$+2],F.push(Y/127,N/127,ea/127)}K=m+3*n*Int8Array.BYTES_PER_ELEMENT;n=K+=z(3*n);
if(p){K=new Float32Array(a,K,2*p);for(m=0;m<p;m++)$=K[2*m],Y=K[2*m+1],I.push($,Y)}p=K=n+2*p*Float32Array.BYTES_PER_ELEMENT;L=p+L+z(2*o);n=L+c+z(2*q);c=n+e+z(2*r);e=c+l+z(2*t);R=e+R+z(2*B);l=R+i+z(2*b);i=l+j+z(2*u);r&&(j=n+3*r*Uint32Array.BYTES_PER_ELEMENT,G(r,n,j+3*r*Uint32Array.BYTES_PER_ELEMENT),y(r,j));t&&(r=c+3*t*Uint32Array.BYTES_PER_ELEMENT,j=r+3*t*Uint32Array.BYTES_PER_ELEMENT,J(t,c,r,j+3*t*Uint32Array.BYTES_PER_ELEMENT),y(t,j));u&&(t=l+4*u*Uint32Array.BYTES_PER_ELEMENT,H(u,l,t+4*u*Uint32Array.BYTES_PER_ELEMENT),
C(u,t));s&&(u=i+4*s*Uint32Array.BYTES_PER_ELEMENT,t=u+4*s*Uint32Array.BYTES_PER_ELEMENT,E(s,i,u,t+4*s*Uint32Array.BYTES_PER_ELEMENT),C(s,t));o&&G(o,p,p+3*o*Uint32Array.BYTES_PER_ELEMENT);q&&(o=L+3*q*Uint32Array.BYTES_PER_ELEMENT,J(q,L,o,o+3*q*Uint32Array.BYTES_PER_ELEMENT));B&&H(B,e,e+4*B*Uint32Array.BYTES_PER_ELEMENT);b&&(q=R+4*b*Uint32Array.BYTES_PER_ELEMENT,E(b,R,q,q+4*b*Uint32Array.BYTES_PER_ELEMENT));this.computeCentroids();this.computeFaceNormals();THREE.Loader.prototype.hasNormals(this)&&this.computeTangents()};
e.prototype=Object.create(THREE.Geometry.prototype);b(new e(c))};THREE.ImageLoader=function(){THREE.EventTarget.call(this);this.crossOrigin=null};
THREE.ImageLoader.prototype={constructor:THREE.ImageLoader,load:function(a,b){var c=this;void 0===b&&(b=new Image);b.addEventListener("load",function(){c.dispatchEvent({type:"load",content:b})},!1);b.addEventListener("error",function(){c.dispatchEvent({type:"error",message:"Couldn't load URL ["+a+"]"})},!1);c.crossOrigin&&(b.crossOrigin=c.crossOrigin);b.src=a}};THREE.JSONLoader=function(a){THREE.Loader.call(this,a)};THREE.JSONLoader.prototype=Object.create(THREE.Loader.prototype);
THREE.JSONLoader.prototype.load=function(a,b,c){c=c?c:this.extractUrlBase(a);this.onLoadStart();this.loadAjaxJSON(this,a,b,c)};
THREE.JSONLoader.prototype.loadAjaxJSON=function(a,b,c,d,e){var f=new XMLHttpRequest,g=0;f.onreadystatechange=function(){if(f.readyState===f.DONE)if(200===f.status||0===f.status){if(f.responseText){var h=JSON.parse(f.responseText);a.createModel(h,c,d)}else console.warn("THREE.JSONLoader: ["+b+"] seems to be unreachable or file there is empty");a.onLoadComplete()}else console.error("THREE.JSONLoader: Couldn't load ["+b+"] ["+f.status+"]");else f.readyState===f.LOADING?e&&(0===g&&(g=f.getResponseHeader("Content-Length")),
e({total:g,loaded:f.responseText.length})):f.readyState===f.HEADERS_RECEIVED&&(g=f.getResponseHeader("Content-Length"))};f.open("GET",b,!0);f.send(null)};
THREE.JSONLoader.prototype.createModel=function(a,b,c){var d=new THREE.Geometry,e=void 0!==a.scale?1/a.scale:1;this.initMaterials(d,a.materials,c);var f,g,h,i,j,l,m,n,p,o,q,r,t,B,u=a.faces;p=a.vertices;var s=a.normals,z=a.colors,A=0;for(f=0;f<a.uvs.length;f++)a.uvs[f].length&&A++;for(f=0;f<A;f++)d.faceUvs[f]=[],d.faceVertexUvs[f]=[];c=0;for(i=p.length;c<i;)j=new THREE.Vector3,j.x=p[c++]*e,j.y=p[c++]*e,j.z=p[c++]*e,d.vertices.push(j);c=0;for(i=u.length;c<i;){p=u[c++];j=p&1;h=p&2;f=p&4;g=p&8;m=p&16;
l=p&32;o=p&64;p&=128;j?(q=new THREE.Face4,q.a=u[c++],q.b=u[c++],q.c=u[c++],q.d=u[c++],j=4):(q=new THREE.Face3,q.a=u[c++],q.b=u[c++],q.c=u[c++],j=3);h&&(h=u[c++],q.materialIndex=h);h=d.faces.length;if(f)for(f=0;f<A;f++)r=a.uvs[f],n=u[c++],B=r[2*n],n=r[2*n+1],d.faceUvs[f][h]=new THREE.UV(B,n);if(g)for(f=0;f<A;f++){r=a.uvs[f];t=[];for(g=0;g<j;g++)n=u[c++],B=r[2*n],n=r[2*n+1],t[g]=new THREE.UV(B,n);d.faceVertexUvs[f][h]=t}m&&(m=3*u[c++],g=new THREE.Vector3,g.x=s[m++],g.y=s[m++],g.z=s[m],q.normal=g);if(l)for(f=
0;f<j;f++)m=3*u[c++],g=new THREE.Vector3,g.x=s[m++],g.y=s[m++],g.z=s[m],q.vertexNormals.push(g);o&&(l=u[c++],l=new THREE.Color(z[l]),q.color=l);if(p)for(f=0;f<j;f++)l=u[c++],l=new THREE.Color(z[l]),q.vertexColors.push(l);d.faces.push(q)}if(a.skinWeights){c=0;for(i=a.skinWeights.length;c<i;c+=2)u=a.skinWeights[c],s=a.skinWeights[c+1],d.skinWeights.push(new THREE.Vector4(u,s,0,0))}if(a.skinIndices){c=0;for(i=a.skinIndices.length;c<i;c+=2)u=a.skinIndices[c],s=a.skinIndices[c+1],d.skinIndices.push(new THREE.Vector4(u,
s,0,0))}d.bones=a.bones;d.animation=a.animation;if(void 0!==a.morphTargets){c=0;for(i=a.morphTargets.length;c<i;c++){d.morphTargets[c]={};d.morphTargets[c].name=a.morphTargets[c].name;d.morphTargets[c].vertices=[];z=d.morphTargets[c].vertices;A=a.morphTargets[c].vertices;u=0;for(s=A.length;u<s;u+=3)p=new THREE.Vector3,p.x=A[u]*e,p.y=A[u+1]*e,p.z=A[u+2]*e,z.push(p)}}if(void 0!==a.morphColors){c=0;for(i=a.morphColors.length;c<i;c++){d.morphColors[c]={};d.morphColors[c].name=a.morphColors[c].name;d.morphColors[c].colors=
[];s=d.morphColors[c].colors;z=a.morphColors[c].colors;e=0;for(u=z.length;e<u;e+=3)A=new THREE.Color(16755200),A.setRGB(z[e],z[e+1],z[e+2]),s.push(A)}}d.computeCentroids();d.computeFaceNormals();this.hasNormals(d)&&d.computeTangents();b(d)};THREE.LoadingMonitor=function(){THREE.EventTarget.call(this);var a=this,b=0,c=0,d=function(){b++;a.dispatchEvent({type:"progress",loaded:b,total:c});b===c&&a.dispatchEvent({type:"load"})};this.add=function(a){c++;a.addEventListener("load",d,!1)}};
THREE.GeometryLoader=function(){THREE.EventTarget.call(this);this.path=this.crossOrigin=null};
THREE.GeometryLoader.prototype={constructor:THREE.GeometryLoader,load:function(a){var b=this,c=null;if(null===b.path){var d=a.split("/");d.pop();b.path=1>d.length?".":d.join("/")}d=new XMLHttpRequest;d.addEventListener("load",function(d){d.target.responseText?c=b.parse(JSON.parse(d.target.responseText),e):b.dispatchEvent({type:"error",message:"Invalid file ["+a+"]"})},!1);d.addEventListener("error",function(){b.dispatchEvent({type:"error",message:"Couldn't load URL ["+a+"]"})},!1);d.open("GET",a,
!0);d.send(null);var e=new THREE.LoadingMonitor;e.addEventListener("load",function(){b.dispatchEvent({type:"load",content:c})});e.add(d)},parse:function(a,b){var c=this,d=new THREE.Geometry,e=void 0!==a.scale?1/a.scale:1;if(a.materials){d.materials=[];for(var f=0;f<a.materials.length;++f){var g=a.materials[f],h=function(a){a=Math.log(a)/Math.LN2;return Math.floor(a)==a},i=function(a){a=Math.log(a)/Math.LN2;return Math.pow(2,Math.round(a))},j=function(a,d,e,f,g,l){a[d]=new THREE.Texture;a[d].sourceFile=
e;if(f&&(a[d].repeat.set(f[0],f[1]),1!==f[0]&&(a[d].wrapS=THREE.RepeatWrapping),1!==f[1]))a[d].wrapT=THREE.RepeatWrapping;g&&a[d].offset.set(g[0],g[1]);if(l&&(f={repeat:THREE.RepeatWrapping,mirror:THREE.MirroredRepeatWrapping},void 0!==f[l[0]]&&(a[d].wrapS=f[l[0]]),void 0!==f[l[1]]))a[d].wrapT=f[l[1]];var j=a[d],a=new THREE.ImageLoader;a.addEventListener("load",function(a){a=a.content;if(!h(a.width)||!h(a.height)){var b=i(a.width),c=i(a.height);j.image=document.createElement("canvas");j.image.width=
b;j.image.height=c;j.image.getContext("2d").drawImage(a,0,0,b,c)}else j.image=a;j.needsUpdate=!0});a.crossOrigin=c.crossOrigin;a.load(c.path+"/"+e);b&&b.add(a)},l=function(a){return(255*a[0]<<16)+(255*a[1]<<8)+255*a[2]},m="MeshLambertMaterial",n={color:15658734,opacity:1,map:null,lightMap:null,normalMap:null,bumpMap:null,wireframe:!1};if(g.shading){var p=g.shading.toLowerCase();"phong"===p?m="MeshPhongMaterial":"basic"===p&&(m="MeshBasicMaterial")}void 0!==g.blending&&void 0!==THREE[g.blending]&&
(n.blending=THREE[g.blending]);if(void 0!==g.transparent||1>g.opacity)n.transparent=g.transparent;void 0!==g.depthTest&&(n.depthTest=g.depthTest);void 0!==g.depthWrite&&(n.depthWrite=g.depthWrite);void 0!==g.vertexColors&&("face"==g.vertexColors?n.vertexColors=THREE.FaceColors:g.vertexColors&&(n.vertexColors=THREE.VertexColors));g.colorDiffuse?n.color=l(g.colorDiffuse):g.DbgColor&&(n.color=g.DbgColor);g.colorSpecular&&(n.specular=l(g.colorSpecular));g.colorAmbient&&(n.ambient=l(g.colorAmbient));g.transparency&&
(n.opacity=g.transparency);g.specularCoef&&(n.shininess=g.specularCoef);void 0!==g.visible&&(n.visible=g.visible);void 0!==g.flipSided&&(n.side=THREE.BackSide);void 0!==g.doubleSided&&(n.side=THREE.DoubleSide);void 0!==g.wireframe&&(n.wireframe=g.wireframe);g.mapDiffuse&&j(n,"map",g.mapDiffuse,g.mapDiffuseRepeat,g.mapDiffuseOffset,g.mapDiffuseWrap);g.mapLight&&j(n,"lightMap",g.mapLight,g.mapLightRepeat,g.mapLightOffset,g.mapLightWrap);g.mapBump&&j(n,"bumpMap",g.mapBump,g.mapBumpRepeat,g.mapBumpOffset,
g.mapBumpWrap);g.mapNormal&&j(n,"normalMap",g.mapNormal,g.mapNormalRepeat,g.mapNormalOffset,g.mapNormalWrap);g.mapSpecular&&j(n,"specularMap",g.mapSpecular,g.mapSpecularRepeat,g.mapSpecularOffset,g.mapSpecularWrap);g.mapNormal?(j=THREE.ShaderUtils.lib.normal,l=THREE.UniformsUtils.clone(j.uniforms),l.tNormal.value=n.normalMap,g.mapNormalFactor&&l.uNormalScale.value.set(g.mapNormalFactor,g.mapNormalFactor),n.map&&(l.tDiffuse.value=n.map,l.enableDiffuse.value=!0),n.specularMap&&(l.tSpecular.value=n.specularMap,
l.enableSpecular.value=!0),n.lightMap&&(l.tAO.value=n.lightMap,l.enableAO.value=!0),l.uDiffuseColor.value.setHex(n.color),l.uSpecularColor.value.setHex(n.specular),l.uAmbientColor.value.setHex(n.ambient),l.uShininess.value=n.shininess,void 0!==n.opacity&&(l.uOpacity.value=n.opacity),n=new THREE.ShaderMaterial({fragmentShader:j.fragmentShader,vertexShader:j.vertexShader,uniforms:l,lights:!0,fog:!0})):n=new THREE[m](n);void 0!==g.DbgName&&(n.name=g.DbgName);d.materials[f]=n}}var g=a.faces,o=a.vertices,
n=a.normals,j=a.colors,l=0;if(a.uvs)for(f=0;f<a.uvs.length;f++)a.uvs[f].length&&l++;for(f=0;f<l;f++)d.faceUvs[f]=[],d.faceVertexUvs[f]=[];m=0;for(p=o.length;m<p;){var q=new THREE.Vector3;q.x=o[m++]*e;q.y=o[m++]*e;q.z=o[m++]*e;d.vertices.push(q)}m=0;for(p=g.length;m<p;){var r=g[m++],t=r&2,f=r&4,B=r&8,u=r&16,o=r&32,s=r&64,q=r&128;if(r&1){r=new THREE.Face4;r.a=g[m++];r.b=g[m++];r.c=g[m++];r.d=g[m++];var z=4}else r=new THREE.Face3,r.a=g[m++],r.b=g[m++],r.c=g[m++],z=3;t&&(t=g[m++],r.materialIndex=t);var A=
d.faces.length;if(f)for(f=0;f<l;f++){var v=a.uvs[f],t=g[m++],y=v[2*t],t=v[2*t+1];d.faceUvs[f][A]=new THREE.UV(y,t)}if(B)for(f=0;f<l;f++){for(var v=a.uvs[f],B=[],C=0;C<z;C++)t=g[m++],y=v[2*t],t=v[2*t+1],B[C]=new THREE.UV(y,t);d.faceVertexUvs[f][A]=B}u&&(u=3*g[m++],t=new THREE.Vector3,t.x=n[u++],t.y=n[u++],t.z=n[u],r.normal=t);if(o)for(f=0;f<z;f++)u=3*g[m++],t=new THREE.Vector3,t.x=n[u++],t.y=n[u++],t.z=n[u],r.vertexNormals.push(t);s&&(o=g[m++],r.color=new THREE.Color(j[o]));if(q)for(f=0;f<z;f++)o=
g[m++],r.vertexColors.push(new THREE.Color(j[o]));d.faces.push(r)}if(a.skinWeights){f=0;for(g=a.skinWeights.length;f<g;f+=2)d.skinWeights.push(new THREE.Vector4(a.skinWeights[f],a.skinWeights[f+1],0,0))}if(a.skinIndices){f=0;for(g=a.skinIndices.length;f<g;f+=2)n=0,d.skinIndices.push(new THREE.Vector4(a.skinIndices[f],a.skinIndices[f+1],n,0))}d.bones=a.bones;d.animation=a.animation;if(a.morphTargets){f=0;for(g=a.morphTargets.length;f<g;f++){d.morphTargets[f]={};d.morphTargets[f].name=a.morphTargets[f].name;
d.morphTargets[f].vertices=[];n=d.morphTargets[f].vertices;j=a.morphTargets[f].vertices;t=0;for(l=j.length;t<l;t+=3)q=new THREE.Vector3,q.x=j[t]*e,q.y=j[t+1]*e,q.z=j[t+2]*e,n.push(q)}}if(a.morphColors){f=0;for(g=a.morphColors.length;f<g;f++){d.morphColors[f]={};d.morphColors[f].name=a.morphColors[f].name;d.morphColors[f].colors=[];e=d.morphColors[f].colors;j=a.morphColors[f].colors;n=0;for(l=j.length;n<l;n+=3)m=new THREE.Color(16755200),m.setRGB(j[n],j[n+1],j[n+2]),e.push(m)}}d.computeCentroids();
d.computeFaceNormals();return d}};THREE.SceneLoader=function(){this.onLoadStart=function(){};this.onLoadProgress=function(){};this.onLoadComplete=function(){};this.callbackSync=function(){};this.callbackProgress=function(){};this.geometryHandlerMap={};this.addGeometryHandler("ascii",THREE.JSONLoader);this.addGeometryHandler("binary",THREE.BinaryLoader)};THREE.SceneLoader.prototype.constructor=THREE.SceneLoader;
THREE.SceneLoader.prototype.load=function(a,b){var c=this,d=new XMLHttpRequest;d.onreadystatechange=function(){if(4===d.readyState)if(200===d.status||0===d.status){var e=JSON.parse(d.responseText);c.parse(e,b,a)}else console.error("THREE.SceneLoader: Couldn't load ["+a+"] ["+d.status+"]")};d.open("GET",a,!0);d.send(null)};THREE.SceneLoader.prototype.addGeometryHandler=function(a,b){this.geometryHandlerMap[a]={loaderClass:b}};
THREE.SceneLoader.prototype.parse=function(a,b,c){function d(a,b){return"relativeToHTML"==b?a:j+"/"+a}function e(a,b){for(var c in b)if(void 0===I.objects[c]){var d=b[c],f=null;if(void 0!==d.geometry){if(y=I.geometries[d.geometry])f=!1,C=I.materials[d.materials[0]],(f=C instanceof THREE.ShaderMaterial)&&y.computeTangents(),B=d.position,u=d.rotation,s=d.quaternion,z=d.scale,r=d.matrix,s=0,0===d.materials.length&&(C=new THREE.MeshFaceMaterial),1<d.materials.length&&(C=new THREE.MeshFaceMaterial),d.morph?
(f=new THREE.MorphAnimMesh(y,C),void 0!==d.duration&&(f.duration=d.duration),void 0!==d.time&&(f.time=d.time),void 0!==d.mirroredLoop&&(f.mirroredLoop=d.mirroredLoop),C.morphNormals&&y.computeMorphNormals()):f=new THREE.Mesh(y,C),f.name=c,r?(f.matrixAutoUpdate=!1,f.matrix.set(r[0],r[1],r[2],r[3],r[4],r[5],r[6],r[7],r[8],r[9],r[10],r[11],r[12],r[13],r[14],r[15])):(f.position.set(B[0],B[1],B[2]),s?(f.quaternion.set(s[0],s[1],s[2],s[3]),f.useQuaternion=!0):f.rotation.set(u[0],u[1],u[2]),f.scale.set(z[0],
z[1],z[2])),f.visible=d.visible,f.castShadow=d.castShadow,f.receiveShadow=d.receiveShadow,a.add(f),I.objects[c]=f}else B=d.position,u=d.rotation,s=d.quaternion,z=d.scale,s=0,f=new THREE.Object3D,f.name=c,f.position.set(B[0],B[1],B[2]),s?(f.quaternion.set(s[0],s[1],s[2],s[3]),f.useQuaternion=!0):f.rotation.set(u[0],u[1],u[2]),f.scale.set(z[0],z[1],z[2]),f.visible=void 0!==d.visible?d.visible:!1,a.add(f),I.objects[c]=f,I.empties[c]=f;if(f){if(void 0!==d.properties)for(var g in d.properties)f.properties[g]=
d.properties[g];void 0!==d.children&&e(f,d.children)}}}function f(a){return function(b){I.geometries[a]=b;e(I.scene,L.objects);E-=1;i.onLoadComplete();h()}}function g(a){return function(b){I.geometries[a]=b}}function h(){i.callbackProgress({totalModels:K,totalTextures:F,loadedModels:K-E,loadedTextures:F-M},I);i.onLoadProgress();0===E&&0===M&&b(I)}var i=this,j=THREE.Loader.prototype.extractUrlBase(c),l,m,n,p,o,q,r,t,B,u,s,z,A,v,y,C,G,H,J,E,M,K,F,I,L=a;for(A in this.geometryHandlerMap)this.geometryHandlerMap[A].loaderObject=
new this.geometryHandlerMap[A].loaderClass;M=E=0;I={scene:new THREE.Scene,geometries:{},materials:{},textures:{},objects:{},cameras:{},lights:{},fogs:{},empties:{}};if(L.transform&&(a=L.transform.position,c=L.transform.rotation,A=L.transform.scale,a&&I.scene.position.set(a[0],a[1],a[2]),c&&I.scene.rotation.set(c[0],c[1],c[2]),A&&I.scene.scale.set(A[0],A[1],A[2]),a||c||A))I.scene.updateMatrix(),I.scene.updateMatrixWorld();a=function(a){return function(){M-=a;h();i.onLoadComplete()}};for(p in L.cameras)A=
L.cameras[p],"perspective"===A.type?G=new THREE.PerspectiveCamera(A.fov,A.aspect,A.near,A.far):"ortho"===A.type&&(G=new THREE.OrthographicCamera(A.left,A.right,A.top,A.bottom,A.near,A.far)),B=A.position,c=A.target,A=A.up,G.position.set(B[0],B[1],B[2]),G.target=new THREE.Vector3(c[0],c[1],c[2]),A&&G.up.set(A[0],A[1],A[2]),I.cameras[p]=G;for(n in L.lights)c=L.lights[n],p=void 0!==c.color?c.color:16777215,G=void 0!==c.intensity?c.intensity:1,"directional"===c.type?(B=c.direction,t=new THREE.DirectionalLight(p,
G),t.position.set(B[0],B[1],B[2]),t.position.normalize()):"point"===c.type?(B=c.position,t=c.distance,t=new THREE.PointLight(p,G,t),t.position.set(B[0],B[1],B[2])):"ambient"===c.type&&(t=new THREE.AmbientLight(p)),I.scene.add(t),I.lights[n]=t;for(o in L.fogs)n=L.fogs[o],"linear"===n.type?H=new THREE.Fog(0,n.near,n.far):"exp2"===n.type&&(H=new THREE.FogExp2(0,n.density)),A=n.color,H.color.setRGB(A[0],A[1],A[2]),I.fogs[o]=H;I.cameras&&L.defaults.camera&&(I.currentCamera=I.cameras[L.defaults.camera]);
I.fogs&&L.defaults.fog&&(I.scene.fog=I.fogs[L.defaults.fog]);A=L.defaults.bgcolor;I.bgColor=new THREE.Color;I.bgColor.setRGB(A[0],A[1],A[2]);I.bgColorAlpha=L.defaults.bgalpha;for(l in L.geometries)o=L.geometries[l],o.type in this.geometryHandlerMap&&(E+=1,i.onLoadStart());K=E;for(l in L.geometries)if(o=L.geometries[l],"cube"===o.type)y=new THREE.CubeGeometry(o.width,o.height,o.depth,o.segmentsWidth,o.segmentsHeight,o.segmentsDepth,null,o.flipped,o.sides),I.geometries[l]=y;else if("plane"===o.type)y=
new THREE.PlaneGeometry(o.width,o.height,o.segmentsWidth,o.segmentsHeight),I.geometries[l]=y;else if("sphere"===o.type)y=new THREE.SphereGeometry(o.radius,o.segmentsWidth,o.segmentsHeight),I.geometries[l]=y;else if("cylinder"===o.type)y=new THREE.CylinderGeometry(o.topRad,o.botRad,o.height,o.radSegs,o.heightSegs),I.geometries[l]=y;else if("torus"===o.type)y=new THREE.TorusGeometry(o.radius,o.tube,o.segmentsR,o.segmentsT),I.geometries[l]=y;else if("icosahedron"===o.type)y=new THREE.IcosahedronGeometry(o.radius,
o.subdivisions),I.geometries[l]=y;else if(o.type in this.geometryHandlerMap){H={};for(J in o)"type"!==J&&"url"!==J&&(H[J]=o[J]);this.geometryHandlerMap[o.type].loaderObject.load(d(o.url,L.urlBaseType),f(l),H)}else"embedded"===o.type&&(o=L.embeds[o.id],o.metadata=L.metadata,o&&this.geometryHandlerMap.ascii.loaderObject.createModel(o,g(l),""));for(q in L.textures)if(l=L.textures[q],l.url instanceof Array){M+=l.url.length;for(J=0;J<l.url.length;J++)i.onLoadStart()}else M+=1,i.onLoadStart();F=M;for(q in L.textures){l=
L.textures[q];void 0!==l.mapping&&void 0!==THREE[l.mapping]&&(l.mapping=new THREE[l.mapping]);if(l.url instanceof Array){o=l.url.length;H=[];for(J=0;J<o;J++)H[J]=d(l.url[J],L.urlBaseType);J=(J=H[0].endsWith(".dds"))?THREE.ImageUtils.loadCompressedTextureCube(H,l.mapping,a(o)):THREE.ImageUtils.loadTextureCube(H,l.mapping,a(o))}else{J=l.url.toLowerCase().endsWith(".dds");o=d(l.url,L.urlBaseType);H=a(1);J=J?THREE.ImageUtils.loadCompressedTexture(o,l.mapping,H):THREE.ImageUtils.loadTexture(o,l.mapping,
H);void 0!==THREE[l.minFilter]&&(J.minFilter=THREE[l.minFilter]);void 0!==THREE[l.magFilter]&&(J.magFilter=THREE[l.magFilter]);l.anisotropy&&(J.anisotropy=l.anisotropy);if(l.repeat&&(J.repeat.set(l.repeat[0],l.repeat[1]),1!==l.repeat[0]&&(J.wrapS=THREE.RepeatWrapping),1!==l.repeat[1]))J.wrapT=THREE.RepeatWrapping;l.offset&&J.offset.set(l.offset[0],l.offset[1]);if(l.wrap&&(o={repeat:THREE.RepeatWrapping,mirror:THREE.MirroredRepeatWrapping},void 0!==o[l.wrap[0]]&&(J.wrapS=o[l.wrap[0]]),void 0!==o[l.wrap[1]]))J.wrapT=
o[l.wrap[1]]}I.textures[q]=J}for(m in L.materials){r=L.materials[m];for(v in r.parameters)"envMap"===v||"map"===v||"lightMap"===v||"bumpMap"===v?r.parameters[v]=I.textures[r.parameters[v]]:"shading"===v?r.parameters[v]="flat"===r.parameters[v]?THREE.FlatShading:THREE.SmoothShading:"side"===v?r.parameters[v]="double"==r.parameters[v]?THREE.DoubleSide:"back"==r.parameters[v]?THREE.BackSide:THREE.FrontSide:"blending"===v?r.parameters[v]=r.parameters[v]in THREE?THREE[r.parameters[v]]:THREE.NormalBlending:
"combine"===v?r.parameters[v]="MixOperation"==r.parameters[v]?THREE.MixOperation:THREE.MultiplyOperation:"vertexColors"===v?"face"==r.parameters[v]?r.parameters[v]=THREE.FaceColors:r.parameters[v]&&(r.parameters[v]=THREE.VertexColors):"wrapRGB"===v&&(q=r.parameters[v],r.parameters[v]=new THREE.Vector3(q[0],q[1],q[2]));void 0!==r.parameters.opacity&&1>r.parameters.opacity&&(r.parameters.transparent=!0);r.parameters.normalMap?(q=THREE.ShaderUtils.lib.normal,a=THREE.UniformsUtils.clone(q.uniforms),l=
r.parameters.color,J=r.parameters.specular,o=r.parameters.ambient,H=r.parameters.shininess,a.tNormal.value=I.textures[r.parameters.normalMap],r.parameters.normalScale&&a.uNormalScale.value.set(r.parameters.normalScale[0],r.parameters.normalScale[1]),r.parameters.map&&(a.tDiffuse.value=r.parameters.map,a.enableDiffuse.value=!0),r.parameters.envMap&&(a.tCube.value=r.parameters.envMap,a.enableReflection.value=!0,a.uReflectivity.value=r.parameters.reflectivity),r.parameters.lightMap&&(a.tAO.value=r.parameters.lightMap,
a.enableAO.value=!0),r.parameters.specularMap&&(a.tSpecular.value=I.textures[r.parameters.specularMap],a.enableSpecular.value=!0),r.parameters.displacementMap&&(a.tDisplacement.value=I.textures[r.parameters.displacementMap],a.enableDisplacement.value=!0,a.uDisplacementBias.value=r.parameters.displacementBias,a.uDisplacementScale.value=r.parameters.displacementScale),a.uDiffuseColor.value.setHex(l),a.uSpecularColor.value.setHex(J),a.uAmbientColor.value.setHex(o),a.uShininess.value=H,r.parameters.opacity&&
(a.uOpacity.value=r.parameters.opacity),C=new THREE.ShaderMaterial({fragmentShader:q.fragmentShader,vertexShader:q.vertexShader,uniforms:a,lights:!0,fog:!0})):C=new THREE[r.type](r.parameters);I.materials[m]=C}e(I.scene,L.objects);i.callbackSync(I);h()};THREE.TextureLoader=function(){THREE.EventTarget.call(this);this.crossOrigin=null};
THREE.TextureLoader.prototype={constructor:THREE.TextureLoader,load:function(a){var b=this,c=new Image;c.addEventListener("load",function(){var a=new THREE.Texture(c);a.needsUpdate=!0;b.dispatchEvent({type:"load",content:a})},!1);c.addEventListener("error",function(){b.dispatchEvent({type:"error",message:"Couldn't load URL ["+a+"]"})},!1);b.crossOrigin&&(c.crossOrigin=b.crossOrigin);c.src=a}};
THREE.Material=function(){THREE.MaterialLibrary.push(this);this.id=THREE.MaterialIdCount++;this.name="";this.side=THREE.FrontSide;this.opacity=1;this.transparent=!1;this.blending=THREE.NormalBlending;this.blendSrc=THREE.SrcAlphaFactor;this.blendDst=THREE.OneMinusSrcAlphaFactor;this.blendEquation=THREE.AddEquation;this.depthWrite=this.depthTest=!0;this.polygonOffset=!1;this.alphaTest=this.polygonOffsetUnits=this.polygonOffsetFactor=0;this.overdraw=!1;this.needsUpdate=this.visible=!0};
THREE.Material.prototype.setValues=function(a){if(void 0!==a)for(var b in a){var c=a[b];if(void 0===c)console.warn("THREE.Material: '"+b+"' parameter is undefined.");else if(b in this){var d=this[b];d instanceof THREE.Color&&c instanceof THREE.Color?d.copy(c):d instanceof THREE.Color&&"number"===typeof c?d.setHex(c):d instanceof THREE.Vector3&&c instanceof THREE.Vector3?d.copy(c):this[b]=c}}};
THREE.Material.prototype.clone=function(a){void 0===a&&(a=new THREE.Material);a.name=this.name;a.side=this.side;a.opacity=this.opacity;a.transparent=this.transparent;a.blending=this.blending;a.blendSrc=this.blendSrc;a.blendDst=this.blendDst;a.blendEquation=this.blendEquation;a.depthTest=this.depthTest;a.depthWrite=this.depthWrite;a.polygonOffset=this.polygonOffset;a.polygonOffsetFactor=this.polygonOffsetFactor;a.polygonOffsetUnits=this.polygonOffsetUnits;a.alphaTest=this.alphaTest;a.overdraw=this.overdraw;
a.visible=this.visible;return a};THREE.Material.prototype.deallocate=function(){var a=THREE.MaterialLibrary.indexOf(this);-1!==a&&THREE.MaterialLibrary.splice(a,1)};THREE.MaterialIdCount=0;THREE.MaterialLibrary=[];THREE.LineBasicMaterial=function(a){THREE.Material.call(this);this.color=new THREE.Color(16777215);this.linewidth=1;this.linejoin=this.linecap="round";this.vertexColors=!1;this.fog=!0;this.setValues(a)};THREE.LineBasicMaterial.prototype=Object.create(THREE.Material.prototype);
THREE.LineBasicMaterial.prototype.clone=function(){var a=new THREE.LineBasicMaterial;THREE.Material.prototype.clone.call(this,a);a.color.copy(this.color);a.linewidth=this.linewidth;a.linecap=this.linecap;a.linejoin=this.linejoin;a.vertexColors=this.vertexColors;a.fog=this.fog;return a};
THREE.MeshBasicMaterial=function(a){THREE.Material.call(this);this.color=new THREE.Color(16777215);this.envMap=this.specularMap=this.lightMap=this.map=null;this.combine=THREE.MultiplyOperation;this.reflectivity=1;this.refractionRatio=0.98;this.fog=!0;this.shading=THREE.SmoothShading;this.wireframe=!1;this.wireframeLinewidth=1;this.wireframeLinejoin=this.wireframeLinecap="round";this.vertexColors=THREE.NoColors;this.morphTargets=this.skinning=!1;this.setValues(a)};
THREE.MeshBasicMaterial.prototype=Object.create(THREE.Material.prototype);
THREE.MeshBasicMaterial.prototype.clone=function(){var a=new THREE.MeshBasicMaterial;THREE.Material.prototype.clone.call(this,a);a.color.copy(this.color);a.map=this.map;a.lightMap=this.lightMap;a.specularMap=this.specularMap;a.envMap=this.envMap;a.combine=this.combine;a.reflectivity=this.reflectivity;a.refractionRatio=this.refractionRatio;a.fog=this.fog;a.shading=this.shading;a.wireframe=this.wireframe;a.wireframeLinewidth=this.wireframeLinewidth;a.wireframeLinecap=this.wireframeLinecap;a.wireframeLinejoin=
this.wireframeLinejoin;a.vertexColors=this.vertexColors;a.skinning=this.skinning;a.morphTargets=this.morphTargets;return a};
THREE.MeshLambertMaterial=function(a){THREE.Material.call(this);this.color=new THREE.Color(16777215);this.ambient=new THREE.Color(16777215);this.emissive=new THREE.Color(0);this.wrapAround=!1;this.wrapRGB=new THREE.Vector3(1,1,1);this.envMap=this.specularMap=this.lightMap=this.map=null;this.combine=THREE.MultiplyOperation;this.reflectivity=1;this.refractionRatio=0.98;this.fog=!0;this.shading=THREE.SmoothShading;this.wireframe=!1;this.wireframeLinewidth=1;this.wireframeLinejoin=this.wireframeLinecap=
"round";this.vertexColors=THREE.NoColors;this.morphNormals=this.morphTargets=this.skinning=!1;this.setValues(a)};THREE.MeshLambertMaterial.prototype=Object.create(THREE.Material.prototype);
THREE.MeshLambertMaterial.prototype.clone=function(){var a=new THREE.MeshLambertMaterial;THREE.Material.prototype.clone.call(this,a);a.color.copy(this.color);a.ambient.copy(this.ambient);a.emissive.copy(this.emissive);a.wrapAround=this.wrapAround;a.wrapRGB.copy(this.wrapRGB);a.map=this.map;a.lightMap=this.lightMap;a.specularMap=this.specularMap;a.envMap=this.envMap;a.combine=this.combine;a.reflectivity=this.reflectivity;a.refractionRatio=this.refractionRatio;a.fog=this.fog;a.shading=this.shading;
a.wireframe=this.wireframe;a.wireframeLinewidth=this.wireframeLinewidth;a.wireframeLinecap=this.wireframeLinecap;a.wireframeLinejoin=this.wireframeLinejoin;a.vertexColors=this.vertexColors;a.skinning=this.skinning;a.morphTargets=this.morphTargets;a.morphNormals=this.morphNormals;return a};
THREE.MeshPhongMaterial=function(a){THREE.Material.call(this);this.color=new THREE.Color(16777215);this.ambient=new THREE.Color(16777215);this.emissive=new THREE.Color(0);this.specular=new THREE.Color(1118481);this.shininess=30;this.wrapAround=this.perPixel=this.metal=!1;this.wrapRGB=new THREE.Vector3(1,1,1);this.bumpMap=this.lightMap=this.map=null;this.bumpScale=1;this.normalMap=null;this.normalScale=new THREE.Vector2(1,1);this.envMap=this.specularMap=null;this.combine=THREE.MultiplyOperation;this.reflectivity=
1;this.refractionRatio=0.98;this.fog=!0;this.shading=THREE.SmoothShading;this.wireframe=!1;this.wireframeLinewidth=1;this.wireframeLinejoin=this.wireframeLinecap="round";this.vertexColors=THREE.NoColors;this.morphNormals=this.morphTargets=this.skinning=!1;this.setValues(a)};THREE.MeshPhongMaterial.prototype=Object.create(THREE.Material.prototype);
THREE.MeshPhongMaterial.prototype.clone=function(){var a=new THREE.MeshPhongMaterial;THREE.Material.prototype.clone.call(this,a);a.color.copy(this.color);a.ambient.copy(this.ambient);a.emissive.copy(this.emissive);a.specular.copy(this.specular);a.shininess=this.shininess;a.metal=this.metal;a.perPixel=this.perPixel;a.wrapAround=this.wrapAround;a.wrapRGB.copy(this.wrapRGB);a.map=this.map;a.lightMap=this.lightMap;a.bumpMap=this.bumpMap;a.bumpScale=this.bumpScale;a.normalMap=this.normalMap;a.normalScale.copy(this.normalScale);
a.specularMap=this.specularMap;a.envMap=this.envMap;a.combine=this.combine;a.reflectivity=this.reflectivity;a.refractionRatio=this.refractionRatio;a.fog=this.fog;a.shading=this.shading;a.wireframe=this.wireframe;a.wireframeLinewidth=this.wireframeLinewidth;a.wireframeLinecap=this.wireframeLinecap;a.wireframeLinejoin=this.wireframeLinejoin;a.vertexColors=this.vertexColors;a.skinning=this.skinning;a.morphTargets=this.morphTargets;a.morphNormals=this.morphNormals;return a};
THREE.MeshDepthMaterial=function(a){THREE.Material.call(this);this.wireframe=!1;this.wireframeLinewidth=1;this.setValues(a)};THREE.MeshDepthMaterial.prototype=Object.create(THREE.Material.prototype);THREE.MeshDepthMaterial.prototype.clone=function(){var a=new THREE.LineBasicMaterial;THREE.Material.prototype.clone.call(this,a);a.wireframe=this.wireframe;a.wireframeLinewidth=this.wireframeLinewidth;return a};
THREE.MeshNormalMaterial=function(a){THREE.Material.call(this,a);this.shading=THREE.FlatShading;this.wireframe=!1;this.wireframeLinewidth=1;this.setValues(a)};THREE.MeshNormalMaterial.prototype=Object.create(THREE.Material.prototype);THREE.MeshNormalMaterial.prototype.clone=function(){var a=new THREE.MeshNormalMaterial;THREE.Material.prototype.clone.call(this,a);a.shading=this.shading;a.wireframe=this.wireframe;a.wireframeLinewidth=this.wireframeLinewidth;return a};THREE.MeshFaceMaterial=function(){};
THREE.MeshFaceMaterial.prototype.clone=function(){return new THREE.MeshFaceMaterial};THREE.ParticleBasicMaterial=function(a){THREE.Material.call(this);this.color=new THREE.Color(16777215);this.map=null;this.size=1;this.sizeAttenuation=!0;this.vertexColors=!1;this.fog=!0;this.setValues(a)};THREE.ParticleBasicMaterial.prototype=Object.create(THREE.Material.prototype);
THREE.ParticleBasicMaterial.prototype.clone=function(){var a=new THREE.ParticleBasicMaterial;THREE.Material.prototype.clone.call(this,a);a.color.copy(this.color);a.map=this.map;a.size=this.size;a.sizeAttenuation=this.sizeAttenuation;a.vertexColors=this.vertexColors;a.fog=this.fog;return a};THREE.ParticleCanvasMaterial=function(a){THREE.Material.call(this);this.color=new THREE.Color(16777215);this.program=function(){};this.setValues(a)};THREE.ParticleCanvasMaterial.prototype=Object.create(THREE.Material.prototype);
THREE.ParticleCanvasMaterial.prototype.clone=function(){var a=new THREE.ParticleCanvasMaterial;THREE.Material.prototype.clone.call(this,a);a.color.copy(this.color);a.program=this.program;return a};THREE.ParticleDOMMaterial=function(a){this.element=a};THREE.ParticleDOMMaterial.prototype.clone=function(){return new THREE.ParticleDOMMaterial(this.element)};
THREE.ShaderMaterial=function(a){THREE.Material.call(this);this.vertexShader=this.fragmentShader="void main() {}";this.uniforms={};this.defines={};this.attributes=null;this.shading=THREE.SmoothShading;this.wireframe=!1;this.wireframeLinewidth=1;this.lights=this.fog=!1;this.vertexColors=THREE.NoColors;this.morphNormals=this.morphTargets=this.skinning=!1;this.setValues(a)};THREE.ShaderMaterial.prototype=Object.create(THREE.Material.prototype);
THREE.ShaderMaterial.prototype.clone=function(){var a=new THREE.ShaderMaterial;THREE.Material.prototype.clone.call(this,a);a.fragmentShader=this.fragmentShader;a.vertexShader=this.vertexShader;a.uniforms=this.uniforms;a.attributes=this.attributes;a.defines=this.defines;a.shading=this.shading;a.wireframe=this.wireframe;a.wireframeLinewidth=this.wireframeLinewidth;a.fog=this.fog;a.lights=this.lights;a.vertexColors=this.vertexColors;a.skinning=this.skinning;a.morphTargets=this.morphTargets;a.morphNormals=
this.morphNormals;return a};
THREE.Texture=function(a,b,c,d,e,f,g,h,i){THREE.TextureLibrary.push(this);this.id=THREE.TextureIdCount++;this.image=a;this.mapping=void 0!==b?b:new THREE.UVMapping;this.wrapS=void 0!==c?c:THREE.ClampToEdgeWrapping;this.wrapT=void 0!==d?d:THREE.ClampToEdgeWrapping;this.magFilter=void 0!==e?e:THREE.LinearFilter;this.minFilter=void 0!==f?f:THREE.LinearMipMapLinearFilter;this.anisotropy=void 0!==i?i:1;this.format=void 0!==g?g:THREE.RGBAFormat;this.type=void 0!==h?h:THREE.UnsignedByteType;this.offset=
new THREE.Vector2(0,0);this.repeat=new THREE.Vector2(1,1);this.generateMipmaps=!0;this.premultiplyAlpha=!1;this.flipY=!0;this.needsUpdate=!1;this.onUpdate=null};
THREE.Texture.prototype={constructor:THREE.Texture,clone:function(){var a=new THREE.Texture;a.image=this.image;a.mapping=this.mapping;a.wrapS=this.wrapS;a.wrapT=this.wrapT;a.magFilter=this.magFilter;a.minFilter=this.minFilter;a.anisotropy=this.anisotropy;a.format=this.format;a.type=this.type;a.offset.copy(this.offset);a.repeat.copy(this.repeat);a.generateMipmaps=this.generateMipmaps;a.premultiplyAlpha=this.premultiplyAlpha;a.flipY=this.flipY;return a},deallocate:function(){var a=THREE.TextureLibrary.indexOf(this);
-1!==a&&THREE.TextureLibrary.splice(a,1)}};THREE.TextureIdCount=0;THREE.TextureLibrary=[];THREE.CompressedTexture=function(a,b,c,d,e,f,g,h,i,j){THREE.Texture.call(this,null,f,g,h,i,j,d,e);this.image={width:b,height:c};this.mipmaps=a};THREE.CompressedTexture.prototype=Object.create(THREE.Texture.prototype);
THREE.CompressedTexture.prototype.clone=function(){var a=new THREE.CompressedTexture;a.image=this.image;a.mipmaps=this.mipmaps;a.format=this.format;a.type=this.type;a.mapping=this.mapping;a.wrapS=this.wrapS;a.wrapT=this.wrapT;a.magFilter=this.magFilter;a.minFilter=this.minFilter;a.anisotropy=this.anisotropy;a.offset.copy(this.offset);a.repeat.copy(this.repeat);return a};THREE.DataTexture=function(a,b,c,d,e,f,g,h,i,j){THREE.Texture.call(this,null,f,g,h,i,j,d,e);this.image={data:a,width:b,height:c}};
THREE.DataTexture.prototype=Object.create(THREE.Texture.prototype);THREE.DataTexture.prototype.clone=function(){var a=new THREE.DataTexture(this.image.data,this.image.width,this.image.height,this.format,this.type,this.mapping,this.wrapS,this.wrapT,this.magFilter,this.minFilter);a.offset.copy(this.offset);a.repeat.copy(this.repeat);return a};THREE.Particle=function(a){THREE.Object3D.call(this);this.material=a};THREE.Particle.prototype=Object.create(THREE.Object3D.prototype);
THREE.Particle.prototype.clone=function(a){void 0===a&&(a=new THREE.Particle(this.material));THREE.Object3D.prototype.clone.call(this,a);return a};THREE.ParticleSystem=function(a,b){THREE.Object3D.call(this);this.geometry=a;this.material=void 0!==b?b:new THREE.ParticleBasicMaterial({color:16777215*Math.random()});this.sortParticles=!1;this.geometry&&(null===this.geometry.boundingSphere&&this.geometry.computeBoundingSphere(),this.boundRadius=a.boundingSphere.radius);this.frustumCulled=!1};
THREE.ParticleSystem.prototype=Object.create(THREE.Object3D.prototype);THREE.ParticleSystem.prototype.clone=function(a){void 0===a&&(a=new THREE.ParticleSystem(this.geometry,this.material));a.sortParticles=this.sortParticles;THREE.Object3D.prototype.clone.call(this,a);return a};
THREE.Line=function(a,b,c){THREE.Object3D.call(this);this.geometry=a;this.material=void 0!==b?b:new THREE.LineBasicMaterial({color:16777215*Math.random()});this.type=void 0!==c?c:THREE.LineStrip;this.geometry&&(this.geometry.boundingSphere||this.geometry.computeBoundingSphere())};THREE.LineStrip=0;THREE.LinePieces=1;THREE.Line.prototype=Object.create(THREE.Object3D.prototype);
THREE.Line.prototype.clone=function(a){void 0===a&&(a=new THREE.Line(this.geometry,this.material,this.type));THREE.Object3D.prototype.clone.call(this,a);return a};
THREE.Mesh=function(a,b){THREE.Object3D.call(this);this.geometry=a;this.material=void 0!==b?b:new THREE.MeshBasicMaterial({color:16777215*Math.random(),wireframe:!0});if(this.geometry&&(null===this.geometry.boundingSphere&&this.geometry.computeBoundingSphere(),this.boundRadius=a.boundingSphere.radius,this.geometry.morphTargets.length)){this.morphTargetBase=-1;this.morphTargetForcedOrder=[];this.morphTargetInfluences=[];this.morphTargetDictionary={};for(var c=0;c<this.geometry.morphTargets.length;c++)this.morphTargetInfluences.push(0),
this.morphTargetDictionary[this.geometry.morphTargets[c].name]=c}};THREE.Mesh.prototype=Object.create(THREE.Object3D.prototype);THREE.Mesh.prototype.getMorphTargetIndexByName=function(a){if(void 0!==this.morphTargetDictionary[a])return this.morphTargetDictionary[a];console.log("THREE.Mesh.getMorphTargetIndexByName: morph target "+a+" does not exist. Returning 0.");return 0};
THREE.Mesh.prototype.clone=function(a){void 0===a&&(a=new THREE.Mesh(this.geometry,this.material));THREE.Object3D.prototype.clone.call(this,a);return a};THREE.Bone=function(a){THREE.Object3D.call(this);this.skin=a;this.skinMatrix=new THREE.Matrix4};THREE.Bone.prototype=Object.create(THREE.Object3D.prototype);
THREE.Bone.prototype.update=function(a,b){this.matrixAutoUpdate&&(b|=this.updateMatrix());if(b||this.matrixWorldNeedsUpdate)a?this.skinMatrix.multiply(a,this.matrix):this.skinMatrix.copy(this.matrix),this.matrixWorldNeedsUpdate=!1,b=!0;var c,d=this.children.length;for(c=0;c<d;c++)this.children[c].update(this.skinMatrix,b)};
THREE.SkinnedMesh=function(a,b,c){THREE.Mesh.call(this,a,b);this.useVertexTexture=void 0!==c?c:!0;this.identityMatrix=new THREE.Matrix4;this.bones=[];this.boneMatrices=[];var d,e,f;if(void 0!==this.geometry.bones){for(a=0;a<this.geometry.bones.length;a++)c=this.geometry.bones[a],d=c.pos,e=c.rotq,f=c.scl,b=this.addBone(),b.name=c.name,b.position.set(d[0],d[1],d[2]),b.quaternion.set(e[0],e[1],e[2],e[3]),b.useQuaternion=!0,void 0!==f?b.scale.set(f[0],f[1],f[2]):b.scale.set(1,1,1);for(a=0;a<this.bones.length;a++)c=
this.geometry.bones[a],b=this.bones[a],-1===c.parent?this.add(b):this.bones[c.parent].add(b);a=this.bones.length;this.useVertexTexture?(this.boneTextureHeight=this.boneTextureWidth=a=256<a?64:64<a?32:16<a?16:8,this.boneMatrices=new Float32Array(4*this.boneTextureWidth*this.boneTextureHeight),this.boneTexture=new THREE.DataTexture(this.boneMatrices,this.boneTextureWidth,this.boneTextureHeight,THREE.RGBAFormat,THREE.FloatType),this.boneTexture.minFilter=THREE.NearestFilter,this.boneTexture.magFilter=
THREE.NearestFilter,this.boneTexture.generateMipmaps=!1,this.boneTexture.flipY=!1):this.boneMatrices=new Float32Array(16*a);this.pose()}};THREE.SkinnedMesh.prototype=Object.create(THREE.Mesh.prototype);THREE.SkinnedMesh.prototype.addBone=function(a){void 0===a&&(a=new THREE.Bone(this));this.bones.push(a);return a};
THREE.SkinnedMesh.prototype.updateMatrixWorld=function(a){this.matrixAutoUpdate&&this.updateMatrix();if(this.matrixWorldNeedsUpdate||a)this.parent?this.matrixWorld.multiply(this.parent.matrixWorld,this.matrix):this.matrixWorld.copy(this.matrix),this.matrixWorldNeedsUpdate=!1;for(var a=0,b=this.children.length;a<b;a++){var c=this.children[a];c instanceof THREE.Bone?c.update(this.identityMatrix,!1):c.updateMatrixWorld(!0)}if(void 0==this.boneInverses){this.boneInverses=[];a=0;for(b=this.bones.length;a<
b;a++)c=new THREE.Matrix4,c.getInverse(this.bones[a].skinMatrix),this.boneInverses.push(c)}a=0;for(b=this.bones.length;a<b;a++)THREE.SkinnedMesh.offsetMatrix.multiply(this.bones[a].skinMatrix,this.boneInverses[a]),THREE.SkinnedMesh.offsetMatrix.flattenToArrayOffset(this.boneMatrices,16*a);this.useVertexTexture&&(this.boneTexture.needsUpdate=!0)};
THREE.SkinnedMesh.prototype.pose=function(){this.updateMatrixWorld(!0);for(var a=0;a<this.geometry.skinIndices.length;a++){var b=this.geometry.skinWeights[a],c=1/b.lengthManhattan();Infinity!==c?b.multiplyScalar(c):b.set(1)}};THREE.SkinnedMesh.prototype.clone=function(a){void 0===a&&(a=new THREE.SkinnedMesh(this.geometry,this.material,this.useVertexTexture));THREE.Mesh.prototype.clone.call(this,a);return a};THREE.SkinnedMesh.offsetMatrix=new THREE.Matrix4;
THREE.MorphAnimMesh=function(a,b){THREE.Mesh.call(this,a,b);this.duration=1E3;this.mirroredLoop=!1;this.currentKeyframe=this.lastKeyframe=this.time=0;this.direction=1;this.directionBackwards=!1;this.setFrameRange(0,this.geometry.morphTargets.length-1)};THREE.MorphAnimMesh.prototype=Object.create(THREE.Mesh.prototype);THREE.MorphAnimMesh.prototype.setFrameRange=function(a,b){this.startKeyframe=a;this.endKeyframe=b;this.length=this.endKeyframe-this.startKeyframe+1};
THREE.MorphAnimMesh.prototype.setDirectionForward=function(){this.direction=1;this.directionBackwards=!1};THREE.MorphAnimMesh.prototype.setDirectionBackward=function(){this.direction=-1;this.directionBackwards=!0};
THREE.MorphAnimMesh.prototype.parseAnimations=function(){var a=this.geometry;a.animations||(a.animations={});for(var b,c=a.animations,d=/([a-z]+)(\d+)/,e=0,f=a.morphTargets.length;e<f;e++){var g=a.morphTargets[e].name.match(d);if(g&&1<g.length){g=g[1];c[g]||(c[g]={start:Infinity,end:-Infinity});var h=c[g];e<h.start&&(h.start=e);e>h.end&&(h.end=e);b||(b=g)}}a.firstAnimation=b};
THREE.MorphAnimMesh.prototype.setAnimationLabel=function(a,b,c){this.geometry.animations||(this.geometry.animations={});this.geometry.animations[a]={start:b,end:c}};THREE.MorphAnimMesh.prototype.playAnimation=function(a,b){var c=this.geometry.animations[a];c?(this.setFrameRange(c.start,c.end),this.duration=1E3*((c.end-c.start)/b),this.time=0):console.warn("animation["+a+"] undefined")};
THREE.MorphAnimMesh.prototype.updateAnimation=function(a){var b=this.duration/this.length;this.time+=this.direction*a;if(this.mirroredLoop){if(this.time>this.duration||0>this.time)if(this.direction*=-1,this.time>this.duration&&(this.time=this.duration,this.directionBackwards=!0),0>this.time)this.time=0,this.directionBackwards=!1}else this.time%=this.duration,0>this.time&&(this.time+=this.duration);a=this.startKeyframe+THREE.Math.clamp(Math.floor(this.time/b),0,this.length-1);a!==this.currentKeyframe&&
(this.morphTargetInfluences[this.lastKeyframe]=0,this.morphTargetInfluences[this.currentKeyframe]=1,this.morphTargetInfluences[a]=0,this.lastKeyframe=this.currentKeyframe,this.currentKeyframe=a);b=this.time%b/b;this.directionBackwards&&(b=1-b);this.morphTargetInfluences[this.currentKeyframe]=b;this.morphTargetInfluences[this.lastKeyframe]=1-b};
THREE.MorphAnimMesh.prototype.clone=function(a){void 0===a&&(a=new THREE.MorphAnimMesh(this.geometry,this.material));a.duration=this.duration;a.mirroredLoop=this.mirroredLoop;a.time=this.time;a.lastKeyframe=this.lastKeyframe;a.currentKeyframe=this.currentKeyframe;a.direction=this.direction;a.directionBackwards=this.directionBackwards;THREE.Mesh.prototype.clone.call(this,a);return a};THREE.Ribbon=function(a,b){THREE.Object3D.call(this);this.geometry=a;this.material=b};THREE.Ribbon.prototype=Object.create(THREE.Object3D.prototype);
THREE.Ribbon.prototype.clone=function(a){void 0===a&&(a=new THREE.Ribbon(this.geometry,this.material));THREE.Object3D.prototype.clone.call(this,a);return a};THREE.LOD=function(){THREE.Object3D.call(this);this.LODs=[]};THREE.LOD.prototype=Object.create(THREE.Object3D.prototype);THREE.LOD.prototype.addLevel=function(a,b){void 0===b&&(b=0);for(var b=Math.abs(b),c=0;c<this.LODs.length&&!(b<this.LODs[c].visibleAtDistance);c++);this.LODs.splice(c,0,{visibleAtDistance:b,object3D:a});this.add(a)};
THREE.LOD.prototype.update=function(a){if(1<this.LODs.length){a.matrixWorldInverse.getInverse(a.matrixWorld);a=a.matrixWorldInverse;a=-(a.elements[2]*this.matrixWorld.elements[12]+a.elements[6]*this.matrixWorld.elements[13]+a.elements[10]*this.matrixWorld.elements[14]+a.elements[14]);this.LODs[0].object3D.visible=!0;for(var b=1;b<this.LODs.length;b++)if(a>=this.LODs[b].visibleAtDistance)this.LODs[b-1].object3D.visible=!1,this.LODs[b].object3D.visible=!0;else break;for(;b<this.LODs.length;b++)this.LODs[b].object3D.visible=
!1}};THREE.LOD.prototype.clone=function(){};
THREE.Sprite=function(a){THREE.Object3D.call(this);this.color=void 0!==a.color?new THREE.Color(a.color):new THREE.Color(16777215);this.map=void 0!==a.map?a.map:new THREE.Texture;this.blending=void 0!==a.blending?a.blending:THREE.NormalBlending;this.blendSrc=void 0!==a.blendSrc?a.blendSrc:THREE.SrcAlphaFactor;this.blendDst=void 0!==a.blendDst?a.blendDst:THREE.OneMinusSrcAlphaFactor;this.blendEquation=void 0!==a.blendEquation?a.blendEquation:THREE.AddEquation;this.useScreenCoordinates=void 0!==a.useScreenCoordinates?
a.useScreenCoordinates:!0;this.mergeWith3D=void 0!==a.mergeWith3D?a.mergeWith3D:!this.useScreenCoordinates;this.affectedByDistance=void 0!==a.affectedByDistance?a.affectedByDistance:!this.useScreenCoordinates;this.scaleByViewport=void 0!==a.scaleByViewport?a.scaleByViewport:!this.affectedByDistance;this.alignment=a.alignment instanceof THREE.Vector2?a.alignment:THREE.SpriteAlignment.center;this.rotation3d=this.rotation;this.rotation=0;this.opacity=1;this.uvOffset=new THREE.Vector2(0,0);this.uvScale=
new THREE.Vector2(1,1)};THREE.Sprite.prototype=Object.create(THREE.Object3D.prototype);THREE.Sprite.prototype.updateMatrix=function(){this.matrix.setPosition(this.position);this.rotation3d.set(0,0,this.rotation);this.matrix.setRotationFromEuler(this.rotation3d);if(1!==this.scale.x||1!==this.scale.y)this.matrix.scale(this.scale),this.boundRadiusScale=Math.max(this.scale.x,this.scale.y);this.matrixWorldNeedsUpdate=!0};
THREE.Sprite.prototype.clone=function(a){void 0===a&&(a=new THREE.Sprite({}));a.color.copy(this.color);a.map=this.map;a.blending=this.blending;a.useScreenCoordinates=this.useScreenCoordinates;a.mergeWith3D=this.mergeWith3D;a.affectedByDistance=this.affectedByDistance;a.scaleByViewport=this.scaleByViewport;a.alignment=this.alignment;a.rotation3d.copy(this.rotation3d);a.rotation=this.rotation;a.opacity=this.opacity;a.uvOffset.copy(this.uvOffset);a.uvScale.copy(this.uvScale);THREE.Object3D.prototype.clone.call(this,
a);return a};THREE.SpriteAlignment={};THREE.SpriteAlignment.topLeft=new THREE.Vector2(1,-1);THREE.SpriteAlignment.topCenter=new THREE.Vector2(0,-1);THREE.SpriteAlignment.topRight=new THREE.Vector2(-1,-1);THREE.SpriteAlignment.centerLeft=new THREE.Vector2(1,0);THREE.SpriteAlignment.center=new THREE.Vector2(0,0);THREE.SpriteAlignment.centerRight=new THREE.Vector2(-1,0);THREE.SpriteAlignment.bottomLeft=new THREE.Vector2(1,1);THREE.SpriteAlignment.bottomCenter=new THREE.Vector2(0,1);
THREE.SpriteAlignment.bottomRight=new THREE.Vector2(-1,1);THREE.Scene=function(){THREE.Object3D.call(this);this.overrideMaterial=this.fog=null;this.matrixAutoUpdate=!1;this.__objects=[];this.__lights=[];this.__objectsAdded=[];this.__objectsRemoved=[]};THREE.Scene.prototype=Object.create(THREE.Object3D.prototype);
THREE.Scene.prototype.__addObject=function(a){if(a instanceof THREE.Light)-1===this.__lights.indexOf(a)&&this.__lights.push(a),a.target&&void 0===a.target.parent&&this.add(a.target);else if(!(a instanceof THREE.Camera||a instanceof THREE.Bone)&&-1===this.__objects.indexOf(a)){this.__objects.push(a);this.__objectsAdded.push(a);var b=this.__objectsRemoved.indexOf(a);-1!==b&&this.__objectsRemoved.splice(b,1)}for(b=0;b<a.children.length;b++)this.__addObject(a.children[b])};
THREE.Scene.prototype.__removeObject=function(a){if(a instanceof THREE.Light){var b=this.__lights.indexOf(a);-1!==b&&this.__lights.splice(b,1)}else a instanceof THREE.Camera||(b=this.__objects.indexOf(a),-1!==b&&(this.__objects.splice(b,1),this.__objectsRemoved.push(a),b=this.__objectsAdded.indexOf(a),-1!==b&&this.__objectsAdded.splice(b,1)));for(b=0;b<a.children.length;b++)this.__removeObject(a.children[b])};
THREE.Fog=function(a,b,c){this.color=new THREE.Color(a);this.near=void 0!==b?b:1;this.far=void 0!==c?c:1E3};THREE.FogExp2=function(a,b){this.color=new THREE.Color(a);this.density=void 0!==b?b:2.5E-4};
THREE.CanvasRenderer=function(a){function b(a){B!==a&&(B=q.globalAlpha=a)}function c(a){u!==a&&(a===THREE.NormalBlending?q.globalCompositeOperation="source-over":a===THREE.AdditiveBlending?q.globalCompositeOperation="lighter":a===THREE.SubtractiveBlending&&(q.globalCompositeOperation="darker"),u=a)}function d(a){s!==a&&(s=q.strokeStyle=a)}function e(a){z!==a&&(z=q.fillStyle=a)}console.log("THREE.CanvasRenderer",THREE.REVISION);var a=a||{},f=this,g,h,i,j=new THREE.Projector,l=void 0!==a.canvas?a.canvas:
document.createElement("canvas"),m,n,p,o,q=l.getContext("2d"),r=new THREE.Color(0),t=0,B=1,u=0,s=null,z=null,A=null,v=null,y=null,C,G,H,J,E=new THREE.RenderableVertex,M=new THREE.RenderableVertex,K,F,I,L,R,$,Y,N,ea,Q,qa,la,O=new THREE.Color,fa=new THREE.Color,W=new THREE.Color,V=new THREE.Color,ia=new THREE.Color,Z=new THREE.Color,ca=new THREE.Color,Ga={},Pa={},Ia,Ua,na,Va,ib,Ra,eb,pb,Pb,db,$a=new THREE.Rectangle,Ja=new THREE.Rectangle,wa=new THREE.Rectangle,wb=!1,Da=new THREE.Color,qb=new THREE.Color,
fb=new THREE.Color,ra=new THREE.Vector3,gb,Za,Wa,Ea,xb,k,a=16;gb=document.createElement("canvas");gb.width=gb.height=2;Za=gb.getContext("2d");Za.fillStyle="rgba(0,0,0,1)";Za.fillRect(0,0,2,2);Wa=Za.getImageData(0,0,2,2);Ea=Wa.data;xb=document.createElement("canvas");xb.width=xb.height=a;k=xb.getContext("2d");k.translate(-a/2,-a/2);k.scale(a,a);a--;this.domElement=l;this.sortElements=this.sortObjects=this.autoClear=!0;this.info={render:{vertices:0,faces:0}};this.setSize=function(a,b){m=a;n=b;p=Math.floor(m/
2);o=Math.floor(n/2);l.width=m;l.height=n;$a.set(-p,-o,p,o);Ja.set(-p,-o,p,o);B=1;u=0;y=v=A=z=s=null};this.setClearColor=function(a,b){r.copy(a);t=void 0!==b?b:1;Ja.set(-p,-o,p,o)};this.setClearColorHex=function(a,b){r.setHex(a);t=void 0!==b?b:1;Ja.set(-p,-o,p,o)};this.getMaxAnisotropy=function(){return 0};this.clear=function(){q.setTransform(1,0,0,-1,p,o);!1===Ja.isEmpty()&&(Ja.minSelf($a),Ja.inflate(2),1>t&&q.clearRect(Math.floor(Ja.getX()),Math.floor(Ja.getY()),Math.floor(Ja.getWidth()),Math.floor(Ja.getHeight())),
0<t&&(c(THREE.NormalBlending),b(1),e("rgba("+Math.floor(255*r.r)+","+Math.floor(255*r.g)+","+Math.floor(255*r.b)+","+t+")"),q.fillRect(Math.floor(Ja.getX()),Math.floor(Ja.getY()),Math.floor(Ja.getWidth()),Math.floor(Ja.getHeight()))),Ja.empty())};this.render=function(a,l){function m(a,b,c){for(var d=0,e=i.length;d<e;d++){var f=i[d],g=f.color;if(f instanceof THREE.DirectionalLight){var h=f.matrixWorld.getPosition().normalize(),k=b.dot(h);0>=k||(k*=f.intensity,c.r+=g.r*k,c.g+=g.g*k,c.b+=g.b*k)}else f instanceof
THREE.PointLight&&(h=f.matrixWorld.getPosition(),k=b.dot(ra.sub(h,a).normalize()),0>=k||(k*=0==f.distance?1:1-Math.min(a.distanceTo(h)/f.distance,1),0!=k&&(k*=f.intensity,c.r+=g.r*k,c.g+=g.g*k,c.b+=g.b*k)))}}function n(a,d,e,g,h,k,i,j){f.info.render.vertices+=3;f.info.render.faces++;b(j.opacity);c(j.blending);K=a.positionScreen.x;F=a.positionScreen.y;I=d.positionScreen.x;L=d.positionScreen.y;R=e.positionScreen.x;$=e.positionScreen.y;r(K,F,I,L,R,$);(j instanceof THREE.MeshLambertMaterial||j instanceof
THREE.MeshPhongMaterial)&&null===j.map&&null===j.map?(Z.copy(j.color),ca.copy(j.emissive),j.vertexColors===THREE.FaceColors&&(Z.r*=i.color.r,Z.g*=i.color.g,Z.b*=i.color.b),!0===wb)?!1===j.wireframe&&j.shading==THREE.SmoothShading&&3==i.vertexNormalsLength?(fa.r=W.r=V.r=Da.r,fa.g=W.g=V.g=Da.g,fa.b=W.b=V.b=Da.b,m(i.v1.positionWorld,i.vertexNormalsWorld[0],fa),m(i.v2.positionWorld,i.vertexNormalsWorld[1],W),m(i.v3.positionWorld,i.vertexNormalsWorld[2],V),fa.r=fa.r*Z.r+ca.r,fa.g=fa.g*Z.g+ca.g,fa.b=fa.b*
Z.b+ca.b,W.r=W.r*Z.r+ca.r,W.g=W.g*Z.g+ca.g,W.b=W.b*Z.b+ca.b,V.r=V.r*Z.r+ca.r,V.g=V.g*Z.g+ca.g,V.b=V.b*Z.b+ca.b,ia.r=0.5*(W.r+V.r),ia.g=0.5*(W.g+V.g),ia.b=0.5*(W.b+V.b),na=Dc(fa,W,V,ia),gc(K,F,I,L,R,$,0,0,1,0,0,1,na)):(O.r=Da.r,O.g=Da.g,O.b=Da.b,m(i.centroidWorld,i.normalWorld,O),O.r=O.r*Z.r+ca.r,O.g=O.g*Z.g+ca.g,O.b=O.b*Z.b+ca.b,!0===j.wireframe?t(O,j.wireframeLinewidth,j.wireframeLinecap,j.wireframeLinejoin):u(O)):!0===j.wireframe?t(j.color,j.wireframeLinewidth,j.wireframeLinecap,j.wireframeLinejoin):
u(j.color):j instanceof THREE.MeshBasicMaterial||j instanceof THREE.MeshLambertMaterial||j instanceof THREE.MeshPhongMaterial?null!==j.map?j.map.mapping instanceof THREE.UVMapping&&(Va=i.uvs[0],Ba(K,F,I,L,R,$,Va[g].u,Va[g].v,Va[h].u,Va[h].v,Va[k].u,Va[k].v,j.map)):null!==j.envMap?j.envMap.mapping instanceof THREE.SphericalReflectionMapping&&(a=l.matrixWorldInverse,ra.copy(i.vertexNormalsWorld[g]),ib=0.5*(ra.x*a.elements[0]+ra.y*a.elements[4]+ra.z*a.elements[8])+0.5,Ra=0.5*(ra.x*a.elements[1]+ra.y*
a.elements[5]+ra.z*a.elements[9])+0.5,ra.copy(i.vertexNormalsWorld[h]),eb=0.5*(ra.x*a.elements[0]+ra.y*a.elements[4]+ra.z*a.elements[8])+0.5,pb=0.5*(ra.x*a.elements[1]+ra.y*a.elements[5]+ra.z*a.elements[9])+0.5,ra.copy(i.vertexNormalsWorld[k]),Pb=0.5*(ra.x*a.elements[0]+ra.y*a.elements[4]+ra.z*a.elements[8])+0.5,db=0.5*(ra.x*a.elements[1]+ra.y*a.elements[5]+ra.z*a.elements[9])+0.5,Ba(K,F,I,L,R,$,ib,Ra,eb,pb,Pb,db,j.envMap)):(O.copy(j.color),j.vertexColors===THREE.FaceColors&&(O.r*=i.color.r,O.g*=
i.color.g,O.b*=i.color.b),!0===j.wireframe?t(O,j.wireframeLinewidth,j.wireframeLinecap,j.wireframeLinejoin):u(O)):j instanceof THREE.MeshDepthMaterial?(Ia=l.near,Ua=l.far,fa.r=fa.g=fa.b=1-tb(a.positionScreen.z,Ia,Ua),W.r=W.g=W.b=1-tb(d.positionScreen.z,Ia,Ua),V.r=V.g=V.b=1-tb(e.positionScreen.z,Ia,Ua),ia.r=0.5*(W.r+V.r),ia.g=0.5*(W.g+V.g),ia.b=0.5*(W.b+V.b),na=Dc(fa,W,V,ia),gc(K,F,I,L,R,$,0,0,1,0,0,1,na)):j instanceof THREE.MeshNormalMaterial&&(O.r=jc(i.normalWorld.x),O.g=jc(i.normalWorld.y),O.b=
jc(i.normalWorld.z),!0===j.wireframe?t(O,j.wireframeLinewidth,j.wireframeLinecap,j.wireframeLinejoin):u(O))}function r(a,b,c,d,e,f){q.beginPath();q.moveTo(a,b);q.lineTo(c,d);q.lineTo(e,f);q.closePath()}function s(a,b,c,d,e,f,g,h){q.beginPath();q.moveTo(a,b);q.lineTo(c,d);q.lineTo(e,f);q.lineTo(g,h);q.closePath()}function t(a,b,c,e){A!==b&&(A=q.lineWidth=b);v!==c&&(v=q.lineCap=c);y!==e&&(y=q.lineJoin=e);d(a.getContextStyle());q.stroke();wa.inflate(2*b)}function u(a){e(a.getContextStyle());q.fill()}
function Ba(a,b,c,d,f,g,h,k,i,j,l,m,n){if(!(n instanceof THREE.DataTexture||void 0===n.image||0==n.image.width)){if(!0===n.needsUpdate){var Ba=n.wrapS==THREE.RepeatWrapping,o=n.wrapT==THREE.RepeatWrapping;Ga[n.id]=q.createPattern(n.image,!0===Ba&&!0===o?"repeat":!0===Ba&&!1===o?"repeat-x":!1===Ba&&!0===o?"repeat-y":"no-repeat");n.needsUpdate=!1}void 0===Ga[n.id]?e("rgba(0,0,0,1)"):e(Ga[n.id]);var Ba=n.offset.x/n.repeat.x,o=n.offset.y/n.repeat.y,p=n.image.width*n.repeat.x,tb=n.image.height*n.repeat.y,
h=(h+Ba)*p,k=(1-k+o)*tb,c=c-a,d=d-b,f=f-a,g=g-b,i=(i+Ba)*p-h,j=(1-j+o)*tb-k,l=(l+Ba)*p-h,m=(1-m+o)*tb-k,Ba=i*m-l*j;0===Ba?(void 0===Pa[n.id]&&(b=document.createElement("canvas"),b.width=n.image.width,b.height=n.image.height,b=b.getContext("2d"),b.drawImage(n.image,0,0),Pa[n.id]=b.getImageData(0,0,n.image.width,n.image.height).data),b=Pa[n.id],h=4*(Math.floor(h)+Math.floor(k)*n.image.width),O.setRGB(b[h]/255,b[h+1]/255,b[h+2]/255),u(O)):(Ba=1/Ba,n=(m*c-j*f)*Ba,j=(m*d-j*g)*Ba,c=(i*f-l*c)*Ba,d=(i*g-
l*d)*Ba,a=a-n*h-c*k,h=b-j*h-d*k,q.save(),q.transform(n,j,c,d,a,h),q.fill(),q.restore())}}function gc(a,b,c,d,e,f,g,h,k,i,j,l,n){var m,Ba;m=n.width-1;Ba=n.height-1;g*=m;h*=Ba;c-=a;d-=b;e-=a;f-=b;k=k*m-g;i=i*Ba-h;j=j*m-g;l=l*Ba-h;Ba=1/(k*l-j*i);m=(l*c-i*e)*Ba;i=(l*d-i*f)*Ba;c=(k*e-j*c)*Ba;d=(k*f-j*d)*Ba;a=a-m*g-c*h;b=b-i*g-d*h;q.save();q.transform(m,i,c,d,a,b);q.clip();q.drawImage(n,0,0);q.restore()}function Dc(a,b,c,d){Ea[0]=255*a.r|0;Ea[1]=255*a.g|0;Ea[2]=255*a.b|0;Ea[4]=255*b.r|0;Ea[5]=255*b.g|0;
Ea[6]=255*b.b|0;Ea[8]=255*c.r|0;Ea[9]=255*c.g|0;Ea[10]=255*c.b|0;Ea[12]=255*d.r|0;Ea[13]=255*d.g|0;Ea[14]=255*d.b|0;Za.putImageData(Wa,0,0);k.drawImage(gb,0,0);return xb}function tb(a,b,c){a=(a-b)/(c-b);return a*a*(3-2*a)}function jc(a){a=0.5*(a+1);return 0>a?0:1<a?1:a}function Wb(a,b){var c=b.x-a.x,d=b.y-a.y,e=c*c+d*d;0!==e&&(e=1/Math.sqrt(e),c*=e,d*=e,b.x+=c,b.y+=d,a.x-=c,a.y-=d)}if(!1===l instanceof THREE.Camera)console.error("THREE.CanvasRenderer.render: camera is not an instance of THREE.Camera.");
else{var B,Fc,ja,aa;!0===this.autoClear?this.clear():q.setTransform(1,0,0,-1,p,o);f.info.render.vertices=0;f.info.render.faces=0;g=j.projectScene(a,l,this.sortObjects,this.sortElements);h=g.elements;i=g.lights;wb=0<i.length;if(!0===wb){Da.setRGB(0,0,0);qb.setRGB(0,0,0);fb.setRGB(0,0,0);B=0;for(Fc=i.length;B<Fc;B++){aa=i[B];var z=aa.color;aa instanceof THREE.AmbientLight?(Da.r+=z.r,Da.g+=z.g,Da.b+=z.b):aa instanceof THREE.DirectionalLight?(qb.r+=z.r,qb.g+=z.g,qb.b+=z.b):aa instanceof THREE.PointLight&&
(fb.r+=z.r,fb.g+=z.g,fb.b+=z.b)}}B=0;for(Fc=h.length;B<Fc;B++)if(ja=h[B],aa=ja.material,!(void 0===aa||!1===aa.visible)){wa.empty();if(ja instanceof THREE.RenderableParticle){C=ja;C.x*=p;C.y*=o;var z=C,Xa=ja;b(aa.opacity);c(aa.blending);var rb=void 0,sb=void 0,jb=void 0,kb=void 0,kc=ja=void 0,Uc=void 0;aa instanceof THREE.ParticleBasicMaterial?null===aa.map?(jb=Xa.object.scale.x,kb=Xa.object.scale.y,jb*=Xa.scale.x*p,kb*=Xa.scale.y*o,wa.set(z.x-jb,z.y-kb,z.x+jb,z.y+kb),!1!==$a.intersects(wa)&&(e(aa.color.getContextStyle()),
q.save(),q.translate(z.x,z.y),q.rotate(-Xa.rotation),q.scale(jb,kb),q.fillRect(-1,-1,2,2),q.restore())):(ja=aa.map.image,kc=ja.width>>1,Uc=ja.height>>1,jb=Xa.scale.x*p,kb=Xa.scale.y*o,rb=jb*kc,sb=kb*Uc,wa.set(z.x-rb,z.y-sb,z.x+rb,z.y+sb),!1!==$a.intersects(wa)&&(q.save(),q.translate(z.x,z.y),q.rotate(-Xa.rotation),q.scale(jb,-kb),q.translate(-kc,-Uc),q.drawImage(ja,0,0),q.restore())):aa instanceof THREE.ParticleCanvasMaterial&&(rb=Xa.scale.x*p,sb=Xa.scale.y*o,wa.set(z.x-rb,z.y-sb,z.x+rb,z.y+sb),!1!==
$a.intersects(wa)&&(d(aa.color.getContextStyle()),e(aa.color.getContextStyle()),q.save(),q.translate(z.x,z.y),q.rotate(-Xa.rotation),q.scale(rb,sb),aa.program(q),q.restore()))}else if(ja instanceof THREE.RenderableLine){if(C=ja.v1,G=ja.v2,C.positionScreen.x*=p,C.positionScreen.y*=o,G.positionScreen.x*=p,G.positionScreen.y*=o,wa.addPoint(C.positionScreen.x,C.positionScreen.y),wa.addPoint(G.positionScreen.x,G.positionScreen.y),!0===$a.intersects(wa)&&(z=C,Xa=G,b(aa.opacity),c(aa.blending),q.beginPath(),
q.moveTo(z.positionScreen.x,z.positionScreen.y),q.lineTo(Xa.positionScreen.x,Xa.positionScreen.y),aa instanceof THREE.LineBasicMaterial))z=aa.linewidth,A!==z&&(A=q.lineWidth=z),z=aa.linecap,v!==z&&(v=q.lineCap=z),z=aa.linejoin,y!==z&&(y=q.lineJoin=z),d(aa.color.getContextStyle()),q.stroke(),wa.inflate(2*aa.linewidth)}else if(ja instanceof THREE.RenderableFace3)C=ja.v1,G=ja.v2,H=ja.v3,C.positionScreen.x*=p,C.positionScreen.y*=o,G.positionScreen.x*=p,G.positionScreen.y*=o,H.positionScreen.x*=p,H.positionScreen.y*=
o,!0===aa.overdraw&&(Wb(C.positionScreen,G.positionScreen),Wb(G.positionScreen,H.positionScreen),Wb(H.positionScreen,C.positionScreen)),wa.add3Points(C.positionScreen.x,C.positionScreen.y,G.positionScreen.x,G.positionScreen.y,H.positionScreen.x,H.positionScreen.y),!0===$a.intersects(wa)&&n(C,G,H,0,1,2,ja,aa,a);else if(ja instanceof THREE.RenderableFace4&&(C=ja.v1,G=ja.v2,H=ja.v3,J=ja.v4,C.positionScreen.x*=p,C.positionScreen.y*=o,G.positionScreen.x*=p,G.positionScreen.y*=o,H.positionScreen.x*=p,H.positionScreen.y*=
o,J.positionScreen.x*=p,J.positionScreen.y*=o,E.positionScreen.copy(G.positionScreen),M.positionScreen.copy(J.positionScreen),!0===aa.overdraw&&(Wb(C.positionScreen,G.positionScreen),Wb(G.positionScreen,J.positionScreen),Wb(J.positionScreen,C.positionScreen),Wb(H.positionScreen,E.positionScreen),Wb(H.positionScreen,M.positionScreen)),wa.addPoint(C.positionScreen.x,C.positionScreen.y),wa.addPoint(G.positionScreen.x,G.positionScreen.y),wa.addPoint(H.positionScreen.x,H.positionScreen.y),wa.addPoint(J.positionScreen.x,
J.positionScreen.y),!0===$a.intersects(wa)))(z=C,Xa=G,rb=H,sb=J,jb=E,kb=M,kc=a,f.info.render.vertices+=4,f.info.render.faces++,b(aa.opacity),c(aa.blending),void 0!==aa.map&&null!==aa.map||void 0!==aa.envMap&&null!==aa.envMap)?(n(z,Xa,sb,0,1,3,ja,aa,kc),n(jb,rb,kb,1,2,3,ja,aa,kc)):(K=z.positionScreen.x,F=z.positionScreen.y,I=Xa.positionScreen.x,L=Xa.positionScreen.y,R=rb.positionScreen.x,$=rb.positionScreen.y,Y=sb.positionScreen.x,N=sb.positionScreen.y,ea=jb.positionScreen.x,Q=jb.positionScreen.y,
qa=kb.positionScreen.x,la=kb.positionScreen.y,aa instanceof THREE.MeshLambertMaterial||aa instanceof THREE.MeshPhongMaterial)?(Z.copy(aa.color),ca.copy(aa.emissive),aa.vertexColors===THREE.FaceColors&&(Z.r*=ja.color.r,Z.g*=ja.color.g,Z.b*=ja.color.b),!0===wb)?!1===aa.wireframe&&aa.shading==THREE.SmoothShading&&4==ja.vertexNormalsLength?(fa.r=W.r=V.r=ia.r=Da.r,fa.g=W.g=V.g=ia.g=Da.g,fa.b=W.b=V.b=ia.b=Da.b,m(ja.v1.positionWorld,ja.vertexNormalsWorld[0],fa),m(ja.v2.positionWorld,ja.vertexNormalsWorld[1],
W),m(ja.v4.positionWorld,ja.vertexNormalsWorld[3],V),m(ja.v3.positionWorld,ja.vertexNormalsWorld[2],ia),fa.r=fa.r*Z.r+ca.r,fa.g=fa.g*Z.g+ca.g,fa.b=fa.b*Z.b+ca.b,W.r=W.r*Z.r+ca.r,W.g=W.g*Z.g+ca.g,W.b=W.b*Z.b+ca.b,V.r=V.r*Z.r+ca.r,V.g=V.g*Z.g+ca.g,V.b=V.b*Z.b+ca.b,ia.r=ia.r*Z.r+ca.r,ia.g=ia.g*Z.g+ca.g,ia.b=ia.b*Z.b+ca.b,na=Dc(fa,W,V,ia),r(K,F,I,L,Y,N),gc(K,F,I,L,Y,N,0,0,1,0,0,1,na),r(ea,Q,R,$,qa,la),gc(ea,Q,R,$,qa,la,1,0,1,1,0,1,na)):(O.r=Da.r,O.g=Da.g,O.b=Da.b,m(ja.centroidWorld,ja.normalWorld,O),
O.r=O.r*Z.r+ca.r,O.g=O.g*Z.g+ca.g,O.b=O.b*Z.b+ca.b,s(K,F,I,L,R,$,Y,N),!0===aa.wireframe?t(O,aa.wireframeLinewidth,aa.wireframeLinecap,aa.wireframeLinejoin):u(O)):(O.r=Z.r+ca.r,O.g=Z.g+ca.g,O.b=Z.b+ca.b,s(K,F,I,L,R,$,Y,N),!0===aa.wireframe?t(O,aa.wireframeLinewidth,aa.wireframeLinecap,aa.wireframeLinejoin):u(O)):aa instanceof THREE.MeshBasicMaterial?(O.copy(aa.color),aa.vertexColors===THREE.FaceColors&&(O.r*=ja.color.r,O.g*=ja.color.g,O.b*=ja.color.b),s(K,F,I,L,R,$,Y,N),!0===aa.wireframe?t(O,aa.wireframeLinewidth,
aa.wireframeLinecap,aa.wireframeLinejoin):u(O)):aa instanceof THREE.MeshNormalMaterial?(O.r=jc(ja.normalWorld.x),O.g=jc(ja.normalWorld.y),O.b=jc(ja.normalWorld.z),s(K,F,I,L,R,$,Y,N),!0===aa.wireframe?t(O,aa.wireframeLinewidth,aa.wireframeLinecap,aa.wireframeLinejoin):u(O)):aa instanceof THREE.MeshDepthMaterial&&(Ia=l.near,Ua=l.far,fa.r=fa.g=fa.b=1-tb(z.positionScreen.z,Ia,Ua),W.r=W.g=W.b=1-tb(Xa.positionScreen.z,Ia,Ua),V.r=V.g=V.b=1-tb(sb.positionScreen.z,Ia,Ua),ia.r=ia.g=ia.b=1-tb(rb.positionScreen.z,
Ia,Ua),na=Dc(fa,W,V,ia),r(K,F,I,L,Y,N),gc(K,F,I,L,Y,N,0,0,1,0,0,1,na),r(ea,Q,R,$,qa,la),gc(ea,Q,R,$,qa,la,1,0,1,1,0,1,na));Ja.addRectangle(wa)}q.setTransform(1,0,0,1,0,0)}}};
THREE.ShaderChunk={fog_pars_fragment:"#ifdef USE_FOG\nuniform vec3 fogColor;\n#ifdef FOG_EXP2\nuniform float fogDensity;\n#else\nuniform float fogNear;\nuniform float fogFar;\n#endif\n#endif",fog_fragment:"#ifdef USE_FOG\nfloat depth = gl_FragCoord.z / gl_FragCoord.w;\n#ifdef FOG_EXP2\nconst float LOG2 = 1.442695;\nfloat fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );\nfogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );\n#else\nfloat fogFactor = smoothstep( fogNear, fogFar, depth );\n#endif\ngl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );\n#endif",envmap_pars_fragment:"#ifdef USE_ENVMAP\nuniform float reflectivity;\nuniform samplerCube envMap;\nuniform float flipEnvMap;\nuniform int combine;\n#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\nuniform bool useRefract;\nuniform float refractionRatio;\n#else\nvarying vec3 vReflect;\n#endif\n#endif",
envmap_fragment:"#ifdef USE_ENVMAP\nvec3 reflectVec;\n#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\nvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\nif ( useRefract ) {\nreflectVec = refract( cameraToVertex, normal, refractionRatio );\n} else { \nreflectVec = reflect( cameraToVertex, normal );\n}\n#else\nreflectVec = vReflect;\n#endif\n#ifdef DOUBLE_SIDED\nfloat flipNormal = ( -1.0 + 2.0 * float( gl_FrontFacing ) );\nvec4 cubeColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n#else\nvec4 cubeColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n#endif\n#ifdef GAMMA_INPUT\ncubeColor.xyz *= cubeColor.xyz;\n#endif\nif ( combine == 1 ) {\ngl_FragColor.xyz = mix( gl_FragColor.xyz, cubeColor.xyz, specularStrength * reflectivity );\n} else {\ngl_FragColor.xyz = mix( gl_FragColor.xyz, gl_FragColor.xyz * cubeColor.xyz, specularStrength * reflectivity );\n}\n#endif",
envmap_pars_vertex:"#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP )\nvarying vec3 vReflect;\nuniform float refractionRatio;\nuniform bool useRefract;\n#endif",worldpos_vertex:"#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\n#ifdef USE_SKINNING\nvec4 mPosition = modelMatrix * skinned;\n#endif\n#if defined( USE_MORPHTARGETS ) && ! defined( USE_SKINNING )\nvec4 mPosition = modelMatrix * vec4( morphed, 1.0 );\n#endif\n#if ! defined( USE_MORPHTARGETS ) && ! defined( USE_SKINNING )\nvec4 mPosition = modelMatrix * vec4( position, 1.0 );\n#endif\n#endif",
envmap_vertex:"#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP )\nvec3 nWorld = mat3( modelMatrix[ 0 ].xyz, modelMatrix[ 1 ].xyz, modelMatrix[ 2 ].xyz ) * objectNormal;\nif ( useRefract ) {\nvReflect = refract( normalize( mPosition.xyz - cameraPosition ), normalize( nWorld.xyz ), refractionRatio );\n} else {\nvReflect = reflect( normalize( mPosition.xyz - cameraPosition ), normalize( nWorld.xyz ) );\n}\n#endif",map_particle_pars_fragment:"#ifdef USE_MAP\nuniform sampler2D map;\n#endif",
map_particle_fragment:"#ifdef USE_MAP\ngl_FragColor = gl_FragColor * texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) );\n#endif",map_pars_vertex:"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP )\nvarying vec2 vUv;\nuniform vec4 offsetRepeat;\n#endif",map_pars_fragment:"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP )\nvarying vec2 vUv;\n#endif\n#ifdef USE_MAP\nuniform sampler2D map;\n#endif",
map_vertex:"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP )\nvUv = uv * offsetRepeat.zw + offsetRepeat.xy;\n#endif",map_fragment:"#ifdef USE_MAP\n#ifdef GAMMA_INPUT\nvec4 texelColor = texture2D( map, vUv );\ntexelColor.xyz *= texelColor.xyz;\ngl_FragColor = gl_FragColor * texelColor;\n#else\ngl_FragColor = gl_FragColor * texture2D( map, vUv );\n#endif\n#endif",lightmap_pars_fragment:"#ifdef USE_LIGHTMAP\nvarying vec2 vUv2;\nuniform sampler2D lightMap;\n#endif",
lightmap_pars_vertex:"#ifdef USE_LIGHTMAP\nvarying vec2 vUv2;\n#endif",lightmap_fragment:"#ifdef USE_LIGHTMAP\ngl_FragColor = gl_FragColor * texture2D( lightMap, vUv2 );\n#endif",lightmap_vertex:"#ifdef USE_LIGHTMAP\nvUv2 = uv2;\n#endif",bumpmap_pars_fragment:"#ifdef USE_BUMPMAP\nuniform sampler2D bumpMap;\nuniform float bumpScale;\nvec2 dHdxy_fwd() {\nvec2 dSTdx = dFdx( vUv );\nvec2 dSTdy = dFdy( vUv );\nfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\nfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\nfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\nreturn vec2( dBx, dBy );\n}\nvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\nvec3 vSigmaX = dFdx( surf_pos );\nvec3 vSigmaY = dFdy( surf_pos );\nvec3 vN = surf_norm;\nvec3 R1 = cross( vSigmaY, vN );\nvec3 R2 = cross( vN, vSigmaX );\nfloat fDet = dot( vSigmaX, R1 );\nvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\nreturn normalize( abs( fDet ) * surf_norm - vGrad );\n}\n#endif",
normalmap_pars_fragment:"#ifdef USE_NORMALMAP\nuniform sampler2D normalMap;\nuniform vec2 normalScale;\nvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\nvec3 q0 = dFdx( eye_pos.xyz );\nvec3 q1 = dFdy( eye_pos.xyz );\nvec2 st0 = dFdx( vUv.st );\nvec2 st1 = dFdy( vUv.st );\nvec3 S = normalize(  q0 * st1.t - q1 * st0.t );\nvec3 T = normalize( -q0 * st1.s + q1 * st0.s );\nvec3 N = normalize( surf_norm );\nvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\nmapN.xy = normalScale * mapN.xy;\nmat3 tsn = mat3( S, T, N );\nreturn normalize( tsn * mapN );\n}\n#endif",
specularmap_pars_fragment:"#ifdef USE_SPECULARMAP\nuniform sampler2D specularMap;\n#endif",specularmap_fragment:"float specularStrength;\n#ifdef USE_SPECULARMAP\nvec4 texelSpecular = texture2D( specularMap, vUv );\nspecularStrength = texelSpecular.r;\n#else\nspecularStrength = 1.0;\n#endif",lights_lambert_pars_vertex:"uniform vec3 ambient;\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 ambientLightColor;\n#if MAX_DIR_LIGHTS > 0\nuniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\nuniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\n#endif\n#if MAX_HEMI_LIGHTS > 0\nuniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\nuniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\nuniform vec3 hemisphereLightPosition[ MAX_HEMI_LIGHTS ];\n#endif\n#if MAX_POINT_LIGHTS > 0\nuniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\nuniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\nuniform float pointLightDistance[ MAX_POINT_LIGHTS ];\n#endif\n#if MAX_SPOT_LIGHTS > 0\nuniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\nuniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\nuniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\nuniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\nuniform float spotLightAngle[ MAX_SPOT_LIGHTS ];\nuniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\n#endif\n#ifdef WRAP_AROUND\nuniform vec3 wrapRGB;\n#endif",
lights_lambert_vertex:"vLightFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\nvLightBack = vec3( 0.0 );\n#endif\ntransformedNormal = normalize( transformedNormal );\n#if MAX_DIR_LIGHTS > 0\nfor( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\nvec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );\nvec3 dirVector = normalize( lDirection.xyz );\nfloat dotProduct = dot( transformedNormal, dirVector );\nvec3 directionalLightWeighting = vec3( max( dotProduct, 0.0 ) );\n#ifdef DOUBLE_SIDED\nvec3 directionalLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\n#ifdef WRAP_AROUND\nvec3 directionalLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\n#endif\n#endif\n#ifdef WRAP_AROUND\nvec3 directionalLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\ndirectionalLightWeighting = mix( directionalLightWeighting, directionalLightWeightingHalf, wrapRGB );\n#ifdef DOUBLE_SIDED\ndirectionalLightWeightingBack = mix( directionalLightWeightingBack, directionalLightWeightingHalfBack, wrapRGB );\n#endif\n#endif\nvLightFront += directionalLightColor[ i ] * directionalLightWeighting;\n#ifdef DOUBLE_SIDED\nvLightBack += directionalLightColor[ i ] * directionalLightWeightingBack;\n#endif\n}\n#endif\n#if MAX_POINT_LIGHTS > 0\nfor( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\nvec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\nvec3 lVector = lPosition.xyz - mvPosition.xyz;\nfloat lDistance = 1.0;\nif ( pointLightDistance[ i ] > 0.0 )\nlDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );\nlVector = normalize( lVector );\nfloat dotProduct = dot( transformedNormal, lVector );\nvec3 pointLightWeighting = vec3( max( dotProduct, 0.0 ) );\n#ifdef DOUBLE_SIDED\nvec3 pointLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\n#ifdef WRAP_AROUND\nvec3 pointLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\n#endif\n#endif\n#ifdef WRAP_AROUND\nvec3 pointLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\npointLightWeighting = mix( pointLightWeighting, pointLightWeightingHalf, wrapRGB );\n#ifdef DOUBLE_SIDED\npointLightWeightingBack = mix( pointLightWeightingBack, pointLightWeightingHalfBack, wrapRGB );\n#endif\n#endif\nvLightFront += pointLightColor[ i ] * pointLightWeighting * lDistance;\n#ifdef DOUBLE_SIDED\nvLightBack += pointLightColor[ i ] * pointLightWeightingBack * lDistance;\n#endif\n}\n#endif\n#if MAX_SPOT_LIGHTS > 0\nfor( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\nvec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\nvec3 lVector = lPosition.xyz - mvPosition.xyz;\nlVector = normalize( lVector );\nfloat spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - mPosition.xyz ) );\nif ( spotEffect > spotLightAngle[ i ] ) {\nspotEffect = pow( spotEffect, spotLightExponent[ i ] );\nfloat lDistance = 1.0;\nif ( spotLightDistance[ i ] > 0.0 )\nlDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );\nfloat dotProduct = dot( transformedNormal, lVector );\nvec3 spotLightWeighting = vec3( max( dotProduct, 0.0 ) );\n#ifdef DOUBLE_SIDED\nvec3 spotLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\n#ifdef WRAP_AROUND\nvec3 spotLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\n#endif\n#endif\n#ifdef WRAP_AROUND\nvec3 spotLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\nspotLightWeighting = mix( spotLightWeighting, spotLightWeightingHalf, wrapRGB );\n#ifdef DOUBLE_SIDED\nspotLightWeightingBack = mix( spotLightWeightingBack, spotLightWeightingHalfBack, wrapRGB );\n#endif\n#endif\nvLightFront += spotLightColor[ i ] * spotLightWeighting * lDistance * spotEffect;\n#ifdef DOUBLE_SIDED\nvLightBack += spotLightColor[ i ] * spotLightWeightingBack * lDistance * spotEffect;\n#endif\n}\n}\n#endif\n#if MAX_HEMI_LIGHTS > 0\nfor( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\nvec4 lPosition = viewMatrix * vec4( hemisphereLightPosition[ i ], 1.0 );\nvec3 lVector = lPosition.xyz - mvPosition.xyz;\nlVector = normalize( lVector );\nfloat dotProduct = dot( transformedNormal, lVector );\nfloat hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\nfloat hemiDiffuseWeightBack = -0.5 * dotProduct + 0.5;\nvLightFront += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\n#ifdef DOUBLE_SIDED\nvLightBack += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeightBack );\n#endif\n}\n#endif\nvLightFront = vLightFront * diffuse + ambient * ambientLightColor + emissive;\n#ifdef DOUBLE_SIDED\nvLightBack = vLightBack * diffuse + ambient * ambientLightColor + emissive;\n#endif",
lights_phong_pars_vertex:"#ifndef PHONG_PER_PIXEL\n#if MAX_POINT_LIGHTS > 0\nuniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\nuniform float pointLightDistance[ MAX_POINT_LIGHTS ];\nvarying vec4 vPointLight[ MAX_POINT_LIGHTS ];\n#endif\n#if MAX_SPOT_LIGHTS > 0\nuniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\nuniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\nvarying vec4 vSpotLight[ MAX_SPOT_LIGHTS ];\n#endif\n#endif\n#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP )\nvarying vec3 vWorldPosition;\n#endif",
lights_phong_vertex:"#ifndef PHONG_PER_PIXEL\n#if MAX_POINT_LIGHTS > 0\nfor( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\nvec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\nvec3 lVector = lPosition.xyz - mvPosition.xyz;\nfloat lDistance = 1.0;\nif ( pointLightDistance[ i ] > 0.0 )\nlDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );\nvPointLight[ i ] = vec4( lVector, lDistance );\n}\n#endif\n#if MAX_SPOT_LIGHTS > 0\nfor( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\nvec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\nvec3 lVector = lPosition.xyz - mvPosition.xyz;\nfloat lDistance = 1.0;\nif ( spotLightDistance[ i ] > 0.0 )\nlDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );\nvSpotLight[ i ] = vec4( lVector, lDistance );\n}\n#endif\n#endif\n#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP )\nvWorldPosition = mPosition.xyz;\n#endif",
lights_phong_pars_fragment:"uniform vec3 ambientLightColor;\n#if MAX_DIR_LIGHTS > 0\nuniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\nuniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\n#endif\n#if MAX_HEMI_LIGHTS > 0\nuniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\nuniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\nuniform vec3 hemisphereLightPosition[ MAX_HEMI_LIGHTS ];\n#endif\n#if MAX_POINT_LIGHTS > 0\nuniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\n#ifdef PHONG_PER_PIXEL\nuniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\nuniform float pointLightDistance[ MAX_POINT_LIGHTS ];\n#else\nvarying vec4 vPointLight[ MAX_POINT_LIGHTS ];\n#endif\n#endif\n#if MAX_SPOT_LIGHTS > 0\nuniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\nuniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\nuniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\nuniform float spotLightAngle[ MAX_SPOT_LIGHTS ];\nuniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\n#ifdef PHONG_PER_PIXEL\nuniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\n#else\nvarying vec4 vSpotLight[ MAX_SPOT_LIGHTS ];\n#endif\n#endif\n#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP )\nvarying vec3 vWorldPosition;\n#endif\n#ifdef WRAP_AROUND\nuniform vec3 wrapRGB;\n#endif\nvarying vec3 vViewPosition;\nvarying vec3 vNormal;",
lights_phong_fragment:"vec3 normal = normalize( vNormal );\nvec3 viewPosition = normalize( vViewPosition );\n#ifdef DOUBLE_SIDED\nnormal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );\n#endif\n#ifdef USE_NORMALMAP\nnormal = perturbNormal2Arb( -viewPosition, normal );\n#elif defined( USE_BUMPMAP )\nnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif\n#if MAX_POINT_LIGHTS > 0\nvec3 pointDiffuse  = vec3( 0.0 );\nvec3 pointSpecular = vec3( 0.0 );\nfor ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\n#ifdef PHONG_PER_PIXEL\nvec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\nvec3 lVector = lPosition.xyz + vViewPosition.xyz;\nfloat lDistance = 1.0;\nif ( pointLightDistance[ i ] > 0.0 )\nlDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );\nlVector = normalize( lVector );\n#else\nvec3 lVector = normalize( vPointLight[ i ].xyz );\nfloat lDistance = vPointLight[ i ].w;\n#endif\nfloat dotProduct = dot( normal, lVector );\n#ifdef WRAP_AROUND\nfloat pointDiffuseWeightFull = max( dotProduct, 0.0 );\nfloat pointDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\nvec3 pointDiffuseWeight = mix( vec3 ( pointDiffuseWeightFull ), vec3( pointDiffuseWeightHalf ), wrapRGB );\n#else\nfloat pointDiffuseWeight = max( dotProduct, 0.0 );\n#endif\npointDiffuse  += diffuse * pointLightColor[ i ] * pointDiffuseWeight * lDistance;\nvec3 pointHalfVector = normalize( lVector + viewPosition );\nfloat pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );\nfloat pointSpecularWeight = specularStrength * max( pow( pointDotNormalHalf, shininess ), 0.0 );\n#ifdef PHYSICALLY_BASED_SHADING\nfloat specularNormalization = ( shininess + 2.0001 ) / 8.0;\nvec3 schlick = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVector, pointHalfVector ), 5.0 );\npointSpecular += schlick * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * lDistance * specularNormalization;\n#else\npointSpecular += specular * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * lDistance;\n#endif\n}\n#endif\n#if MAX_SPOT_LIGHTS > 0\nvec3 spotDiffuse  = vec3( 0.0 );\nvec3 spotSpecular = vec3( 0.0 );\nfor ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\n#ifdef PHONG_PER_PIXEL\nvec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\nvec3 lVector = lPosition.xyz + vViewPosition.xyz;\nfloat lDistance = 1.0;\nif ( spotLightDistance[ i ] > 0.0 )\nlDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );\nlVector = normalize( lVector );\n#else\nvec3 lVector = normalize( vSpotLight[ i ].xyz );\nfloat lDistance = vSpotLight[ i ].w;\n#endif\nfloat spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - vWorldPosition ) );\nif ( spotEffect > spotLightAngle[ i ] ) {\nspotEffect = pow( spotEffect, spotLightExponent[ i ] );\nfloat dotProduct = dot( normal, lVector );\n#ifdef WRAP_AROUND\nfloat spotDiffuseWeightFull = max( dotProduct, 0.0 );\nfloat spotDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\nvec3 spotDiffuseWeight = mix( vec3 ( spotDiffuseWeightFull ), vec3( spotDiffuseWeightHalf ), wrapRGB );\n#else\nfloat spotDiffuseWeight = max( dotProduct, 0.0 );\n#endif\nspotDiffuse += diffuse * spotLightColor[ i ] * spotDiffuseWeight * lDistance * spotEffect;\nvec3 spotHalfVector = normalize( lVector + viewPosition );\nfloat spotDotNormalHalf = max( dot( normal, spotHalfVector ), 0.0 );\nfloat spotSpecularWeight = specularStrength * max( pow( spotDotNormalHalf, shininess ), 0.0 );\n#ifdef PHYSICALLY_BASED_SHADING\nfloat specularNormalization = ( shininess + 2.0001 ) / 8.0;\nvec3 schlick = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVector, spotHalfVector ), 5.0 );\nspotSpecular += schlick * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * lDistance * specularNormalization * spotEffect;\n#else\nspotSpecular += specular * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * lDistance * spotEffect;\n#endif\n}\n}\n#endif\n#if MAX_DIR_LIGHTS > 0\nvec3 dirDiffuse  = vec3( 0.0 );\nvec3 dirSpecular = vec3( 0.0 );\nfor( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\nvec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );\nvec3 dirVector = normalize( lDirection.xyz );\nfloat dotProduct = dot( normal, dirVector );\n#ifdef WRAP_AROUND\nfloat dirDiffuseWeightFull = max( dotProduct, 0.0 );\nfloat dirDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\nvec3 dirDiffuseWeight = mix( vec3( dirDiffuseWeightFull ), vec3( dirDiffuseWeightHalf ), wrapRGB );\n#else\nfloat dirDiffuseWeight = max( dotProduct, 0.0 );\n#endif\ndirDiffuse  += diffuse * directionalLightColor[ i ] * dirDiffuseWeight;\nvec3 dirHalfVector = normalize( dirVector + viewPosition );\nfloat dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );\nfloat dirSpecularWeight = specularStrength * max( pow( dirDotNormalHalf, shininess ), 0.0 );\n#ifdef PHYSICALLY_BASED_SHADING\nfloat specularNormalization = ( shininess + 2.0001 ) / 8.0;\nvec3 schlick = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( dirVector, dirHalfVector ), 5.0 );\ndirSpecular += schlick * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization;\n#else\ndirSpecular += specular * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight;\n#endif\n}\n#endif\n#if MAX_HEMI_LIGHTS > 0\nvec3 hemiDiffuse  = vec3( 0.0 );\nvec3 hemiSpecular = vec3( 0.0 );\nfor( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\nvec4 lPosition = viewMatrix * vec4( hemisphereLightPosition[ i ], 1.0 );\nvec3 lVector = normalize( lPosition.xyz + vViewPosition.xyz );\nfloat dotProduct = dot( normal, lVector );\nfloat hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\nvec3 hemiColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\nhemiDiffuse += diffuse * hemiColor;\nvec3 hemiHalfVectorSky = normalize( lVector + viewPosition );\nfloat hemiDotNormalHalfSky = 0.5 * dot( normal, hemiHalfVectorSky ) + 0.5;\nfloat hemiSpecularWeightSky = specularStrength * max( pow( hemiDotNormalHalfSky, shininess ), 0.0 );\nvec3 lVectorGround = normalize( -lPosition.xyz + vViewPosition.xyz );\nvec3 hemiHalfVectorGround = normalize( lVectorGround + viewPosition );\nfloat hemiDotNormalHalfGround = 0.5 * dot( normal, hemiHalfVectorGround ) + 0.5;\nfloat hemiSpecularWeightGround = specularStrength * max( pow( hemiDotNormalHalfGround, shininess ), 0.0 );\n#ifdef PHYSICALLY_BASED_SHADING\nfloat dotProductGround = dot( normal, lVectorGround );\nfloat specularNormalization = ( shininess + 2.0001 ) / 8.0;\nvec3 schlickSky = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVector, hemiHalfVectorSky ), 5.0 );\nvec3 schlickGround = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVectorGround, hemiHalfVectorGround ), 5.0 );\nhemiSpecular += hemiColor * specularNormalization * ( schlickSky * hemiSpecularWeightSky * max( dotProduct, 0.0 ) + schlickGround * hemiSpecularWeightGround * max( dotProductGround, 0.0 ) );\n#else\nhemiSpecular += specular * hemiColor * ( hemiSpecularWeightSky + hemiSpecularWeightGround ) * hemiDiffuseWeight;\n#endif\n}\n#endif\nvec3 totalDiffuse = vec3( 0.0 );\nvec3 totalSpecular = vec3( 0.0 );\n#if MAX_DIR_LIGHTS > 0\ntotalDiffuse += dirDiffuse;\ntotalSpecular += dirSpecular;\n#endif\n#if MAX_HEMI_LIGHTS > 0\ntotalDiffuse += hemiDiffuse;\ntotalSpecular += hemiSpecular;\n#endif\n#if MAX_POINT_LIGHTS > 0\ntotalDiffuse += pointDiffuse;\ntotalSpecular += pointSpecular;\n#endif\n#if MAX_SPOT_LIGHTS > 0\ntotalDiffuse += spotDiffuse;\ntotalSpecular += spotSpecular;\n#endif\n#ifdef METAL\ngl_FragColor.xyz = gl_FragColor.xyz * ( emissive + totalDiffuse + ambientLightColor * ambient + totalSpecular );\n#else\ngl_FragColor.xyz = gl_FragColor.xyz * ( emissive + totalDiffuse + ambientLightColor * ambient ) + totalSpecular;\n#endif",
color_pars_fragment:"#ifdef USE_COLOR\nvarying vec3 vColor;\n#endif",color_fragment:"#ifdef USE_COLOR\ngl_FragColor = gl_FragColor * vec4( vColor, opacity );\n#endif",color_pars_vertex:"#ifdef USE_COLOR\nvarying vec3 vColor;\n#endif",color_vertex:"#ifdef USE_COLOR\n#ifdef GAMMA_INPUT\nvColor = color * color;\n#else\nvColor = color;\n#endif\n#endif",skinning_pars_vertex:"#ifdef USE_SKINNING\n#ifdef BONE_TEXTURE\nuniform sampler2D boneTexture;\nmat4 getBoneMatrix( const in float i ) {\nfloat j = i * 4.0;\nfloat x = mod( j, N_BONE_PIXEL_X );\nfloat y = floor( j / N_BONE_PIXEL_X );\nconst float dx = 1.0 / N_BONE_PIXEL_X;\nconst float dy = 1.0 / N_BONE_PIXEL_Y;\ny = dy * ( y + 0.5 );\nvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\nvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\nvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\nvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\nmat4 bone = mat4( v1, v2, v3, v4 );\nreturn bone;\n}\n#else\nuniform mat4 boneGlobalMatrices[ MAX_BONES ];\nmat4 getBoneMatrix( const in float i ) {\nmat4 bone = boneGlobalMatrices[ int(i) ];\nreturn bone;\n}\n#endif\n#endif",
skinbase_vertex:"#ifdef USE_SKINNING\nmat4 boneMatX = getBoneMatrix( skinIndex.x );\nmat4 boneMatY = getBoneMatrix( skinIndex.y );\n#endif",skinning_vertex:"#ifdef USE_SKINNING\n#ifdef USE_MORPHTARGETS\nvec4 skinVertex = vec4( morphed, 1.0 );\n#else\nvec4 skinVertex = vec4( position, 1.0 );\n#endif\nvec4 skinned  = boneMatX * skinVertex * skinWeight.x;\nskinned \t  += boneMatY * skinVertex * skinWeight.y;\n#endif",morphtarget_pars_vertex:"#ifdef USE_MORPHTARGETS\n#ifndef USE_MORPHNORMALS\nuniform float morphTargetInfluences[ 8 ];\n#else\nuniform float morphTargetInfluences[ 4 ];\n#endif\n#endif",
morphtarget_vertex:"#ifdef USE_MORPHTARGETS\nvec3 morphed = vec3( 0.0 );\nmorphed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\nmorphed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\nmorphed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\nmorphed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n#ifndef USE_MORPHNORMALS\nmorphed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\nmorphed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\nmorphed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\nmorphed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n#endif\nmorphed += position;\n#endif",
default_vertex:"vec4 mvPosition;\n#ifdef USE_SKINNING\nmvPosition = modelViewMatrix * skinned;\n#endif\n#if !defined( USE_SKINNING ) && defined( USE_MORPHTARGETS )\nmvPosition = modelViewMatrix * vec4( morphed, 1.0 );\n#endif\n#if !defined( USE_SKINNING ) && ! defined( USE_MORPHTARGETS )\nmvPosition = modelViewMatrix * vec4( position, 1.0 );\n#endif\ngl_Position = projectionMatrix * mvPosition;",morphnormal_vertex:"#ifdef USE_MORPHNORMALS\nvec3 morphedNormal = vec3( 0.0 );\nmorphedNormal +=  ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\nmorphedNormal +=  ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\nmorphedNormal +=  ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\nmorphedNormal +=  ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\nmorphedNormal += normal;\n#endif",
skinnormal_vertex:"#ifdef USE_SKINNING\nmat4 skinMatrix = skinWeight.x * boneMatX;\nskinMatrix \t+= skinWeight.y * boneMatY;\n#ifdef USE_MORPHNORMALS\nvec4 skinnedNormal = skinMatrix * vec4( morphedNormal, 0.0 );\n#else\nvec4 skinnedNormal = skinMatrix * vec4( normal, 0.0 );\n#endif\n#endif",defaultnormal_vertex:"vec3 objectNormal;\n#ifdef USE_SKINNING\nobjectNormal = skinnedNormal.xyz;\n#endif\n#if !defined( USE_SKINNING ) && defined( USE_MORPHNORMALS )\nobjectNormal = morphedNormal;\n#endif\n#if !defined( USE_SKINNING ) && ! defined( USE_MORPHNORMALS )\nobjectNormal = normal;\n#endif\n#ifdef FLIP_SIDED\nobjectNormal = -objectNormal;\n#endif\nvec3 transformedNormal = normalMatrix * objectNormal;",
shadowmap_pars_fragment:"#ifdef USE_SHADOWMAP\nuniform sampler2D shadowMap[ MAX_SHADOWS ];\nuniform vec2 shadowMapSize[ MAX_SHADOWS ];\nuniform float shadowDarkness[ MAX_SHADOWS ];\nuniform float shadowBias[ MAX_SHADOWS ];\nvarying vec4 vShadowCoord[ MAX_SHADOWS ];\nfloat unpackDepth( const in vec4 rgba_depth ) {\nconst vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );\nfloat depth = dot( rgba_depth, bit_shift );\nreturn depth;\n}\n#endif",shadowmap_fragment:"#ifdef USE_SHADOWMAP\n#ifdef SHADOWMAP_DEBUG\nvec3 frustumColors[3];\nfrustumColors[0] = vec3( 1.0, 0.5, 0.0 );\nfrustumColors[1] = vec3( 0.0, 1.0, 0.8 );\nfrustumColors[2] = vec3( 0.0, 0.5, 1.0 );\n#endif\n#ifdef SHADOWMAP_CASCADE\nint inFrustumCount = 0;\n#endif\nfloat fDepth;\nvec3 shadowColor = vec3( 1.0 );\nfor( int i = 0; i < MAX_SHADOWS; i ++ ) {\nvec3 shadowCoord = vShadowCoord[ i ].xyz / vShadowCoord[ i ].w;\nbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\nbool inFrustum = all( inFrustumVec );\n#ifdef SHADOWMAP_CASCADE\ninFrustumCount += int( inFrustum );\nbvec3 frustumTestVec = bvec3( inFrustum, inFrustumCount == 1, shadowCoord.z <= 1.0 );\n#else\nbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n#endif\nbool frustumTest = all( frustumTestVec );\nif ( frustumTest ) {\nshadowCoord.z += shadowBias[ i ];\n#ifdef SHADOWMAP_SOFT\nfloat shadow = 0.0;\nconst float shadowDelta = 1.0 / 9.0;\nfloat xPixelOffset = 1.0 / shadowMapSize[ i ].x;\nfloat yPixelOffset = 1.0 / shadowMapSize[ i ].y;\nfloat dx0 = -1.25 * xPixelOffset;\nfloat dy0 = -1.25 * yPixelOffset;\nfloat dx1 = 1.25 * xPixelOffset;\nfloat dy1 = 1.25 * yPixelOffset;\nfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\nif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\nfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\nif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\nfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\nif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\nfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\nif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\nfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\nif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\nfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\nif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\nfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\nif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\nfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\nif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\nfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\nif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\nshadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\n#else\nvec4 rgbaDepth = texture2D( shadowMap[ i ], shadowCoord.xy );\nfloat fDepth = unpackDepth( rgbaDepth );\nif ( fDepth < shadowCoord.z )\nshadowColor = shadowColor * vec3( 1.0 - shadowDarkness[ i ] );\n#endif\n}\n#ifdef SHADOWMAP_DEBUG\n#ifdef SHADOWMAP_CASCADE\nif ( inFrustum && inFrustumCount == 1 ) gl_FragColor.xyz *= frustumColors[ i ];\n#else\nif ( inFrustum ) gl_FragColor.xyz *= frustumColors[ i ];\n#endif\n#endif\n}\n#ifdef GAMMA_OUTPUT\nshadowColor *= shadowColor;\n#endif\ngl_FragColor.xyz = gl_FragColor.xyz * shadowColor;\n#endif",
shadowmap_pars_vertex:"#ifdef USE_SHADOWMAP\nvarying vec4 vShadowCoord[ MAX_SHADOWS ];\nuniform mat4 shadowMatrix[ MAX_SHADOWS ];\n#endif",shadowmap_vertex:"#ifdef USE_SHADOWMAP\nfor( int i = 0; i < MAX_SHADOWS; i ++ ) {\nvShadowCoord[ i ] = shadowMatrix[ i ] * mPosition;\n}\n#endif",alphatest_fragment:"#ifdef ALPHATEST\nif ( gl_FragColor.a < ALPHATEST ) discard;\n#endif",linear_to_gamma_fragment:"#ifdef GAMMA_OUTPUT\ngl_FragColor.xyz = sqrt( gl_FragColor.xyz );\n#endif"};
THREE.UniformsUtils={merge:function(a){var b,c,d,e={};for(b=0;b<a.length;b++)for(c in d=this.clone(a[b]),d)e[c]=d[c];return e},clone:function(a){var b,c,d,e={};for(b in a)for(c in e[b]={},a[b])d=a[b][c],e[b][c]=d instanceof THREE.Color||d instanceof THREE.Vector2||d instanceof THREE.Vector3||d instanceof THREE.Vector4||d instanceof THREE.Matrix4||d instanceof THREE.Texture?d.clone():d instanceof Array?d.slice():d;return e}};
THREE.UniformsLib={common:{diffuse:{type:"c",value:new THREE.Color(15658734)},opacity:{type:"f",value:1},map:{type:"t",value:null},offsetRepeat:{type:"v4",value:new THREE.Vector4(0,0,1,1)},lightMap:{type:"t",value:null},specularMap:{type:"t",value:null},envMap:{type:"t",value:null},flipEnvMap:{type:"f",value:-1},useRefract:{type:"i",value:0},reflectivity:{type:"f",value:1},refractionRatio:{type:"f",value:0.98},combine:{type:"i",value:0},morphTargetInfluences:{type:"f",value:0}},bump:{bumpMap:{type:"t",
value:null},bumpScale:{type:"f",value:1}},normalmap:{normalMap:{type:"t",value:null},normalScale:{type:"v2",value:new THREE.Vector2(1,1)}},fog:{fogDensity:{type:"f",value:2.5E-4},fogNear:{type:"f",value:1},fogFar:{type:"f",value:2E3},fogColor:{type:"c",value:new THREE.Color(16777215)}},lights:{ambientLightColor:{type:"fv",value:[]},directionalLightDirection:{type:"fv",value:[]},directionalLightColor:{type:"fv",value:[]},hemisphereLightPosition:{type:"fv",value:[]},hemisphereLightSkyColor:{type:"fv",
value:[]},hemisphereLightGroundColor:{type:"fv",value:[]},pointLightColor:{type:"fv",value:[]},pointLightPosition:{type:"fv",value:[]},pointLightDistance:{type:"fv1",value:[]},spotLightColor:{type:"fv",value:[]},spotLightPosition:{type:"fv",value:[]},spotLightDirection:{type:"fv",value:[]},spotLightDistance:{type:"fv1",value:[]},spotLightAngle:{type:"fv1",value:[]},spotLightExponent:{type:"fv1",value:[]}},particle:{psColor:{type:"c",value:new THREE.Color(15658734)},opacity:{type:"f",value:1},size:{type:"f",
value:1},scale:{type:"f",value:1},map:{type:"t",value:null},fogDensity:{type:"f",value:2.5E-4},fogNear:{type:"f",value:1},fogFar:{type:"f",value:2E3},fogColor:{type:"c",value:new THREE.Color(16777215)}},shadowmap:{shadowMap:{type:"tv",value:[]},shadowMapSize:{type:"v2v",value:[]},shadowBias:{type:"fv1",value:[]},shadowDarkness:{type:"fv1",value:[]},shadowMatrix:{type:"m4v",value:[]}}};
THREE.ShaderLib={depth:{uniforms:{mNear:{type:"f",value:1},mFar:{type:"f",value:2E3},opacity:{type:"f",value:1}},vertexShader:"void main() {\ngl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",fragmentShader:"uniform float mNear;\nuniform float mFar;\nuniform float opacity;\nvoid main() {\nfloat depth = gl_FragCoord.z / gl_FragCoord.w;\nfloat color = 1.0 - smoothstep( mNear, mFar, depth );\ngl_FragColor = vec4( vec3( color ), opacity );\n}"},normal:{uniforms:{opacity:{type:"f",
value:1}},vertexShader:"varying vec3 vNormal;\nvoid main() {\nvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\nvNormal = normalMatrix * normal;\ngl_Position = projectionMatrix * mvPosition;\n}",fragmentShader:"uniform float opacity;\nvarying vec3 vNormal;\nvoid main() {\ngl_FragColor = vec4( 0.5 * normalize( vNormal ) + 0.5, opacity );\n}"},basic:{uniforms:THREE.UniformsUtils.merge([THREE.UniformsLib.common,THREE.UniformsLib.fog,THREE.UniformsLib.shadowmap]),vertexShader:[THREE.ShaderChunk.map_pars_vertex,
THREE.ShaderChunk.lightmap_pars_vertex,THREE.ShaderChunk.envmap_pars_vertex,THREE.ShaderChunk.color_pars_vertex,THREE.ShaderChunk.morphtarget_pars_vertex,THREE.ShaderChunk.skinning_pars_vertex,THREE.ShaderChunk.shadowmap_pars_vertex,"void main() {",THREE.ShaderChunk.map_vertex,THREE.ShaderChunk.lightmap_vertex,THREE.ShaderChunk.color_vertex,"#ifdef USE_ENVMAP",THREE.ShaderChunk.morphnormal_vertex,THREE.ShaderChunk.skinbase_vertex,THREE.ShaderChunk.skinnormal_vertex,THREE.ShaderChunk.defaultnormal_vertex,
"#endif",THREE.ShaderChunk.morphtarget_vertex,THREE.ShaderChunk.skinning_vertex,THREE.ShaderChunk.default_vertex,THREE.ShaderChunk.worldpos_vertex,THREE.ShaderChunk.envmap_vertex,THREE.ShaderChunk.shadowmap_vertex,"}"].join("\n"),fragmentShader:["uniform vec3 diffuse;\nuniform float opacity;",THREE.ShaderChunk.color_pars_fragment,THREE.ShaderChunk.map_pars_fragment,THREE.ShaderChunk.lightmap_pars_fragment,THREE.ShaderChunk.envmap_pars_fragment,THREE.ShaderChunk.fog_pars_fragment,THREE.ShaderChunk.shadowmap_pars_fragment,
THREE.ShaderChunk.specularmap_pars_fragment,"void main() {\ngl_FragColor = vec4( diffuse, opacity );",THREE.ShaderChunk.map_fragment,THREE.ShaderChunk.alphatest_fragment,THREE.ShaderChunk.specularmap_fragment,THREE.ShaderChunk.lightmap_fragment,THREE.ShaderChunk.color_fragment,THREE.ShaderChunk.envmap_fragment,THREE.ShaderChunk.shadowmap_fragment,THREE.ShaderChunk.linear_to_gamma_fragment,THREE.ShaderChunk.fog_fragment,"}"].join("\n")},lambert:{uniforms:THREE.UniformsUtils.merge([THREE.UniformsLib.common,
THREE.UniformsLib.fog,THREE.UniformsLib.lights,THREE.UniformsLib.shadowmap,{ambient:{type:"c",value:new THREE.Color(16777215)},emissive:{type:"c",value:new THREE.Color(0)},wrapRGB:{type:"v3",value:new THREE.Vector3(1,1,1)}}]),vertexShader:["#define LAMBERT\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\nvarying vec3 vLightBack;\n#endif",THREE.ShaderChunk.map_pars_vertex,THREE.ShaderChunk.lightmap_pars_vertex,THREE.ShaderChunk.envmap_pars_vertex,THREE.ShaderChunk.lights_lambert_pars_vertex,THREE.ShaderChunk.color_pars_vertex,
THREE.ShaderChunk.morphtarget_pars_vertex,THREE.ShaderChunk.skinning_pars_vertex,THREE.ShaderChunk.shadowmap_pars_vertex,"void main() {",THREE.ShaderChunk.map_vertex,THREE.ShaderChunk.lightmap_vertex,THREE.ShaderChunk.color_vertex,THREE.ShaderChunk.morphnormal_vertex,THREE.ShaderChunk.skinbase_vertex,THREE.ShaderChunk.skinnormal_vertex,THREE.ShaderChunk.defaultnormal_vertex,THREE.ShaderChunk.morphtarget_vertex,THREE.ShaderChunk.skinning_vertex,THREE.ShaderChunk.default_vertex,THREE.ShaderChunk.worldpos_vertex,
THREE.ShaderChunk.envmap_vertex,THREE.ShaderChunk.lights_lambert_vertex,THREE.ShaderChunk.shadowmap_vertex,"}"].join("\n"),fragmentShader:["uniform float opacity;\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\nvarying vec3 vLightBack;\n#endif",THREE.ShaderChunk.color_pars_fragment,THREE.ShaderChunk.map_pars_fragment,THREE.ShaderChunk.lightmap_pars_fragment,THREE.ShaderChunk.envmap_pars_fragment,THREE.ShaderChunk.fog_pars_fragment,THREE.ShaderChunk.shadowmap_pars_fragment,THREE.ShaderChunk.specularmap_pars_fragment,
"void main() {\ngl_FragColor = vec4( vec3 ( 1.0 ), opacity );",THREE.ShaderChunk.map_fragment,THREE.ShaderChunk.alphatest_fragment,THREE.ShaderChunk.specularmap_fragment,"#ifdef DOUBLE_SIDED\nif ( gl_FrontFacing )\ngl_FragColor.xyz *= vLightFront;\nelse\ngl_FragColor.xyz *= vLightBack;\n#else\ngl_FragColor.xyz *= vLightFront;\n#endif",THREE.ShaderChunk.lightmap_fragment,THREE.ShaderChunk.color_fragment,THREE.ShaderChunk.envmap_fragment,THREE.ShaderChunk.shadowmap_fragment,THREE.ShaderChunk.linear_to_gamma_fragment,
THREE.ShaderChunk.fog_fragment,"}"].join("\n")},phong:{uniforms:THREE.UniformsUtils.merge([THREE.UniformsLib.common,THREE.UniformsLib.bump,THREE.UniformsLib.normalmap,THREE.UniformsLib.fog,THREE.UniformsLib.lights,THREE.UniformsLib.shadowmap,{ambient:{type:"c",value:new THREE.Color(16777215)},emissive:{type:"c",value:new THREE.Color(0)},specular:{type:"c",value:new THREE.Color(1118481)},shininess:{type:"f",value:30},wrapRGB:{type:"v3",value:new THREE.Vector3(1,1,1)}}]),vertexShader:["#define PHONG\nvarying vec3 vViewPosition;\nvarying vec3 vNormal;",
THREE.ShaderChunk.map_pars_vertex,THREE.ShaderChunk.lightmap_pars_vertex,THREE.ShaderChunk.envmap_pars_vertex,THREE.ShaderChunk.lights_phong_pars_vertex,THREE.ShaderChunk.color_pars_vertex,THREE.ShaderChunk.morphtarget_pars_vertex,THREE.ShaderChunk.skinning_pars_vertex,THREE.ShaderChunk.shadowmap_pars_vertex,"void main() {",THREE.ShaderChunk.map_vertex,THREE.ShaderChunk.lightmap_vertex,THREE.ShaderChunk.color_vertex,THREE.ShaderChunk.morphnormal_vertex,THREE.ShaderChunk.skinbase_vertex,THREE.ShaderChunk.skinnormal_vertex,
THREE.ShaderChunk.defaultnormal_vertex,"vNormal = transformedNormal;",THREE.ShaderChunk.morphtarget_vertex,THREE.ShaderChunk.skinning_vertex,THREE.ShaderChunk.default_vertex,"vViewPosition = -mvPosition.xyz;",THREE.ShaderChunk.worldpos_vertex,THREE.ShaderChunk.envmap_vertex,THREE.ShaderChunk.lights_phong_vertex,THREE.ShaderChunk.shadowmap_vertex,"}"].join("\n"),fragmentShader:["uniform vec3 diffuse;\nuniform float opacity;\nuniform vec3 ambient;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;",
THREE.ShaderChunk.color_pars_fragment,THREE.ShaderChunk.map_pars_fragment,THREE.ShaderChunk.lightmap_pars_fragment,THREE.ShaderChunk.envmap_pars_fragment,THREE.ShaderChunk.fog_pars_fragment,THREE.ShaderChunk.lights_phong_pars_fragment,THREE.ShaderChunk.shadowmap_pars_fragment,THREE.ShaderChunk.bumpmap_pars_fragment,THREE.ShaderChunk.normalmap_pars_fragment,THREE.ShaderChunk.specularmap_pars_fragment,"void main() {\ngl_FragColor = vec4( vec3 ( 1.0 ), opacity );",THREE.ShaderChunk.map_fragment,THREE.ShaderChunk.alphatest_fragment,
THREE.ShaderChunk.specularmap_fragment,THREE.ShaderChunk.lights_phong_fragment,THREE.ShaderChunk.lightmap_fragment,THREE.ShaderChunk.color_fragment,THREE.ShaderChunk.envmap_fragment,THREE.ShaderChunk.shadowmap_fragment,THREE.ShaderChunk.linear_to_gamma_fragment,THREE.ShaderChunk.fog_fragment,"}"].join("\n")},particle_basic:{uniforms:THREE.UniformsUtils.merge([THREE.UniformsLib.particle,THREE.UniformsLib.shadowmap]),vertexShader:["uniform float size;\nuniform float scale;",THREE.ShaderChunk.color_pars_vertex,
THREE.ShaderChunk.shadowmap_pars_vertex,"void main() {",THREE.ShaderChunk.color_vertex,"vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n#ifdef USE_SIZEATTENUATION\ngl_PointSize = size * ( scale / length( mvPosition.xyz ) );\n#else\ngl_PointSize = size;\n#endif\ngl_Position = projectionMatrix * mvPosition;",THREE.ShaderChunk.worldpos_vertex,THREE.ShaderChunk.shadowmap_vertex,"}"].join("\n"),fragmentShader:["uniform vec3 psColor;\nuniform float opacity;",THREE.ShaderChunk.color_pars_fragment,
THREE.ShaderChunk.map_particle_pars_fragment,THREE.ShaderChunk.fog_pars_fragment,THREE.ShaderChunk.shadowmap_pars_fragment,"void main() {\ngl_FragColor = vec4( psColor, opacity );",THREE.ShaderChunk.map_particle_fragment,THREE.ShaderChunk.alphatest_fragment,THREE.ShaderChunk.color_fragment,THREE.ShaderChunk.shadowmap_fragment,THREE.ShaderChunk.fog_fragment,"}"].join("\n")},depthRGBA:{uniforms:{},vertexShader:[THREE.ShaderChunk.morphtarget_pars_vertex,THREE.ShaderChunk.skinning_pars_vertex,"void main() {",
THREE.ShaderChunk.skinbase_vertex,THREE.ShaderChunk.morphtarget_vertex,THREE.ShaderChunk.skinning_vertex,THREE.ShaderChunk.default_vertex,"}"].join("\n"),fragmentShader:"vec4 pack_depth( const in float depth ) {\nconst vec4 bit_shift = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );\nconst vec4 bit_mask  = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );\nvec4 res = fract( depth * bit_shift );\nres -= res.xxyz * bit_mask;\nreturn res;\n}\nvoid main() {\ngl_FragData[ 0 ] = pack_depth( gl_FragCoord.z );\n}"}};
THREE.WebGLRenderer=function(a){function b(a,b){var c=a.vertices.length,d=b.material;if(d.attributes){void 0===a.__webglCustomAttributesList&&(a.__webglCustomAttributesList=[]);for(var e in d.attributes){var f=d.attributes[e];if(!f.__webglInitialized||f.createUniqueBuffers){f.__webglInitialized=!0;var g=1;"v2"===f.type?g=2:"v3"===f.type?g=3:"v4"===f.type?g=4:"c"===f.type&&(g=3);f.size=g;f.array=new Float32Array(c*g);f.buffer=k.createBuffer();f.buffer.belongsToAttribute=e;f.needsUpdate=!0}a.__webglCustomAttributesList.push(f)}}}
function c(a,b){if(a.material&&!(a.material instanceof THREE.MeshFaceMaterial))return a.material;if(0<=b.materialIndex)return a.geometry.materials[b.materialIndex]}function d(a){return a instanceof THREE.MeshBasicMaterial&&!a.envMap||a instanceof THREE.MeshDepthMaterial?!1:a&&void 0!==a.shading&&a.shading===THREE.SmoothShading?THREE.SmoothShading:THREE.FlatShading}function e(a){return a.map||a.lightMap||a.bumpMap||a.normalMap||a.specularMap||a instanceof THREE.ShaderMaterial?!0:!1}function f(a){var b,
c,d;for(b in a.attributes)d="index"===b?k.ELEMENT_ARRAY_BUFFER:k.ARRAY_BUFFER,c=a.attributes[b],c.buffer=k.createBuffer(),k.bindBuffer(d,c.buffer),k.bufferData(d,c.array,k.STATIC_DRAW)}function g(a,b,c){var d,e,f,g,h=a.vertices;g=h.length;var i=a.colors,j=i.length,l=a.__vertexArray,n=a.__colorArray,m=a.__sortArray,o=a.verticesNeedUpdate,p=a.colorsNeedUpdate,q=a.__webglCustomAttributesList;if(c.sortParticles){gb.copy(ra);gb.multiplySelf(c.matrixWorld);for(d=0;d<g;d++)e=h[d],Za.copy(e),gb.multiplyVector3(Za),
m[d]=[Za.z,d];m.sort(function(a,b){return b[0]-a[0]});for(d=0;d<g;d++)e=h[m[d][1]],f=3*d,l[f]=e.x,l[f+1]=e.y,l[f+2]=e.z;for(d=0;d<j;d++)f=3*d,e=i[m[d][1]],n[f]=e.r,n[f+1]=e.g,n[f+2]=e.b;if(q){i=0;for(j=q.length;i<j;i++)if(h=q[i],void 0===h.boundTo||"vertices"===h.boundTo)if(f=0,e=h.value.length,1===h.size)for(d=0;d<e;d++)g=m[d][1],h.array[d]=h.value[g];else if(2===h.size)for(d=0;d<e;d++)g=m[d][1],g=h.value[g],h.array[f]=g.x,h.array[f+1]=g.y,f+=2;else if(3===h.size)if("c"===h.type)for(d=0;d<e;d++)g=
m[d][1],g=h.value[g],h.array[f]=g.r,h.array[f+1]=g.g,h.array[f+2]=g.b,f+=3;else for(d=0;d<e;d++)g=m[d][1],g=h.value[g],h.array[f]=g.x,h.array[f+1]=g.y,h.array[f+2]=g.z,f+=3;else if(4===h.size)for(d=0;d<e;d++)g=m[d][1],g=h.value[g],h.array[f]=g.x,h.array[f+1]=g.y,h.array[f+2]=g.z,h.array[f+3]=g.w,f+=4}}else{if(o)for(d=0;d<g;d++)e=h[d],f=3*d,l[f]=e.x,l[f+1]=e.y,l[f+2]=e.z;if(p)for(d=0;d<j;d++)e=i[d],f=3*d,n[f]=e.r,n[f+1]=e.g,n[f+2]=e.b;if(q){i=0;for(j=q.length;i<j;i++)if(h=q[i],h.needsUpdate&&(void 0===
h.boundTo||"vertices"===h.boundTo))if(e=h.value.length,f=0,1===h.size)for(d=0;d<e;d++)h.array[d]=h.value[d];else if(2===h.size)for(d=0;d<e;d++)g=h.value[d],h.array[f]=g.x,h.array[f+1]=g.y,f+=2;else if(3===h.size)if("c"===h.type)for(d=0;d<e;d++)g=h.value[d],h.array[f]=g.r,h.array[f+1]=g.g,h.array[f+2]=g.b,f+=3;else for(d=0;d<e;d++)g=h.value[d],h.array[f]=g.x,h.array[f+1]=g.y,h.array[f+2]=g.z,f+=3;else if(4===h.size)for(d=0;d<e;d++)g=h.value[d],h.array[f]=g.x,h.array[f+1]=g.y,h.array[f+2]=g.z,h.array[f+
3]=g.w,f+=4}}if(o||c.sortParticles)k.bindBuffer(k.ARRAY_BUFFER,a.__webglVertexBuffer),k.bufferData(k.ARRAY_BUFFER,l,b);if(p||c.sortParticles)k.bindBuffer(k.ARRAY_BUFFER,a.__webglColorBuffer),k.bufferData(k.ARRAY_BUFFER,n,b);if(q){i=0;for(j=q.length;i<j;i++)if(h=q[i],h.needsUpdate||c.sortParticles)k.bindBuffer(k.ARRAY_BUFFER,h.buffer),k.bufferData(k.ARRAY_BUFFER,h.array,b)}}function h(a,b,c){var d=a.attributes,f=d.index,e=d.position,g=d.normal,h=d.uv,i=d.color,d=d.tangent;a.elementsNeedUpdate&&void 0!==
f&&(k.bindBuffer(k.ELEMENT_ARRAY_BUFFER,f.buffer),k.bufferData(k.ELEMENT_ARRAY_BUFFER,f.array,b));a.verticesNeedUpdate&&void 0!==e&&(k.bindBuffer(k.ARRAY_BUFFER,e.buffer),k.bufferData(k.ARRAY_BUFFER,e.array,b));a.normalsNeedUpdate&&void 0!==g&&(k.bindBuffer(k.ARRAY_BUFFER,g.buffer),k.bufferData(k.ARRAY_BUFFER,g.array,b));a.uvsNeedUpdate&&void 0!==h&&(k.bindBuffer(k.ARRAY_BUFFER,h.buffer),k.bufferData(k.ARRAY_BUFFER,h.array,b));a.colorsNeedUpdate&&void 0!==i&&(k.bindBuffer(k.ARRAY_BUFFER,i.buffer),
k.bufferData(k.ARRAY_BUFFER,i.array,b));a.tangentsNeedUpdate&&void 0!==d&&(k.bindBuffer(k.ARRAY_BUFFER,d.buffer),k.bufferData(k.ARRAY_BUFFER,d.array,b));if(c)for(var j in a.attributes)delete a.attributes[j].array}function i(a,b){return b.z-a.z}function j(a,b){return b[1]-a[1]}function l(a,b,c){if(a.length)for(var d=0,f=a.length;d<f;d++)ia=O=null,W=V=Pa=Ga=Ra=ib=Ia=-1,Ea=!0,a[d].render(b,c,Da,qb),ia=O=null,W=V=Pa=Ga=Ra=ib=Ia=-1,Ea=!0}function m(a,b,c,d,f,e,g,h){var k,i,j,l;b?(i=a.length-1,l=b=-1):
(i=0,b=a.length,l=1);for(var n=i;n!==b;n+=l)if(k=a[n],k.render){i=k.object;j=k.buffer;if(h)k=h;else{k=k[c];if(!k)continue;g&&Q.setBlending(k.blending,k.blendEquation,k.blendSrc,k.blendDst);Q.setDepthTest(k.depthTest);Q.setDepthWrite(k.depthWrite);v(k.polygonOffset,k.polygonOffsetFactor,k.polygonOffsetUnits)}Q.setMaterialFaces(k);j instanceof THREE.BufferGeometry?Q.renderBufferDirect(d,f,e,k,j,i):Q.renderBuffer(d,f,e,k,j,i)}}function n(a,b,c,d,f,e,g){for(var h,k,i=0,j=a.length;i<j;i++)if(h=a[i],k=
h.object,k.visible){if(g)h=g;else{h=h[b];if(!h)continue;e&&Q.setBlending(h.blending,h.blendEquation,h.blendSrc,h.blendDst);Q.setDepthTest(h.depthTest);Q.setDepthWrite(h.depthWrite);v(h.polygonOffset,h.polygonOffsetFactor,h.polygonOffsetUnits)}Q.renderImmediateObject(c,d,f,h,k)}}function p(a,b,c){a.push({buffer:b,object:c,opaque:null,transparent:null})}function o(a){for(var b in a.attributes)if(a.attributes[b].needsUpdate)return!0;return!1}function q(a){for(var b in a.attributes)a.attributes[b].needsUpdate=
!1}function r(a,b){for(var c=a.length-1;0<=c;c--)a[c].object===b&&a.splice(c,1)}function t(a,b){for(var c=a.length-1;0<=c;c--)a[c]===b&&a.splice(c,1)}function B(a,b,c,d,f){ca=0;d.needsUpdate&&(d.program&&Q.deallocateMaterial(d),Q.initMaterial(d,b,c,f),d.needsUpdate=!1);d.morphTargets&&!f.__webglMorphTargetInfluences&&(f.__webglMorphTargetInfluences=new Float32Array(Q.maxMorphTargets));var e=!1,g=d.program,h=g.uniforms,i=d.uniforms;g!==O&&(k.useProgram(g),O=g,e=!0);d.id!==W&&(W=d.id,e=!0);if(e||a!==
ia)k.uniformMatrix4fv(h.projectionMatrix,!1,a._projectionMatrixArray),a!==ia&&(ia=a);if(d.skinning)if(ic&&f.useVertexTexture){if(null!==h.boneTexture){var j=u();k.uniform1i(h.boneTexture,j);Q.setTexture(f.boneTexture,j)}}else null!==h.boneGlobalMatrices&&k.uniformMatrix4fv(h.boneGlobalMatrices,!1,f.boneMatrices);if(e){c&&d.fog&&(i.fogColor.value=c.color,c instanceof THREE.Fog?(i.fogNear.value=c.near,i.fogFar.value=c.far):c instanceof THREE.FogExp2&&(i.fogDensity.value=c.density));if(d instanceof THREE.MeshPhongMaterial||
d instanceof THREE.MeshLambertMaterial||d.lights){if(Ea){for(var l=0,n=0,m=0,o,p,q,r,s=xb,t=s.directional.colors,v=s.directional.positions,y=s.point.colors,B=s.point.positions,C=s.point.distances,H=s.spot.colors,J=s.spot.positions,I=s.spot.distances,K=s.spot.directions,F=s.spot.angles,L=s.spot.exponents,N=s.hemi.skyColors,V=s.hemi.groundColors,Z=s.hemi.positions,fa=0,R=0,ea=0,$=0,c=o=q=q=p=0,e=b.length;c<e;c++)j=b[c],!j.onlyShadow&&j.visible&&(o=j.color,r=j.intensity,p=j.distance,j instanceof THREE.AmbientLight?
Q.gammaInput?(l+=o.r*o.r,n+=o.g*o.g,m+=o.b*o.b):(l+=o.r,n+=o.g,m+=o.b):j instanceof THREE.DirectionalLight?(p=3*fa,Q.gammaInput?z(t,p,o,r*r):A(t,p,o,r),Wa.copy(j.matrixWorld.getPosition()),Wa.subSelf(j.target.matrixWorld.getPosition()),Wa.normalize(),v[p]=Wa.x,v[p+1]=Wa.y,v[p+2]=Wa.z,fa+=1):j instanceof THREE.PointLight?(q=3*R,Q.gammaInput?z(y,q,o,r*r):A(y,q,o,r),r=j.matrixWorld.getPosition(),B[q]=r.x,B[q+1]=r.y,B[q+2]=r.z,C[R]=p,R+=1):j instanceof THREE.SpotLight?(q=3*ea,Q.gammaInput?z(H,q,o,r*r):
A(H,q,o,r),r=j.matrixWorld.getPosition(),J[q]=r.x,J[q+1]=r.y,J[q+2]=r.z,I[ea]=p,Wa.copy(r),Wa.subSelf(j.target.matrixWorld.getPosition()),Wa.normalize(),K[q]=Wa.x,K[q+1]=Wa.y,K[q+2]=Wa.z,F[ea]=Math.cos(j.angle),L[ea]=j.exponent,ea+=1):j instanceof THREE.HemisphereLight&&(p=j.color,q=j.groundColor,o=3*$,Q.gammaInput?(r*=r,z(N,o,p,r),z(V,o,q,r)):(A(N,o,p,r),A(V,o,q,r)),r=j.matrixWorld.getPosition(),Z[o]=r.x,Z[o+1]=r.y,Z[o+2]=r.z,$+=1));c=3*fa;for(e=t.length;c<e;c++)t[c]=0;c=3*R;for(e=y.length;c<e;c++)y[c]=
0;c=3*ea;for(e=H.length;c<e;c++)H[c]=0;c=3*$;for(e=N.length;c<e;c++)N[c]=0;c=3*$;for(e=V.length;c<e;c++)V[c]=0;s.directional.length=fa;s.point.length=R;s.spot.length=ea;s.hemi.length=$;s.ambient[0]=l;s.ambient[1]=n;s.ambient[2]=m;Ea=!1}c=xb;i.ambientLightColor.value=c.ambient;i.directionalLightColor.value=c.directional.colors;i.directionalLightDirection.value=c.directional.positions;i.pointLightColor.value=c.point.colors;i.pointLightPosition.value=c.point.positions;i.pointLightDistance.value=c.point.distances;
i.spotLightColor.value=c.spot.colors;i.spotLightPosition.value=c.spot.positions;i.spotLightDistance.value=c.spot.distances;i.spotLightDirection.value=c.spot.directions;i.spotLightAngle.value=c.spot.angles;i.spotLightExponent.value=c.spot.exponents;i.hemisphereLightSkyColor.value=c.hemi.skyColors;i.hemisphereLightGroundColor.value=c.hemi.groundColors;i.hemisphereLightPosition.value=c.hemi.positions}if(d instanceof THREE.MeshBasicMaterial||d instanceof THREE.MeshLambertMaterial||d instanceof THREE.MeshPhongMaterial){i.opacity.value=
d.opacity;Q.gammaInput?i.diffuse.value.copyGammaToLinear(d.color):i.diffuse.value=d.color;i.map.value=d.map;i.lightMap.value=d.lightMap;i.specularMap.value=d.specularMap;d.bumpMap&&(i.bumpMap.value=d.bumpMap,i.bumpScale.value=d.bumpScale);d.normalMap&&(i.normalMap.value=d.normalMap,i.normalScale.value.copy(d.normalScale));var Y;d.map?Y=d.map:d.specularMap?Y=d.specularMap:d.normalMap?Y=d.normalMap:d.bumpMap&&(Y=d.bumpMap);void 0!==Y&&(c=Y.offset,Y=Y.repeat,i.offsetRepeat.value.set(c.x,c.y,Y.x,Y.y));
i.envMap.value=d.envMap;i.flipEnvMap.value=d.envMap instanceof THREE.WebGLRenderTargetCube?1:-1;i.reflectivity.value=d.reflectivity;i.refractionRatio.value=d.refractionRatio;i.combine.value=d.combine;i.useRefract.value=d.envMap&&d.envMap.mapping instanceof THREE.CubeRefractionMapping}d instanceof THREE.LineBasicMaterial?(i.diffuse.value=d.color,i.opacity.value=d.opacity):d instanceof THREE.ParticleBasicMaterial?(i.psColor.value=d.color,i.opacity.value=d.opacity,i.size.value=d.size,i.scale.value=M.height/
2,i.map.value=d.map):d instanceof THREE.MeshPhongMaterial?(i.shininess.value=d.shininess,Q.gammaInput?(i.ambient.value.copyGammaToLinear(d.ambient),i.emissive.value.copyGammaToLinear(d.emissive),i.specular.value.copyGammaToLinear(d.specular)):(i.ambient.value=d.ambient,i.emissive.value=d.emissive,i.specular.value=d.specular),d.wrapAround&&i.wrapRGB.value.copy(d.wrapRGB)):d instanceof THREE.MeshLambertMaterial?(Q.gammaInput?(i.ambient.value.copyGammaToLinear(d.ambient),i.emissive.value.copyGammaToLinear(d.emissive)):
(i.ambient.value=d.ambient,i.emissive.value=d.emissive),d.wrapAround&&i.wrapRGB.value.copy(d.wrapRGB)):d instanceof THREE.MeshDepthMaterial?(i.mNear.value=a.near,i.mFar.value=a.far,i.opacity.value=d.opacity):d instanceof THREE.MeshNormalMaterial&&(i.opacity.value=d.opacity);if(f.receiveShadow&&!d._shadowPass&&i.shadowMatrix){c=Y=0;for(e=b.length;c<e;c++)if(j=b[c],j.castShadow&&(j instanceof THREE.SpotLight||j instanceof THREE.DirectionalLight&&!j.shadowCascade))i.shadowMap.value[Y]=j.shadowMap,i.shadowMapSize.value[Y]=
j.shadowMapSize,i.shadowMatrix.value[Y]=j.shadowMatrix,i.shadowDarkness.value[Y]=j.shadowDarkness,i.shadowBias.value[Y]=j.shadowBias,Y++}b=d.uniformsList;i=0;for(Y=b.length;i<Y;i++)if(e=g.uniforms[b[i][1]])if(c=b[i][0],l=c.type,j=c.value,"i"===l)k.uniform1i(e,j);else if("f"===l)k.uniform1f(e,j);else if("v2"===l)k.uniform2f(e,j.x,j.y);else if("v3"===l)k.uniform3f(e,j.x,j.y,j.z);else if("v4"===l)k.uniform4f(e,j.x,j.y,j.z,j.w);else if("c"===l)k.uniform3f(e,j.r,j.g,j.b);else if("iv1"===l)k.uniform1iv(e,
j);else if("iv"===l)k.uniform3iv(e,j);else if("fv1"===l)k.uniform1fv(e,j);else if("fv"===l)k.uniform3fv(e,j);else if("v2v"===l){void 0===c._array&&(c._array=new Float32Array(2*j.length));l=0;for(n=j.length;l<n;l++)m=2*l,c._array[m]=j[l].x,c._array[m+1]=j[l].y;k.uniform2fv(e,c._array)}else if("v3v"===l){void 0===c._array&&(c._array=new Float32Array(3*j.length));l=0;for(n=j.length;l<n;l++)m=3*l,c._array[m]=j[l].x,c._array[m+1]=j[l].y,c._array[m+2]=j[l].z;k.uniform3fv(e,c._array)}else if("v4v"===l){void 0===
c._array&&(c._array=new Float32Array(4*j.length));l=0;for(n=j.length;l<n;l++)m=4*l,c._array[m]=j[l].x,c._array[m+1]=j[l].y,c._array[m+2]=j[l].z,c._array[m+3]=j[l].w;k.uniform4fv(e,c._array)}else if("m4"===l)void 0===c._array&&(c._array=new Float32Array(16)),j.flattenToArray(c._array),k.uniformMatrix4fv(e,!1,c._array);else if("m4v"===l){void 0===c._array&&(c._array=new Float32Array(16*j.length));l=0;for(n=j.length;l<n;l++)j[l].flattenToArrayOffset(c._array,16*l);k.uniformMatrix4fv(e,!1,c._array)}else if("t"===
l){if(m=j,j=u(),k.uniform1i(e,j),m)if(m.image instanceof Array&&6===m.image.length){if(c=m,e=j,6===c.image.length)if(c.needsUpdate){c.image.__webglTextureCube||(c.image.__webglTextureCube=k.createTexture());k.activeTexture(k.TEXTURE0+e);k.bindTexture(k.TEXTURE_CUBE_MAP,c.image.__webglTextureCube);k.pixelStorei(k.UNPACK_FLIP_Y_WEBGL,c.flipY);e=c instanceof THREE.CompressedTexture;j=[];for(l=0;6>l;l++)Q.autoScaleCubemaps&&!e?(n=j,m=l,s=c.image[l],v=Tc,s.width<=v&&s.height<=v||(y=Math.max(s.width,s.height),
t=Math.floor(s.width*v/y),v=Math.floor(s.height*v/y),y=document.createElement("canvas"),y.width=t,y.height=v,y.getContext("2d").drawImage(s,0,0,s.width,s.height,0,0,t,v),s=y),n[m]=s):j[l]=c.image[l];l=j[0];n=0===(l.width&l.width-1)&&0===(l.height&l.height-1);m=E(c.format);s=E(c.type);G(k.TEXTURE_CUBE_MAP,c,n);for(l=0;6>l;l++)if(e){v=j[l].mipmaps;y=0;for(B=v.length;y<B;y++)t=v[y],k.compressedTexImage2D(k.TEXTURE_CUBE_MAP_POSITIVE_X+l,y,m,t.width,t.height,0,t.data)}else k.texImage2D(k.TEXTURE_CUBE_MAP_POSITIVE_X+
l,0,m,m,s,j[l]);c.generateMipmaps&&n&&k.generateMipmap(k.TEXTURE_CUBE_MAP);c.needsUpdate=!1;if(c.onUpdate)c.onUpdate()}else k.activeTexture(k.TEXTURE0+e),k.bindTexture(k.TEXTURE_CUBE_MAP,c.image.__webglTextureCube)}else m instanceof THREE.WebGLRenderTargetCube?(c=m,k.activeTexture(k.TEXTURE0+j),k.bindTexture(k.TEXTURE_CUBE_MAP,c.__webglTexture)):Q.setTexture(m,j)}else if("tv"===l){void 0===c._array&&(c._array=[]);l=0;for(n=c.value.length;l<n;l++)c._array[l]=u();k.uniform1iv(e,c._array);l=0;for(n=
c.value.length;l<n;l++)m=c.value[l],j=c._array[l],m&&Q.setTexture(m,j)}if((d instanceof THREE.ShaderMaterial||d instanceof THREE.MeshPhongMaterial||d.envMap)&&null!==h.cameraPosition)b=a.matrixWorld.getPosition(),k.uniform3f(h.cameraPosition,b.x,b.y,b.z);(d instanceof THREE.MeshPhongMaterial||d instanceof THREE.MeshLambertMaterial||d instanceof THREE.ShaderMaterial||d.skinning)&&null!==h.viewMatrix&&k.uniformMatrix4fv(h.viewMatrix,!1,a._viewMatrixArray)}k.uniformMatrix4fv(h.modelViewMatrix,!1,f._modelViewMatrix.elements);
h.normalMatrix&&k.uniformMatrix3fv(h.normalMatrix,!1,f._normalMatrix.elements);null!==h.modelMatrix&&k.uniformMatrix4fv(h.modelMatrix,!1,f.matrixWorld.elements);return g}function u(){var a=ca;a>=rc&&console.warn("Trying to use "+a+" texture units while this GPU supports only "+rc);ca+=1;return a}function s(a,b){a._modelViewMatrix.multiply(b.matrixWorldInverse,a.matrixWorld);a._normalMatrix.getInverse(a._modelViewMatrix);a._normalMatrix.transpose()}function z(a,b,c,d){a[b]=c.r*c.r*d;a[b+1]=c.g*c.g*
d;a[b+2]=c.b*c.b*d}function A(a,b,c,d){a[b]=c.r*d;a[b+1]=c.g*d;a[b+2]=c.b*d}function v(a,b,c){eb!==a&&(a?k.enable(k.POLYGON_OFFSET_FILL):k.disable(k.POLYGON_OFFSET_FILL),eb=a);if(a&&(pb!==b||Pb!==c))k.polygonOffset(b,c),pb=b,Pb=c}function y(a){for(var a=a.split("\n"),b=0,c=a.length;b<c;b++)a[b]=b+1+": "+a[b];return a.join("\n")}function C(a,b){var c;"fragment"===a?c=k.createShader(k.FRAGMENT_SHADER):"vertex"===a&&(c=k.createShader(k.VERTEX_SHADER));k.shaderSource(c,b);k.compileShader(c);return!k.getShaderParameter(c,
k.COMPILE_STATUS)?(console.error(k.getShaderInfoLog(c)),console.error(y(b)),null):c}function G(a,b,c){c?(k.texParameteri(a,k.TEXTURE_WRAP_S,E(b.wrapS)),k.texParameteri(a,k.TEXTURE_WRAP_T,E(b.wrapT)),k.texParameteri(a,k.TEXTURE_MAG_FILTER,E(b.magFilter)),k.texParameteri(a,k.TEXTURE_MIN_FILTER,E(b.minFilter))):(k.texParameteri(a,k.TEXTURE_WRAP_S,k.CLAMP_TO_EDGE),k.texParameteri(a,k.TEXTURE_WRAP_T,k.CLAMP_TO_EDGE),k.texParameteri(a,k.TEXTURE_MAG_FILTER,J(b.magFilter)),k.texParameteri(a,k.TEXTURE_MIN_FILTER,
J(b.minFilter)));if(Qb&&b.type!==THREE.FloatType&&(1<b.anisotropy||b.__oldAnisotropy))k.texParameterf(a,Qb.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(b.anisotropy,Ec)),b.__oldAnisotropy=b.anisotropy}function H(a,b){k.bindRenderbuffer(k.RENDERBUFFER,a);b.depthBuffer&&!b.stencilBuffer?(k.renderbufferStorage(k.RENDERBUFFER,k.DEPTH_COMPONENT16,b.width,b.height),k.framebufferRenderbuffer(k.FRAMEBUFFER,k.DEPTH_ATTACHMENT,k.RENDERBUFFER,a)):b.depthBuffer&&b.stencilBuffer?(k.renderbufferStorage(k.RENDERBUFFER,k.DEPTH_STENCIL,
b.width,b.height),k.framebufferRenderbuffer(k.FRAMEBUFFER,k.DEPTH_STENCIL_ATTACHMENT,k.RENDERBUFFER,a)):k.renderbufferStorage(k.RENDERBUFFER,k.RGBA4,b.width,b.height)}function J(a){return a===THREE.NearestFilter||a===THREE.NearestMipMapNearestFilter||a===THREE.NearestMipMapLinearFilter?k.NEAREST:k.LINEAR}function E(a){if(a===THREE.RepeatWrapping)return k.REPEAT;if(a===THREE.ClampToEdgeWrapping)return k.CLAMP_TO_EDGE;if(a===THREE.MirroredRepeatWrapping)return k.MIRRORED_REPEAT;if(a===THREE.NearestFilter)return k.NEAREST;
if(a===THREE.NearestMipMapNearestFilter)return k.NEAREST_MIPMAP_NEAREST;if(a===THREE.NearestMipMapLinearFilter)return k.NEAREST_MIPMAP_LINEAR;if(a===THREE.LinearFilter)return k.LINEAR;if(a===THREE.LinearMipMapNearestFilter)return k.LINEAR_MIPMAP_NEAREST;if(a===THREE.LinearMipMapLinearFilter)return k.LINEAR_MIPMAP_LINEAR;if(a===THREE.UnsignedByteType)return k.UNSIGNED_BYTE;if(a===THREE.UnsignedShort4444Type)return k.UNSIGNED_SHORT_4_4_4_4;if(a===THREE.UnsignedShort5551Type)return k.UNSIGNED_SHORT_5_5_5_1;
if(a===THREE.UnsignedShort565Type)return k.UNSIGNED_SHORT_5_6_5;if(a===THREE.ByteType)return k.BYTE;if(a===THREE.ShortType)return k.SHORT;if(a===THREE.UnsignedShortType)return k.UNSIGNED_SHORT;if(a===THREE.IntType)return k.INT;if(a===THREE.UnsignedIntType)return k.UNSIGNED_INT;if(a===THREE.FloatType)return k.FLOAT;if(a===THREE.AlphaFormat)return k.ALPHA;if(a===THREE.RGBFormat)return k.RGB;if(a===THREE.RGBAFormat)return k.RGBA;if(a===THREE.LuminanceFormat)return k.LUMINANCE;if(a===THREE.LuminanceAlphaFormat)return k.LUMINANCE_ALPHA;
if(a===THREE.AddEquation)return k.FUNC_ADD;if(a===THREE.SubtractEquation)return k.FUNC_SUBTRACT;if(a===THREE.ReverseSubtractEquation)return k.FUNC_REVERSE_SUBTRACT;if(a===THREE.ZeroFactor)return k.ZERO;if(a===THREE.OneFactor)return k.ONE;if(a===THREE.SrcColorFactor)return k.SRC_COLOR;if(a===THREE.OneMinusSrcColorFactor)return k.ONE_MINUS_SRC_COLOR;if(a===THREE.SrcAlphaFactor)return k.SRC_ALPHA;if(a===THREE.OneMinusSrcAlphaFactor)return k.ONE_MINUS_SRC_ALPHA;if(a===THREE.DstAlphaFactor)return k.DST_ALPHA;
if(a===THREE.OneMinusDstAlphaFactor)return k.ONE_MINUS_DST_ALPHA;if(a===THREE.DstColorFactor)return k.DST_COLOR;if(a===THREE.OneMinusDstColorFactor)return k.ONE_MINUS_DST_COLOR;if(a===THREE.SrcAlphaSaturateFactor)return k.SRC_ALPHA_SATURATE;if(void 0!==yb){if(a===THREE.RGB_S3TC_DXT1_Format)return yb.COMPRESSED_RGB_S3TC_DXT1_EXT;if(a===THREE.RGBA_S3TC_DXT1_Format)return yb.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(a===THREE.RGBA_S3TC_DXT3_Format)return yb.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(a===THREE.RGBA_S3TC_DXT5_Format)return yb.COMPRESSED_RGBA_S3TC_DXT5_EXT}return 0}
console.log("THREE.WebGLRenderer",THREE.REVISION);var a=a||{},M=void 0!==a.canvas?a.canvas:document.createElement("canvas"),K=void 0!==a.precision?a.precision:"highp",F=void 0!==a.alpha?a.alpha:!0,I=void 0!==a.premultipliedAlpha?a.premultipliedAlpha:!0,L=void 0!==a.antialias?a.antialias:!1,R=void 0!==a.stencil?a.stencil:!0,$=void 0!==a.preserveDrawingBuffer?a.preserveDrawingBuffer:!1,Y=void 0!==a.clearColor?new THREE.Color(a.clearColor):new THREE.Color(0),N=void 0!==a.clearAlpha?a.clearAlpha:0,ea=
void 0!==a.maxLights?a.maxLights:4;this.domElement=M;this.context=null;this.autoUpdateScene=this.autoUpdateObjects=this.sortObjects=this.autoClearStencil=this.autoClearDepth=this.autoClearColor=this.autoClear=!0;this.shadowMapEnabled=this.physicallyBasedShading=this.gammaOutput=this.gammaInput=!1;this.shadowMapCullFrontFaces=this.shadowMapSoft=this.shadowMapAutoUpdate=!0;this.shadowMapCascade=this.shadowMapDebug=!1;this.maxMorphTargets=8;this.maxMorphNormals=4;this.autoScaleCubemaps=!0;this.renderPluginsPre=
[];this.renderPluginsPost=[];this.info={memory:{programs:0,geometries:0,textures:0},render:{calls:0,vertices:0,faces:0,points:0}};var Q=this,qa=[],la=0,O=null,fa=null,W=-1,V=null,ia=null,Z=0,ca=0,Ga=-1,Pa=-1,Ia=-1,Ua=-1,na=-1,Va=-1,ib=-1,Ra=-1,eb=null,pb=null,Pb=null,db=null,$a=0,Ja=0,wa=0,wb=0,Da=0,qb=0,fb=new THREE.Frustum,ra=new THREE.Matrix4,gb=new THREE.Matrix4,Za=new THREE.Vector4,Wa=new THREE.Vector3,Ea=!0,xb={ambient:[0,0,0],directional:{length:0,colors:[],positions:[]},point:{length:0,colors:[],
positions:[],distances:[]},spot:{length:0,colors:[],positions:[],distances:[],directions:[],angles:[],exponents:[]},hemi:{length:0,skyColors:[],groundColors:[],positions:[]}},k,Qb,yb;try{if(!(k=M.getContext("experimental-webgl",{alpha:F,premultipliedAlpha:I,antialias:L,stencil:R,preserveDrawingBuffer:$})))throw"Error creating WebGL context.";}catch(Sc){console.error(Sc)}a=k.getExtension("OES_texture_float");F=k.getExtension("OES_standard_derivatives");Qb=k.getExtension("EXT_texture_filter_anisotropic")||
k.getExtension("MOZ_EXT_texture_filter_anisotropic")||k.getExtension("WEBKIT_EXT_texture_filter_anisotropic");yb=k.getExtension("WEBGL_compressed_texture_s3tc")||k.getExtension("MOZ_WEBGL_compressed_texture_s3tc")||k.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");a||console.log("THREE.WebGLRenderer: Float textures not supported.");F||console.log("THREE.WebGLRenderer: Standard derivatives not supported.");Qb||console.log("THREE.WebGLRenderer: Anisotropic texture filtering not supported.");yb||
console.log("THREE.WebGLRenderer: S3TC compressed textures not supported.");k.clearColor(0,0,0,1);k.clearDepth(1);k.clearStencil(0);k.enable(k.DEPTH_TEST);k.depthFunc(k.LEQUAL);k.frontFace(k.CCW);k.cullFace(k.BACK);k.enable(k.CULL_FACE);k.enable(k.BLEND);k.blendEquation(k.FUNC_ADD);k.blendFunc(k.SRC_ALPHA,k.ONE_MINUS_SRC_ALPHA);k.clearColor(Y.r,Y.g,Y.b,N);this.context=k;var rc=k.getParameter(k.MAX_TEXTURE_IMAGE_UNITS),F=k.getParameter(k.MAX_VERTEX_TEXTURE_IMAGE_UNITS);k.getParameter(k.MAX_TEXTURE_SIZE);
var Tc=k.getParameter(k.MAX_CUBE_MAP_TEXTURE_SIZE),Ec=Qb?k.getParameter(Qb.MAX_TEXTURE_MAX_ANISOTROPY_EXT):0,hc=0<F,ic=hc&&a;yb&&k.getParameter(k.COMPRESSED_TEXTURE_FORMATS);this.getContext=function(){return k};this.supportsVertexTextures=function(){return hc};this.getMaxAnisotropy=function(){return Ec};this.setSize=function(a,b){M.width=a;M.height=b;this.setViewport(0,0,M.width,M.height)};this.setViewport=function(a,b,c,d){$a=void 0!==a?a:0;Ja=void 0!==b?b:0;wa=void 0!==c?c:M.width;wb=void 0!==d?
d:M.height;k.viewport($a,Ja,wa,wb)};this.setScissor=function(a,b,c,d){k.scissor(a,b,c,d)};this.enableScissorTest=function(a){a?k.enable(k.SCISSOR_TEST):k.disable(k.SCISSOR_TEST)};this.setClearColorHex=function(a,b){Y.setHex(a);N=b;k.clearColor(Y.r,Y.g,Y.b,N)};this.setClearColor=function(a,b){Y.copy(a);N=b;k.clearColor(Y.r,Y.g,Y.b,N)};this.getClearColor=function(){return Y};this.getClearAlpha=function(){return N};this.clear=function(a,b,c){var d=0;if(void 0===a||a)d|=k.COLOR_BUFFER_BIT;if(void 0===
b||b)d|=k.DEPTH_BUFFER_BIT;if(void 0===c||c)d|=k.STENCIL_BUFFER_BIT;k.clear(d)};this.clearTarget=function(a,b,c,d){this.setRenderTarget(a);this.clear(b,c,d)};this.addPostPlugin=function(a){a.init(this);this.renderPluginsPost.push(a)};this.addPrePlugin=function(a){a.init(this);this.renderPluginsPre.push(a)};this.deallocateObject=function(a){if(a.__webglInit)if(a.__webglInit=!1,delete a._modelViewMatrix,delete a._normalMatrix,delete a._normalMatrixArray,delete a._modelViewMatrixArray,delete a._modelMatrixArray,
a instanceof THREE.Mesh)for(var b in a.geometry.geometryGroups){var c=a.geometry.geometryGroups[b];k.deleteBuffer(c.__webglVertexBuffer);k.deleteBuffer(c.__webglNormalBuffer);k.deleteBuffer(c.__webglTangentBuffer);k.deleteBuffer(c.__webglColorBuffer);k.deleteBuffer(c.__webglUVBuffer);k.deleteBuffer(c.__webglUV2Buffer);k.deleteBuffer(c.__webglSkinIndicesBuffer);k.deleteBuffer(c.__webglSkinWeightsBuffer);k.deleteBuffer(c.__webglFaceBuffer);k.deleteBuffer(c.__webglLineBuffer);var d=void 0,e=void 0;if(c.numMorphTargets){d=
0;for(e=c.numMorphTargets;d<e;d++)k.deleteBuffer(c.__webglMorphTargetsBuffers[d])}if(c.numMorphNormals){d=0;for(e=c.numMorphNormals;d<e;d++)k.deleteBuffer(c.__webglMorphNormalsBuffers[d])}if(c.__webglCustomAttributesList)for(d in d=void 0,c.__webglCustomAttributesList)k.deleteBuffer(c.__webglCustomAttributesList[d].buffer);Q.info.memory.geometries--}else a instanceof THREE.Ribbon?(a=a.geometry,k.deleteBuffer(a.__webglVertexBuffer),k.deleteBuffer(a.__webglColorBuffer),Q.info.memory.geometries--):a instanceof
THREE.Line?(a=a.geometry,k.deleteBuffer(a.__webglVertexBuffer),k.deleteBuffer(a.__webglColorBuffer),Q.info.memory.geometries--):a instanceof THREE.ParticleSystem&&(a=a.geometry,k.deleteBuffer(a.__webglVertexBuffer),k.deleteBuffer(a.__webglColorBuffer),Q.info.memory.geometries--)};this.deallocateTexture=function(a){a.__webglInit&&(a.__webglInit=!1,k.deleteTexture(a.__webglTexture),Q.info.memory.textures--)};this.deallocateRenderTarget=function(a){if(a&&a.__webglTexture)if(k.deleteTexture(a.__webglTexture),
a instanceof THREE.WebGLRenderTargetCube)for(var b=0;6>b;b++)k.deleteFramebuffer(a.__webglFramebuffer[b]),k.deleteRenderbuffer(a.__webglRenderbuffer[b]);else k.deleteFramebuffer(a.__webglFramebuffer),k.deleteRenderbuffer(a.__webglRenderbuffer)};this.deallocateMaterial=function(a){var b=a.program;if(b){a.program=void 0;var c,d,e=!1,a=0;for(c=qa.length;a<c;a++)if(d=qa[a],d.program===b){d.usedTimes--;0===d.usedTimes&&(e=!0);break}if(e){e=[];a=0;for(c=qa.length;a<c;a++)d=qa[a],d.program!==b&&e.push(d);
qa=e;k.deleteProgram(b);Q.info.memory.programs--}}};this.updateShadowMap=function(a,b){O=null;W=V=Ra=ib=Ia=-1;Ea=!0;Pa=Ga=-1;this.shadowMapPlugin.update(a,b)};this.renderBufferImmediate=function(a,b,c){a.hasPositions&&!a.__webglVertexBuffer&&(a.__webglVertexBuffer=k.createBuffer());a.hasNormals&&!a.__webglNormalBuffer&&(a.__webglNormalBuffer=k.createBuffer());a.hasUvs&&!a.__webglUvBuffer&&(a.__webglUvBuffer=k.createBuffer());a.hasColors&&!a.__webglColorBuffer&&(a.__webglColorBuffer=k.createBuffer());
a.hasPositions&&(k.bindBuffer(k.ARRAY_BUFFER,a.__webglVertexBuffer),k.bufferData(k.ARRAY_BUFFER,a.positionArray,k.DYNAMIC_DRAW),k.enableVertexAttribArray(b.attributes.position),k.vertexAttribPointer(b.attributes.position,3,k.FLOAT,!1,0,0));if(a.hasNormals){k.bindBuffer(k.ARRAY_BUFFER,a.__webglNormalBuffer);if(c.shading===THREE.FlatShading){var d,e,f,g,h,i,j,l,n,m,o,p=3*a.count;for(o=0;o<p;o+=9)m=a.normalArray,d=m[o],e=m[o+1],f=m[o+2],g=m[o+3],i=m[o+4],l=m[o+5],h=m[o+6],j=m[o+7],n=m[o+8],d=(d+g+h)/
3,e=(e+i+j)/3,f=(f+l+n)/3,m[o]=d,m[o+1]=e,m[o+2]=f,m[o+3]=d,m[o+4]=e,m[o+5]=f,m[o+6]=d,m[o+7]=e,m[o+8]=f}k.bufferData(k.ARRAY_BUFFER,a.normalArray,k.DYNAMIC_DRAW);k.enableVertexAttribArray(b.attributes.normal);k.vertexAttribPointer(b.attributes.normal,3,k.FLOAT,!1,0,0)}a.hasUvs&&c.map&&(k.bindBuffer(k.ARRAY_BUFFER,a.__webglUvBuffer),k.bufferData(k.ARRAY_BUFFER,a.uvArray,k.DYNAMIC_DRAW),k.enableVertexAttribArray(b.attributes.uv),k.vertexAttribPointer(b.attributes.uv,2,k.FLOAT,!1,0,0));a.hasColors&&
c.vertexColors!==THREE.NoColors&&(k.bindBuffer(k.ARRAY_BUFFER,a.__webglColorBuffer),k.bufferData(k.ARRAY_BUFFER,a.colorArray,k.DYNAMIC_DRAW),k.enableVertexAttribArray(b.attributes.color),k.vertexAttribPointer(b.attributes.color,3,k.FLOAT,!1,0,0));k.drawArrays(k.TRIANGLES,0,a.count);a.count=0};this.renderBufferDirect=function(a,b,c,d,e,f){if(!1!==d.visible)if(c=B(a,b,c,d,f),a=c.attributes,b=!1,d=16777215*e.id+2*c.id+(d.wireframe?1:0),d!==V&&(V=d,b=!0),f instanceof THREE.Mesh){f=e.offsets;1<f.length&&
(b=!0);d=0;for(c=f.length;d<c;++d){var g=f[d].index;if(b){var h=e.attributes.position,i=h.itemSize;k.bindBuffer(k.ARRAY_BUFFER,h.buffer);k.vertexAttribPointer(a.position,i,k.FLOAT,!1,0,4*g*i);h=e.attributes.normal;0<=a.normal&&h&&(i=h.itemSize,k.bindBuffer(k.ARRAY_BUFFER,h.buffer),k.vertexAttribPointer(a.normal,i,k.FLOAT,!1,0,4*g*i));h=e.attributes.uv;0<=a.uv&&h&&(h.buffer?(i=h.itemSize,k.bindBuffer(k.ARRAY_BUFFER,h.buffer),k.vertexAttribPointer(a.uv,i,k.FLOAT,!1,0,4*g*i),k.enableVertexAttribArray(a.uv)):
k.disableVertexAttribArray(a.uv));i=e.attributes.color;if(0<=a.color&&i){var j=i.itemSize;k.bindBuffer(k.ARRAY_BUFFER,i.buffer);k.vertexAttribPointer(a.color,j,k.FLOAT,!1,0,4*g*j)}h=e.attributes.tangent;0<=a.tangent&&h&&(i=h.itemSize,k.bindBuffer(k.ARRAY_BUFFER,h.buffer),k.vertexAttribPointer(a.tangent,i,k.FLOAT,!1,0,4*g*i));k.bindBuffer(k.ELEMENT_ARRAY_BUFFER,e.attributes.index.buffer)}k.drawElements(k.TRIANGLES,f[d].count,k.UNSIGNED_SHORT,2*f[d].start);Q.info.render.calls++;Q.info.render.vertices+=
f[d].count;Q.info.render.faces+=f[d].count/3}}else f instanceof THREE.ParticleSystem&&b&&(h=e.attributes.position,i=h.itemSize,k.bindBuffer(k.ARRAY_BUFFER,h.buffer),k.vertexAttribPointer(a.position,i,k.FLOAT,!1,0,0),i=e.attributes.color,0<=a.color&&i&&(j=i.itemSize,k.bindBuffer(k.ARRAY_BUFFER,i.buffer),k.vertexAttribPointer(a.color,j,k.FLOAT,!1,0,0)),k.drawArrays(k.POINTS,0,h.numItems/3),Q.info.render.calls++,Q.info.render.points+=h.numItems/3)};this.renderBuffer=function(a,b,c,d,e,f){if(!1!==d.visible){var g,
h,c=B(a,b,c,d,f),b=c.attributes,a=!1,c=16777215*e.id+2*c.id+(d.wireframe?1:0);c!==V&&(V=c,a=!0);if(!d.morphTargets&&0<=b.position)a&&(k.bindBuffer(k.ARRAY_BUFFER,e.__webglVertexBuffer),k.vertexAttribPointer(b.position,3,k.FLOAT,!1,0,0));else if(f.morphTargetBase){c=d.program.attributes;-1!==f.morphTargetBase?(k.bindBuffer(k.ARRAY_BUFFER,e.__webglMorphTargetsBuffers[f.morphTargetBase]),k.vertexAttribPointer(c.position,3,k.FLOAT,!1,0,0)):0<=c.position&&(k.bindBuffer(k.ARRAY_BUFFER,e.__webglVertexBuffer),
k.vertexAttribPointer(c.position,3,k.FLOAT,!1,0,0));if(f.morphTargetForcedOrder.length){var i=0;h=f.morphTargetForcedOrder;for(g=f.morphTargetInfluences;i<d.numSupportedMorphTargets&&i<h.length;)k.bindBuffer(k.ARRAY_BUFFER,e.__webglMorphTargetsBuffers[h[i]]),k.vertexAttribPointer(c["morphTarget"+i],3,k.FLOAT,!1,0,0),d.morphNormals&&(k.bindBuffer(k.ARRAY_BUFFER,e.__webglMorphNormalsBuffers[h[i]]),k.vertexAttribPointer(c["morphNormal"+i],3,k.FLOAT,!1,0,0)),f.__webglMorphTargetInfluences[i]=g[h[i]],
i++}else{h=[];g=f.morphTargetInfluences;var l,m=g.length;for(l=0;l<m;l++)i=g[l],0<i&&h.push([l,i]);h.length>d.numSupportedMorphTargets?(h.sort(j),h.length=d.numSupportedMorphTargets):h.length>d.numSupportedMorphNormals?h.sort(j):0===h.length&&h.push([0,0]);for(i=0;i<d.numSupportedMorphTargets;)h[i]?(l=h[i][0],k.bindBuffer(k.ARRAY_BUFFER,e.__webglMorphTargetsBuffers[l]),k.vertexAttribPointer(c["morphTarget"+i],3,k.FLOAT,!1,0,0),d.morphNormals&&(k.bindBuffer(k.ARRAY_BUFFER,e.__webglMorphNormalsBuffers[l]),
k.vertexAttribPointer(c["morphNormal"+i],3,k.FLOAT,!1,0,0)),f.__webglMorphTargetInfluences[i]=g[l]):(k.vertexAttribPointer(c["morphTarget"+i],3,k.FLOAT,!1,0,0),d.morphNormals&&k.vertexAttribPointer(c["morphNormal"+i],3,k.FLOAT,!1,0,0),f.__webglMorphTargetInfluences[i]=0),i++}null!==d.program.uniforms.morphTargetInfluences&&k.uniform1fv(d.program.uniforms.morphTargetInfluences,f.__webglMorphTargetInfluences)}if(a){if(e.__webglCustomAttributesList){g=0;for(h=e.__webglCustomAttributesList.length;g<h;g++)c=
e.__webglCustomAttributesList[g],0<=b[c.buffer.belongsToAttribute]&&(k.bindBuffer(k.ARRAY_BUFFER,c.buffer),k.vertexAttribPointer(b[c.buffer.belongsToAttribute],c.size,k.FLOAT,!1,0,0))}0<=b.color&&(k.bindBuffer(k.ARRAY_BUFFER,e.__webglColorBuffer),k.vertexAttribPointer(b.color,3,k.FLOAT,!1,0,0));0<=b.normal&&(k.bindBuffer(k.ARRAY_BUFFER,e.__webglNormalBuffer),k.vertexAttribPointer(b.normal,3,k.FLOAT,!1,0,0));0<=b.tangent&&(k.bindBuffer(k.ARRAY_BUFFER,e.__webglTangentBuffer),k.vertexAttribPointer(b.tangent,
4,k.FLOAT,!1,0,0));0<=b.uv&&(e.__webglUVBuffer?(k.bindBuffer(k.ARRAY_BUFFER,e.__webglUVBuffer),k.vertexAttribPointer(b.uv,2,k.FLOAT,!1,0,0),k.enableVertexAttribArray(b.uv)):k.disableVertexAttribArray(b.uv));0<=b.uv2&&(e.__webglUV2Buffer?(k.bindBuffer(k.ARRAY_BUFFER,e.__webglUV2Buffer),k.vertexAttribPointer(b.uv2,2,k.FLOAT,!1,0,0),k.enableVertexAttribArray(b.uv2)):k.disableVertexAttribArray(b.uv2));d.skinning&&(0<=b.skinIndex&&0<=b.skinWeight)&&(k.bindBuffer(k.ARRAY_BUFFER,e.__webglSkinIndicesBuffer),
k.vertexAttribPointer(b.skinIndex,4,k.FLOAT,!1,0,0),k.bindBuffer(k.ARRAY_BUFFER,e.__webglSkinWeightsBuffer),k.vertexAttribPointer(b.skinWeight,4,k.FLOAT,!1,0,0))}f instanceof THREE.Mesh?(d.wireframe?(d=d.wireframeLinewidth,d!==db&&(k.lineWidth(d),db=d),a&&k.bindBuffer(k.ELEMENT_ARRAY_BUFFER,e.__webglLineBuffer),k.drawElements(k.LINES,e.__webglLineCount,k.UNSIGNED_SHORT,0)):(a&&k.bindBuffer(k.ELEMENT_ARRAY_BUFFER,e.__webglFaceBuffer),k.drawElements(k.TRIANGLES,e.__webglFaceCount,k.UNSIGNED_SHORT,0)),
Q.info.render.calls++,Q.info.render.vertices+=e.__webglFaceCount,Q.info.render.faces+=e.__webglFaceCount/3):f instanceof THREE.Line?(f=f.type===THREE.LineStrip?k.LINE_STRIP:k.LINES,d=d.linewidth,d!==db&&(k.lineWidth(d),db=d),k.drawArrays(f,0,e.__webglLineCount),Q.info.render.calls++):f instanceof THREE.ParticleSystem?(k.drawArrays(k.POINTS,0,e.__webglParticleCount),Q.info.render.calls++,Q.info.render.points+=e.__webglParticleCount):f instanceof THREE.Ribbon&&(k.drawArrays(k.TRIANGLE_STRIP,0,e.__webglVertexCount),
Q.info.render.calls++)}};this.render=function(a,b,c,d){if(!1===b instanceof THREE.Camera)console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");else{var e,f,g,h,j=a.__lights,o=a.fog;W=-1;Ea=!0;this.autoUpdateScene&&a.updateMatrixWorld();void 0===b.parent&&b.updateMatrixWorld();b._viewMatrixArray||(b._viewMatrixArray=new Float32Array(16));b._projectionMatrixArray||(b._projectionMatrixArray=new Float32Array(16));b.matrixWorldInverse.getInverse(b.matrixWorld);b.matrixWorldInverse.flattenToArray(b._viewMatrixArray);
b.projectionMatrix.flattenToArray(b._projectionMatrixArray);ra.multiply(b.projectionMatrix,b.matrixWorldInverse);fb.setFromMatrix(ra);this.autoUpdateObjects&&this.initWebGLObjects(a);l(this.renderPluginsPre,a,b);Q.info.render.calls=0;Q.info.render.vertices=0;Q.info.render.faces=0;Q.info.render.points=0;this.setRenderTarget(c);(this.autoClear||d)&&this.clear(this.autoClearColor,this.autoClearDepth,this.autoClearStencil);h=a.__webglObjects;d=0;for(e=h.length;d<e;d++)if(f=h[d],g=f.object,f.render=!1,
g.visible&&(!(g instanceof THREE.Mesh||g instanceof THREE.ParticleSystem)||!g.frustumCulled||fb.contains(g))){s(g,b);var p=f,q=p.object,r=p.buffer,t=void 0,t=t=void 0,t=q.material;t instanceof THREE.MeshFaceMaterial?(t=r.materialIndex,0<=t&&(t=q.geometry.materials[t],t.transparent?(p.transparent=t,p.opaque=null):(p.opaque=t,p.transparent=null))):t&&(t.transparent?(p.transparent=t,p.opaque=null):(p.opaque=t,p.transparent=null));f.render=!0;!0===this.sortObjects&&(null!==g.renderDepth?f.z=g.renderDepth:
(Za.copy(g.matrixWorld.getPosition()),ra.multiplyVector3(Za),f.z=Za.z))}this.sortObjects&&h.sort(i);h=a.__webglObjectsImmediate;d=0;for(e=h.length;d<e;d++)f=h[d],g=f.object,g.visible&&(s(g,b),g=f.object.material,g.transparent?(f.transparent=g,f.opaque=null):(f.opaque=g,f.transparent=null));a.overrideMaterial?(d=a.overrideMaterial,this.setBlending(d.blending,d.blendEquation,d.blendSrc,d.blendDst),this.setDepthTest(d.depthTest),this.setDepthWrite(d.depthWrite),v(d.polygonOffset,d.polygonOffsetFactor,
d.polygonOffsetUnits),m(a.__webglObjects,!1,"",b,j,o,!0,d),n(a.__webglObjectsImmediate,"",b,j,o,!1,d)):(this.setBlending(THREE.NormalBlending),m(a.__webglObjects,!0,"opaque",b,j,o,!1),n(a.__webglObjectsImmediate,"opaque",b,j,o,!1),m(a.__webglObjects,!1,"transparent",b,j,o,!0),n(a.__webglObjectsImmediate,"transparent",b,j,o,!0));l(this.renderPluginsPost,a,b);c&&(c.generateMipmaps&&c.minFilter!==THREE.NearestFilter&&c.minFilter!==THREE.LinearFilter)&&(c instanceof THREE.WebGLRenderTargetCube?(k.bindTexture(k.TEXTURE_CUBE_MAP,
c.__webglTexture),k.generateMipmap(k.TEXTURE_CUBE_MAP),k.bindTexture(k.TEXTURE_CUBE_MAP,null)):(k.bindTexture(k.TEXTURE_2D,c.__webglTexture),k.generateMipmap(k.TEXTURE_2D),k.bindTexture(k.TEXTURE_2D,null)));this.setDepthTest(!0);this.setDepthWrite(!0)}};this.renderImmediateObject=function(a,b,c,d,e){var f=B(a,b,c,d,e);V=-1;Q.setMaterialFaces(d);e.immediateRenderCallback?e.immediateRenderCallback(f,k,fb):e.render(function(a){Q.renderBufferImmediate(a,f,d)})};this.initWebGLObjects=function(a){a.__webglObjects||
(a.__webglObjects=[],a.__webglObjectsImmediate=[],a.__webglSprites=[],a.__webglFlares=[]);for(;a.__objectsAdded.length;){var i=a.__objectsAdded[0],j=a,l=void 0,m=void 0,n=void 0;if(!i.__webglInit)if(i.__webglInit=!0,i._modelViewMatrix=new THREE.Matrix4,i._normalMatrix=new THREE.Matrix3,i instanceof THREE.Mesh)if(m=i.geometry,m instanceof THREE.Geometry){if(void 0===m.geometryGroups){var s=m,u=void 0,v=void 0,y=void 0,z=void 0,A=void 0,B=void 0,C=void 0,E={},G=s.morphTargets.length,H=s.morphNormals.length;
s.geometryGroups={};u=0;for(v=s.faces.length;u<v;u++)y=s.faces[u],z=y.materialIndex,B=void 0!==z?z:-1,void 0===E[B]&&(E[B]={hash:B,counter:0}),C=E[B].hash+"_"+E[B].counter,void 0===s.geometryGroups[C]&&(s.geometryGroups[C]={faces3:[],faces4:[],materialIndex:z,vertices:0,numMorphTargets:G,numMorphNormals:H}),A=y instanceof THREE.Face3?3:4,65535<s.geometryGroups[C].vertices+A&&(E[B].counter+=1,C=E[B].hash+"_"+E[B].counter,void 0===s.geometryGroups[C]&&(s.geometryGroups[C]={faces3:[],faces4:[],materialIndex:z,
vertices:0,numMorphTargets:G,numMorphNormals:H})),y instanceof THREE.Face3?s.geometryGroups[C].faces3.push(u):s.geometryGroups[C].faces4.push(u),s.geometryGroups[C].vertices+=A;s.geometryGroupsList=[];var J=void 0;for(J in s.geometryGroups)s.geometryGroups[J].id=Z++,s.geometryGroupsList.push(s.geometryGroups[J])}for(l in m.geometryGroups)if(n=m.geometryGroups[l],!n.__webglVertexBuffer){var I=n;I.__webglVertexBuffer=k.createBuffer();I.__webglNormalBuffer=k.createBuffer();I.__webglTangentBuffer=k.createBuffer();
I.__webglColorBuffer=k.createBuffer();I.__webglUVBuffer=k.createBuffer();I.__webglUV2Buffer=k.createBuffer();I.__webglSkinIndicesBuffer=k.createBuffer();I.__webglSkinWeightsBuffer=k.createBuffer();I.__webglFaceBuffer=k.createBuffer();I.__webglLineBuffer=k.createBuffer();var O=void 0,K=void 0;if(I.numMorphTargets){I.__webglMorphTargetsBuffers=[];O=0;for(K=I.numMorphTargets;O<K;O++)I.__webglMorphTargetsBuffers.push(k.createBuffer())}if(I.numMorphNormals){I.__webglMorphNormalsBuffers=[];O=0;for(K=I.numMorphNormals;O<
K;O++)I.__webglMorphNormalsBuffers.push(k.createBuffer())}Q.info.memory.geometries++;var F=n,M=i,L=M.geometry,N=F.faces3,W=F.faces4,V=3*N.length+4*W.length,fa=1*N.length+2*W.length,ca=3*N.length+4*W.length,R=c(M,F),Y=e(R),ea=d(R),ia=R.vertexColors?R.vertexColors:!1;F.__vertexArray=new Float32Array(3*V);ea&&(F.__normalArray=new Float32Array(3*V));L.hasTangents&&(F.__tangentArray=new Float32Array(4*V));ia&&(F.__colorArray=new Float32Array(3*V));if(Y){if(0<L.faceUvs.length||0<L.faceVertexUvs.length)F.__uvArray=
new Float32Array(2*V);if(1<L.faceUvs.length||1<L.faceVertexUvs.length)F.__uv2Array=new Float32Array(2*V)}M.geometry.skinWeights.length&&M.geometry.skinIndices.length&&(F.__skinIndexArray=new Float32Array(4*V),F.__skinWeightArray=new Float32Array(4*V));F.__faceArray=new Uint16Array(3*fa);F.__lineArray=new Uint16Array(2*ca);var $=void 0,qa=void 0;if(F.numMorphTargets){F.__morphTargetsArrays=[];$=0;for(qa=F.numMorphTargets;$<qa;$++)F.__morphTargetsArrays.push(new Float32Array(3*V))}if(F.numMorphNormals){F.__morphNormalsArrays=
[];$=0;for(qa=F.numMorphNormals;$<qa;$++)F.__morphNormalsArrays.push(new Float32Array(3*V))}F.__webglFaceCount=3*fa;F.__webglLineCount=2*ca;if(R.attributes){void 0===F.__webglCustomAttributesList&&(F.__webglCustomAttributesList=[]);var Ga=void 0;for(Ga in R.attributes){var na=R.attributes[Ga],la={},Pa;for(Pa in na)la[Pa]=na[Pa];if(!la.__webglInitialized||la.createUniqueBuffers){la.__webglInitialized=!0;var ra=1;"v2"===la.type?ra=2:"v3"===la.type?ra=3:"v4"===la.type?ra=4:"c"===la.type&&(ra=3);la.size=
ra;la.array=new Float32Array(V*ra);la.buffer=k.createBuffer();la.buffer.belongsToAttribute=Ga;na.needsUpdate=!0;la.__original=na}F.__webglCustomAttributesList.push(la)}}F.__inittedArrays=!0;m.verticesNeedUpdate=!0;m.morphTargetsNeedUpdate=!0;m.elementsNeedUpdate=!0;m.uvsNeedUpdate=!0;m.normalsNeedUpdate=!0;m.tangentsNeedUpdate=!0;m.colorsNeedUpdate=!0}}else m instanceof THREE.BufferGeometry&&f(m);else if(i instanceof THREE.Ribbon){if(m=i.geometry,!m.__webglVertexBuffer){var Ia=m;Ia.__webglVertexBuffer=
k.createBuffer();Ia.__webglColorBuffer=k.createBuffer();Q.info.memory.geometries++;var wa=m,Da=wa.vertices.length;wa.__vertexArray=new Float32Array(3*Da);wa.__colorArray=new Float32Array(3*Da);wa.__webglVertexCount=Da;m.verticesNeedUpdate=!0;m.colorsNeedUpdate=!0}}else if(i instanceof THREE.Line){if(m=i.geometry,!m.__webglVertexBuffer){var Ja=m;Ja.__webglVertexBuffer=k.createBuffer();Ja.__webglColorBuffer=k.createBuffer();Q.info.memory.geometries++;var Ea=m,Ua=i,Va=Ea.vertices.length;Ea.__vertexArray=
new Float32Array(3*Va);Ea.__colorArray=new Float32Array(3*Va);Ea.__webglLineCount=Va;b(Ea,Ua);m.verticesNeedUpdate=!0;m.colorsNeedUpdate=!0}}else if(i instanceof THREE.ParticleSystem&&(m=i.geometry,!m.__webglVertexBuffer))if(m instanceof THREE.Geometry){var Wa=m;Wa.__webglVertexBuffer=k.createBuffer();Wa.__webglColorBuffer=k.createBuffer();Q.info.memory.geometries++;var Ra=m,ib=i,$a=Ra.vertices.length;Ra.__vertexArray=new Float32Array(3*$a);Ra.__colorArray=new Float32Array(3*$a);Ra.__sortArray=[];
Ra.__webglParticleCount=$a;b(Ra,ib);m.verticesNeedUpdate=!0;m.colorsNeedUpdate=!0}else m instanceof THREE.BufferGeometry&&f(m);if(!i.__webglActive){if(i instanceof THREE.Mesh)if(m=i.geometry,m instanceof THREE.BufferGeometry)p(j.__webglObjects,m,i);else for(l in m.geometryGroups)n=m.geometryGroups[l],p(j.__webglObjects,n,i);else i instanceof THREE.Ribbon||i instanceof THREE.Line||i instanceof THREE.ParticleSystem?(m=i.geometry,p(j.__webglObjects,m,i)):i instanceof THREE.ImmediateRenderObject||i.immediateRenderCallback?
j.__webglObjectsImmediate.push({object:i,opaque:null,transparent:null}):i instanceof THREE.Sprite?j.__webglSprites.push(i):i instanceof THREE.LensFlare&&j.__webglFlares.push(i);i.__webglActive=!0}a.__objectsAdded.splice(0,1)}for(;a.__objectsRemoved.length;){var lb=a.__objectsRemoved[0],Za=a;lb instanceof THREE.Mesh||lb instanceof THREE.ParticleSystem||lb instanceof THREE.Ribbon||lb instanceof THREE.Line?r(Za.__webglObjects,lb):lb instanceof THREE.Sprite?t(Za.__webglSprites,lb):lb instanceof THREE.LensFlare?
t(Za.__webglFlares,lb):(lb instanceof THREE.ImmediateRenderObject||lb.immediateRenderCallback)&&r(Za.__webglObjectsImmediate,lb);lb.__webglActive=!1;a.__objectsRemoved.splice(0,1)}for(var fb=0,qb=a.__webglObjects.length;fb<qb;fb++){var ub=a.__webglObjects[fb].object,ga=ub.geometry,gb=void 0,eb=void 0,ab=void 0;if(ub instanceof THREE.Mesh)if(ga instanceof THREE.BufferGeometry)(ga.verticesNeedUpdate||ga.elementsNeedUpdate||ga.uvsNeedUpdate||ga.normalsNeedUpdate||ga.colorsNeedUpdate||ga.tangentsNeedUpdate)&&
h(ga,k.DYNAMIC_DRAW,!ga.dynamic),ga.verticesNeedUpdate=!1,ga.elementsNeedUpdate=!1,ga.uvsNeedUpdate=!1,ga.normalsNeedUpdate=!1,ga.colorsNeedUpdate=!1,ga.tangentsNeedUpdate=!1;else{for(var pb=0,wb=ga.geometryGroupsList.length;pb<wb;pb++)if(gb=ga.geometryGroupsList[pb],ab=c(ub,gb),eb=ab.attributes&&o(ab),ga.verticesNeedUpdate||ga.morphTargetsNeedUpdate||ga.elementsNeedUpdate||ga.uvsNeedUpdate||ga.normalsNeedUpdate||ga.colorsNeedUpdate||ga.tangentsNeedUpdate||eb){var ma=gb,xb=ub,mb=k.DYNAMIC_DRAW,yb=
!ga.dynamic,db=ab;if(ma.__inittedArrays){var Qb=d(db),Pb=db.vertexColors?db.vertexColors:!1,hc=e(db),Gc=Qb===THREE.SmoothShading,D=void 0,X=void 0,Xb=void 0,P=void 0,lc=void 0,Yb=void 0,vb=void 0,Hc=void 0,Rb=void 0,mc=void 0,nc=void 0,S=void 0,T=void 0,U=void 0,ka=void 0,zb=void 0,Ab=void 0,Bb=void 0,sc=void 0,Cb=void 0,Db=void 0,Eb=void 0,tc=void 0,Fb=void 0,Gb=void 0,Hb=void 0,uc=void 0,Ib=void 0,Jb=void 0,Kb=void 0,vc=void 0,Lb=void 0,Mb=void 0,Nb=void 0,wc=void 0,sa=void 0,ic=void 0,Zb=void 0,
oc=void 0,pc=void 0,Ma=void 0,rc=void 0,Ka=void 0,La=void 0,$b=void 0,Sb=void 0,Ca=0,Ha=0,Tb=0,Ub=0,nb=0,Sa=0,ua=0,Ya=0,Fa=0,da=0,ha=0,x=0,ta=void 0,Na=ma.__vertexArray,xc=ma.__uvArray,yc=ma.__uv2Array,ob=ma.__normalArray,xa=ma.__tangentArray,Oa=ma.__colorArray,ya=ma.__skinIndexArray,za=ma.__skinWeightArray,Vc=ma.__morphTargetsArrays,Wc=ma.__morphNormalsArrays,Xc=ma.__webglCustomAttributesList,w=void 0,Ob=ma.__faceArray,hb=ma.__lineArray,bb=xb.geometry,Ec=bb.elementsNeedUpdate,bd=bb.uvsNeedUpdate,
Sc=bb.normalsNeedUpdate,Tc=bb.tangentsNeedUpdate,id=bb.colorsNeedUpdate,jd=bb.morphTargetsNeedUpdate,ec=bb.vertices,oa=ma.faces3,pa=ma.faces4,Ta=bb.faces,Yc=bb.faceVertexUvs[0],Zc=bb.faceVertexUvs[1],fc=bb.skinIndices,ac=bb.skinWeights,bc=bb.morphTargets,Ic=bb.morphNormals;if(bb.verticesNeedUpdate){D=0;for(X=oa.length;D<X;D++)P=Ta[oa[D]],S=ec[P.a],T=ec[P.b],U=ec[P.c],Na[Ha]=S.x,Na[Ha+1]=S.y,Na[Ha+2]=S.z,Na[Ha+3]=T.x,Na[Ha+4]=T.y,Na[Ha+5]=T.z,Na[Ha+6]=U.x,Na[Ha+7]=U.y,Na[Ha+8]=U.z,Ha+=9;D=0;for(X=
pa.length;D<X;D++)P=Ta[pa[D]],S=ec[P.a],T=ec[P.b],U=ec[P.c],ka=ec[P.d],Na[Ha]=S.x,Na[Ha+1]=S.y,Na[Ha+2]=S.z,Na[Ha+3]=T.x,Na[Ha+4]=T.y,Na[Ha+5]=T.z,Na[Ha+6]=U.x,Na[Ha+7]=U.y,Na[Ha+8]=U.z,Na[Ha+9]=ka.x,Na[Ha+10]=ka.y,Na[Ha+11]=ka.z,Ha+=12;k.bindBuffer(k.ARRAY_BUFFER,ma.__webglVertexBuffer);k.bufferData(k.ARRAY_BUFFER,Na,mb)}if(jd){Ma=0;for(rc=bc.length;Ma<rc;Ma++){D=ha=0;for(X=oa.length;D<X;D++)$b=oa[D],P=Ta[$b],S=bc[Ma].vertices[P.a],T=bc[Ma].vertices[P.b],U=bc[Ma].vertices[P.c],Ka=Vc[Ma],Ka[ha]=S.x,
Ka[ha+1]=S.y,Ka[ha+2]=S.z,Ka[ha+3]=T.x,Ka[ha+4]=T.y,Ka[ha+5]=T.z,Ka[ha+6]=U.x,Ka[ha+7]=U.y,Ka[ha+8]=U.z,db.morphNormals&&(Gc?(Sb=Ic[Ma].vertexNormals[$b],Cb=Sb.a,Db=Sb.b,Eb=Sb.c):Eb=Db=Cb=Ic[Ma].faceNormals[$b],La=Wc[Ma],La[ha]=Cb.x,La[ha+1]=Cb.y,La[ha+2]=Cb.z,La[ha+3]=Db.x,La[ha+4]=Db.y,La[ha+5]=Db.z,La[ha+6]=Eb.x,La[ha+7]=Eb.y,La[ha+8]=Eb.z),ha+=9;D=0;for(X=pa.length;D<X;D++)$b=pa[D],P=Ta[$b],S=bc[Ma].vertices[P.a],T=bc[Ma].vertices[P.b],U=bc[Ma].vertices[P.c],ka=bc[Ma].vertices[P.d],Ka=Vc[Ma],
Ka[ha]=S.x,Ka[ha+1]=S.y,Ka[ha+2]=S.z,Ka[ha+3]=T.x,Ka[ha+4]=T.y,Ka[ha+5]=T.z,Ka[ha+6]=U.x,Ka[ha+7]=U.y,Ka[ha+8]=U.z,Ka[ha+9]=ka.x,Ka[ha+10]=ka.y,Ka[ha+11]=ka.z,db.morphNormals&&(Gc?(Sb=Ic[Ma].vertexNormals[$b],Cb=Sb.a,Db=Sb.b,Eb=Sb.c,tc=Sb.d):tc=Eb=Db=Cb=Ic[Ma].faceNormals[$b],La=Wc[Ma],La[ha]=Cb.x,La[ha+1]=Cb.y,La[ha+2]=Cb.z,La[ha+3]=Db.x,La[ha+4]=Db.y,La[ha+5]=Db.z,La[ha+6]=Eb.x,La[ha+7]=Eb.y,La[ha+8]=Eb.z,La[ha+9]=tc.x,La[ha+10]=tc.y,La[ha+11]=tc.z),ha+=12;k.bindBuffer(k.ARRAY_BUFFER,ma.__webglMorphTargetsBuffers[Ma]);
k.bufferData(k.ARRAY_BUFFER,Vc[Ma],mb);db.morphNormals&&(k.bindBuffer(k.ARRAY_BUFFER,ma.__webglMorphNormalsBuffers[Ma]),k.bufferData(k.ARRAY_BUFFER,Wc[Ma],mb))}}if(ac.length){D=0;for(X=oa.length;D<X;D++)P=Ta[oa[D]],Ib=ac[P.a],Jb=ac[P.b],Kb=ac[P.c],za[da]=Ib.x,za[da+1]=Ib.y,za[da+2]=Ib.z,za[da+3]=Ib.w,za[da+4]=Jb.x,za[da+5]=Jb.y,za[da+6]=Jb.z,za[da+7]=Jb.w,za[da+8]=Kb.x,za[da+9]=Kb.y,za[da+10]=Kb.z,za[da+11]=Kb.w,Lb=fc[P.a],Mb=fc[P.b],Nb=fc[P.c],ya[da]=Lb.x,ya[da+1]=Lb.y,ya[da+2]=Lb.z,ya[da+3]=Lb.w,
ya[da+4]=Mb.x,ya[da+5]=Mb.y,ya[da+6]=Mb.z,ya[da+7]=Mb.w,ya[da+8]=Nb.x,ya[da+9]=Nb.y,ya[da+10]=Nb.z,ya[da+11]=Nb.w,da+=12;D=0;for(X=pa.length;D<X;D++)P=Ta[pa[D]],Ib=ac[P.a],Jb=ac[P.b],Kb=ac[P.c],vc=ac[P.d],za[da]=Ib.x,za[da+1]=Ib.y,za[da+2]=Ib.z,za[da+3]=Ib.w,za[da+4]=Jb.x,za[da+5]=Jb.y,za[da+6]=Jb.z,za[da+7]=Jb.w,za[da+8]=Kb.x,za[da+9]=Kb.y,za[da+10]=Kb.z,za[da+11]=Kb.w,za[da+12]=vc.x,za[da+13]=vc.y,za[da+14]=vc.z,za[da+15]=vc.w,Lb=fc[P.a],Mb=fc[P.b],Nb=fc[P.c],wc=fc[P.d],ya[da]=Lb.x,ya[da+1]=Lb.y,
ya[da+2]=Lb.z,ya[da+3]=Lb.w,ya[da+4]=Mb.x,ya[da+5]=Mb.y,ya[da+6]=Mb.z,ya[da+7]=Mb.w,ya[da+8]=Nb.x,ya[da+9]=Nb.y,ya[da+10]=Nb.z,ya[da+11]=Nb.w,ya[da+12]=wc.x,ya[da+13]=wc.y,ya[da+14]=wc.z,ya[da+15]=wc.w,da+=16;0<da&&(k.bindBuffer(k.ARRAY_BUFFER,ma.__webglSkinIndicesBuffer),k.bufferData(k.ARRAY_BUFFER,ya,mb),k.bindBuffer(k.ARRAY_BUFFER,ma.__webglSkinWeightsBuffer),k.bufferData(k.ARRAY_BUFFER,za,mb))}if(id&&Pb){D=0;for(X=oa.length;D<X;D++)P=Ta[oa[D]],vb=P.vertexColors,Hc=P.color,3===vb.length&&Pb===
THREE.VertexColors?(Fb=vb[0],Gb=vb[1],Hb=vb[2]):Hb=Gb=Fb=Hc,Oa[Fa]=Fb.r,Oa[Fa+1]=Fb.g,Oa[Fa+2]=Fb.b,Oa[Fa+3]=Gb.r,Oa[Fa+4]=Gb.g,Oa[Fa+5]=Gb.b,Oa[Fa+6]=Hb.r,Oa[Fa+7]=Hb.g,Oa[Fa+8]=Hb.b,Fa+=9;D=0;for(X=pa.length;D<X;D++)P=Ta[pa[D]],vb=P.vertexColors,Hc=P.color,4===vb.length&&Pb===THREE.VertexColors?(Fb=vb[0],Gb=vb[1],Hb=vb[2],uc=vb[3]):uc=Hb=Gb=Fb=Hc,Oa[Fa]=Fb.r,Oa[Fa+1]=Fb.g,Oa[Fa+2]=Fb.b,Oa[Fa+3]=Gb.r,Oa[Fa+4]=Gb.g,Oa[Fa+5]=Gb.b,Oa[Fa+6]=Hb.r,Oa[Fa+7]=Hb.g,Oa[Fa+8]=Hb.b,Oa[Fa+9]=uc.r,Oa[Fa+10]=uc.g,
Oa[Fa+11]=uc.b,Fa+=12;0<Fa&&(k.bindBuffer(k.ARRAY_BUFFER,ma.__webglColorBuffer),k.bufferData(k.ARRAY_BUFFER,Oa,mb))}if(Tc&&bb.hasTangents){D=0;for(X=oa.length;D<X;D++)P=Ta[oa[D]],Rb=P.vertexTangents,zb=Rb[0],Ab=Rb[1],Bb=Rb[2],xa[ua]=zb.x,xa[ua+1]=zb.y,xa[ua+2]=zb.z,xa[ua+3]=zb.w,xa[ua+4]=Ab.x,xa[ua+5]=Ab.y,xa[ua+6]=Ab.z,xa[ua+7]=Ab.w,xa[ua+8]=Bb.x,xa[ua+9]=Bb.y,xa[ua+10]=Bb.z,xa[ua+11]=Bb.w,ua+=12;D=0;for(X=pa.length;D<X;D++)P=Ta[pa[D]],Rb=P.vertexTangents,zb=Rb[0],Ab=Rb[1],Bb=Rb[2],sc=Rb[3],xa[ua]=
zb.x,xa[ua+1]=zb.y,xa[ua+2]=zb.z,xa[ua+3]=zb.w,xa[ua+4]=Ab.x,xa[ua+5]=Ab.y,xa[ua+6]=Ab.z,xa[ua+7]=Ab.w,xa[ua+8]=Bb.x,xa[ua+9]=Bb.y,xa[ua+10]=Bb.z,xa[ua+11]=Bb.w,xa[ua+12]=sc.x,xa[ua+13]=sc.y,xa[ua+14]=sc.z,xa[ua+15]=sc.w,ua+=16;k.bindBuffer(k.ARRAY_BUFFER,ma.__webglTangentBuffer);k.bufferData(k.ARRAY_BUFFER,xa,mb)}if(Sc&&Qb){D=0;for(X=oa.length;D<X;D++)if(P=Ta[oa[D]],lc=P.vertexNormals,Yb=P.normal,3===lc.length&&Gc)for(sa=0;3>sa;sa++)Zb=lc[sa],ob[Sa]=Zb.x,ob[Sa+1]=Zb.y,ob[Sa+2]=Zb.z,Sa+=3;else for(sa=
0;3>sa;sa++)ob[Sa]=Yb.x,ob[Sa+1]=Yb.y,ob[Sa+2]=Yb.z,Sa+=3;D=0;for(X=pa.length;D<X;D++)if(P=Ta[pa[D]],lc=P.vertexNormals,Yb=P.normal,4===lc.length&&Gc)for(sa=0;4>sa;sa++)Zb=lc[sa],ob[Sa]=Zb.x,ob[Sa+1]=Zb.y,ob[Sa+2]=Zb.z,Sa+=3;else for(sa=0;4>sa;sa++)ob[Sa]=Yb.x,ob[Sa+1]=Yb.y,ob[Sa+2]=Yb.z,Sa+=3;k.bindBuffer(k.ARRAY_BUFFER,ma.__webglNormalBuffer);k.bufferData(k.ARRAY_BUFFER,ob,mb)}if(bd&&Yc&&hc){D=0;for(X=oa.length;D<X;D++)if(Xb=oa[D],mc=Yc[Xb],void 0!==mc)for(sa=0;3>sa;sa++)oc=mc[sa],xc[Tb]=oc.u,xc[Tb+
1]=oc.v,Tb+=2;D=0;for(X=pa.length;D<X;D++)if(Xb=pa[D],mc=Yc[Xb],void 0!==mc)for(sa=0;4>sa;sa++)oc=mc[sa],xc[Tb]=oc.u,xc[Tb+1]=oc.v,Tb+=2;0<Tb&&(k.bindBuffer(k.ARRAY_BUFFER,ma.__webglUVBuffer),k.bufferData(k.ARRAY_BUFFER,xc,mb))}if(bd&&Zc&&hc){D=0;for(X=oa.length;D<X;D++)if(Xb=oa[D],nc=Zc[Xb],void 0!==nc)for(sa=0;3>sa;sa++)pc=nc[sa],yc[Ub]=pc.u,yc[Ub+1]=pc.v,Ub+=2;D=0;for(X=pa.length;D<X;D++)if(Xb=pa[D],nc=Zc[Xb],void 0!==nc)for(sa=0;4>sa;sa++)pc=nc[sa],yc[Ub]=pc.u,yc[Ub+1]=pc.v,Ub+=2;0<Ub&&(k.bindBuffer(k.ARRAY_BUFFER,
ma.__webglUV2Buffer),k.bufferData(k.ARRAY_BUFFER,yc,mb))}if(Ec){D=0;for(X=oa.length;D<X;D++)Ob[nb]=Ca,Ob[nb+1]=Ca+1,Ob[nb+2]=Ca+2,nb+=3,hb[Ya]=Ca,hb[Ya+1]=Ca+1,hb[Ya+2]=Ca,hb[Ya+3]=Ca+2,hb[Ya+4]=Ca+1,hb[Ya+5]=Ca+2,Ya+=6,Ca+=3;D=0;for(X=pa.length;D<X;D++)Ob[nb]=Ca,Ob[nb+1]=Ca+1,Ob[nb+2]=Ca+3,Ob[nb+3]=Ca+1,Ob[nb+4]=Ca+2,Ob[nb+5]=Ca+3,nb+=6,hb[Ya]=Ca,hb[Ya+1]=Ca+1,hb[Ya+2]=Ca,hb[Ya+3]=Ca+3,hb[Ya+4]=Ca+1,hb[Ya+5]=Ca+2,hb[Ya+6]=Ca+2,hb[Ya+7]=Ca+3,Ya+=8,Ca+=4;k.bindBuffer(k.ELEMENT_ARRAY_BUFFER,ma.__webglFaceBuffer);
k.bufferData(k.ELEMENT_ARRAY_BUFFER,Ob,mb);k.bindBuffer(k.ELEMENT_ARRAY_BUFFER,ma.__webglLineBuffer);k.bufferData(k.ELEMENT_ARRAY_BUFFER,hb,mb)}if(Xc){sa=0;for(ic=Xc.length;sa<ic;sa++)if(w=Xc[sa],w.__original.needsUpdate){x=0;if(1===w.size)if(void 0===w.boundTo||"vertices"===w.boundTo){D=0;for(X=oa.length;D<X;D++)P=Ta[oa[D]],w.array[x]=w.value[P.a],w.array[x+1]=w.value[P.b],w.array[x+2]=w.value[P.c],x+=3;D=0;for(X=pa.length;D<X;D++)P=Ta[pa[D]],w.array[x]=w.value[P.a],w.array[x+1]=w.value[P.b],w.array[x+
2]=w.value[P.c],w.array[x+3]=w.value[P.d],x+=4}else{if("faces"===w.boundTo){D=0;for(X=oa.length;D<X;D++)ta=w.value[oa[D]],w.array[x]=ta,w.array[x+1]=ta,w.array[x+2]=ta,x+=3;D=0;for(X=pa.length;D<X;D++)ta=w.value[pa[D]],w.array[x]=ta,w.array[x+1]=ta,w.array[x+2]=ta,w.array[x+3]=ta,x+=4}}else if(2===w.size)if(void 0===w.boundTo||"vertices"===w.boundTo){D=0;for(X=oa.length;D<X;D++)P=Ta[oa[D]],S=w.value[P.a],T=w.value[P.b],U=w.value[P.c],w.array[x]=S.x,w.array[x+1]=S.y,w.array[x+2]=T.x,w.array[x+3]=T.y,
w.array[x+4]=U.x,w.array[x+5]=U.y,x+=6;D=0;for(X=pa.length;D<X;D++)P=Ta[pa[D]],S=w.value[P.a],T=w.value[P.b],U=w.value[P.c],ka=w.value[P.d],w.array[x]=S.x,w.array[x+1]=S.y,w.array[x+2]=T.x,w.array[x+3]=T.y,w.array[x+4]=U.x,w.array[x+5]=U.y,w.array[x+6]=ka.x,w.array[x+7]=ka.y,x+=8}else{if("faces"===w.boundTo){D=0;for(X=oa.length;D<X;D++)U=T=S=ta=w.value[oa[D]],w.array[x]=S.x,w.array[x+1]=S.y,w.array[x+2]=T.x,w.array[x+3]=T.y,w.array[x+4]=U.x,w.array[x+5]=U.y,x+=6;D=0;for(X=pa.length;D<X;D++)ka=U=T=
S=ta=w.value[pa[D]],w.array[x]=S.x,w.array[x+1]=S.y,w.array[x+2]=T.x,w.array[x+3]=T.y,w.array[x+4]=U.x,w.array[x+5]=U.y,w.array[x+6]=ka.x,w.array[x+7]=ka.y,x+=8}}else if(3===w.size){var ba;ba="c"===w.type?["r","g","b"]:["x","y","z"];if(void 0===w.boundTo||"vertices"===w.boundTo){D=0;for(X=oa.length;D<X;D++)P=Ta[oa[D]],S=w.value[P.a],T=w.value[P.b],U=w.value[P.c],w.array[x]=S[ba[0]],w.array[x+1]=S[ba[1]],w.array[x+2]=S[ba[2]],w.array[x+3]=T[ba[0]],w.array[x+4]=T[ba[1]],w.array[x+5]=T[ba[2]],w.array[x+
6]=U[ba[0]],w.array[x+7]=U[ba[1]],w.array[x+8]=U[ba[2]],x+=9;D=0;for(X=pa.length;D<X;D++)P=Ta[pa[D]],S=w.value[P.a],T=w.value[P.b],U=w.value[P.c],ka=w.value[P.d],w.array[x]=S[ba[0]],w.array[x+1]=S[ba[1]],w.array[x+2]=S[ba[2]],w.array[x+3]=T[ba[0]],w.array[x+4]=T[ba[1]],w.array[x+5]=T[ba[2]],w.array[x+6]=U[ba[0]],w.array[x+7]=U[ba[1]],w.array[x+8]=U[ba[2]],w.array[x+9]=ka[ba[0]],w.array[x+10]=ka[ba[1]],w.array[x+11]=ka[ba[2]],x+=12}else if("faces"===w.boundTo){D=0;for(X=oa.length;D<X;D++)U=T=S=ta=
w.value[oa[D]],w.array[x]=S[ba[0]],w.array[x+1]=S[ba[1]],w.array[x+2]=S[ba[2]],w.array[x+3]=T[ba[0]],w.array[x+4]=T[ba[1]],w.array[x+5]=T[ba[2]],w.array[x+6]=U[ba[0]],w.array[x+7]=U[ba[1]],w.array[x+8]=U[ba[2]],x+=9;D=0;for(X=pa.length;D<X;D++)ka=U=T=S=ta=w.value[pa[D]],w.array[x]=S[ba[0]],w.array[x+1]=S[ba[1]],w.array[x+2]=S[ba[2]],w.array[x+3]=T[ba[0]],w.array[x+4]=T[ba[1]],w.array[x+5]=T[ba[2]],w.array[x+6]=U[ba[0]],w.array[x+7]=U[ba[1]],w.array[x+8]=U[ba[2]],w.array[x+9]=ka[ba[0]],w.array[x+10]=
ka[ba[1]],w.array[x+11]=ka[ba[2]],x+=12}else if("faceVertices"===w.boundTo){D=0;for(X=oa.length;D<X;D++)ta=w.value[oa[D]],S=ta[0],T=ta[1],U=ta[2],w.array[x]=S[ba[0]],w.array[x+1]=S[ba[1]],w.array[x+2]=S[ba[2]],w.array[x+3]=T[ba[0]],w.array[x+4]=T[ba[1]],w.array[x+5]=T[ba[2]],w.array[x+6]=U[ba[0]],w.array[x+7]=U[ba[1]],w.array[x+8]=U[ba[2]],x+=9;D=0;for(X=pa.length;D<X;D++)ta=w.value[pa[D]],S=ta[0],T=ta[1],U=ta[2],ka=ta[3],w.array[x]=S[ba[0]],w.array[x+1]=S[ba[1]],w.array[x+2]=S[ba[2]],w.array[x+3]=
T[ba[0]],w.array[x+4]=T[ba[1]],w.array[x+5]=T[ba[2]],w.array[x+6]=U[ba[0]],w.array[x+7]=U[ba[1]],w.array[x+8]=U[ba[2]],w.array[x+9]=ka[ba[0]],w.array[x+10]=ka[ba[1]],w.array[x+11]=ka[ba[2]],x+=12}}else if(4===w.size)if(void 0===w.boundTo||"vertices"===w.boundTo){D=0;for(X=oa.length;D<X;D++)P=Ta[oa[D]],S=w.value[P.a],T=w.value[P.b],U=w.value[P.c],w.array[x]=S.x,w.array[x+1]=S.y,w.array[x+2]=S.z,w.array[x+3]=S.w,w.array[x+4]=T.x,w.array[x+5]=T.y,w.array[x+6]=T.z,w.array[x+7]=T.w,w.array[x+8]=U.x,w.array[x+
9]=U.y,w.array[x+10]=U.z,w.array[x+11]=U.w,x+=12;D=0;for(X=pa.length;D<X;D++)P=Ta[pa[D]],S=w.value[P.a],T=w.value[P.b],U=w.value[P.c],ka=w.value[P.d],w.array[x]=S.x,w.array[x+1]=S.y,w.array[x+2]=S.z,w.array[x+3]=S.w,w.array[x+4]=T.x,w.array[x+5]=T.y,w.array[x+6]=T.z,w.array[x+7]=T.w,w.array[x+8]=U.x,w.array[x+9]=U.y,w.array[x+10]=U.z,w.array[x+11]=U.w,w.array[x+12]=ka.x,w.array[x+13]=ka.y,w.array[x+14]=ka.z,w.array[x+15]=ka.w,x+=16}else if("faces"===w.boundTo){D=0;for(X=oa.length;D<X;D++)U=T=S=ta=
w.value[oa[D]],w.array[x]=S.x,w.array[x+1]=S.y,w.array[x+2]=S.z,w.array[x+3]=S.w,w.array[x+4]=T.x,w.array[x+5]=T.y,w.array[x+6]=T.z,w.array[x+7]=T.w,w.array[x+8]=U.x,w.array[x+9]=U.y,w.array[x+10]=U.z,w.array[x+11]=U.w,x+=12;D=0;for(X=pa.length;D<X;D++)ka=U=T=S=ta=w.value[pa[D]],w.array[x]=S.x,w.array[x+1]=S.y,w.array[x+2]=S.z,w.array[x+3]=S.w,w.array[x+4]=T.x,w.array[x+5]=T.y,w.array[x+6]=T.z,w.array[x+7]=T.w,w.array[x+8]=U.x,w.array[x+9]=U.y,w.array[x+10]=U.z,w.array[x+11]=U.w,w.array[x+12]=ka.x,
w.array[x+13]=ka.y,w.array[x+14]=ka.z,w.array[x+15]=ka.w,x+=16}else if("faceVertices"===w.boundTo){D=0;for(X=oa.length;D<X;D++)ta=w.value[oa[D]],S=ta[0],T=ta[1],U=ta[2],w.array[x]=S.x,w.array[x+1]=S.y,w.array[x+2]=S.z,w.array[x+3]=S.w,w.array[x+4]=T.x,w.array[x+5]=T.y,w.array[x+6]=T.z,w.array[x+7]=T.w,w.array[x+8]=U.x,w.array[x+9]=U.y,w.array[x+10]=U.z,w.array[x+11]=U.w,x+=12;D=0;for(X=pa.length;D<X;D++)ta=w.value[pa[D]],S=ta[0],T=ta[1],U=ta[2],ka=ta[3],w.array[x]=S.x,w.array[x+1]=S.y,w.array[x+2]=
S.z,w.array[x+3]=S.w,w.array[x+4]=T.x,w.array[x+5]=T.y,w.array[x+6]=T.z,w.array[x+7]=T.w,w.array[x+8]=U.x,w.array[x+9]=U.y,w.array[x+10]=U.z,w.array[x+11]=U.w,w.array[x+12]=ka.x,w.array[x+13]=ka.y,w.array[x+14]=ka.z,w.array[x+15]=ka.w,x+=16}k.bindBuffer(k.ARRAY_BUFFER,w.buffer);k.bufferData(k.ARRAY_BUFFER,w.array,mb)}}yb&&(delete ma.__inittedArrays,delete ma.__colorArray,delete ma.__normalArray,delete ma.__tangentArray,delete ma.__uvArray,delete ma.__uv2Array,delete ma.__faceArray,delete ma.__vertexArray,
delete ma.__lineArray,delete ma.__skinIndexArray,delete ma.__skinWeightArray)}}ga.verticesNeedUpdate=!1;ga.morphTargetsNeedUpdate=!1;ga.elementsNeedUpdate=!1;ga.uvsNeedUpdate=!1;ga.normalsNeedUpdate=!1;ga.colorsNeedUpdate=!1;ga.tangentsNeedUpdate=!1;ab.attributes&&q(ab)}else if(ub instanceof THREE.Ribbon){if(ga.verticesNeedUpdate||ga.colorsNeedUpdate){var cc=ga,cd=k.DYNAMIC_DRAW,zc=void 0,Ac=void 0,Jc=void 0,dc=void 0,Kc=void 0,dd=cc.vertices,ed=cc.colors,kd=dd.length,ld=ed.length,Lc=cc.__vertexArray,
Mc=cc.__colorArray,md=cc.colorsNeedUpdate;if(cc.verticesNeedUpdate){for(zc=0;zc<kd;zc++)Jc=dd[zc],dc=3*zc,Lc[dc]=Jc.x,Lc[dc+1]=Jc.y,Lc[dc+2]=Jc.z;k.bindBuffer(k.ARRAY_BUFFER,cc.__webglVertexBuffer);k.bufferData(k.ARRAY_BUFFER,Lc,cd)}if(md){for(Ac=0;Ac<ld;Ac++)Kc=ed[Ac],dc=3*Ac,Mc[dc]=Kc.r,Mc[dc+1]=Kc.g,Mc[dc+2]=Kc.b;k.bindBuffer(k.ARRAY_BUFFER,cc.__webglColorBuffer);k.bufferData(k.ARRAY_BUFFER,Mc,cd)}}ga.verticesNeedUpdate=!1;ga.colorsNeedUpdate=!1}else if(ub instanceof THREE.Line){ab=c(ub,gb);eb=
ab.attributes&&o(ab);if(ga.verticesNeedUpdate||ga.colorsNeedUpdate||eb){var Vb=ga,$c=k.DYNAMIC_DRAW,Bc=void 0,Cc=void 0,Nc=void 0,Aa=void 0,Oc=void 0,fd=Vb.vertices,gd=Vb.colors,nd=fd.length,od=gd.length,Pc=Vb.__vertexArray,Qc=Vb.__colorArray,pd=Vb.colorsNeedUpdate,ad=Vb.__webglCustomAttributesList,Rc=void 0,hd=void 0,Qa=void 0,qc=void 0,cb=void 0,va=void 0;if(Vb.verticesNeedUpdate){for(Bc=0;Bc<nd;Bc++)Nc=fd[Bc],Aa=3*Bc,Pc[Aa]=Nc.x,Pc[Aa+1]=Nc.y,Pc[Aa+2]=Nc.z;k.bindBuffer(k.ARRAY_BUFFER,Vb.__webglVertexBuffer);
k.bufferData(k.ARRAY_BUFFER,Pc,$c)}if(pd){for(Cc=0;Cc<od;Cc++)Oc=gd[Cc],Aa=3*Cc,Qc[Aa]=Oc.r,Qc[Aa+1]=Oc.g,Qc[Aa+2]=Oc.b;k.bindBuffer(k.ARRAY_BUFFER,Vb.__webglColorBuffer);k.bufferData(k.ARRAY_BUFFER,Qc,$c)}if(ad){Rc=0;for(hd=ad.length;Rc<hd;Rc++)if(va=ad[Rc],va.needsUpdate&&(void 0===va.boundTo||"vertices"===va.boundTo)){Aa=0;qc=va.value.length;if(1===va.size)for(Qa=0;Qa<qc;Qa++)va.array[Qa]=va.value[Qa];else if(2===va.size)for(Qa=0;Qa<qc;Qa++)cb=va.value[Qa],va.array[Aa]=cb.x,va.array[Aa+1]=cb.y,
Aa+=2;else if(3===va.size)if("c"===va.type)for(Qa=0;Qa<qc;Qa++)cb=va.value[Qa],va.array[Aa]=cb.r,va.array[Aa+1]=cb.g,va.array[Aa+2]=cb.b,Aa+=3;else for(Qa=0;Qa<qc;Qa++)cb=va.value[Qa],va.array[Aa]=cb.x,va.array[Aa+1]=cb.y,va.array[Aa+2]=cb.z,Aa+=3;else if(4===va.size)for(Qa=0;Qa<qc;Qa++)cb=va.value[Qa],va.array[Aa]=cb.x,va.array[Aa+1]=cb.y,va.array[Aa+2]=cb.z,va.array[Aa+3]=cb.w,Aa+=4;k.bindBuffer(k.ARRAY_BUFFER,va.buffer);k.bufferData(k.ARRAY_BUFFER,va.array,$c)}}}ga.verticesNeedUpdate=!1;ga.colorsNeedUpdate=
!1;ab.attributes&&q(ab)}else ub instanceof THREE.ParticleSystem&&(ga instanceof THREE.BufferGeometry?((ga.verticesNeedUpdate||ga.colorsNeedUpdate)&&h(ga,k.DYNAMIC_DRAW,!ga.dynamic),ga.verticesNeedUpdate=!1,ga.colorsNeedUpdate=!1):(ab=c(ub,gb),eb=ab.attributes&&o(ab),(ga.verticesNeedUpdate||ga.colorsNeedUpdate||ub.sortParticles||eb)&&g(ga,k.DYNAMIC_DRAW,ub),ga.verticesNeedUpdate=!1,ga.colorsNeedUpdate=!1,ab.attributes&&q(ab)))}};this.initMaterial=function(a,b,c,d){var e,f,g,h,i,j,l,m,n;a instanceof
THREE.MeshDepthMaterial?n="depth":a instanceof THREE.MeshNormalMaterial?n="normal":a instanceof THREE.MeshBasicMaterial?n="basic":a instanceof THREE.MeshLambertMaterial?n="lambert":a instanceof THREE.MeshPhongMaterial?n="phong":a instanceof THREE.LineBasicMaterial?n="basic":a instanceof THREE.ParticleBasicMaterial&&(n="particle_basic");if(n){var o=THREE.ShaderLib[n];a.uniforms=THREE.UniformsUtils.clone(o.uniforms);a.vertexShader=o.vertexShader;a.fragmentShader=o.fragmentShader}var p,q,s;e=p=q=s=o=
0;for(f=b.length;e<f;e++)g=b[e],g.onlyShadow||(g instanceof THREE.DirectionalLight&&p++,g instanceof THREE.PointLight&&q++,g instanceof THREE.SpotLight&&s++,g instanceof THREE.HemisphereLight&&o++);q+s+p+o<=ea?e=p:(e=Math.ceil(ea*p/(q+p)),s=q=ea-e,o=e);f=q;g=s;h=o;o=p=0;for(s=b.length;o<s;o++)q=b[o],q.castShadow&&(q instanceof THREE.SpotLight&&p++,q instanceof THREE.DirectionalLight&&!q.shadowCascade&&p++);m=p;ic&&d&&d.useVertexTexture?l=1024:(b=k.getParameter(k.MAX_VERTEX_UNIFORM_VECTORS),b=Math.floor((b-
20)/4),void 0!==d&&d instanceof THREE.SkinnedMesh&&(b=Math.min(d.bones.length,b),b<d.bones.length&&console.warn("WebGLRenderer: too many bones - "+d.bones.length+", this GPU supports just "+b+" (try OpenGL instead of ANGLE)")),l=b);var r;a:{q=a.fragmentShader;s=a.vertexShader;o=a.uniforms;b=a.attributes;p=a.defines;var c={map:!!a.map,envMap:!!a.envMap,lightMap:!!a.lightMap,bumpMap:!!a.bumpMap,normalMap:!!a.normalMap,specularMap:!!a.specularMap,vertexColors:a.vertexColors,fog:c,useFog:a.fog,sizeAttenuation:a.sizeAttenuation,
skinning:a.skinning,maxBones:l,useVertexTexture:ic&&d&&d.useVertexTexture,boneTextureWidth:d&&d.boneTextureWidth,boneTextureHeight:d&&d.boneTextureHeight,morphTargets:a.morphTargets,morphNormals:a.morphNormals,maxMorphTargets:this.maxMorphTargets,maxMorphNormals:this.maxMorphNormals,maxDirLights:e,maxPointLights:f,maxSpotLights:g,maxHemiLights:h,maxShadows:m,shadowMapEnabled:this.shadowMapEnabled&&d.receiveShadow,shadowMapSoft:this.shadowMapSoft,shadowMapDebug:this.shadowMapDebug,shadowMapCascade:this.shadowMapCascade,
alphaTest:a.alphaTest,metal:a.metal,perPixel:a.perPixel,wrapAround:a.wrapAround,doubleSided:a.side===THREE.DoubleSide,flipSided:a.side===THREE.BackSide},t,u,v,d=[];n?d.push(n):(d.push(q),d.push(s));for(u in p)d.push(u),d.push(p[u]);for(t in c)d.push(t),d.push(c[t]);n=d.join();t=0;for(u=qa.length;t<u;t++)if(d=qa[t],d.code===n){d.usedTimes++;r=d.program;break a}t=[];for(v in p)u=p[v],!1!==u&&(u="#define "+v+" "+u,t.push(u));u=t.join("\n");v=k.createProgram();t=["precision "+K+" float;",u,hc?"#define VERTEX_TEXTURES":
"",Q.gammaInput?"#define GAMMA_INPUT":"",Q.gammaOutput?"#define GAMMA_OUTPUT":"",Q.physicallyBasedShading?"#define PHYSICALLY_BASED_SHADING":"","#define MAX_DIR_LIGHTS "+c.maxDirLights,"#define MAX_POINT_LIGHTS "+c.maxPointLights,"#define MAX_SPOT_LIGHTS "+c.maxSpotLights,"#define MAX_HEMI_LIGHTS "+c.maxHemiLights,"#define MAX_SHADOWS "+c.maxShadows,"#define MAX_BONES "+c.maxBones,c.map?"#define USE_MAP":"",c.envMap?"#define USE_ENVMAP":"",c.lightMap?"#define USE_LIGHTMAP":"",c.bumpMap?"#define USE_BUMPMAP":
"",c.normalMap?"#define USE_NORMALMAP":"",c.specularMap?"#define USE_SPECULARMAP":"",c.vertexColors?"#define USE_COLOR":"",c.skinning?"#define USE_SKINNING":"",c.useVertexTexture?"#define BONE_TEXTURE":"",c.boneTextureWidth?"#define N_BONE_PIXEL_X "+c.boneTextureWidth.toFixed(1):"",c.boneTextureHeight?"#define N_BONE_PIXEL_Y "+c.boneTextureHeight.toFixed(1):"",c.morphTargets?"#define USE_MORPHTARGETS":"",c.morphNormals?"#define USE_MORPHNORMALS":"",c.perPixel?"#define PHONG_PER_PIXEL":"",c.wrapAround?
"#define WRAP_AROUND":"",c.doubleSided?"#define DOUBLE_SIDED":"",c.flipSided?"#define FLIP_SIDED":"",c.shadowMapEnabled?"#define USE_SHADOWMAP":"",c.shadowMapSoft?"#define SHADOWMAP_SOFT":"",c.shadowMapDebug?"#define SHADOWMAP_DEBUG":"",c.shadowMapCascade?"#define SHADOWMAP_CASCADE":"",c.sizeAttenuation?"#define USE_SIZEATTENUATION":"","uniform mat4 modelMatrix;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat3 normalMatrix;\nuniform vec3 cameraPosition;\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec2 uv;\nattribute vec2 uv2;\n#ifdef USE_COLOR\nattribute vec3 color;\n#endif\n#ifdef USE_MORPHTARGETS\nattribute vec3 morphTarget0;\nattribute vec3 morphTarget1;\nattribute vec3 morphTarget2;\nattribute vec3 morphTarget3;\n#ifdef USE_MORPHNORMALS\nattribute vec3 morphNormal0;\nattribute vec3 morphNormal1;\nattribute vec3 morphNormal2;\nattribute vec3 morphNormal3;\n#else\nattribute vec3 morphTarget4;\nattribute vec3 morphTarget5;\nattribute vec3 morphTarget6;\nattribute vec3 morphTarget7;\n#endif\n#endif\n#ifdef USE_SKINNING\nattribute vec4 skinIndex;\nattribute vec4 skinWeight;\n#endif\n"].join("\n");
u=["precision "+K+" float;",c.bumpMap||c.normalMap?"#extension GL_OES_standard_derivatives : enable":"",u,"#define MAX_DIR_LIGHTS "+c.maxDirLights,"#define MAX_POINT_LIGHTS "+c.maxPointLights,"#define MAX_SPOT_LIGHTS "+c.maxSpotLights,"#define MAX_HEMI_LIGHTS "+c.maxHemiLights,"#define MAX_SHADOWS "+c.maxShadows,c.alphaTest?"#define ALPHATEST "+c.alphaTest:"",Q.gammaInput?"#define GAMMA_INPUT":"",Q.gammaOutput?"#define GAMMA_OUTPUT":"",Q.physicallyBasedShading?"#define PHYSICALLY_BASED_SHADING":"",
c.useFog&&c.fog?"#define USE_FOG":"",c.useFog&&c.fog instanceof THREE.FogExp2?"#define FOG_EXP2":"",c.map?"#define USE_MAP":"",c.envMap?"#define USE_ENVMAP":"",c.lightMap?"#define USE_LIGHTMAP":"",c.bumpMap?"#define USE_BUMPMAP":"",c.normalMap?"#define USE_NORMALMAP":"",c.specularMap?"#define USE_SPECULARMAP":"",c.vertexColors?"#define USE_COLOR":"",c.metal?"#define METAL":"",c.perPixel?"#define PHONG_PER_PIXEL":"",c.wrapAround?"#define WRAP_AROUND":"",c.doubleSided?"#define DOUBLE_SIDED":"",c.flipSided?
"#define FLIP_SIDED":"",c.shadowMapEnabled?"#define USE_SHADOWMAP":"",c.shadowMapSoft?"#define SHADOWMAP_SOFT":"",c.shadowMapDebug?"#define SHADOWMAP_DEBUG":"",c.shadowMapCascade?"#define SHADOWMAP_CASCADE":"","uniform mat4 viewMatrix;\nuniform vec3 cameraPosition;\n"].join("\n");u=C("fragment",u+q);t=C("vertex",t+s);k.attachShader(v,t);k.attachShader(v,u);k.linkProgram(v);k.getProgramParameter(v,k.LINK_STATUS)||console.error("Could not initialise shader\nVALIDATE_STATUS: "+k.getProgramParameter(v,
k.VALIDATE_STATUS)+", gl error ["+k.getError()+"]");k.deleteShader(u);k.deleteShader(t);v.uniforms={};v.attributes={};var y;t="viewMatrix modelViewMatrix projectionMatrix normalMatrix modelMatrix cameraPosition morphTargetInfluences".split(" ");c.useVertexTexture?t.push("boneTexture"):t.push("boneGlobalMatrices");for(y in o)t.push(y);y=t;t=0;for(u=y.length;t<u;t++)d=y[t],v.uniforms[d]=k.getUniformLocation(v,d);t="position normal uv uv2 tangent color skinIndex skinWeight".split(" ");for(y=0;y<c.maxMorphTargets;y++)t.push("morphTarget"+
y);for(y=0;y<c.maxMorphNormals;y++)t.push("morphNormal"+y);for(r in b)t.push(r);r=t;y=0;for(t=r.length;y<t;y++)u=r[y],v.attributes[u]=k.getAttribLocation(v,u);v.id=la++;qa.push({program:v,code:n,usedTimes:1});Q.info.memory.programs=qa.length;r=v}a.program=r;r=a.program.attributes;0<=r.position&&k.enableVertexAttribArray(r.position);0<=r.color&&k.enableVertexAttribArray(r.color);0<=r.normal&&k.enableVertexAttribArray(r.normal);0<=r.tangent&&k.enableVertexAttribArray(r.tangent);a.skinning&&(0<=r.skinIndex&&
0<=r.skinWeight)&&(k.enableVertexAttribArray(r.skinIndex),k.enableVertexAttribArray(r.skinWeight));if(a.attributes)for(j in a.attributes)void 0!==r[j]&&0<=r[j]&&k.enableVertexAttribArray(r[j]);if(a.morphTargets){a.numSupportedMorphTargets=0;v="morphTarget";for(j=0;j<this.maxMorphTargets;j++)y=v+j,0<=r[y]&&(k.enableVertexAttribArray(r[y]),a.numSupportedMorphTargets++)}if(a.morphNormals){a.numSupportedMorphNormals=0;v="morphNormal";for(j=0;j<this.maxMorphNormals;j++)y=v+j,0<=r[y]&&(k.enableVertexAttribArray(r[y]),
a.numSupportedMorphNormals++)}a.uniformsList=[];for(i in a.uniforms)a.uniformsList.push([a.uniforms[i],i])};this.setFaceCulling=function(a,b){a?(!b||"ccw"===b?k.frontFace(k.CCW):k.frontFace(k.CW),"back"===a?k.cullFace(k.BACK):"front"===a?k.cullFace(k.FRONT):k.cullFace(k.FRONT_AND_BACK),k.enable(k.CULL_FACE)):k.disable(k.CULL_FACE)};this.setMaterialFaces=function(a){var b=a.side===THREE.DoubleSide,a=a.side===THREE.BackSide;Ga!==b&&(b?k.disable(k.CULL_FACE):k.enable(k.CULL_FACE),Ga=b);Pa!==a&&(a?k.frontFace(k.CW):
k.frontFace(k.CCW),Pa=a)};this.setDepthTest=function(a){ib!==a&&(a?k.enable(k.DEPTH_TEST):k.disable(k.DEPTH_TEST),ib=a)};this.setDepthWrite=function(a){Ra!==a&&(k.depthMask(a),Ra=a)};this.setBlending=function(a,b,c,d){a!==Ia&&(a===THREE.NoBlending?k.disable(k.BLEND):a===THREE.AdditiveBlending?(k.enable(k.BLEND),k.blendEquation(k.FUNC_ADD),k.blendFunc(k.SRC_ALPHA,k.ONE)):a===THREE.SubtractiveBlending?(k.enable(k.BLEND),k.blendEquation(k.FUNC_ADD),k.blendFunc(k.ZERO,k.ONE_MINUS_SRC_COLOR)):a===THREE.MultiplyBlending?
(k.enable(k.BLEND),k.blendEquation(k.FUNC_ADD),k.blendFunc(k.ZERO,k.SRC_COLOR)):a===THREE.CustomBlending?k.enable(k.BLEND):(k.enable(k.BLEND),k.blendEquationSeparate(k.FUNC_ADD,k.FUNC_ADD),k.blendFuncSeparate(k.SRC_ALPHA,k.ONE_MINUS_SRC_ALPHA,k.ONE,k.ONE_MINUS_SRC_ALPHA)),Ia=a);if(a===THREE.CustomBlending){if(b!==Ua&&(k.blendEquation(E(b)),Ua=b),c!==na||d!==Va)k.blendFunc(E(c),E(d)),na=c,Va=d}else Va=na=Ua=null};this.setTexture=function(a,b){if(a.needsUpdate){a.__webglInit||(a.__webglInit=!0,a.__webglTexture=
k.createTexture(),Q.info.memory.textures++);k.activeTexture(k.TEXTURE0+b);k.bindTexture(k.TEXTURE_2D,a.__webglTexture);k.pixelStorei(k.UNPACK_FLIP_Y_WEBGL,a.flipY);k.pixelStorei(k.UNPACK_PREMULTIPLY_ALPHA_WEBGL,a.premultiplyAlpha);var c=a.image,d=0===(c.width&c.width-1)&&0===(c.height&c.height-1),e=E(a.format),f=E(a.type);G(k.TEXTURE_2D,a,d);if(a instanceof THREE.CompressedTexture)for(var f=a.mipmaps,g=0,h=f.length;g<h;g++)c=f[g],k.compressedTexImage2D(k.TEXTURE_2D,g,e,c.width,c.height,0,c.data);
else a instanceof THREE.DataTexture?k.texImage2D(k.TEXTURE_2D,0,e,c.width,c.height,0,e,f,c.data):k.texImage2D(k.TEXTURE_2D,0,e,e,f,a.image);a.generateMipmaps&&d&&k.generateMipmap(k.TEXTURE_2D);a.needsUpdate=!1;if(a.onUpdate)a.onUpdate()}else k.activeTexture(k.TEXTURE0+b),k.bindTexture(k.TEXTURE_2D,a.__webglTexture)};this.setRenderTarget=function(a){var b=a instanceof THREE.WebGLRenderTargetCube;if(a&&!a.__webglFramebuffer){void 0===a.depthBuffer&&(a.depthBuffer=!0);void 0===a.stencilBuffer&&(a.stencilBuffer=
!0);a.__webglTexture=k.createTexture();var c=0===(a.width&a.width-1)&&0===(a.height&a.height-1),d=E(a.format),e=E(a.type);if(b){a.__webglFramebuffer=[];a.__webglRenderbuffer=[];k.bindTexture(k.TEXTURE_CUBE_MAP,a.__webglTexture);G(k.TEXTURE_CUBE_MAP,a,c);for(var f=0;6>f;f++){a.__webglFramebuffer[f]=k.createFramebuffer();a.__webglRenderbuffer[f]=k.createRenderbuffer();k.texImage2D(k.TEXTURE_CUBE_MAP_POSITIVE_X+f,0,d,a.width,a.height,0,d,e,null);var g=a,h=k.TEXTURE_CUBE_MAP_POSITIVE_X+f;k.bindFramebuffer(k.FRAMEBUFFER,
a.__webglFramebuffer[f]);k.framebufferTexture2D(k.FRAMEBUFFER,k.COLOR_ATTACHMENT0,h,g.__webglTexture,0);H(a.__webglRenderbuffer[f],a)}c&&k.generateMipmap(k.TEXTURE_CUBE_MAP)}else a.__webglFramebuffer=k.createFramebuffer(),a.__webglRenderbuffer=k.createRenderbuffer(),k.bindTexture(k.TEXTURE_2D,a.__webglTexture),G(k.TEXTURE_2D,a,c),k.texImage2D(k.TEXTURE_2D,0,d,a.width,a.height,0,d,e,null),d=k.TEXTURE_2D,k.bindFramebuffer(k.FRAMEBUFFER,a.__webglFramebuffer),k.framebufferTexture2D(k.FRAMEBUFFER,k.COLOR_ATTACHMENT0,
d,a.__webglTexture,0),H(a.__webglRenderbuffer,a),c&&k.generateMipmap(k.TEXTURE_2D);b?k.bindTexture(k.TEXTURE_CUBE_MAP,null):k.bindTexture(k.TEXTURE_2D,null);k.bindRenderbuffer(k.RENDERBUFFER,null);k.bindFramebuffer(k.FRAMEBUFFER,null)}a?(b=b?a.__webglFramebuffer[a.activeCubeFace]:a.__webglFramebuffer,c=a.width,a=a.height,e=d=0):(b=null,c=wa,a=wb,d=$a,e=Ja);b!==fa&&(k.bindFramebuffer(k.FRAMEBUFFER,b),k.viewport(d,e,c,a),fa=b);Da=c;qb=a};this.shadowMapPlugin=new THREE.ShadowMapPlugin;this.addPrePlugin(this.shadowMapPlugin);
this.addPostPlugin(new THREE.SpritePlugin);this.addPostPlugin(new THREE.LensFlarePlugin)};
THREE.WebGLRenderTarget=function(a,b,c){this.width=a;this.height=b;c=c||{};this.wrapS=void 0!==c.wrapS?c.wrapS:THREE.ClampToEdgeWrapping;this.wrapT=void 0!==c.wrapT?c.wrapT:THREE.ClampToEdgeWrapping;this.magFilter=void 0!==c.magFilter?c.magFilter:THREE.LinearFilter;this.minFilter=void 0!==c.minFilter?c.minFilter:THREE.LinearMipMapLinearFilter;this.anisotropy=void 0!==c.anisotropy?c.anisotropy:1;this.offset=new THREE.Vector2(0,0);this.repeat=new THREE.Vector2(1,1);this.format=void 0!==c.format?c.format:
THREE.RGBAFormat;this.type=void 0!==c.type?c.type:THREE.UnsignedByteType;this.depthBuffer=void 0!==c.depthBuffer?c.depthBuffer:!0;this.stencilBuffer=void 0!==c.stencilBuffer?c.stencilBuffer:!0;this.generateMipmaps=!0};
THREE.WebGLRenderTarget.prototype.clone=function(){var a=new THREE.WebGLRenderTarget(this.width,this.height);a.wrapS=this.wrapS;a.wrapT=this.wrapT;a.magFilter=this.magFilter;a.anisotropy=this.anisotropy;a.minFilter=this.minFilter;a.offset.copy(this.offset);a.repeat.copy(this.repeat);a.format=this.format;a.type=this.type;a.depthBuffer=this.depthBuffer;a.stencilBuffer=this.stencilBuffer;a.generateMipmaps=this.generateMipmaps;return a};
THREE.WebGLRenderTargetCube=function(a,b,c){THREE.WebGLRenderTarget.call(this,a,b,c);this.activeCubeFace=0};THREE.WebGLRenderTargetCube.prototype=Object.create(THREE.WebGLRenderTarget.prototype);THREE.RenderableVertex=function(){this.positionWorld=new THREE.Vector3;this.positionScreen=new THREE.Vector4;this.visible=!0};THREE.RenderableVertex.prototype.copy=function(a){this.positionWorld.copy(a.positionWorld);this.positionScreen.copy(a.positionScreen)};
THREE.RenderableFace3=function(){this.v1=new THREE.RenderableVertex;this.v2=new THREE.RenderableVertex;this.v3=new THREE.RenderableVertex;this.centroidWorld=new THREE.Vector3;this.centroidScreen=new THREE.Vector3;this.normalWorld=new THREE.Vector3;this.vertexNormalsWorld=[new THREE.Vector3,new THREE.Vector3,new THREE.Vector3];this.vertexNormalsLength=0;this.material=this.color=null;this.uvs=[[]];this.z=null};
THREE.RenderableFace4=function(){this.v1=new THREE.RenderableVertex;this.v2=new THREE.RenderableVertex;this.v3=new THREE.RenderableVertex;this.v4=new THREE.RenderableVertex;this.centroidWorld=new THREE.Vector3;this.centroidScreen=new THREE.Vector3;this.normalWorld=new THREE.Vector3;this.vertexNormalsWorld=[new THREE.Vector3,new THREE.Vector3,new THREE.Vector3,new THREE.Vector3];this.vertexNormalsLength=0;this.material=this.color=null;this.uvs=[[]];this.z=null};
THREE.RenderableObject=function(){this.z=this.object=null};THREE.RenderableParticle=function(){this.rotation=this.z=this.y=this.x=this.object=null;this.scale=new THREE.Vector2;this.material=null};THREE.RenderableLine=function(){this.z=null;this.v1=new THREE.RenderableVertex;this.v2=new THREE.RenderableVertex;this.material=null};
THREE.ColorUtils={adjustHSV:function(a,b,c,d){var e=THREE.ColorUtils.__hsv;THREE.ColorUtils.rgbToHsv(a,e);e.h=THREE.Math.clamp(e.h+b,0,1);e.s=THREE.Math.clamp(e.s+c,0,1);e.v=THREE.Math.clamp(e.v+d,0,1);a.setHSV(e.h,e.s,e.v)},rgbToHsv:function(a,b){var c=a.r,d=a.g,e=a.b,f=Math.max(Math.max(c,d),e),g=Math.min(Math.min(c,d),e);if(g===f)g=c=0;else{var h=f-g,g=h/f,c=(c===f?(d-e)/h:d===f?2+(e-c)/h:4+(c-d)/h)/6;0>c&&(c+=1);1<c&&(c-=1)}void 0===b&&(b={h:0,s:0,v:0});b.h=c;b.s=g;b.v=f;return b}};
THREE.ColorUtils.__hsv={h:0,s:0,v:0};
THREE.GeometryUtils={merge:function(a,b){for(var c,d,e=a.vertices.length,f=b instanceof THREE.Mesh?b.geometry:b,g=a.vertices,h=f.vertices,i=a.faces,j=f.faces,l=a.faceVertexUvs[0],m=f.faceVertexUvs[0],n={},p=0;p<a.materials.length;p++)n[a.materials[p].id]=p;b instanceof THREE.Mesh&&(b.matrixAutoUpdate&&b.updateMatrix(),c=b.matrix,d=new THREE.Matrix4,d.extractRotation(c,b.scale));for(var p=0,o=h.length;p<o;p++){var q=h[p].clone();c&&c.multiplyVector3(q);g.push(q)}p=0;for(o=j.length;p<o;p++){var g=j[p],
r,t,B=g.vertexNormals,u=g.vertexColors;g instanceof THREE.Face3?r=new THREE.Face3(g.a+e,g.b+e,g.c+e):g instanceof THREE.Face4&&(r=new THREE.Face4(g.a+e,g.b+e,g.c+e,g.d+e));r.normal.copy(g.normal);d&&d.multiplyVector3(r.normal);h=0;for(q=B.length;h<q;h++)t=B[h].clone(),d&&d.multiplyVector3(t),r.vertexNormals.push(t);r.color.copy(g.color);h=0;for(q=u.length;h<q;h++)t=u[h],r.vertexColors.push(t.clone());void 0!==g.materialIndex&&(h=f.materials[g.materialIndex],q=h.id,u=n[q],void 0===u&&(u=a.materials.length,
n[q]=u,a.materials.push(h)),r.materialIndex=u);r.centroid.copy(g.centroid);c&&c.multiplyVector3(r.centroid);i.push(r)}p=0;for(o=m.length;p<o;p++){c=m[p];d=[];h=0;for(q=c.length;h<q;h++)d.push(new THREE.UV(c[h].u,c[h].v));l.push(d)}},clone:function(a){var b=new THREE.Geometry,c,d=a.vertices,e=a.faces,f=a.faceVertexUvs[0];a.materials&&(b.materials=a.materials.slice());a=0;for(c=d.length;a<c;a++)b.vertices.push(d[a].clone());a=0;for(c=e.length;a<c;a++)b.faces.push(e[a].clone());a=0;for(c=f.length;a<
c;a++){for(var d=f[a],e=[],g=0,h=d.length;g<h;g++)e.push(new THREE.UV(d[g].u,d[g].v));b.faceVertexUvs[0].push(e)}return b},randomPointInTriangle:function(a,b,c){var d,e,f,g=new THREE.Vector3,h=THREE.GeometryUtils.__v1;d=THREE.GeometryUtils.random();e=THREE.GeometryUtils.random();1<d+e&&(d=1-d,e=1-e);f=1-d-e;g.copy(a);g.multiplyScalar(d);h.copy(b);h.multiplyScalar(e);g.addSelf(h);h.copy(c);h.multiplyScalar(f);g.addSelf(h);return g},randomPointInFace:function(a,b,c){var d,e,f;if(a instanceof THREE.Face3)return d=
b.vertices[a.a],e=b.vertices[a.b],f=b.vertices[a.c],THREE.GeometryUtils.randomPointInTriangle(d,e,f);if(a instanceof THREE.Face4){d=b.vertices[a.a];e=b.vertices[a.b];f=b.vertices[a.c];var b=b.vertices[a.d],g;c?a._area1&&a._area2?(c=a._area1,g=a._area2):(c=THREE.GeometryUtils.triangleArea(d,e,b),g=THREE.GeometryUtils.triangleArea(e,f,b),a._area1=c,a._area2=g):(c=THREE.GeometryUtils.triangleArea(d,e,b),g=THREE.GeometryUtils.triangleArea(e,f,b));return THREE.GeometryUtils.random()*(c+g)<c?THREE.GeometryUtils.randomPointInTriangle(d,
e,b):THREE.GeometryUtils.randomPointInTriangle(e,f,b)}},randomPointsInGeometry:function(a,b){function c(a){function b(c,d){if(d<c)return c;var e=c+Math.floor((d-c)/2);return j[e]>a?b(c,e-1):j[e]<a?b(e+1,d):e}return b(0,j.length-1)}var d,e,f=a.faces,g=a.vertices,h=f.length,i=0,j=[],l,m,n,p;for(e=0;e<h;e++)d=f[e],d instanceof THREE.Face3?(l=g[d.a],m=g[d.b],n=g[d.c],d._area=THREE.GeometryUtils.triangleArea(l,m,n)):d instanceof THREE.Face4&&(l=g[d.a],m=g[d.b],n=g[d.c],p=g[d.d],d._area1=THREE.GeometryUtils.triangleArea(l,
m,p),d._area2=THREE.GeometryUtils.triangleArea(m,n,p),d._area=d._area1+d._area2),i+=d._area,j[e]=i;d=[];for(e=0;e<b;e++)g=THREE.GeometryUtils.random()*i,g=c(g),d[e]=THREE.GeometryUtils.randomPointInFace(f[g],a,!0);return d},triangleArea:function(a,b,c){var d,e=THREE.GeometryUtils.__v1;e.sub(a,b);d=e.length();e.sub(a,c);a=e.length();e.sub(b,c);c=e.length();b=0.5*(d+a+c);return Math.sqrt(b*(b-d)*(b-a)*(b-c))},center:function(a){a.computeBoundingBox();var b=a.boundingBox,c=new THREE.Vector3;c.add(b.min,
b.max);c.multiplyScalar(-0.5);a.applyMatrix((new THREE.Matrix4).makeTranslation(c.x,c.y,c.z));a.computeBoundingBox();return c},normalizeUVs:function(a){for(var a=a.faceVertexUvs[0],b=0,c=a.length;b<c;b++)for(var d=a[b],e=0,f=d.length;e<f;e++)if(1!==d[e].u&&(d[e].u-=Math.floor(d[e].u)),1!==d[e].v)d[e].v-=Math.floor(d[e].v)},triangulateQuads:function(a){var b,c,d,e,f=[],g=[],h=[];b=0;for(c=a.faceUvs.length;b<c;b++)g[b]=[];b=0;for(c=a.faceVertexUvs.length;b<c;b++)h[b]=[];b=0;for(c=a.faces.length;b<c;b++)if(d=
a.faces[b],d instanceof THREE.Face4){e=d.a;var i=d.b,j=d.c,l=d.d,m=new THREE.Face3,n=new THREE.Face3;m.color.copy(d.color);n.color.copy(d.color);m.materialIndex=d.materialIndex;n.materialIndex=d.materialIndex;m.a=e;m.b=i;m.c=l;n.a=i;n.b=j;n.c=l;4===d.vertexColors.length&&(m.vertexColors[0]=d.vertexColors[0].clone(),m.vertexColors[1]=d.vertexColors[1].clone(),m.vertexColors[2]=d.vertexColors[3].clone(),n.vertexColors[0]=d.vertexColors[1].clone(),n.vertexColors[1]=d.vertexColors[2].clone(),n.vertexColors[2]=
d.vertexColors[3].clone());f.push(m,n);d=0;for(e=a.faceVertexUvs.length;d<e;d++)a.faceVertexUvs[d].length&&(m=a.faceVertexUvs[d][b],i=m[1],j=m[2],l=m[3],m=[m[0].clone(),i.clone(),l.clone()],i=[i.clone(),j.clone(),l.clone()],h[d].push(m,i));d=0;for(e=a.faceUvs.length;d<e;d++)a.faceUvs[d].length&&(i=a.faceUvs[d][b],g[d].push(i,i))}else{f.push(d);d=0;for(e=a.faceUvs.length;d<e;d++)g[d].push(a.faceUvs[d][b]);d=0;for(e=a.faceVertexUvs.length;d<e;d++)h[d].push(a.faceVertexUvs[d][b])}a.faces=f;a.faceUvs=
g;a.faceVertexUvs=h;a.computeCentroids();a.computeFaceNormals();a.computeVertexNormals();a.hasTangents&&a.computeTangents()},explode:function(a){for(var b=[],c=0,d=a.faces.length;c<d;c++){var e=b.length,f=a.faces[c];if(f instanceof THREE.Face4){var g=f.a,h=f.b,i=f.c,g=a.vertices[g],h=a.vertices[h],i=a.vertices[i],j=a.vertices[f.d];b.push(g.clone());b.push(h.clone());b.push(i.clone());b.push(j.clone());f.a=e;f.b=e+1;f.c=e+2;f.d=e+3}else g=f.a,h=f.b,i=f.c,g=a.vertices[g],h=a.vertices[h],i=a.vertices[i],
b.push(g.clone()),b.push(h.clone()),b.push(i.clone()),f.a=e,f.b=e+1,f.c=e+2}a.vertices=b;delete a.__tmpVertices},tessellate:function(a,b){var c,d,e,f,g,h,i,j,l,m,n,p,o,q,r,t,B,u,s,z=[],A=[];c=0;for(d=a.faceVertexUvs.length;c<d;c++)A[c]=[];c=0;for(d=a.faces.length;c<d;c++)if(e=a.faces[c],e instanceof THREE.Face3)if(f=e.a,g=e.b,h=e.c,j=a.vertices[f],l=a.vertices[g],m=a.vertices[h],p=j.distanceTo(l),o=l.distanceTo(m),n=j.distanceTo(m),p>b||o>b||n>b){i=a.vertices.length;u=e.clone();s=e.clone();p>=o&&
p>=n?(j=j.clone(),j.lerpSelf(l,0.5),u.a=f,u.b=i,u.c=h,s.a=i,s.b=g,s.c=h,3===e.vertexNormals.length&&(f=e.vertexNormals[0].clone(),f.lerpSelf(e.vertexNormals[1],0.5),u.vertexNormals[1].copy(f),s.vertexNormals[0].copy(f)),3===e.vertexColors.length&&(f=e.vertexColors[0].clone(),f.lerpSelf(e.vertexColors[1],0.5),u.vertexColors[1].copy(f),s.vertexColors[0].copy(f)),e=0):o>=p&&o>=n?(j=l.clone(),j.lerpSelf(m,0.5),u.a=f,u.b=g,u.c=i,s.a=i,s.b=h,s.c=f,3===e.vertexNormals.length&&(f=e.vertexNormals[1].clone(),
f.lerpSelf(e.vertexNormals[2],0.5),u.vertexNormals[2].copy(f),s.vertexNormals[0].copy(f),s.vertexNormals[1].copy(e.vertexNormals[2]),s.vertexNormals[2].copy(e.vertexNormals[0])),3===e.vertexColors.length&&(f=e.vertexColors[1].clone(),f.lerpSelf(e.vertexColors[2],0.5),u.vertexColors[2].copy(f),s.vertexColors[0].copy(f),s.vertexColors[1].copy(e.vertexColors[2]),s.vertexColors[2].copy(e.vertexColors[0])),e=1):(j=j.clone(),j.lerpSelf(m,0.5),u.a=f,u.b=g,u.c=i,s.a=i,s.b=g,s.c=h,3===e.vertexNormals.length&&
(f=e.vertexNormals[0].clone(),f.lerpSelf(e.vertexNormals[2],0.5),u.vertexNormals[2].copy(f),s.vertexNormals[0].copy(f)),3===e.vertexColors.length&&(f=e.vertexColors[0].clone(),f.lerpSelf(e.vertexColors[2],0.5),u.vertexColors[2].copy(f),s.vertexColors[0].copy(f)),e=2);z.push(u,s);a.vertices.push(j);f=0;for(g=a.faceVertexUvs.length;f<g;f++)a.faceVertexUvs[f].length&&(j=a.faceVertexUvs[f][c],s=j[0],h=j[1],u=j[2],0===e?(l=s.clone(),l.lerpSelf(h,0.5),j=[s.clone(),l.clone(),u.clone()],h=[l.clone(),h.clone(),
u.clone()]):1===e?(l=h.clone(),l.lerpSelf(u,0.5),j=[s.clone(),h.clone(),l.clone()],h=[l.clone(),u.clone(),s.clone()]):(l=s.clone(),l.lerpSelf(u,0.5),j=[s.clone(),h.clone(),l.clone()],h=[l.clone(),h.clone(),u.clone()]),A[f].push(j,h))}else{z.push(e);f=0;for(g=a.faceVertexUvs.length;f<g;f++)A[f].push(a.faceVertexUvs[f][c])}else if(f=e.a,g=e.b,h=e.c,i=e.d,j=a.vertices[f],l=a.vertices[g],m=a.vertices[h],n=a.vertices[i],p=j.distanceTo(l),o=l.distanceTo(m),q=m.distanceTo(n),r=j.distanceTo(n),p>b||o>b||
q>b||r>b){t=a.vertices.length;B=a.vertices.length+1;u=e.clone();s=e.clone();p>=o&&p>=q&&p>=r||q>=o&&q>=p&&q>=r?(p=j.clone(),p.lerpSelf(l,0.5),l=m.clone(),l.lerpSelf(n,0.5),u.a=f,u.b=t,u.c=B,u.d=i,s.a=t,s.b=g,s.c=h,s.d=B,4===e.vertexNormals.length&&(f=e.vertexNormals[0].clone(),f.lerpSelf(e.vertexNormals[1],0.5),g=e.vertexNormals[2].clone(),g.lerpSelf(e.vertexNormals[3],0.5),u.vertexNormals[1].copy(f),u.vertexNormals[2].copy(g),s.vertexNormals[0].copy(f),s.vertexNormals[3].copy(g)),4===e.vertexColors.length&&
(f=e.vertexColors[0].clone(),f.lerpSelf(e.vertexColors[1],0.5),g=e.vertexColors[2].clone(),g.lerpSelf(e.vertexColors[3],0.5),u.vertexColors[1].copy(f),u.vertexColors[2].copy(g),s.vertexColors[0].copy(f),s.vertexColors[3].copy(g)),e=0):(p=l.clone(),p.lerpSelf(m,0.5),l=n.clone(),l.lerpSelf(j,0.5),u.a=f,u.b=g,u.c=t,u.d=B,s.a=B,s.b=t,s.c=h,s.d=i,4===e.vertexNormals.length&&(f=e.vertexNormals[1].clone(),f.lerpSelf(e.vertexNormals[2],0.5),g=e.vertexNormals[3].clone(),g.lerpSelf(e.vertexNormals[0],0.5),
u.vertexNormals[2].copy(f),u.vertexNormals[3].copy(g),s.vertexNormals[0].copy(g),s.vertexNormals[1].copy(f)),4===e.vertexColors.length&&(f=e.vertexColors[1].clone(),f.lerpSelf(e.vertexColors[2],0.5),g=e.vertexColors[3].clone(),g.lerpSelf(e.vertexColors[0],0.5),u.vertexColors[2].copy(f),u.vertexColors[3].copy(g),s.vertexColors[0].copy(g),s.vertexColors[1].copy(f)),e=1);z.push(u,s);a.vertices.push(p,l);f=0;for(g=a.faceVertexUvs.length;f<g;f++)a.faceVertexUvs[f].length&&(j=a.faceVertexUvs[f][c],s=j[0],
h=j[1],u=j[2],j=j[3],0===e?(l=s.clone(),l.lerpSelf(h,0.5),m=u.clone(),m.lerpSelf(j,0.5),s=[s.clone(),l.clone(),m.clone(),j.clone()],h=[l.clone(),h.clone(),u.clone(),m.clone()]):(l=h.clone(),l.lerpSelf(u,0.5),m=j.clone(),m.lerpSelf(s,0.5),s=[s.clone(),h.clone(),l.clone(),m.clone()],h=[m.clone(),l.clone(),u.clone(),j.clone()]),A[f].push(s,h))}else{z.push(e);f=0;for(g=a.faceVertexUvs.length;f<g;f++)A[f].push(a.faceVertexUvs[f][c])}a.faces=z;a.faceVertexUvs=A}};THREE.GeometryUtils.random=THREE.Math.random16;
THREE.GeometryUtils.__v1=new THREE.Vector3;
THREE.ImageUtils={crossOrigin:"anonymous",loadTexture:function(a,b,c,d){var e=new Image,f=new THREE.Texture(e,b),b=new THREE.ImageLoader;b.addEventListener("load",function(a){f.image=a.content;f.needsUpdate=!0;c&&c(f)});b.addEventListener("error",function(a){d&&d(a.message)});b.crossOrigin=this.crossOrigin;b.load(a,e);return f},loadCompressedTexture:function(a,b,c,d){var e=new THREE.CompressedTexture;e.mapping=b;var f=new XMLHttpRequest;f.onload=function(){var a=THREE.ImageUtils.parseDDS(f.response,
!0);e.format=a.format;e.mipmaps=a.mipmaps;e.image.width=a.width;e.image.height=a.height;e.generateMipmaps=!1;e.needsUpdate=!0;c&&c(e)};f.onerror=d;f.open("GET",a,!0);f.responseType="arraybuffer";f.send(null);return e},loadTextureCube:function(a,b,c,d){var e=[];e.loadCount=0;var f=new THREE.Texture;f.image=e;void 0!==b&&(f.mapping=b);f.flipY=!1;for(var b=0,g=a.length;b<g;++b){var h=new Image;e[b]=h;h.onload=function(){e.loadCount=e.loadCount+1;if(e.loadCount===6){f.needsUpdate=true;c&&c()}};h.onerror=
d;h.crossOrigin=this.crossOrigin;h.src=a[b]}return f},loadCompressedTextureCube:function(a,b,c,d){var e=[];e.loadCount=0;var f=new THREE.CompressedTexture;f.image=e;void 0!==b&&(f.mapping=b);f.flipY=!1;f.generateMipmaps=!1;for(var b=function(a,b){return function(){var d=THREE.ImageUtils.parseDDS(a.response,true);b.format=d.format;b.mipmaps=d.mipmaps;b.width=d.width;b.height=d.height;e.loadCount=e.loadCount+1;if(e.loadCount===6){f.format=d.format;f.needsUpdate=true;c&&c()}}},g=0,h=a.length;g<h;++g){var i=
{};e[g]=i;var j=new XMLHttpRequest;j.onload=b(j,i);j.onerror=d;j.open("GET",a[g],!0);j.responseType="arraybuffer";j.send(null)}return f},parseDDS:function(a,b){function c(a){return a.charCodeAt(0)+(a.charCodeAt(1)<<8)+(a.charCodeAt(2)<<16)+(a.charCodeAt(3)<<24)}var d={mipmaps:[],width:0,height:0,format:null,mipmapCount:1},e=c("DXT1"),f=c("DXT3"),g=c("DXT5"),h=new Int32Array(a,0,31);if(542327876!==h[0])return console.error("ImageUtils.parseDDS(): Invalid magic number in DDS header"),d;if(!h[20]&4)return console.error("ImageUtils.parseDDS(): Unsupported format, must contain a FourCC code"),
d;var i=h[21];switch(i){case e:e=8;d.format=THREE.RGB_S3TC_DXT1_Format;break;case f:e=16;d.format=THREE.RGBA_S3TC_DXT3_Format;break;case g:e=16;d.format=THREE.RGBA_S3TC_DXT5_Format;break;default:return console.error("ImageUtils.parseDDS(): Unsupported FourCC code: ",String.fromCharCode(i&255,i>>8&255,i>>16&255,i>>24&255)),d}d.mipmapCount=1;h[2]&131072&&!1!==b&&(d.mipmapCount=Math.max(1,h[7]));d.width=h[4];d.height=h[3];h=h[1]+4;f=d.width;g=d.height;for(i=0;i<d.mipmapCount;i++){var j=Math.max(4,f)/
4*Math.max(4,g)/4*e,l={data:new Uint8Array(a,h,j),width:f,height:g};d.mipmaps.push(l);h+=j;f=Math.max(0.5*f,1);g=Math.max(0.5*g,1)}return d},getNormalMap:function(a,b){var c=function(a){var b=Math.sqrt(a[0]*a[0]+a[1]*a[1]+a[2]*a[2]);return[a[0]/b,a[1]/b,a[2]/b]},b=b|1,d=a.width,e=a.height,f=document.createElement("canvas");f.width=d;f.height=e;var g=f.getContext("2d");g.drawImage(a,0,0);for(var h=g.getImageData(0,0,d,e).data,i=g.createImageData(d,e),j=i.data,l=0;l<d;l++)for(var m=0;m<e;m++){var n=
0>m-1?0:m-1,p=m+1>e-1?e-1:m+1,o=0>l-1?0:l-1,q=l+1>d-1?d-1:l+1,r=[],t=[0,0,h[4*(m*d+l)]/255*b];r.push([-1,0,h[4*(m*d+o)]/255*b]);r.push([-1,-1,h[4*(n*d+o)]/255*b]);r.push([0,-1,h[4*(n*d+l)]/255*b]);r.push([1,-1,h[4*(n*d+q)]/255*b]);r.push([1,0,h[4*(m*d+q)]/255*b]);r.push([1,1,h[4*(p*d+q)]/255*b]);r.push([0,1,h[4*(p*d+l)]/255*b]);r.push([-1,1,h[4*(p*d+o)]/255*b]);n=[];o=r.length;for(p=0;p<o;p++){var q=r[p],B=r[(p+1)%o],q=[q[0]-t[0],q[1]-t[1],q[2]-t[2]],B=[B[0]-t[0],B[1]-t[1],B[2]-t[2]];n.push(c([q[1]*
B[2]-q[2]*B[1],q[2]*B[0]-q[0]*B[2],q[0]*B[1]-q[1]*B[0]]))}r=[0,0,0];for(p=0;p<n.length;p++)r[0]+=n[p][0],r[1]+=n[p][1],r[2]+=n[p][2];r[0]/=n.length;r[1]/=n.length;r[2]/=n.length;t=4*(m*d+l);j[t]=255*((r[0]+1)/2)|0;j[t+1]=255*((r[1]+1)/2)|0;j[t+2]=255*r[2]|0;j[t+3]=255}g.putImageData(i,0,0);return f},generateDataTexture:function(a,b,c){for(var d=a*b,e=new Uint8Array(3*d),f=Math.floor(255*c.r),g=Math.floor(255*c.g),c=Math.floor(255*c.b),h=0;h<d;h++)e[3*h]=f,e[3*h+1]=g,e[3*h+2]=c;a=new THREE.DataTexture(e,
a,b,THREE.RGBFormat);a.needsUpdate=!0;return a}};THREE.SceneUtils={createMultiMaterialObject:function(a,b){for(var c=new THREE.Object3D,d=0,e=b.length;d<e;d++)c.add(new THREE.Mesh(a,b[d]));return c},detach:function(a,b,c){a.applyMatrix(b.matrixWorld);b.remove(a);c.add(a)},attach:function(a,b,c){var d=new THREE.Matrix4;d.getInverse(c.matrixWorld);a.applyMatrix(d);b.remove(a);c.add(a)}};
THREE.WebGLRenderer&&(THREE.ShaderUtils={lib:{fresnel:{uniforms:{mRefractionRatio:{type:"f",value:1.02},mFresnelBias:{type:"f",value:0.1},mFresnelPower:{type:"f",value:2},mFresnelScale:{type:"f",value:1},tCube:{type:"t",value:null}},fragmentShader:"uniform samplerCube tCube;\nvarying vec3 vReflect;\nvarying vec3 vRefract[3];\nvarying float vReflectionFactor;\nvoid main() {\nvec4 reflectedColor = textureCube( tCube, vec3( -vReflect.x, vReflect.yz ) );\nvec4 refractedColor = vec4( 1.0, 1.0, 1.0, 1.0 );\nrefractedColor.r = textureCube( tCube, vec3( -vRefract[0].x, vRefract[0].yz ) ).r;\nrefractedColor.g = textureCube( tCube, vec3( -vRefract[1].x, vRefract[1].yz ) ).g;\nrefractedColor.b = textureCube( tCube, vec3( -vRefract[2].x, vRefract[2].yz ) ).b;\nrefractedColor.a = 1.0;\ngl_FragColor = mix( refractedColor, reflectedColor, clamp( vReflectionFactor, 0.0, 1.0 ) );\n}",
vertexShader:"uniform float mRefractionRatio;\nuniform float mFresnelBias;\nuniform float mFresnelScale;\nuniform float mFresnelPower;\nvarying vec3 vReflect;\nvarying vec3 vRefract[3];\nvarying float vReflectionFactor;\nvoid main() {\nvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\nvec4 mPosition = modelMatrix * vec4( position, 1.0 );\nvec3 nWorld = normalize( mat3( modelMatrix[0].xyz, modelMatrix[1].xyz, modelMatrix[2].xyz ) * normal );\nvec3 I = mPosition.xyz - cameraPosition;\nvReflect = reflect( I, nWorld );\nvRefract[0] = refract( normalize( I ), nWorld, mRefractionRatio );\nvRefract[1] = refract( normalize( I ), nWorld, mRefractionRatio * 0.99 );\nvRefract[2] = refract( normalize( I ), nWorld, mRefractionRatio * 0.98 );\nvReflectionFactor = mFresnelBias + mFresnelScale * pow( 1.0 + dot( normalize( I ), nWorld ), mFresnelPower );\ngl_Position = projectionMatrix * mvPosition;\n}"},
normal:{uniforms:THREE.UniformsUtils.merge([THREE.UniformsLib.fog,THREE.UniformsLib.lights,THREE.UniformsLib.shadowmap,{enableAO:{type:"i",value:0},enableDiffuse:{type:"i",value:0},enableSpecular:{type:"i",value:0},enableReflection:{type:"i",value:0},enableDisplacement:{type:"i",value:0},tDisplacement:{type:"t",value:null},tDiffuse:{type:"t",value:null},tCube:{type:"t",value:null},tNormal:{type:"t",value:null},tSpecular:{type:"t",value:null},tAO:{type:"t",value:null},uNormalScale:{type:"v2",value:new THREE.Vector2(1,
1)},uDisplacementBias:{type:"f",value:0},uDisplacementScale:{type:"f",value:1},uDiffuseColor:{type:"c",value:new THREE.Color(16777215)},uSpecularColor:{type:"c",value:new THREE.Color(1118481)},uAmbientColor:{type:"c",value:new THREE.Color(16777215)},uShininess:{type:"f",value:30},uOpacity:{type:"f",value:1},useRefract:{type:"i",value:0},uRefractionRatio:{type:"f",value:0.98},uReflectivity:{type:"f",value:0.5},uOffset:{type:"v2",value:new THREE.Vector2(0,0)},uRepeat:{type:"v2",value:new THREE.Vector2(1,
1)},wrapRGB:{type:"v3",value:new THREE.Vector3(1,1,1)}}]),fragmentShader:["uniform vec3 uAmbientColor;\nuniform vec3 uDiffuseColor;\nuniform vec3 uSpecularColor;\nuniform float uShininess;\nuniform float uOpacity;\nuniform bool enableDiffuse;\nuniform bool enableSpecular;\nuniform bool enableAO;\nuniform bool enableReflection;\nuniform sampler2D tDiffuse;\nuniform sampler2D tNormal;\nuniform sampler2D tSpecular;\nuniform sampler2D tAO;\nuniform samplerCube tCube;\nuniform vec2 uNormalScale;\nuniform bool useRefract;\nuniform float uRefractionRatio;\nuniform float uReflectivity;\nvarying vec3 vTangent;\nvarying vec3 vBinormal;\nvarying vec3 vNormal;\nvarying vec2 vUv;\nuniform vec3 ambientLightColor;\n#if MAX_DIR_LIGHTS > 0\nuniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\nuniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\n#endif\n#if MAX_HEMI_LIGHTS > 0\nuniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\nuniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\nuniform vec3 hemisphereLightPosition[ MAX_HEMI_LIGHTS ];\n#endif\n#if MAX_POINT_LIGHTS > 0\nuniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\nuniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\nuniform float pointLightDistance[ MAX_POINT_LIGHTS ];\n#endif\n#if MAX_SPOT_LIGHTS > 0\nuniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\nuniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\nuniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\nuniform float spotLightAngle[ MAX_SPOT_LIGHTS ];\nuniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\nuniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\n#endif\n#ifdef WRAP_AROUND\nuniform vec3 wrapRGB;\n#endif\nvarying vec3 vWorldPosition;\nvarying vec3 vViewPosition;",
THREE.ShaderChunk.shadowmap_pars_fragment,THREE.ShaderChunk.fog_pars_fragment,"void main() {\ngl_FragColor = vec4( vec3( 1.0 ), uOpacity );\nvec3 specularTex = vec3( 1.0 );\nvec3 normalTex = texture2D( tNormal, vUv ).xyz * 2.0 - 1.0;\nnormalTex.xy *= uNormalScale;\nnormalTex = normalize( normalTex );\nif( enableDiffuse ) {\n#ifdef GAMMA_INPUT\nvec4 texelColor = texture2D( tDiffuse, vUv );\ntexelColor.xyz *= texelColor.xyz;\ngl_FragColor = gl_FragColor * texelColor;\n#else\ngl_FragColor = gl_FragColor * texture2D( tDiffuse, vUv );\n#endif\n}\nif( enableAO ) {\n#ifdef GAMMA_INPUT\nvec4 aoColor = texture2D( tAO, vUv );\naoColor.xyz *= aoColor.xyz;\ngl_FragColor.xyz = gl_FragColor.xyz * aoColor.xyz;\n#else\ngl_FragColor.xyz = gl_FragColor.xyz * texture2D( tAO, vUv ).xyz;\n#endif\n}\nif( enableSpecular )\nspecularTex = texture2D( tSpecular, vUv ).xyz;\nmat3 tsb = mat3( normalize( vTangent ), normalize( vBinormal ), normalize( vNormal ) );\nvec3 finalNormal = tsb * normalTex;\n#ifdef FLIP_SIDED\nfinalNormal = -finalNormal;\n#endif\nvec3 normal = normalize( finalNormal );\nvec3 viewPosition = normalize( vViewPosition );\n#if MAX_POINT_LIGHTS > 0\nvec3 pointDiffuse = vec3( 0.0 );\nvec3 pointSpecular = vec3( 0.0 );\nfor ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\nvec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\nvec3 pointVector = lPosition.xyz + vViewPosition.xyz;\nfloat pointDistance = 1.0;\nif ( pointLightDistance[ i ] > 0.0 )\npointDistance = 1.0 - min( ( length( pointVector ) / pointLightDistance[ i ] ), 1.0 );\npointVector = normalize( pointVector );\n#ifdef WRAP_AROUND\nfloat pointDiffuseWeightFull = max( dot( normal, pointVector ), 0.0 );\nfloat pointDiffuseWeightHalf = max( 0.5 * dot( normal, pointVector ) + 0.5, 0.0 );\nvec3 pointDiffuseWeight = mix( vec3 ( pointDiffuseWeightFull ), vec3( pointDiffuseWeightHalf ), wrapRGB );\n#else\nfloat pointDiffuseWeight = max( dot( normal, pointVector ), 0.0 );\n#endif\npointDiffuse += pointDistance * pointLightColor[ i ] * uDiffuseColor * pointDiffuseWeight;\nvec3 pointHalfVector = normalize( pointVector + viewPosition );\nfloat pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );\nfloat pointSpecularWeight = specularTex.r * max( pow( pointDotNormalHalf, uShininess ), 0.0 );\n#ifdef PHYSICALLY_BASED_SHADING\nfloat specularNormalization = ( uShininess + 2.0001 ) / 8.0;\nvec3 schlick = uSpecularColor + vec3( 1.0 - uSpecularColor ) * pow( 1.0 - dot( pointVector, pointHalfVector ), 5.0 );\npointSpecular += schlick * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * pointDistance * specularNormalization;\n#else\npointSpecular += pointDistance * pointLightColor[ i ] * uSpecularColor * pointSpecularWeight * pointDiffuseWeight;\n#endif\n}\n#endif\n#if MAX_SPOT_LIGHTS > 0\nvec3 spotDiffuse = vec3( 0.0 );\nvec3 spotSpecular = vec3( 0.0 );\nfor ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\nvec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\nvec3 spotVector = lPosition.xyz + vViewPosition.xyz;\nfloat spotDistance = 1.0;\nif ( spotLightDistance[ i ] > 0.0 )\nspotDistance = 1.0 - min( ( length( spotVector ) / spotLightDistance[ i ] ), 1.0 );\nspotVector = normalize( spotVector );\nfloat spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - vWorldPosition ) );\nif ( spotEffect > spotLightAngle[ i ] ) {\nspotEffect = pow( spotEffect, spotLightExponent[ i ] );\n#ifdef WRAP_AROUND\nfloat spotDiffuseWeightFull = max( dot( normal, spotVector ), 0.0 );\nfloat spotDiffuseWeightHalf = max( 0.5 * dot( normal, spotVector ) + 0.5, 0.0 );\nvec3 spotDiffuseWeight = mix( vec3 ( spotDiffuseWeightFull ), vec3( spotDiffuseWeightHalf ), wrapRGB );\n#else\nfloat spotDiffuseWeight = max( dot( normal, spotVector ), 0.0 );\n#endif\nspotDiffuse += spotDistance * spotLightColor[ i ] * uDiffuseColor * spotDiffuseWeight * spotEffect;\nvec3 spotHalfVector = normalize( spotVector + viewPosition );\nfloat spotDotNormalHalf = max( dot( normal, spotHalfVector ), 0.0 );\nfloat spotSpecularWeight = specularTex.r * max( pow( spotDotNormalHalf, uShininess ), 0.0 );\n#ifdef PHYSICALLY_BASED_SHADING\nfloat specularNormalization = ( uShininess + 2.0001 ) / 8.0;\nvec3 schlick = uSpecularColor + vec3( 1.0 - uSpecularColor ) * pow( 1.0 - dot( spotVector, spotHalfVector ), 5.0 );\nspotSpecular += schlick * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * spotDistance * specularNormalization * spotEffect;\n#else\nspotSpecular += spotDistance * spotLightColor[ i ] * uSpecularColor * spotSpecularWeight * spotDiffuseWeight * spotEffect;\n#endif\n}\n}\n#endif\n#if MAX_DIR_LIGHTS > 0\nvec3 dirDiffuse = vec3( 0.0 );\nvec3 dirSpecular = vec3( 0.0 );\nfor( int i = 0; i < MAX_DIR_LIGHTS; i++ ) {\nvec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );\nvec3 dirVector = normalize( lDirection.xyz );\n#ifdef WRAP_AROUND\nfloat directionalLightWeightingFull = max( dot( normal, dirVector ), 0.0 );\nfloat directionalLightWeightingHalf = max( 0.5 * dot( normal, dirVector ) + 0.5, 0.0 );\nvec3 dirDiffuseWeight = mix( vec3( directionalLightWeightingFull ), vec3( directionalLightWeightingHalf ), wrapRGB );\n#else\nfloat dirDiffuseWeight = max( dot( normal, dirVector ), 0.0 );\n#endif\ndirDiffuse += directionalLightColor[ i ] * uDiffuseColor * dirDiffuseWeight;\nvec3 dirHalfVector = normalize( dirVector + viewPosition );\nfloat dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );\nfloat dirSpecularWeight = specularTex.r * max( pow( dirDotNormalHalf, uShininess ), 0.0 );\n#ifdef PHYSICALLY_BASED_SHADING\nfloat specularNormalization = ( uShininess + 2.0001 ) / 8.0;\nvec3 schlick = uSpecularColor + vec3( 1.0 - uSpecularColor ) * pow( 1.0 - dot( dirVector, dirHalfVector ), 5.0 );\ndirSpecular += schlick * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization;\n#else\ndirSpecular += directionalLightColor[ i ] * uSpecularColor * dirSpecularWeight * dirDiffuseWeight;\n#endif\n}\n#endif\n#if MAX_HEMI_LIGHTS > 0\nvec3 hemiDiffuse  = vec3( 0.0 );\nvec3 hemiSpecular = vec3( 0.0 );\nfor( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\nvec4 lPosition = viewMatrix * vec4( hemisphereLightPosition[ i ], 1.0 );\nvec3 lVector = normalize( lPosition.xyz + vViewPosition.xyz );\nfloat dotProduct = dot( normal, lVector );\nfloat hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\nvec3 hemiColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\nhemiDiffuse += uDiffuseColor * hemiColor;\nvec3 hemiHalfVectorSky = normalize( lVector + viewPosition );\nfloat hemiDotNormalHalfSky = 0.5 * dot( normal, hemiHalfVectorSky ) + 0.5;\nfloat hemiSpecularWeightSky = specularTex.r * max( pow( hemiDotNormalHalfSky, uShininess ), 0.0 );\nvec3 lVectorGround = normalize( -lPosition.xyz + vViewPosition.xyz );\nvec3 hemiHalfVectorGround = normalize( lVectorGround + viewPosition );\nfloat hemiDotNormalHalfGround = 0.5 * dot( normal, hemiHalfVectorGround ) + 0.5;\nfloat hemiSpecularWeightGround = specularTex.r * max( pow( hemiDotNormalHalfGround, uShininess ), 0.0 );\n#ifdef PHYSICALLY_BASED_SHADING\nfloat dotProductGround = dot( normal, lVectorGround );\nfloat specularNormalization = ( uShininess + 2.0001 ) / 8.0;\nvec3 schlickSky = uSpecularColor + vec3( 1.0 - uSpecularColor ) * pow( 1.0 - dot( lVector, hemiHalfVectorSky ), 5.0 );\nvec3 schlickGround = uSpecularColor + vec3( 1.0 - uSpecularColor ) * pow( 1.0 - dot( lVectorGround, hemiHalfVectorGround ), 5.0 );\nhemiSpecular += hemiColor * specularNormalization * ( schlickSky * hemiSpecularWeightSky * max( dotProduct, 0.0 ) + schlickGround * hemiSpecularWeightGround * max( dotProductGround, 0.0 ) );\n#else\nhemiSpecular += uSpecularColor * hemiColor * ( hemiSpecularWeightSky + hemiSpecularWeightGround ) * hemiDiffuseWeight;\n#endif\n}\n#endif\nvec3 totalDiffuse = vec3( 0.0 );\nvec3 totalSpecular = vec3( 0.0 );\n#if MAX_DIR_LIGHTS > 0\ntotalDiffuse += dirDiffuse;\ntotalSpecular += dirSpecular;\n#endif\n#if MAX_HEMI_LIGHTS > 0\ntotalDiffuse += hemiDiffuse;\ntotalSpecular += hemiSpecular;\n#endif\n#if MAX_POINT_LIGHTS > 0\ntotalDiffuse += pointDiffuse;\ntotalSpecular += pointSpecular;\n#endif\n#if MAX_SPOT_LIGHTS > 0\ntotalDiffuse += spotDiffuse;\ntotalSpecular += spotSpecular;\n#endif\n#ifdef METAL\ngl_FragColor.xyz = gl_FragColor.xyz * ( totalDiffuse + ambientLightColor * uAmbientColor + totalSpecular );\n#else\ngl_FragColor.xyz = gl_FragColor.xyz * ( totalDiffuse + ambientLightColor * uAmbientColor ) + totalSpecular;\n#endif\nif ( enableReflection ) {\nvec3 vReflect;\nvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\nif ( useRefract ) {\nvReflect = refract( cameraToVertex, normal, uRefractionRatio );\n} else {\nvReflect = reflect( cameraToVertex, normal );\n}\nvec4 cubeColor = textureCube( tCube, vec3( -vReflect.x, vReflect.yz ) );\n#ifdef GAMMA_INPUT\ncubeColor.xyz *= cubeColor.xyz;\n#endif\ngl_FragColor.xyz = mix( gl_FragColor.xyz, cubeColor.xyz, specularTex.r * uReflectivity );\n}",
THREE.ShaderChunk.shadowmap_fragment,THREE.ShaderChunk.linear_to_gamma_fragment,THREE.ShaderChunk.fog_fragment,"}"].join("\n"),vertexShader:["attribute vec4 tangent;\nuniform vec2 uOffset;\nuniform vec2 uRepeat;\nuniform bool enableDisplacement;\n#ifdef VERTEX_TEXTURES\nuniform sampler2D tDisplacement;\nuniform float uDisplacementScale;\nuniform float uDisplacementBias;\n#endif\nvarying vec3 vTangent;\nvarying vec3 vBinormal;\nvarying vec3 vNormal;\nvarying vec2 vUv;\nvarying vec3 vWorldPosition;\nvarying vec3 vViewPosition;",
THREE.ShaderChunk.skinning_pars_vertex,THREE.ShaderChunk.shadowmap_pars_vertex,"void main() {",THREE.ShaderChunk.skinbase_vertex,THREE.ShaderChunk.skinnormal_vertex,"#ifdef USE_SKINNING\nvNormal = normalMatrix * skinnedNormal.xyz;\nvec4 skinnedTangent = skinMatrix * vec4( tangent.xyz, 0.0 );\nvTangent = normalMatrix * skinnedTangent.xyz;\n#else\nvNormal = normalMatrix * normal;\nvTangent = normalMatrix * tangent.xyz;\n#endif\nvBinormal = cross( vNormal, vTangent ) * tangent.w;\nvUv = uv * uRepeat + uOffset;\nvec3 displacedPosition;\n#ifdef VERTEX_TEXTURES\nif ( enableDisplacement ) {\nvec3 dv = texture2D( tDisplacement, uv ).xyz;\nfloat df = uDisplacementScale * dv.x + uDisplacementBias;\ndisplacedPosition = position + normalize( normal ) * df;\n} else {\n#ifdef USE_SKINNING\nvec4 skinVertex = vec4( position, 1.0 );\nvec4 skinned  = boneMatX * skinVertex * skinWeight.x;\nskinned \t  += boneMatY * skinVertex * skinWeight.y;\ndisplacedPosition  = skinned.xyz;\n#else\ndisplacedPosition = position;\n#endif\n}\n#else\n#ifdef USE_SKINNING\nvec4 skinVertex = vec4( position, 1.0 );\nvec4 skinned  = boneMatX * skinVertex * skinWeight.x;\nskinned \t  += boneMatY * skinVertex * skinWeight.y;\ndisplacedPosition  = skinned.xyz;\n#else\ndisplacedPosition = position;\n#endif\n#endif\nvec4 mvPosition = modelViewMatrix * vec4( displacedPosition, 1.0 );\nvec4 mPosition = modelMatrix * vec4( displacedPosition, 1.0 );\ngl_Position = projectionMatrix * mvPosition;\nvWorldPosition = mPosition.xyz;\nvViewPosition = -mvPosition.xyz;\n#ifdef USE_SHADOWMAP\nfor( int i = 0; i < MAX_SHADOWS; i ++ ) {\nvShadowCoord[ i ] = shadowMatrix[ i ] * mPosition;\n}\n#endif\n}"].join("\n")},
cube:{uniforms:{tCube:{type:"t",value:null},tFlip:{type:"f",value:-1}},vertexShader:"varying vec3 vViewPosition;\nvoid main() {\nvec4 mPosition = modelMatrix * vec4( position, 1.0 );\nvViewPosition = cameraPosition - mPosition.xyz;\ngl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",fragmentShader:"uniform samplerCube tCube;\nuniform float tFlip;\nvarying vec3 vViewPosition;\nvoid main() {\nvec3 wPos = cameraPosition - vViewPosition;\ngl_FragColor = textureCube( tCube, vec3( tFlip * wPos.x, wPos.yz ) );\n}"}}});
THREE.FontUtils={faces:{},face:"helvetiker",weight:"normal",style:"normal",size:150,divisions:10,getFace:function(){return this.faces[this.face][this.weight][this.style]},loadFace:function(a){var b=a.familyName.toLowerCase();this.faces[b]=this.faces[b]||{};this.faces[b][a.cssFontWeight]=this.faces[b][a.cssFontWeight]||{};this.faces[b][a.cssFontWeight][a.cssFontStyle]=a;return this.faces[b][a.cssFontWeight][a.cssFontStyle]=a},drawText:function(a){for(var b=this.getFace(),c=this.size/b.resolution,d=
0,e=String(a).split(""),f=e.length,g=[],a=0;a<f;a++){var h=new THREE.Path,h=this.extractGlyphPoints(e[a],b,c,d,h),d=d+h.offset;g.push(h.path)}return{paths:g,offset:d/2}},extractGlyphPoints:function(a,b,c,d,e){var f=[],g,h,i,j,l,m,n,p,o,q,r,t=b.glyphs[a]||b.glyphs["?"];if(t){if(t.o){b=t._cachedOutline||(t._cachedOutline=t.o.split(" "));j=b.length;for(a=0;a<j;){i=b[a++];switch(i){case "m":i=b[a++]*c+d;l=b[a++]*c;e.moveTo(i,l);break;case "l":i=b[a++]*c+d;l=b[a++]*c;e.lineTo(i,l);break;case "q":i=b[a++]*
c+d;l=b[a++]*c;p=b[a++]*c+d;o=b[a++]*c;e.quadraticCurveTo(p,o,i,l);if(g=f[f.length-1]){m=g.x;n=g.y;g=1;for(h=this.divisions;g<=h;g++){var B=g/h;THREE.Shape.Utils.b2(B,m,p,i);THREE.Shape.Utils.b2(B,n,o,l)}}break;case "b":i=b[a++]*c+d;l=b[a++]*c;p=b[a++]*c+d;o=b[a++]*-c;q=b[a++]*c+d;r=b[a++]*-c;e.bezierCurveTo(i,l,p,o,q,r);if(g=f[f.length-1]){m=g.x;n=g.y;g=1;for(h=this.divisions;g<=h;g++){B=g/h;THREE.Shape.Utils.b3(B,m,p,q,i);THREE.Shape.Utils.b3(B,n,o,r,l)}}}}}return{offset:t.ha*c,path:e}}}};
THREE.FontUtils.generateShapes=function(a,b){var b=b||{},c=b.curveSegments!==void 0?b.curveSegments:4,d=b.font!==void 0?b.font:"helvetiker",e=b.weight!==void 0?b.weight:"normal",f=b.style!==void 0?b.style:"normal";THREE.FontUtils.size=b.size!==void 0?b.size:100;THREE.FontUtils.divisions=c;THREE.FontUtils.face=d;THREE.FontUtils.weight=e;THREE.FontUtils.style=f;c=THREE.FontUtils.drawText(a).paths;d=[];e=0;for(f=c.length;e<f;e++)Array.prototype.push.apply(d,c[e].toShapes());return d};
(function(a){var b=function(a){for(var b=a.length,e=0,f=b-1,g=0;g<b;f=g++)e=e+(a[f].x*a[g].y-a[g].x*a[f].y);return e*0.5};a.Triangulate=function(a,d){var e=a.length;if(e<3)return null;var f=[],g=[],h=[],i,j,l;if(b(a)>0)for(j=0;j<e;j++)g[j]=j;else for(j=0;j<e;j++)g[j]=e-1-j;var m=2*e;for(j=e-1;e>2;){if(m--<=0){console.log("Warning, unable to triangulate polygon!");break}i=j;e<=i&&(i=0);j=i+1;e<=j&&(j=0);l=j+1;e<=l&&(l=0);var n;a:{n=a;var p=i,o=j,q=l,r=e,t=g,B=void 0,u=void 0,s=void 0,z=void 0,A=void 0,
v=void 0,y=void 0,C=void 0,G=void 0,u=n[t[p]].x,s=n[t[p]].y,z=n[t[o]].x,A=n[t[o]].y,v=n[t[q]].x,y=n[t[q]].y;if(1E-10>(z-u)*(y-s)-(A-s)*(v-u))n=false;else{for(B=0;B<r;B++)if(!(B==p||B==o||B==q)){var C=n[t[B]].x,G=n[t[B]].y,H=void 0,J=void 0,E=void 0,M=void 0,K=void 0,F=void 0,I=void 0,L=void 0,R=void 0,$=void 0,Y=void 0,N=void 0,H=E=K=void 0,H=v-z,J=y-A,E=u-v,M=s-y,K=z-u,F=A-s,I=C-u,L=G-s,R=C-z,$=G-A,Y=C-v,N=G-y,H=H*$-J*R,K=K*L-F*I,E=E*N-M*Y;if(H>=0&&E>=0&&K>=0){n=false;break a}}n=true}}if(n){f.push([a[g[i]],
a[g[j]],a[g[l]]]);h.push([g[i],g[j],g[l]]);i=j;for(l=j+1;l<e;i++,l++)g[i]=g[l];e--;m=2*e}}return d?h:f};a.Triangulate.area=b;return a})(THREE.FontUtils);self._typeface_js={faces:THREE.FontUtils.faces,loadFace:THREE.FontUtils.loadFace};THREE.Curve=function(){};THREE.Curve.prototype.getPoint=function(){console.log("Warning, getPoint() not implemented!");return null};THREE.Curve.prototype.getPointAt=function(a){a=this.getUtoTmapping(a);return this.getPoint(a)};
THREE.Curve.prototype.getPoints=function(a){a||(a=5);var b,c=[];for(b=0;b<=a;b++)c.push(this.getPoint(b/a));return c};THREE.Curve.prototype.getSpacedPoints=function(a){a||(a=5);var b,c=[];for(b=0;b<=a;b++)c.push(this.getPointAt(b/a));return c};THREE.Curve.prototype.getLength=function(){var a=this.getLengths();return a[a.length-1]};
THREE.Curve.prototype.getLengths=function(a){a||(a=this.__arcLengthDivisions?this.__arcLengthDivisions:200);if(this.cacheArcLengths&&this.cacheArcLengths.length==a+1&&!this.needsUpdate)return this.cacheArcLengths;this.needsUpdate=false;var b=[],c,d=this.getPoint(0),e,f=0;b.push(0);for(e=1;e<=a;e++){c=this.getPoint(e/a);f=f+c.distanceTo(d);b.push(f);d=c}return this.cacheArcLengths=b};THREE.Curve.prototype.updateArcLengths=function(){this.needsUpdate=true;this.getLengths()};
THREE.Curve.prototype.getUtoTmapping=function(a,b){var c=this.getLengths(),d=0,e=c.length,f;f=b?b:a*c[e-1];for(var g=0,h=e-1,i;g<=h;){d=Math.floor(g+(h-g)/2);i=c[d]-f;if(i<0)g=d+1;else if(i>0)h=d-1;else{h=d;break}}d=h;if(c[d]==f)return d/(e-1);g=c[d];return c=(d+(f-g)/(c[d+1]-g))/(e-1)};THREE.Curve.prototype.getNormalVector=function(a){a=this.getTangent(a);return new THREE.Vector2(-a.y,a.x)};
THREE.Curve.prototype.getTangent=function(a){var b=a-1E-4,a=a+1E-4;b<0&&(b=0);a>1&&(a=1);b=this.getPoint(b);return this.getPoint(a).clone().subSelf(b).normalize()};THREE.Curve.prototype.getTangentAt=function(a){a=this.getUtoTmapping(a);return this.getTangent(a)};THREE.LineCurve=function(a,b){this.v1=a;this.v2=b};THREE.LineCurve.prototype=Object.create(THREE.Curve.prototype);THREE.LineCurve.prototype.getPoint=function(a){var b=this.v2.clone().subSelf(this.v1);b.multiplyScalar(a).addSelf(this.v1);return b};
THREE.LineCurve.prototype.getPointAt=function(a){return this.getPoint(a)};THREE.LineCurve.prototype.getTangent=function(){return this.v2.clone().subSelf(this.v1).normalize()};THREE.QuadraticBezierCurve=function(a,b,c){this.v0=a;this.v1=b;this.v2=c};THREE.QuadraticBezierCurve.prototype=Object.create(THREE.Curve.prototype);
THREE.QuadraticBezierCurve.prototype.getPoint=function(a){var b;b=THREE.Shape.Utils.b2(a,this.v0.x,this.v1.x,this.v2.x);a=THREE.Shape.Utils.b2(a,this.v0.y,this.v1.y,this.v2.y);return new THREE.Vector2(b,a)};THREE.QuadraticBezierCurve.prototype.getTangent=function(a){var b;b=THREE.Curve.Utils.tangentQuadraticBezier(a,this.v0.x,this.v1.x,this.v2.x);a=THREE.Curve.Utils.tangentQuadraticBezier(a,this.v0.y,this.v1.y,this.v2.y);b=new THREE.Vector2(b,a);b.normalize();return b};
THREE.CubicBezierCurve=function(a,b,c,d){this.v0=a;this.v1=b;this.v2=c;this.v3=d};THREE.CubicBezierCurve.prototype=Object.create(THREE.Curve.prototype);THREE.CubicBezierCurve.prototype.getPoint=function(a){var b;b=THREE.Shape.Utils.b3(a,this.v0.x,this.v1.x,this.v2.x,this.v3.x);a=THREE.Shape.Utils.b3(a,this.v0.y,this.v1.y,this.v2.y,this.v3.y);return new THREE.Vector2(b,a)};
THREE.CubicBezierCurve.prototype.getTangent=function(a){var b;b=THREE.Curve.Utils.tangentCubicBezier(a,this.v0.x,this.v1.x,this.v2.x,this.v3.x);a=THREE.Curve.Utils.tangentCubicBezier(a,this.v0.y,this.v1.y,this.v2.y,this.v3.y);b=new THREE.Vector2(b,a);b.normalize();return b};THREE.SplineCurve=function(a){this.points=a==void 0?[]:a};THREE.SplineCurve.prototype=Object.create(THREE.Curve.prototype);
THREE.SplineCurve.prototype.getPoint=function(a){var b=new THREE.Vector2,c=[],d=this.points,e;e=(d.length-1)*a;a=Math.floor(e);e=e-a;c[0]=a==0?a:a-1;c[1]=a;c[2]=a>d.length-2?d.length-1:a+1;c[3]=a>d.length-3?d.length-1:a+2;b.x=THREE.Curve.Utils.interpolate(d[c[0]].x,d[c[1]].x,d[c[2]].x,d[c[3]].x,e);b.y=THREE.Curve.Utils.interpolate(d[c[0]].y,d[c[1]].y,d[c[2]].y,d[c[3]].y,e);return b};
THREE.EllipseCurve=function(a,b,c,d,e,f,g){this.aX=a;this.aY=b;this.xRadius=c;this.yRadius=d;this.aStartAngle=e;this.aEndAngle=f;this.aClockwise=g};THREE.EllipseCurve.prototype=Object.create(THREE.Curve.prototype);THREE.EllipseCurve.prototype.getPoint=function(a){var b=this.aEndAngle-this.aStartAngle;this.aClockwise||(a=1-a);b=this.aStartAngle+a*b;a=this.aX+this.xRadius*Math.cos(b);b=this.aY+this.yRadius*Math.sin(b);return new THREE.Vector2(a,b)};
THREE.ArcCurve=function(a,b,c,d,e,f){THREE.EllipseCurve.call(this,a,b,c,c,d,e,f)};THREE.ArcCurve.prototype=Object.create(THREE.EllipseCurve.prototype);
THREE.Curve.Utils={tangentQuadraticBezier:function(a,b,c,d){return 2*(1-a)*(c-b)+2*a*(d-c)},tangentCubicBezier:function(a,b,c,d,e){return-3*b*(1-a)*(1-a)+3*c*(1-a)*(1-a)-6*a*c*(1-a)+6*a*d*(1-a)-3*a*a*d+3*a*a*e},tangentSpline:function(a){return 6*a*a-6*a+(3*a*a-4*a+1)+(-6*a*a+6*a)+(3*a*a-2*a)},interpolate:function(a,b,c,d,e){var a=(c-a)*0.5,d=(d-b)*0.5,f=e*e;return(2*b-2*c+a+d)*e*f+(-3*b+3*c-2*a-d)*f+a*e+b}};
THREE.Curve.create=function(a,b){a.prototype=Object.create(THREE.Curve.prototype);a.prototype.getPoint=b;return a};THREE.LineCurve3=THREE.Curve.create(function(a,b){this.v1=a;this.v2=b},function(a){var b=new THREE.Vector3;b.sub(this.v2,this.v1);b.multiplyScalar(a);b.addSelf(this.v1);return b});
THREE.QuadraticBezierCurve3=THREE.Curve.create(function(a,b,c){this.v0=a;this.v1=b;this.v2=c},function(a){var b,c;b=THREE.Shape.Utils.b2(a,this.v0.x,this.v1.x,this.v2.x);c=THREE.Shape.Utils.b2(a,this.v0.y,this.v1.y,this.v2.y);a=THREE.Shape.Utils.b2(a,this.v0.z,this.v1.z,this.v2.z);return new THREE.Vector3(b,c,a)});
THREE.CubicBezierCurve3=THREE.Curve.create(function(a,b,c,d){this.v0=a;this.v1=b;this.v2=c;this.v3=d},function(a){var b,c;b=THREE.Shape.Utils.b3(a,this.v0.x,this.v1.x,this.v2.x,this.v3.x);c=THREE.Shape.Utils.b3(a,this.v0.y,this.v1.y,this.v2.y,this.v3.y);a=THREE.Shape.Utils.b3(a,this.v0.z,this.v1.z,this.v2.z,this.v3.z);return new THREE.Vector3(b,c,a)});
THREE.SplineCurve3=THREE.Curve.create(function(a){this.points=a==void 0?[]:a},function(a){var b=new THREE.Vector3,c=[],d=this.points,e,a=(d.length-1)*a;e=Math.floor(a);a=a-e;c[0]=e==0?e:e-1;c[1]=e;c[2]=e>d.length-2?d.length-1:e+1;c[3]=e>d.length-3?d.length-1:e+2;e=d[c[0]];var f=d[c[1]],g=d[c[2]],c=d[c[3]];b.x=THREE.Curve.Utils.interpolate(e.x,f.x,g.x,c.x,a);b.y=THREE.Curve.Utils.interpolate(e.y,f.y,g.y,c.y,a);b.z=THREE.Curve.Utils.interpolate(e.z,f.z,g.z,c.z,a);return b});
THREE.ClosedSplineCurve3=THREE.Curve.create(function(a){this.points=a==void 0?[]:a},function(a){var b=new THREE.Vector3,c=[],d=this.points,e;e=(d.length-0)*a;a=Math.floor(e);e=e-a;a=a+(a>0?0:(Math.floor(Math.abs(a)/d.length)+1)*d.length);c[0]=(a-1)%d.length;c[1]=a%d.length;c[2]=(a+1)%d.length;c[3]=(a+2)%d.length;b.x=THREE.Curve.Utils.interpolate(d[c[0]].x,d[c[1]].x,d[c[2]].x,d[c[3]].x,e);b.y=THREE.Curve.Utils.interpolate(d[c[0]].y,d[c[1]].y,d[c[2]].y,d[c[3]].y,e);b.z=THREE.Curve.Utils.interpolate(d[c[0]].z,
d[c[1]].z,d[c[2]].z,d[c[3]].z,e);return b});THREE.CurvePath=function(){this.curves=[];this.bends=[];this.autoClose=false};THREE.CurvePath.prototype=Object.create(THREE.Curve.prototype);THREE.CurvePath.prototype.add=function(a){this.curves.push(a)};THREE.CurvePath.prototype.checkConnection=function(){};THREE.CurvePath.prototype.closePath=function(){var a=this.curves[0].getPoint(0),b=this.curves[this.curves.length-1].getPoint(1);a.equals(b)||this.curves.push(new THREE.LineCurve(b,a))};
THREE.CurvePath.prototype.getPoint=function(a){for(var b=a*this.getLength(),c=this.getCurveLengths(),a=0;a<c.length;){if(c[a]>=b){b=c[a]-b;a=this.curves[a];b=1-b/a.getLength();return a.getPointAt(b)}a++}return null};THREE.CurvePath.prototype.getLength=function(){var a=this.getCurveLengths();return a[a.length-1]};
THREE.CurvePath.prototype.getCurveLengths=function(){if(this.cacheLengths&&this.cacheLengths.length==this.curves.length)return this.cacheLengths;var a=[],b=0,c,d=this.curves.length;for(c=0;c<d;c++){b=b+this.curves[c].getLength();a.push(b)}return this.cacheLengths=a};
THREE.CurvePath.prototype.getBoundingBox=function(){var a=this.getPoints(),b,c,d,e,f,g;b=c=Number.NEGATIVE_INFINITY;e=f=Number.POSITIVE_INFINITY;var h,i,j,l,m=a[0]instanceof THREE.Vector3;l=m?new THREE.Vector3:new THREE.Vector2;i=0;for(j=a.length;i<j;i++){h=a[i];if(h.x>b)b=h.x;else if(h.x<e)e=h.x;if(h.y>c)c=h.y;else if(h.y<f)f=h.y;if(m)if(h.z>d)d=h.z;else if(h.z<g)g=h.z;l.addSelf(h)}a={minX:e,minY:f,maxX:b,maxY:c,centroid:l.divideScalar(j)};if(m){a.maxZ=d;a.minZ=g}return a};
THREE.CurvePath.prototype.createPointsGeometry=function(a){a=this.getPoints(a,true);return this.createGeometry(a)};THREE.CurvePath.prototype.createSpacedPointsGeometry=function(a){a=this.getSpacedPoints(a,true);return this.createGeometry(a)};THREE.CurvePath.prototype.createGeometry=function(a){for(var b=new THREE.Geometry,c=0;c<a.length;c++)b.vertices.push(new THREE.Vector3(a[c].x,a[c].y,a[c].z||0));return b};THREE.CurvePath.prototype.addWrapPath=function(a){this.bends.push(a)};
THREE.CurvePath.prototype.getTransformedPoints=function(a,b){var c=this.getPoints(a),d,e;if(!b)b=this.bends;d=0;for(e=b.length;d<e;d++)c=this.getWrapPoints(c,b[d]);return c};THREE.CurvePath.prototype.getTransformedSpacedPoints=function(a,b){var c=this.getSpacedPoints(a),d,e;if(!b)b=this.bends;d=0;for(e=b.length;d<e;d++)c=this.getWrapPoints(c,b[d]);return c};
THREE.CurvePath.prototype.getWrapPoints=function(a,b){var c=this.getBoundingBox(),d,e,f,g,h,i;d=0;for(e=a.length;d<e;d++){f=a[d];g=f.x;h=f.y;i=g/c.maxX;i=b.getUtoTmapping(i,g);g=b.getPoint(i);h=b.getNormalVector(i).multiplyScalar(h);f.x=g.x+h.x;f.y=g.y+h.y}return a};THREE.Gyroscope=function(){THREE.Object3D.call(this)};THREE.Gyroscope.prototype=Object.create(THREE.Object3D.prototype);
THREE.Gyroscope.prototype.updateMatrixWorld=function(a){this.matrixAutoUpdate&&this.updateMatrix();if(this.matrixWorldNeedsUpdate||a){if(this.parent){this.matrixWorld.multiply(this.parent.matrixWorld,this.matrix);this.matrixWorld.decompose(this.translationWorld,this.rotationWorld,this.scaleWorld);this.matrix.decompose(this.translationObject,this.rotationObject,this.scaleObject);this.matrixWorld.compose(this.translationWorld,this.rotationObject,this.scaleWorld)}else this.matrixWorld.copy(this.matrix);
this.matrixWorldNeedsUpdate=false;a=true}for(var b=0,c=this.children.length;b<c;b++)this.children[b].updateMatrixWorld(a)};THREE.Gyroscope.prototype.translationWorld=new THREE.Vector3;THREE.Gyroscope.prototype.translationObject=new THREE.Vector3;THREE.Gyroscope.prototype.rotationWorld=new THREE.Quaternion;THREE.Gyroscope.prototype.rotationObject=new THREE.Quaternion;THREE.Gyroscope.prototype.scaleWorld=new THREE.Vector3;THREE.Gyroscope.prototype.scaleObject=new THREE.Vector3;
THREE.Path=function(a){THREE.CurvePath.call(this);this.actions=[];a&&this.fromPoints(a)};THREE.Path.prototype=Object.create(THREE.CurvePath.prototype);THREE.PathActions={MOVE_TO:"moveTo",LINE_TO:"lineTo",QUADRATIC_CURVE_TO:"quadraticCurveTo",BEZIER_CURVE_TO:"bezierCurveTo",CSPLINE_THRU:"splineThru",ARC:"arc",ELLIPSE:"ellipse"};THREE.Path.prototype.fromPoints=function(a){this.moveTo(a[0].x,a[0].y);for(var b=1,c=a.length;b<c;b++)this.lineTo(a[b].x,a[b].y)};
THREE.Path.prototype.moveTo=function(a,b){var c=Array.prototype.slice.call(arguments);this.actions.push({action:THREE.PathActions.MOVE_TO,args:c})};THREE.Path.prototype.lineTo=function(a,b){var c=Array.prototype.slice.call(arguments),d=this.actions[this.actions.length-1].args,d=new THREE.LineCurve(new THREE.Vector2(d[d.length-2],d[d.length-1]),new THREE.Vector2(a,b));this.curves.push(d);this.actions.push({action:THREE.PathActions.LINE_TO,args:c})};
THREE.Path.prototype.quadraticCurveTo=function(a,b,c,d){var e=Array.prototype.slice.call(arguments),f=this.actions[this.actions.length-1].args,f=new THREE.QuadraticBezierCurve(new THREE.Vector2(f[f.length-2],f[f.length-1]),new THREE.Vector2(a,b),new THREE.Vector2(c,d));this.curves.push(f);this.actions.push({action:THREE.PathActions.QUADRATIC_CURVE_TO,args:e})};
THREE.Path.prototype.bezierCurveTo=function(a,b,c,d,e,f){var g=Array.prototype.slice.call(arguments),h=this.actions[this.actions.length-1].args,h=new THREE.CubicBezierCurve(new THREE.Vector2(h[h.length-2],h[h.length-1]),new THREE.Vector2(a,b),new THREE.Vector2(c,d),new THREE.Vector2(e,f));this.curves.push(h);this.actions.push({action:THREE.PathActions.BEZIER_CURVE_TO,args:g})};
THREE.Path.prototype.splineThru=function(a){var b=Array.prototype.slice.call(arguments),c=this.actions[this.actions.length-1].args,c=[new THREE.Vector2(c[c.length-2],c[c.length-1])];Array.prototype.push.apply(c,a);c=new THREE.SplineCurve(c);this.curves.push(c);this.actions.push({action:THREE.PathActions.CSPLINE_THRU,args:b})};THREE.Path.prototype.arc=function(a,b,c,d,e,f){var g=this.actions[this.actions.length-1].args;this.absarc(a+g[g.length-2],b+g[g.length-1],c,d,e,f)};
THREE.Path.prototype.absarc=function(a,b,c,d,e,f){this.absellipse(a,b,c,c,d,e,f)};THREE.Path.prototype.ellipse=function(a,b,c,d,e,f,g){var h=this.actions[this.actions.length-1].args;this.absellipse(a+h[h.length-2],b+h[h.length-1],c,d,e,f,g)};THREE.Path.prototype.absellipse=function(a,b,c,d,e,f,g){var h=Array.prototype.slice.call(arguments),i=new THREE.EllipseCurve(a,b,c,d,e,f,g);this.curves.push(i);i=i.getPoint(g?1:0);h.push(i.x);h.push(i.y);this.actions.push({action:THREE.PathActions.ELLIPSE,args:h})};
THREE.Path.prototype.getSpacedPoints=function(a){a||(a=40);for(var b=[],c=0;c<a;c++)b.push(this.getPoint(c/a));return b};
THREE.Path.prototype.getPoints=function(a,b){if(this.useSpacedPoints){console.log("tata");return this.getSpacedPoints(a,b)}var a=a||12,c=[],d,e,f,g,h,i,j,l,m,n,p,o,q;d=0;for(e=this.actions.length;d<e;d++){f=this.actions[d];g=f.action;f=f.args;switch(g){case THREE.PathActions.MOVE_TO:c.push(new THREE.Vector2(f[0],f[1]));break;case THREE.PathActions.LINE_TO:c.push(new THREE.Vector2(f[0],f[1]));break;case THREE.PathActions.QUADRATIC_CURVE_TO:h=f[2];i=f[3];m=f[0];n=f[1];if(c.length>0){g=c[c.length-1];
p=g.x;o=g.y}else{g=this.actions[d-1].args;p=g[g.length-2];o=g[g.length-1]}for(f=1;f<=a;f++){q=f/a;g=THREE.Shape.Utils.b2(q,p,m,h);q=THREE.Shape.Utils.b2(q,o,n,i);c.push(new THREE.Vector2(g,q))}break;case THREE.PathActions.BEZIER_CURVE_TO:h=f[4];i=f[5];m=f[0];n=f[1];j=f[2];l=f[3];if(c.length>0){g=c[c.length-1];p=g.x;o=g.y}else{g=this.actions[d-1].args;p=g[g.length-2];o=g[g.length-1]}for(f=1;f<=a;f++){q=f/a;g=THREE.Shape.Utils.b3(q,p,m,j,h);q=THREE.Shape.Utils.b3(q,o,n,l,i);c.push(new THREE.Vector2(g,
q))}break;case THREE.PathActions.CSPLINE_THRU:g=this.actions[d-1].args;q=[new THREE.Vector2(g[g.length-2],g[g.length-1])];g=a*f[0].length;q=q.concat(f[0]);q=new THREE.SplineCurve(q);for(f=1;f<=g;f++)c.push(q.getPointAt(f/g));break;case THREE.PathActions.ARC:h=f[0];i=f[1];n=f[2];j=f[3];g=f[4];m=!!f[5];p=g-j;o=a*2;for(f=1;f<=o;f++){q=f/o;m||(q=1-q);q=j+q*p;g=h+n*Math.cos(q);q=i+n*Math.sin(q);c.push(new THREE.Vector2(g,q))}break;case THREE.PathActions.ELLIPSE:h=f[0];i=f[1];n=f[2];l=f[3];j=f[4];g=f[5];
m=!!f[6];p=g-j;o=a*2;for(f=1;f<=o;f++){q=f/o;m||(q=1-q);q=j+q*p;g=h+n*Math.cos(q);q=i+l*Math.sin(q);c.push(new THREE.Vector2(g,q))}}}d=c[c.length-1];Math.abs(d.x-c[0].x)<1E-10&&Math.abs(d.y-c[0].y)<1E-10&&c.splice(c.length-1,1);b&&c.push(c[0]);return c};
THREE.Path.prototype.toShapes=function(){var a,b,c,d,e=[],f=new THREE.Path;a=0;for(b=this.actions.length;a<b;a++){c=this.actions[a];d=c.args;c=c.action;if(c==THREE.PathActions.MOVE_TO&&f.actions.length!=0){e.push(f);f=new THREE.Path}f[c].apply(f,d)}f.actions.length!=0&&e.push(f);if(e.length==0)return[];var g;d=[];a=!THREE.Shape.Utils.isClockWise(e[0].getPoints());if(e.length==1){f=e[0];g=new THREE.Shape;g.actions=f.actions;g.curves=f.curves;d.push(g);return d}if(a){g=new THREE.Shape;a=0;for(b=e.length;a<
b;a++){f=e[a];if(THREE.Shape.Utils.isClockWise(f.getPoints())){g.actions=f.actions;g.curves=f.curves;d.push(g);g=new THREE.Shape}else g.holes.push(f)}}else{a=0;for(b=e.length;a<b;a++){f=e[a];if(THREE.Shape.Utils.isClockWise(f.getPoints())){g&&d.push(g);g=new THREE.Shape;g.actions=f.actions;g.curves=f.curves}else g.holes.push(f)}d.push(g)}return d};THREE.Shape=function(){THREE.Path.apply(this,arguments);this.holes=[]};THREE.Shape.prototype=Object.create(THREE.Path.prototype);
THREE.Shape.prototype.extrude=function(a){return new THREE.ExtrudeGeometry(this,a)};THREE.Shape.prototype.makeGeometry=function(a){return new THREE.ShapeGeometry(this,a)};THREE.Shape.prototype.getPointsHoles=function(a){var b,c=this.holes.length,d=[];for(b=0;b<c;b++)d[b]=this.holes[b].getTransformedPoints(a,this.bends);return d};THREE.Shape.prototype.getSpacedPointsHoles=function(a){var b,c=this.holes.length,d=[];for(b=0;b<c;b++)d[b]=this.holes[b].getTransformedSpacedPoints(a,this.bends);return d};
THREE.Shape.prototype.extractAllPoints=function(a){return{shape:this.getTransformedPoints(a),holes:this.getPointsHoles(a)}};THREE.Shape.prototype.extractPoints=function(a){return this.useSpacedPoints?this.extractAllSpacedPoints(a):this.extractAllPoints(a)};THREE.Shape.prototype.extractAllSpacedPoints=function(a){return{shape:this.getTransformedSpacedPoints(a),holes:this.getSpacedPointsHoles(a)}};
THREE.Shape.Utils={removeHoles:function(a,b){var c=a.concat(),d=c.concat(),e,f,g,h,i,j,l,m,n,p,o=[];for(i=0;i<b.length;i++){j=b[i];Array.prototype.push.apply(d,j);f=Number.POSITIVE_INFINITY;for(e=0;e<j.length;e++){n=j[e];p=[];for(m=0;m<c.length;m++){l=c[m];l=n.distanceToSquared(l);p.push(l);if(l<f){f=l;g=e;h=m}}}e=h-1>=0?h-1:c.length-1;f=g-1>=0?g-1:j.length-1;var q=[j[g],c[h],c[e]];m=THREE.FontUtils.Triangulate.area(q);var r=[j[g],j[f],c[h]];n=THREE.FontUtils.Triangulate.area(r);p=h;l=g;h=h+1;g=g+
-1;h<0&&(h=h+c.length);h=h%c.length;g<0&&(g=g+j.length);g=g%j.length;e=h-1>=0?h-1:c.length-1;f=g-1>=0?g-1:j.length-1;q=[j[g],c[h],c[e]];q=THREE.FontUtils.Triangulate.area(q);r=[j[g],j[f],c[h]];r=THREE.FontUtils.Triangulate.area(r);if(m+n>q+r){h=p;g=l;h<0&&(h=h+c.length);h=h%c.length;g<0&&(g=g+j.length);g=g%j.length;e=h-1>=0?h-1:c.length-1;f=g-1>=0?g-1:j.length-1}m=c.slice(0,h);n=c.slice(h);p=j.slice(g);l=j.slice(0,g);f=[j[g],j[f],c[h]];o.push([j[g],c[h],c[e]]);o.push(f);c=m.concat(p).concat(l).concat(n)}return{shape:c,
isolatedPts:o,allpoints:d}},triangulateShape:function(a,b){var c=THREE.Shape.Utils.removeHoles(a,b),d=c.allpoints,e=c.isolatedPts,c=THREE.FontUtils.Triangulate(c.shape,false),f,g,h,i,j={};f=0;for(g=d.length;f<g;f++){i=d[f].x+":"+d[f].y;j[i]!==void 0&&console.log("Duplicate point",i);j[i]=f}f=0;for(g=c.length;f<g;f++){h=c[f];for(d=0;d<3;d++){i=h[d].x+":"+h[d].y;i=j[i];i!==void 0&&(h[d]=i)}}f=0;for(g=e.length;f<g;f++){h=e[f];for(d=0;d<3;d++){i=h[d].x+":"+h[d].y;i=j[i];i!==void 0&&(h[d]=i)}}return c.concat(e)},
isClockWise:function(a){return THREE.FontUtils.Triangulate.area(a)<0},b2p0:function(a,b){var c=1-a;return c*c*b},b2p1:function(a,b){return 2*(1-a)*a*b},b2p2:function(a,b){return a*a*b},b2:function(a,b,c,d){return this.b2p0(a,b)+this.b2p1(a,c)+this.b2p2(a,d)},b3p0:function(a,b){var c=1-a;return c*c*c*b},b3p1:function(a,b){var c=1-a;return 3*c*c*a*b},b3p2:function(a,b){return 3*(1-a)*a*a*b},b3p3:function(a,b){return a*a*a*b},b3:function(a,b,c,d,e){return this.b3p0(a,b)+this.b3p1(a,c)+this.b3p2(a,d)+
this.b3p3(a,e)}};
THREE.AnimationHandler=function(){var a=[],b={},c={update:function(b){for(var c=0;c<a.length;c++)a[c].update(b)},addToUpdate:function(b){a.indexOf(b)===-1&&a.push(b)},removeFromUpdate:function(b){b=a.indexOf(b);b!==-1&&a.splice(b,1)},add:function(a){b[a.name]!==void 0&&console.log("THREE.AnimationHandler.add: Warning! "+a.name+" already exists in library. Overwriting.");b[a.name]=a;if(a.initialized!==true){for(var c=0;c<a.hierarchy.length;c++){for(var d=0;d<a.hierarchy[c].keys.length;d++){if(a.hierarchy[c].keys[d].time<0)a.hierarchy[c].keys[d].time=
0;if(a.hierarchy[c].keys[d].rot!==void 0&&!(a.hierarchy[c].keys[d].rot instanceof THREE.Quaternion)){var h=a.hierarchy[c].keys[d].rot;a.hierarchy[c].keys[d].rot=new THREE.Quaternion(h[0],h[1],h[2],h[3])}}if(a.hierarchy[c].keys.length&&a.hierarchy[c].keys[0].morphTargets!==void 0){h={};for(d=0;d<a.hierarchy[c].keys.length;d++)for(var i=0;i<a.hierarchy[c].keys[d].morphTargets.length;i++){var j=a.hierarchy[c].keys[d].morphTargets[i];h[j]=-1}a.hierarchy[c].usedMorphTargets=h;for(d=0;d<a.hierarchy[c].keys.length;d++){var l=
{};for(j in h){for(i=0;i<a.hierarchy[c].keys[d].morphTargets.length;i++)if(a.hierarchy[c].keys[d].morphTargets[i]===j){l[j]=a.hierarchy[c].keys[d].morphTargetsInfluences[i];break}i===a.hierarchy[c].keys[d].morphTargets.length&&(l[j]=0)}a.hierarchy[c].keys[d].morphTargetsInfluences=l}}for(d=1;d<a.hierarchy[c].keys.length;d++)if(a.hierarchy[c].keys[d].time===a.hierarchy[c].keys[d-1].time){a.hierarchy[c].keys.splice(d,1);d--}for(d=0;d<a.hierarchy[c].keys.length;d++)a.hierarchy[c].keys[d].index=d}d=parseInt(a.length*
a.fps,10);a.JIT={};a.JIT.hierarchy=[];for(c=0;c<a.hierarchy.length;c++)a.JIT.hierarchy.push(Array(d));a.initialized=true}},get:function(a){if(typeof a==="string"){if(b[a])return b[a];console.log("THREE.AnimationHandler.get: Couldn't find animation "+a);return null}},parse:function(a){var b=[];if(a instanceof THREE.SkinnedMesh)for(var c=0;c<a.bones.length;c++)b.push(a.bones[c]);else d(a,b);return b}},d=function(a,b){b.push(a);for(var c=0;c<a.children.length;c++)d(a.children[c],b)};c.LINEAR=0;c.CATMULLROM=
1;c.CATMULLROM_FORWARD=2;return c}();THREE.Animation=function(a,b,c){this.root=a;this.data=THREE.AnimationHandler.get(b);this.hierarchy=THREE.AnimationHandler.parse(a);this.currentTime=0;this.timeScale=1;this.isPlaying=false;this.loop=this.isPaused=true;this.interpolationType=c!==void 0?c:THREE.AnimationHandler.LINEAR;this.points=[];this.target=new THREE.Vector3};
THREE.Animation.prototype.play=function(a,b){if(this.isPlaying===false){this.isPlaying=true;this.loop=a!==void 0?a:true;this.currentTime=b!==void 0?b:0;var c,d=this.hierarchy.length,e;for(c=0;c<d;c++){e=this.hierarchy[c];if(this.interpolationType!==THREE.AnimationHandler.CATMULLROM_FORWARD)e.useQuaternion=true;e.matrixAutoUpdate=true;if(e.animationCache===void 0){e.animationCache={};e.animationCache.prevKey={pos:0,rot:0,scl:0};e.animationCache.nextKey={pos:0,rot:0,scl:0};e.animationCache.originalMatrix=
e instanceof THREE.Bone?e.skinMatrix:e.matrix}var f=e.animationCache.prevKey;e=e.animationCache.nextKey;f.pos=this.data.hierarchy[c].keys[0];f.rot=this.data.hierarchy[c].keys[0];f.scl=this.data.hierarchy[c].keys[0];e.pos=this.getNextKeyWith("pos",c,1);e.rot=this.getNextKeyWith("rot",c,1);e.scl=this.getNextKeyWith("scl",c,1)}this.update(0)}this.isPaused=false;THREE.AnimationHandler.addToUpdate(this)};
THREE.Animation.prototype.pause=function(){this.isPaused===true?THREE.AnimationHandler.addToUpdate(this):THREE.AnimationHandler.removeFromUpdate(this);this.isPaused=!this.isPaused};THREE.Animation.prototype.stop=function(){this.isPaused=this.isPlaying=false;THREE.AnimationHandler.removeFromUpdate(this)};
THREE.Animation.prototype.update=function(a){if(this.isPlaying!==false){var b=["pos","rot","scl"],c,d,e,f,g,h,i,j,l;l=this.currentTime=this.currentTime+a*this.timeScale;j=this.currentTime=this.currentTime%this.data.length;parseInt(Math.min(j*this.data.fps,this.data.length*this.data.fps),10);for(var m=0,n=this.hierarchy.length;m<n;m++){a=this.hierarchy[m];i=a.animationCache;for(var p=0;p<3;p++){c=b[p];g=i.prevKey[c];h=i.nextKey[c];if(h.time<=l){if(j<l)if(this.loop){g=this.data.hierarchy[m].keys[0];
for(h=this.getNextKeyWith(c,m,1);h.time<j;){g=h;h=this.getNextKeyWith(c,m,h.index+1)}}else{this.stop();return}else{do{g=h;h=this.getNextKeyWith(c,m,h.index+1)}while(h.time<j)}i.prevKey[c]=g;i.nextKey[c]=h}a.matrixAutoUpdate=true;a.matrixWorldNeedsUpdate=true;d=(j-g.time)/(h.time-g.time);e=g[c];f=h[c];if(d<0||d>1){console.log("THREE.Animation.update: Warning! Scale out of bounds:"+d+" on bone "+m);d=d<0?0:1}if(c==="pos"){c=a.position;if(this.interpolationType===THREE.AnimationHandler.LINEAR){c.x=e[0]+
(f[0]-e[0])*d;c.y=e[1]+(f[1]-e[1])*d;c.z=e[2]+(f[2]-e[2])*d}else if(this.interpolationType===THREE.AnimationHandler.CATMULLROM||this.interpolationType===THREE.AnimationHandler.CATMULLROM_FORWARD){this.points[0]=this.getPrevKeyWith("pos",m,g.index-1).pos;this.points[1]=e;this.points[2]=f;this.points[3]=this.getNextKeyWith("pos",m,h.index+1).pos;d=d*0.33+0.33;e=this.interpolateCatmullRom(this.points,d);c.x=e[0];c.y=e[1];c.z=e[2];if(this.interpolationType===THREE.AnimationHandler.CATMULLROM_FORWARD){d=
this.interpolateCatmullRom(this.points,d*1.01);this.target.set(d[0],d[1],d[2]);this.target.subSelf(c);this.target.y=0;this.target.normalize();d=Math.atan2(this.target.x,this.target.z);a.rotation.set(0,d,0)}}}else if(c==="rot")THREE.Quaternion.slerp(e,f,a.quaternion,d);else if(c==="scl"){c=a.scale;c.x=e[0]+(f[0]-e[0])*d;c.y=e[1]+(f[1]-e[1])*d;c.z=e[2]+(f[2]-e[2])*d}}}}};
THREE.Animation.prototype.interpolateCatmullRom=function(a,b){var c=[],d=[],e,f,g,h,i,j;e=(a.length-1)*b;f=Math.floor(e);e=e-f;c[0]=f===0?f:f-1;c[1]=f;c[2]=f>a.length-2?f:f+1;c[3]=f>a.length-3?f:f+2;f=a[c[0]];h=a[c[1]];i=a[c[2]];j=a[c[3]];c=e*e;g=e*c;d[0]=this.interpolate(f[0],h[0],i[0],j[0],e,c,g);d[1]=this.interpolate(f[1],h[1],i[1],j[1],e,c,g);d[2]=this.interpolate(f[2],h[2],i[2],j[2],e,c,g);return d};
THREE.Animation.prototype.interpolate=function(a,b,c,d,e,f,g){a=(c-a)*0.5;d=(d-b)*0.5;return(2*(b-c)+a+d)*g+(-3*(b-c)-2*a-d)*f+a*e+b};THREE.Animation.prototype.getNextKeyWith=function(a,b,c){for(var d=this.data.hierarchy[b].keys,c=this.interpolationType===THREE.AnimationHandler.CATMULLROM||this.interpolationType===THREE.AnimationHandler.CATMULLROM_FORWARD?c<d.length-1?c:d.length-1:c%d.length;c<d.length;c++)if(d[c][a]!==void 0)return d[c];return this.data.hierarchy[b].keys[0]};
THREE.Animation.prototype.getPrevKeyWith=function(a,b,c){for(var d=this.data.hierarchy[b].keys,c=this.interpolationType===THREE.AnimationHandler.CATMULLROM||this.interpolationType===THREE.AnimationHandler.CATMULLROM_FORWARD?c>0?c:0:c>=0?c:c+d.length;c>=0;c--)if(d[c][a]!==void 0)return d[c];return this.data.hierarchy[b].keys[d.length-1]};
THREE.KeyFrameAnimation=function(a,b,c){this.root=a;this.data=THREE.AnimationHandler.get(b);this.hierarchy=THREE.AnimationHandler.parse(a);this.currentTime=0;this.timeScale=0.001;this.isPlaying=false;this.loop=this.isPaused=true;this.JITCompile=c!==void 0?c:true;a=0;for(b=this.hierarchy.length;a<b;a++){var c=this.data.hierarchy[a].sids,d=this.hierarchy[a];if(this.data.hierarchy[a].keys.length&&c){for(var e=0;e<c.length;e++){var f=c[e],g=this.getNextKeyWith(f,a,0);g&&g.apply(f)}d.matrixAutoUpdate=
false;this.data.hierarchy[a].node.updateMatrix();d.matrixWorldNeedsUpdate=true}}};
THREE.KeyFrameAnimation.prototype.play=function(a,b){if(!this.isPlaying){this.isPlaying=true;this.loop=a!==void 0?a:true;this.currentTime=b!==void 0?b:0;this.startTimeMs=b;this.startTime=1E7;this.endTime=-this.startTime;var c,d=this.hierarchy.length,e,f;for(c=0;c<d;c++){e=this.hierarchy[c];f=this.data.hierarchy[c];e.useQuaternion=true;if(f.animationCache===void 0){f.animationCache={};f.animationCache.prevKey=null;f.animationCache.nextKey=null;f.animationCache.originalMatrix=e instanceof THREE.Bone?
e.skinMatrix:e.matrix}e=this.data.hierarchy[c].keys;if(e.length){f.animationCache.prevKey=e[0];f.animationCache.nextKey=e[1];this.startTime=Math.min(e[0].time,this.startTime);this.endTime=Math.max(e[e.length-1].time,this.endTime)}}this.update(0)}this.isPaused=false;THREE.AnimationHandler.addToUpdate(this)};THREE.KeyFrameAnimation.prototype.pause=function(){this.isPaused?THREE.AnimationHandler.addToUpdate(this):THREE.AnimationHandler.removeFromUpdate(this);this.isPaused=!this.isPaused};
THREE.KeyFrameAnimation.prototype.stop=function(){this.isPaused=this.isPlaying=false;THREE.AnimationHandler.removeFromUpdate(this);for(var a=0;a<this.data.hierarchy.length;a++){var b=this.hierarchy[a],c=this.data.hierarchy[a];if(c.animationCache!==void 0){var d=c.animationCache.originalMatrix;if(b instanceof THREE.Bone){d.copy(b.skinMatrix);b.skinMatrix=d}else{d.copy(b.matrix);b.matrix=d}delete c.animationCache}}};
THREE.KeyFrameAnimation.prototype.update=function(a){if(this.isPlaying){var b,c,d,e,f=this.data.JIT.hierarchy,g,h,i;h=this.currentTime=this.currentTime+a*this.timeScale;g=this.currentTime=this.currentTime%this.data.length;if(g<this.startTimeMs)g=this.currentTime=this.startTimeMs+g;e=parseInt(Math.min(g*this.data.fps,this.data.length*this.data.fps),10);if((i=g<h)&&!this.loop){for(var a=0,j=this.hierarchy.length;a<j;a++){var l=this.data.hierarchy[a].keys,f=this.data.hierarchy[a].sids;d=l.length-1;e=
this.hierarchy[a];if(l.length){for(l=0;l<f.length;l++){g=f[l];(h=this.getPrevKeyWith(g,a,d))&&h.apply(g)}this.data.hierarchy[a].node.updateMatrix();e.matrixWorldNeedsUpdate=true}}this.stop()}else if(!(g<this.startTime)){a=0;for(j=this.hierarchy.length;a<j;a++){d=this.hierarchy[a];b=this.data.hierarchy[a];var l=b.keys,m=b.animationCache;if(this.JITCompile&&f[a][e]!==void 0)if(d instanceof THREE.Bone){d.skinMatrix=f[a][e];d.matrixWorldNeedsUpdate=false}else{d.matrix=f[a][e];d.matrixWorldNeedsUpdate=
true}else if(l.length){if(this.JITCompile&&m)d instanceof THREE.Bone?d.skinMatrix=m.originalMatrix:d.matrix=m.originalMatrix;b=m.prevKey;c=m.nextKey;if(b&&c){if(c.time<=h){if(i&&this.loop){b=l[0];for(c=l[1];c.time<g;){b=c;c=l[b.index+1]}}else if(!i)for(var n=l.length-1;c.time<g&&c.index!==n;){b=c;c=l[b.index+1]}m.prevKey=b;m.nextKey=c}c.time>=g?b.interpolate(c,g):b.interpolate(c,c.time)}this.data.hierarchy[a].node.updateMatrix();d.matrixWorldNeedsUpdate=true}}if(this.JITCompile&&f[0][e]===void 0){this.hierarchy[0].updateMatrixWorld(true);
for(a=0;a<this.hierarchy.length;a++)f[a][e]=this.hierarchy[a]instanceof THREE.Bone?this.hierarchy[a].skinMatrix.clone():this.hierarchy[a].matrix.clone()}}}};THREE.KeyFrameAnimation.prototype.getNextKeyWith=function(a,b,c){b=this.data.hierarchy[b].keys;for(c=c%b.length;c<b.length;c++)if(b[c].hasTarget(a))return b[c];return b[0]};
THREE.KeyFrameAnimation.prototype.getPrevKeyWith=function(a,b,c){b=this.data.hierarchy[b].keys;for(c=c>=0?c:c+b.length;c>=0;c--)if(b[c].hasTarget(a))return b[c];return b[b.length-1]};
THREE.CubeCamera=function(a,b,c){THREE.Object3D.call(this);var d=new THREE.PerspectiveCamera(90,1,a,b);d.up.set(0,-1,0);d.lookAt(new THREE.Vector3(1,0,0));this.add(d);var e=new THREE.PerspectiveCamera(90,1,a,b);e.up.set(0,-1,0);e.lookAt(new THREE.Vector3(-1,0,0));this.add(e);var f=new THREE.PerspectiveCamera(90,1,a,b);f.up.set(0,0,1);f.lookAt(new THREE.Vector3(0,1,0));this.add(f);var g=new THREE.PerspectiveCamera(90,1,a,b);g.up.set(0,0,-1);g.lookAt(new THREE.Vector3(0,-1,0));this.add(g);var h=new THREE.PerspectiveCamera(90,
1,a,b);h.up.set(0,-1,0);h.lookAt(new THREE.Vector3(0,0,1));this.add(h);var i=new THREE.PerspectiveCamera(90,1,a,b);i.up.set(0,-1,0);i.lookAt(new THREE.Vector3(0,0,-1));this.add(i);this.renderTarget=new THREE.WebGLRenderTargetCube(c,c,{format:THREE.RGBFormat,magFilter:THREE.LinearFilter,minFilter:THREE.LinearFilter});this.updateCubeMap=function(a,b){var c=this.renderTarget,n=c.generateMipmaps;c.generateMipmaps=false;c.activeCubeFace=0;a.render(b,d,c);c.activeCubeFace=1;a.render(b,e,c);c.activeCubeFace=
2;a.render(b,f,c);c.activeCubeFace=3;a.render(b,g,c);c.activeCubeFace=4;a.render(b,h,c);c.generateMipmaps=n;c.activeCubeFace=5;a.render(b,i,c)}};THREE.CubeCamera.prototype=Object.create(THREE.Object3D.prototype);THREE.CombinedCamera=function(a,b,c,d,e,f,g){THREE.Camera.call(this);this.fov=c;this.left=-a/2;this.right=a/2;this.top=b/2;this.bottom=-b/2;this.cameraO=new THREE.OrthographicCamera(a/-2,a/2,b/2,b/-2,f,g);this.cameraP=new THREE.PerspectiveCamera(c,a/b,d,e);this.zoom=1;this.toPerspective()};
THREE.CombinedCamera.prototype=Object.create(THREE.Camera.prototype);THREE.CombinedCamera.prototype.toPerspective=function(){this.near=this.cameraP.near;this.far=this.cameraP.far;this.cameraP.fov=this.fov/this.zoom;this.cameraP.updateProjectionMatrix();this.projectionMatrix=this.cameraP.projectionMatrix;this.inPerspectiveMode=true;this.inOrthographicMode=false};
THREE.CombinedCamera.prototype.toOrthographic=function(){var a=this.cameraP.aspect,b=(this.cameraP.near+this.cameraP.far)/2,b=Math.tan(this.fov/2)*b,a=2*b*a/2,b=b/this.zoom,a=a/this.zoom;this.cameraO.left=-a;this.cameraO.right=a;this.cameraO.top=b;this.cameraO.bottom=-b;this.cameraO.updateProjectionMatrix();this.near=this.cameraO.near;this.far=this.cameraO.far;this.projectionMatrix=this.cameraO.projectionMatrix;this.inPerspectiveMode=false;this.inOrthographicMode=true};
THREE.CombinedCamera.prototype.setSize=function(a,b){this.cameraP.aspect=a/b;this.left=-a/2;this.right=a/2;this.top=b/2;this.bottom=-b/2};THREE.CombinedCamera.prototype.setFov=function(a){this.fov=a;this.inPerspectiveMode?this.toPerspective():this.toOrthographic()};THREE.CombinedCamera.prototype.updateProjectionMatrix=function(){if(this.inPerspectiveMode)this.toPerspective();else{this.toPerspective();this.toOrthographic()}};
THREE.CombinedCamera.prototype.setLens=function(a,b){b===void 0&&(b=24);var c=2*Math.atan(b/(a*2))*(180/Math.PI);this.setFov(c);return c};THREE.CombinedCamera.prototype.setZoom=function(a){this.zoom=a;this.inPerspectiveMode?this.toPerspective():this.toOrthographic()};THREE.CombinedCamera.prototype.toFrontView=function(){this.rotation.x=0;this.rotation.y=0;this.rotation.z=0;this.rotationAutoUpdate=false};
THREE.CombinedCamera.prototype.toBackView=function(){this.rotation.x=0;this.rotation.y=Math.PI;this.rotation.z=0;this.rotationAutoUpdate=false};THREE.CombinedCamera.prototype.toLeftView=function(){this.rotation.x=0;this.rotation.y=-Math.PI/2;this.rotation.z=0;this.rotationAutoUpdate=false};THREE.CombinedCamera.prototype.toRightView=function(){this.rotation.x=0;this.rotation.y=Math.PI/2;this.rotation.z=0;this.rotationAutoUpdate=false};
THREE.CombinedCamera.prototype.toTopView=function(){this.rotation.x=-Math.PI/2;this.rotation.y=0;this.rotation.z=0;this.rotationAutoUpdate=false};THREE.CombinedCamera.prototype.toBottomView=function(){this.rotation.x=Math.PI/2;this.rotation.y=0;this.rotation.z=0;this.rotationAutoUpdate=false};
THREE.CircleGeometry=function(a,b,c,d){THREE.Geometry.call(this);var a=a||50,c=c!==void 0?c:0,d=d!==void 0?d:Math.PI*2,b=b!==void 0?Math.max(3,b):8,e,f=[];e=new THREE.Vector3;var g=new THREE.UV(0.5,0.5);this.vertices.push(e);f.push(g);for(e=0;e<=b;e++){var h=new THREE.Vector3;h.x=a*Math.cos(c+e/b*d);h.y=a*Math.sin(c+e/b*d);this.vertices.push(h);f.push(new THREE.UV((h.x/a+1)/2,-(h.y/a+1)/2+1))}c=new THREE.Vector3(0,0,-1);for(e=1;e<=b;e++){this.faces.push(new THREE.Face3(e,e+1,0,[c,c,c]));this.faceVertexUvs[0].push([f[e],
f[e+1],g])}this.computeCentroids();this.computeFaceNormals();this.boundingSphere={radius:a}};THREE.CircleGeometry.prototype=Object.create(THREE.Geometry.prototype);
THREE.CubeGeometry=function(a,b,c,d,e,f,g,h){function i(a,b,c,g,h,i,l,m){var n,o=d||1,p=e||1,q=h/2,r=i/2,t=j.vertices.length;if(a==="x"&&b==="y"||a==="y"&&b==="x")n="z";else if(a==="x"&&b==="z"||a==="z"&&b==="x"){n="y";p=f||1}else if(a==="z"&&b==="y"||a==="y"&&b==="z"){n="x";o=f||1}var u=o+1,B=p+1,$=h/o,Y=i/p,N=new THREE.Vector3;N[n]=l>0?1:-1;for(h=0;h<B;h++)for(i=0;i<u;i++){var ea=new THREE.Vector3;ea[a]=(i*$-q)*c;ea[b]=(h*Y-r)*g;ea[n]=l;j.vertices.push(ea)}for(h=0;h<p;h++)for(i=0;i<o;i++){a=new THREE.Face4(i+
u*h+t,i+u*(h+1)+t,i+1+u*(h+1)+t,i+1+u*h+t);a.normal.copy(N);a.vertexNormals.push(N.clone(),N.clone(),N.clone(),N.clone());a.materialIndex=m;j.faces.push(a);j.faceVertexUvs[0].push([new THREE.UV(i/o,1-h/p),new THREE.UV(i/o,1-(h+1)/p),new THREE.UV((i+1)/o,1-(h+1)/p),new THREE.UV((i+1)/o,1-h/p)])}}THREE.Geometry.call(this);var j=this,l=a/2,m=b/2,n=c/2,p,o,q,r,t,B;if(g!==void 0){if(g instanceof Array)this.materials=g;else{this.materials=[];for(p=0;p<6;p++)this.materials.push(g)}p=0;r=1;o=2;t=3;q=4;B=
5}else this.materials=[];this.sides={px:true,nx:true,py:true,ny:true,pz:true,nz:true};if(h!=void 0)for(var u in h)this.sides[u]!==void 0&&(this.sides[u]=h[u]);this.sides.px&&i("z","y",-1,-1,c,b,l,p);this.sides.nx&&i("z","y",1,-1,c,b,-l,r);this.sides.py&&i("x","z",1,1,a,c,m,o);this.sides.ny&&i("x","z",1,-1,a,c,-m,t);this.sides.pz&&i("x","y",1,-1,a,b,n,q);this.sides.nz&&i("x","y",-1,-1,a,b,-n,B);this.computeCentroids();this.mergeVertices()};THREE.CubeGeometry.prototype=Object.create(THREE.Geometry.prototype);
THREE.CylinderGeometry=function(a,b,c,d,e,f){THREE.Geometry.call(this);var a=a!==void 0?a:20,b=b!==void 0?b:20,c=c!==void 0?c:100,g=c/2,d=d||8,e=e||1,h,i,j=[],l=[];for(i=0;i<=e;i++){var m=[],n=[],p=i/e,o=p*(b-a)+a;for(h=0;h<=d;h++){var q=h/d,r=new THREE.Vector3;r.x=o*Math.sin(q*Math.PI*2);r.y=-p*c+g;r.z=o*Math.cos(q*Math.PI*2);this.vertices.push(r);m.push(this.vertices.length-1);n.push(new THREE.UV(q,1-p))}j.push(m);l.push(n)}c=(b-a)/c;for(h=0;h<d;h++){if(a!==0){m=this.vertices[j[0][h]].clone();n=
this.vertices[j[0][h+1]].clone()}else{m=this.vertices[j[1][h]].clone();n=this.vertices[j[1][h+1]].clone()}m.setY(Math.sqrt(m.x*m.x+m.z*m.z)*c).normalize();n.setY(Math.sqrt(n.x*n.x+n.z*n.z)*c).normalize();for(i=0;i<e;i++){var p=j[i][h],o=j[i+1][h],q=j[i+1][h+1],r=j[i][h+1],t=m.clone(),B=m.clone(),u=n.clone(),s=n.clone(),z=l[i][h].clone(),A=l[i+1][h].clone(),v=l[i+1][h+1].clone(),y=l[i][h+1].clone();this.faces.push(new THREE.Face4(p,o,q,r,[t,B,u,s]));this.faceVertexUvs[0].push([z,A,v,y])}}if(!f&&a>
0){this.vertices.push(new THREE.Vector3(0,g,0));for(h=0;h<d;h++){p=j[0][h];o=j[0][h+1];q=this.vertices.length-1;t=new THREE.Vector3(0,1,0);B=new THREE.Vector3(0,1,0);u=new THREE.Vector3(0,1,0);z=l[0][h].clone();A=l[0][h+1].clone();v=new THREE.UV(A.u,0);this.faces.push(new THREE.Face3(p,o,q,[t,B,u]));this.faceVertexUvs[0].push([z,A,v])}}if(!f&&b>0){this.vertices.push(new THREE.Vector3(0,-g,0));for(h=0;h<d;h++){p=j[i][h+1];o=j[i][h];q=this.vertices.length-1;t=new THREE.Vector3(0,-1,0);B=new THREE.Vector3(0,
-1,0);u=new THREE.Vector3(0,-1,0);z=l[i][h+1].clone();A=l[i][h].clone();v=new THREE.UV(A.u,1);this.faces.push(new THREE.Face3(p,o,q,[t,B,u]));this.faceVertexUvs[0].push([z,A,v])}}this.computeCentroids();this.computeFaceNormals()};THREE.CylinderGeometry.prototype=Object.create(THREE.Geometry.prototype);
THREE.ExtrudeGeometry=function(a,b){if(typeof a!=="undefined"){THREE.Geometry.call(this);a=a instanceof Array?a:[a];this.shapebb=a[a.length-1].getBoundingBox();this.addShapeList(a,b);this.computeCentroids();this.computeFaceNormals()}};THREE.ExtrudeGeometry.prototype=Object.create(THREE.Geometry.prototype);THREE.ExtrudeGeometry.prototype.addShapeList=function(a,b){for(var c=a.length,d=0;d<c;d++)this.addShape(a[d],b)};
THREE.ExtrudeGeometry.prototype.addShape=function(a,b){function c(a,b,c){b||console.log("die");return b.clone().multiplyScalar(c).addSelf(a)}function d(a,b,c){var d=THREE.ExtrudeGeometry.__v1,e=THREE.ExtrudeGeometry.__v2,f=THREE.ExtrudeGeometry.__v3,g=THREE.ExtrudeGeometry.__v4,h=THREE.ExtrudeGeometry.__v5,i=THREE.ExtrudeGeometry.__v6;d.set(a.x-b.x,a.y-b.y);e.set(a.x-c.x,a.y-c.y);d=d.normalize();e=e.normalize();f.set(-d.y,d.x);g.set(e.y,-e.x);h.copy(a).addSelf(f);i.copy(a).addSelf(g);if(h.equals(i))return g.clone();
h.copy(b).addSelf(f);i.copy(c).addSelf(g);f=d.dot(g);g=i.subSelf(h).dot(g);if(f===0){console.log("Either infinite or no solutions!");g===0?console.log("Its finite solutions."):console.log("Too bad, no solutions.")}g=g/f;if(g<0){b=Math.atan2(b.y-a.y,b.x-a.x);a=Math.atan2(c.y-a.y,c.x-a.x);b>a&&(a=a+Math.PI*2);c=(b+a)/2;a=-Math.cos(c);c=-Math.sin(c);return new THREE.Vector2(a,c)}return d.multiplyScalar(g).addSelf(h).subSelf(a).clone()}function e(c,d){var e,f;for(N=c.length;--N>=0;){e=N;f=N-1;f<0&&(f=
c.length-1);for(var g=0,h=n+l*2,g=0;g<h;g++){var i=R*g,j=R*(g+1),m=d+e+i,i=d+f+i,o=d+f+j,j=d+e+j,p=c,q=g,r=h,s=e,u=f,m=m+H,i=i+H,o=o+H,j=j+H;G.faces.push(new THREE.Face4(m,i,o,j,null,null,t));m=B.generateSideWallUV(G,a,p,b,m,i,o,j,q,r,s,u);G.faceVertexUvs[0].push(m)}}}function f(a,b,c){G.vertices.push(new THREE.Vector3(a,b,c))}function g(c,d,e,f){c=c+H;d=d+H;e=e+H;G.faces.push(new THREE.Face3(c,d,e,null,null,r));c=f?B.generateBottomUV(G,a,b,c,d,e):B.generateTopUV(G,a,b,c,d,e);G.faceVertexUvs[0].push(c)}
var h=b.amount!==void 0?b.amount:100,i=b.bevelThickness!==void 0?b.bevelThickness:6,j=b.bevelSize!==void 0?b.bevelSize:i-2,l=b.bevelSegments!==void 0?b.bevelSegments:3,m=b.bevelEnabled!==void 0?b.bevelEnabled:true,n=b.steps!==void 0?b.steps:1,p=b.extrudePath,o,q=false,r=b.material,t=b.extrudeMaterial,B=b.UVGenerator!==void 0?b.UVGenerator:THREE.ExtrudeGeometry.WorldUVGenerator,u,s,z,A;if(p){o=p.getSpacedPoints(n);q=true;m=false;u=b.frames!==void 0?b.frames:new THREE.TubeGeometry.FrenetFrames(p,n,
false);s=new THREE.Vector3;z=new THREE.Vector3;A=new THREE.Vector3}if(!m)j=i=l=0;var v,y,C,G=this,H=this.vertices.length,p=a.extractPoints(),J=p.shape,p=p.holes,E=!THREE.Shape.Utils.isClockWise(J);if(E){J=J.reverse();y=0;for(C=p.length;y<C;y++){v=p[y];THREE.Shape.Utils.isClockWise(v)&&(p[y]=v.reverse())}E=false}var M=THREE.Shape.Utils.triangulateShape(J,p),E=J;y=0;for(C=p.length;y<C;y++){v=p[y];J=J.concat(v)}var K,F,I,L,R=J.length,$=M.length,Y=[],N=0,ea=E.length;K=ea-1;for(F=N+1;N<ea;N++,K++,F++){K===
ea&&(K=0);F===ea&&(F=0);Y[N]=d(E[N],E[K],E[F])}var Q=[],qa,la=Y.concat();y=0;for(C=p.length;y<C;y++){v=p[y];qa=[];N=0;ea=v.length;K=ea-1;for(F=N+1;N<ea;N++,K++,F++){K===ea&&(K=0);F===ea&&(F=0);qa[N]=d(v[N],v[K],v[F])}Q.push(qa);la=la.concat(qa)}for(K=0;K<l;K++){v=K/l;I=i*(1-v);F=j*Math.sin(v*Math.PI/2);N=0;for(ea=E.length;N<ea;N++){L=c(E[N],Y[N],F);f(L.x,L.y,-I)}y=0;for(C=p.length;y<C;y++){v=p[y];qa=Q[y];N=0;for(ea=v.length;N<ea;N++){L=c(v[N],qa[N],F);f(L.x,L.y,-I)}}}F=j;for(N=0;N<R;N++){L=m?c(J[N],
la[N],F):J[N];if(q){z.copy(u.normals[0]).multiplyScalar(L.x);s.copy(u.binormals[0]).multiplyScalar(L.y);A.copy(o[0]).addSelf(z).addSelf(s);f(A.x,A.y,A.z)}else f(L.x,L.y,0)}for(v=1;v<=n;v++)for(N=0;N<R;N++){L=m?c(J[N],la[N],F):J[N];if(q){z.copy(u.normals[v]).multiplyScalar(L.x);s.copy(u.binormals[v]).multiplyScalar(L.y);A.copy(o[v]).addSelf(z).addSelf(s);f(A.x,A.y,A.z)}else f(L.x,L.y,h/n*v)}for(K=l-1;K>=0;K--){v=K/l;I=i*(1-v);F=j*Math.sin(v*Math.PI/2);N=0;for(ea=E.length;N<ea;N++){L=c(E[N],Y[N],F);
f(L.x,L.y,h+I)}y=0;for(C=p.length;y<C;y++){v=p[y];qa=Q[y];N=0;for(ea=v.length;N<ea;N++){L=c(v[N],qa[N],F);q?f(L.x,L.y+o[n-1].y,o[n-1].x+I):f(L.x,L.y,h+I)}}}if(m){i=R*0;for(N=0;N<$;N++){h=M[N];g(h[2]+i,h[1]+i,h[0]+i,true)}i=R*(n+l*2);for(N=0;N<$;N++){h=M[N];g(h[0]+i,h[1]+i,h[2]+i,false)}}else{for(N=0;N<$;N++){h=M[N];g(h[2],h[1],h[0],true)}for(N=0;N<$;N++){h=M[N];g(h[0]+R*n,h[1]+R*n,h[2]+R*n,false)}}h=0;e(E,h);h=h+E.length;y=0;for(C=p.length;y<C;y++){v=p[y];e(v,h);h=h+v.length}};
THREE.ExtrudeGeometry.WorldUVGenerator={generateTopUV:function(a,b,c,d,e,f){b=a.vertices[e].x;e=a.vertices[e].y;c=a.vertices[f].x;f=a.vertices[f].y;return[new THREE.UV(a.vertices[d].x,a.vertices[d].y),new THREE.UV(b,e),new THREE.UV(c,f)]},generateBottomUV:function(a,b,c,d,e,f){return this.generateTopUV(a,b,c,d,e,f)},generateSideWallUV:function(a,b,c,d,e,f,g,h){var b=a.vertices[e].x,c=a.vertices[e].y,e=a.vertices[e].z,d=a.vertices[f].x,i=a.vertices[f].y,f=a.vertices[f].z,j=a.vertices[g].x,l=a.vertices[g].y,
g=a.vertices[g].z,m=a.vertices[h].x,n=a.vertices[h].y,a=a.vertices[h].z;return Math.abs(c-i)<0.01?[new THREE.UV(b,1-e),new THREE.UV(d,1-f),new THREE.UV(j,1-g),new THREE.UV(m,1-a)]:[new THREE.UV(c,1-e),new THREE.UV(i,1-f),new THREE.UV(l,1-g),new THREE.UV(n,1-a)]}};THREE.ExtrudeGeometry.__v1=new THREE.Vector2;THREE.ExtrudeGeometry.__v2=new THREE.Vector2;THREE.ExtrudeGeometry.__v3=new THREE.Vector2;THREE.ExtrudeGeometry.__v4=new THREE.Vector2;THREE.ExtrudeGeometry.__v5=new THREE.Vector2;
THREE.ExtrudeGeometry.__v6=new THREE.Vector2;THREE.ShapeGeometry=function(a,b){THREE.Geometry.call(this);a instanceof Array===false&&(a=[a]);this.shapebb=a[a.length-1].getBoundingBox();this.addShapeList(a,b);this.computeCentroids();this.computeFaceNormals()};THREE.ShapeGeometry.prototype=Object.create(THREE.Geometry.prototype);THREE.ShapeGeometry.prototype.addShapeList=function(a,b){for(var c=0,d=a.length;c<d;c++)this.addShape(a[c],b);return this};
THREE.ShapeGeometry.prototype.addShape=function(a,b){b===void 0&&(b={});var c=b.material,d=b.UVGenerator===void 0?THREE.ExtrudeGeometry.WorldUVGenerator:b.UVGenerator,e,f,g,h=this.vertices.length;e=a.extractPoints();var i=e.shape,j=e.holes;if(!THREE.Shape.Utils.isClockWise(i)){i=i.reverse();e=0;for(f=j.length;e<f;e++){g=j[e];THREE.Shape.Utils.isClockWise(g)&&(j[e]=g.reverse())}}var l=THREE.Shape.Utils.triangulateShape(i,j);e=0;for(f=j.length;e<f;e++){g=j[e];i=i.concat(g)}j=i.length;f=l.length;for(e=
0;e<j;e++){g=i[e];this.vertices.push(new THREE.Vector3(g.x,g.y,0))}for(e=0;e<f;e++){j=l[e];i=j[0]+h;g=j[1]+h;j=j[2]+h;this.faces.push(new THREE.Face3(i,g,j,null,null,c));this.faceVertexUvs[0].push(d.generateBottomUV(this,a,b,i,g,j))}};
THREE.LatheGeometry=function(a,b,c){THREE.Geometry.call(this);for(var b=b||12,c=c||2*Math.PI,d=[],e=(new THREE.Matrix4).makeRotationZ(c/b),f=0;f<a.length;f++){d[f]=a[f].clone();this.vertices.push(d[f])}for(var g=b+1,c=0;c<g;c++)for(f=0;f<d.length;f++){d[f]=e.multiplyVector3(d[f].clone());this.vertices.push(d[f])}for(c=0;c<b;c++){d=0;for(e=a.length;d<e-1;d++){this.faces.push(new THREE.Face4(c*e+d,(c+1)%g*e+d,(c+1)%g*e+(d+1)%e,c*e+(d+1)%e));this.faceVertexUvs[0].push([new THREE.UV(1-c/b,d/e),new THREE.UV(1-
(c+1)/b,d/e),new THREE.UV(1-(c+1)/b,(d+1)/e),new THREE.UV(1-c/b,(d+1)/e)])}}this.computeCentroids();this.computeFaceNormals();this.computeVertexNormals()};THREE.LatheGeometry.prototype=Object.create(THREE.Geometry.prototype);
THREE.PlaneGeometry=function(a,b,c,d){THREE.Geometry.call(this);for(var e=a/2,f=b/2,c=c||1,d=d||1,g=c+1,h=d+1,i=a/c,j=b/d,l=new THREE.Vector3(0,0,1),a=0;a<h;a++)for(b=0;b<g;b++)this.vertices.push(new THREE.Vector3(b*i-e,-(a*j-f),0));for(a=0;a<d;a++)for(b=0;b<c;b++){e=new THREE.Face4(b+g*a,b+g*(a+1),b+1+g*(a+1),b+1+g*a);e.normal.copy(l);e.vertexNormals.push(l.clone(),l.clone(),l.clone(),l.clone());this.faces.push(e);this.faceVertexUvs[0].push([new THREE.UV(b/c,1-a/d),new THREE.UV(b/c,1-(a+1)/d),new THREE.UV((b+
1)/c,1-(a+1)/d),new THREE.UV((b+1)/c,1-a/d)])}this.computeCentroids()};THREE.PlaneGeometry.prototype=Object.create(THREE.Geometry.prototype);
THREE.SphereGeometry=function(a,b,c,d,e,f,g){THREE.Geometry.call(this);var a=a||50,d=d!==void 0?d:0,e=e!==void 0?e:Math.PI*2,f=f!==void 0?f:0,g=g!==void 0?g:Math.PI,b=Math.max(3,Math.floor(b)||8),c=Math.max(2,Math.floor(c)||6),h,i,j=[],l=[];for(i=0;i<=c;i++){var m=[],n=[];for(h=0;h<=b;h++){var p=h/b,o=i/c,q=new THREE.Vector3;q.x=-a*Math.cos(d+p*e)*Math.sin(f+o*g);q.y=a*Math.cos(f+o*g);q.z=a*Math.sin(d+p*e)*Math.sin(f+o*g);this.vertices.push(q);m.push(this.vertices.length-1);n.push(new THREE.UV(p,
1-o))}j.push(m);l.push(n)}for(i=0;i<c;i++)for(h=0;h<b;h++){var d=j[i][h+1],e=j[i][h],f=j[i+1][h],g=j[i+1][h+1],m=this.vertices[d].clone().normalize(),n=this.vertices[e].clone().normalize(),p=this.vertices[f].clone().normalize(),o=this.vertices[g].clone().normalize(),q=l[i][h+1].clone(),r=l[i][h].clone(),t=l[i+1][h].clone(),B=l[i+1][h+1].clone();if(Math.abs(this.vertices[d].y)==a){this.faces.push(new THREE.Face3(d,f,g,[m,p,o]));this.faceVertexUvs[0].push([q,t,B])}else if(Math.abs(this.vertices[f].y)==
a){this.faces.push(new THREE.Face3(d,e,f,[m,n,p]));this.faceVertexUvs[0].push([q,r,t])}else{this.faces.push(new THREE.Face4(d,e,f,g,[m,n,p,o]));this.faceVertexUvs[0].push([q,r,t,B])}}this.computeCentroids();this.computeFaceNormals();this.boundingSphere={radius:a}};THREE.SphereGeometry.prototype=Object.create(THREE.Geometry.prototype);
THREE.TextGeometry=function(a,b){var c=THREE.FontUtils.generateShapes(a,b);b.amount=b.height!==void 0?b.height:50;if(b.bevelThickness===void 0)b.bevelThickness=10;if(b.bevelSize===void 0)b.bevelSize=8;if(b.bevelEnabled===void 0)b.bevelEnabled=false;THREE.ExtrudeGeometry.call(this,c,b)};THREE.TextGeometry.prototype=Object.create(THREE.ExtrudeGeometry.prototype);
THREE.TorusGeometry=function(a,b,c,d,e){THREE.Geometry.call(this);this.radius=a||100;this.tube=b||40;this.radialSegments=c||8;this.tubularSegments=d||6;this.arc=e||Math.PI*2;e=new THREE.Vector3;a=[];b=[];for(c=0;c<=this.radialSegments;c++)for(d=0;d<=this.tubularSegments;d++){var f=d/this.tubularSegments*this.arc,g=c/this.radialSegments*Math.PI*2;e.x=this.radius*Math.cos(f);e.y=this.radius*Math.sin(f);var h=new THREE.Vector3;h.x=(this.radius+this.tube*Math.cos(g))*Math.cos(f);h.y=(this.radius+this.tube*
Math.cos(g))*Math.sin(f);h.z=this.tube*Math.sin(g);this.vertices.push(h);a.push(new THREE.UV(d/this.tubularSegments,c/this.radialSegments));b.push(h.clone().subSelf(e).normalize())}for(c=1;c<=this.radialSegments;c++)for(d=1;d<=this.tubularSegments;d++){var e=(this.tubularSegments+1)*c+d-1,f=(this.tubularSegments+1)*(c-1)+d-1,g=(this.tubularSegments+1)*(c-1)+d,h=(this.tubularSegments+1)*c+d,i=new THREE.Face4(e,f,g,h,[b[e],b[f],b[g],b[h]]);i.normal.addSelf(b[e]);i.normal.addSelf(b[f]);i.normal.addSelf(b[g]);
i.normal.addSelf(b[h]);i.normal.normalize();this.faces.push(i);this.faceVertexUvs[0].push([a[e].clone(),a[f].clone(),a[g].clone(),a[h].clone()])}this.computeCentroids()};THREE.TorusGeometry.prototype=Object.create(THREE.Geometry.prototype);
THREE.TorusKnotGeometry=function(a,b,c,d,e,f,g){function h(a,b,c,d,e,f){var g=Math.cos(a);Math.cos(b);b=Math.sin(a);a=c/d*a;c=Math.cos(a);g=e*(2+c)*0.5*g;b=e*(2+c)*b*0.5;e=f*e*Math.sin(a)*0.5;return new THREE.Vector3(g,b,e)}THREE.Geometry.call(this);this.radius=a||200;this.tube=b||40;this.radialSegments=c||64;this.tubularSegments=d||8;this.p=e||2;this.q=f||3;this.heightScale=g||1;this.grid=Array(this.radialSegments);c=new THREE.Vector3;d=new THREE.Vector3;e=new THREE.Vector3;for(a=0;a<this.radialSegments;++a){this.grid[a]=
Array(this.tubularSegments);for(b=0;b<this.tubularSegments;++b){var i=a/this.radialSegments*2*this.p*Math.PI,g=b/this.tubularSegments*2*Math.PI,f=h(i,g,this.q,this.p,this.radius,this.heightScale),i=h(i+0.01,g,this.q,this.p,this.radius,this.heightScale);c.sub(i,f);d.add(i,f);e.cross(c,d);d.cross(e,c);e.normalize();d.normalize();i=-this.tube*Math.cos(g);g=this.tube*Math.sin(g);f.x=f.x+(i*d.x+g*e.x);f.y=f.y+(i*d.y+g*e.y);f.z=f.z+(i*d.z+g*e.z);this.grid[a][b]=this.vertices.push(new THREE.Vector3(f.x,
f.y,f.z))-1}}for(a=0;a<this.radialSegments;++a)for(b=0;b<this.tubularSegments;++b){var e=(a+1)%this.radialSegments,f=(b+1)%this.tubularSegments,c=this.grid[a][b],d=this.grid[e][b],e=this.grid[e][f],f=this.grid[a][f],g=new THREE.UV(a/this.radialSegments,b/this.tubularSegments),i=new THREE.UV((a+1)/this.radialSegments,b/this.tubularSegments),j=new THREE.UV((a+1)/this.radialSegments,(b+1)/this.tubularSegments),l=new THREE.UV(a/this.radialSegments,(b+1)/this.tubularSegments);this.faces.push(new THREE.Face4(c,
d,e,f));this.faceVertexUvs[0].push([g,i,j,l])}this.computeCentroids();this.computeFaceNormals();this.computeVertexNormals()};THREE.TorusKnotGeometry.prototype=Object.create(THREE.Geometry.prototype);
THREE.TubeGeometry=function(a,b,c,d,e,f){THREE.Geometry.call(this);this.path=a;this.segments=b||64;this.radius=c||1;this.radiusSegments=d||8;this.closed=e||false;if(f)this.debug=new THREE.Object3D;this.grid=[];var g,h,f=this.segments+1,i,j,l,m=new THREE.Vector3,n,p,o,b=new THREE.TubeGeometry.FrenetFrames(a,b,e);n=b.tangents;p=b.normals;o=b.binormals;this.tangents=n;this.normals=p;this.binormals=o;for(b=0;b<f;b++){this.grid[b]=[];d=b/(f-1);l=a.getPointAt(d);d=n[b];g=p[b];h=o[b];if(this.debug){this.debug.add(new THREE.ArrowHelper(d,
l,c,255));this.debug.add(new THREE.ArrowHelper(g,l,c,16711680));this.debug.add(new THREE.ArrowHelper(h,l,c,65280))}for(d=0;d<this.radiusSegments;d++){i=d/this.radiusSegments*2*Math.PI;j=-this.radius*Math.cos(i);i=this.radius*Math.sin(i);m.copy(l);m.x=m.x+(j*g.x+i*h.x);m.y=m.y+(j*g.y+i*h.y);m.z=m.z+(j*g.z+i*h.z);this.grid[b][d]=this.vertices.push(new THREE.Vector3(m.x,m.y,m.z))-1}}for(b=0;b<this.segments;b++)for(d=0;d<this.radiusSegments;d++){f=e?(b+1)%this.segments:b+1;m=(d+1)%this.radiusSegments;
a=this.grid[b][d];c=this.grid[f][d];f=this.grid[f][m];m=this.grid[b][m];n=new THREE.UV(b/this.segments,d/this.radiusSegments);p=new THREE.UV((b+1)/this.segments,d/this.radiusSegments);o=new THREE.UV((b+1)/this.segments,(d+1)/this.radiusSegments);g=new THREE.UV(b/this.segments,(d+1)/this.radiusSegments);this.faces.push(new THREE.Face4(a,c,f,m));this.faceVertexUvs[0].push([n,p,o,g])}this.computeCentroids();this.computeFaceNormals();this.computeVertexNormals()};THREE.TubeGeometry.prototype=Object.create(THREE.Geometry.prototype);
THREE.TubeGeometry.FrenetFrames=function(a,b,c){new THREE.Vector3;var d=new THREE.Vector3;new THREE.Vector3;var e=[],f=[],g=[],h=new THREE.Vector3,i=new THREE.Matrix4,b=b+1,j,l,m;this.tangents=e;this.normals=f;this.binormals=g;for(j=0;j<b;j++){l=j/(b-1);e[j]=a.getTangentAt(l);e[j].normalize()}f[0]=new THREE.Vector3;g[0]=new THREE.Vector3;a=Number.MAX_VALUE;j=Math.abs(e[0].x);l=Math.abs(e[0].y);m=Math.abs(e[0].z);if(j<=a){a=j;d.set(1,0,0)}if(l<=a){a=l;d.set(0,1,0)}m<=a&&d.set(0,0,1);h.cross(e[0],d).normalize();
f[0].cross(e[0],h);g[0].cross(e[0],f[0]);for(j=1;j<b;j++){f[j]=f[j-1].clone();g[j]=g[j-1].clone();h.cross(e[j-1],e[j]);if(h.length()>1E-4){h.normalize();d=Math.acos(e[j-1].dot(e[j]));i.makeRotationAxis(h,d).multiplyVector3(f[j])}g[j].cross(e[j],f[j])}if(c){d=Math.acos(f[0].dot(f[b-1]));d=d/(b-1);e[0].dot(h.cross(f[0],f[b-1]))>0&&(d=-d);for(j=1;j<b;j++){i.makeRotationAxis(e[j],d*j).multiplyVector3(f[j]);g[j].cross(e[j],f[j])}}};
THREE.PolyhedronGeometry=function(a,b,c,d){function e(a){var b=a.normalize().clone();b.index=i.vertices.push(b)-1;var c=Math.atan2(a.z,-a.x)/2/Math.PI+0.5,a=Math.atan2(-a.y,Math.sqrt(a.x*a.x+a.z*a.z))/Math.PI+0.5;b.uv=new THREE.UV(c,1-a);return b}function f(a,b,c,d){if(d<1){d=new THREE.Face3(a.index,b.index,c.index,[a.clone(),b.clone(),c.clone()]);d.centroid.addSelf(a).addSelf(b).addSelf(c).divideScalar(3);d.normal=d.centroid.clone().normalize();i.faces.push(d);d=Math.atan2(d.centroid.z,-d.centroid.x);
i.faceVertexUvs[0].push([h(a.uv,a,d),h(b.uv,b,d),h(c.uv,c,d)])}else{d=d-1;f(a,g(a,b),g(a,c),d);f(g(a,b),b,g(b,c),d);f(g(a,c),g(b,c),c,d);f(g(a,b),g(b,c),g(a,c),d)}}function g(a,b){m[a.index]||(m[a.index]=[]);m[b.index]||(m[b.index]=[]);var c=m[a.index][b.index];c===void 0&&(m[a.index][b.index]=m[b.index][a.index]=c=e((new THREE.Vector3).add(a,b).divideScalar(2)));return c}function h(a,b,c){c<0&&a.u===1&&(a=new THREE.UV(a.u-1,a.v));b.x===0&&b.z===0&&(a=new THREE.UV(c/2/Math.PI+0.5,a.v));return a}THREE.Geometry.call(this);
for(var c=c||1,d=d||0,i=this,j=0,l=a.length;j<l;j++)e(new THREE.Vector3(a[j][0],a[j][1],a[j][2]));for(var m=[],a=this.vertices,j=0,l=b.length;j<l;j++)f(a[b[j][0]],a[b[j][1]],a[b[j][2]],d);this.mergeVertices();j=0;for(l=this.vertices.length;j<l;j++)this.vertices[j].multiplyScalar(c);this.computeCentroids();this.boundingSphere={radius:c}};THREE.PolyhedronGeometry.prototype=Object.create(THREE.Geometry.prototype);
THREE.IcosahedronGeometry=function(a,b){var c=(1+Math.sqrt(5))/2;THREE.PolyhedronGeometry.call(this,[[-1,c,0],[1,c,0],[-1,-c,0],[1,-c,0],[0,-1,c],[0,1,c],[0,-1,-c],[0,1,-c],[c,0,-1],[c,0,1],[-c,0,-1],[-c,0,1]],[[0,11,5],[0,5,1],[0,1,7],[0,7,10],[0,10,11],[1,5,9],[5,11,4],[11,10,2],[10,7,6],[7,1,8],[3,9,4],[3,4,2],[3,2,6],[3,6,8],[3,8,9],[4,9,5],[2,4,11],[6,2,10],[8,6,7],[9,8,1]],a,b)};THREE.IcosahedronGeometry.prototype=Object.create(THREE.Geometry.prototype);
THREE.OctahedronGeometry=function(a,b){THREE.PolyhedronGeometry.call(this,[[1,0,0],[-1,0,0],[0,1,0],[0,-1,0],[0,0,1],[0,0,-1]],[[0,2,4],[0,4,3],[0,3,5],[0,5,2],[1,2,5],[1,5,3],[1,3,4],[1,4,2]],a,b)};THREE.OctahedronGeometry.prototype=Object.create(THREE.Geometry.prototype);THREE.TetrahedronGeometry=function(a,b){THREE.PolyhedronGeometry.call(this,[[1,1,1],[-1,-1,1],[-1,1,-1],[1,-1,-1]],[[2,1,0],[0,3,2],[1,3,0],[2,3,1]],a,b)};THREE.TetrahedronGeometry.prototype=Object.create(THREE.Geometry.prototype);
THREE.ParametricGeometry=function(a,b,c,d){THREE.Geometry.call(this);var e=this.vertices,f=this.faces,g=this.faceVertexUvs[0],d=d===void 0?false:d,h,i,j,l,m=b+1;for(h=0;h<=c;h++){l=h/c;for(i=0;i<=b;i++){j=i/b;j=a(j,l);e.push(j)}}var n,p,o,q;for(h=0;h<c;h++)for(i=0;i<b;i++){a=h*m+i;e=h*m+i+1;l=(h+1)*m+i;j=(h+1)*m+i+1;n=new THREE.UV(i/b,h/c);p=new THREE.UV((i+1)/b,h/c);o=new THREE.UV(i/b,(h+1)/c);q=new THREE.UV((i+1)/b,(h+1)/c);if(d){f.push(new THREE.Face3(a,e,l));f.push(new THREE.Face3(e,j,l));g.push([n,
p,o]);g.push([p,q,o])}else{f.push(new THREE.Face4(a,e,j,l));g.push([n,p,q,o])}}this.computeCentroids();this.computeFaceNormals();this.computeVertexNormals()};THREE.ParametricGeometry.prototype=Object.create(THREE.Geometry.prototype);
THREE.ConvexGeometry=function(a){function b(a){var b=a.length();return new THREE.UV(a.x/b,a.y/b)}THREE.Geometry.call(this);for(var c=[[0,1,2],[0,2,1]],d=3;d<a.length;d++){var e=d,f=a[e].clone(),g=f.length();f.x=f.x+g*(Math.random()-0.5)*2E-6;f.y=f.y+g*(Math.random()-0.5)*2E-6;f.z=f.z+g*(Math.random()-0.5)*2E-6;for(var g=[],h=0;h<c.length;){var i=c[h],j=f,l=a[i[0]],m;m=l;var n=a[i[1]],p=a[i[2]],o=new THREE.Vector3,q=new THREE.Vector3;o.sub(p,n);q.sub(m,n);o.crossSelf(q);o.isZero()||o.normalize();m=
o;l=m.dot(l);if(m.dot(j)>=l){for(j=0;j<3;j++){l=[i[j],i[(j+1)%3]];m=true;for(n=0;n<g.length;n++)if(g[n][0]===l[1]&&g[n][1]===l[0]){g[n]=g[g.length-1];g.pop();m=false;break}m&&g.push(l)}c[h]=c[c.length-1];c.pop()}else h++}for(n=0;n<g.length;n++)c.push([g[n][0],g[n][1],e])}e=0;f=Array(a.length);for(d=0;d<c.length;d++){g=c[d];for(h=0;h<3;h++){if(f[g[h]]===void 0){f[g[h]]=e++;this.vertices.push(a[g[h]])}g[h]=f[g[h]]}}for(d=0;d<c.length;d++)this.faces.push(new THREE.Face3(c[d][0],c[d][1],c[d][2]));for(d=
0;d<this.faces.length;d++){g=this.faces[d];this.faceVertexUvs[0].push([b(this.vertices[g.a]),b(this.vertices[g.b]),b(this.vertices[g.c])])}this.computeCentroids();this.computeFaceNormals();this.computeVertexNormals()};THREE.ConvexGeometry.prototype=Object.create(THREE.Geometry.prototype);
THREE.AxisHelper=function(a){var b=new THREE.Geometry;b.vertices.push(new THREE.Vector3,new THREE.Vector3(a||1,0,0),new THREE.Vector3,new THREE.Vector3(0,a||1,0),new THREE.Vector3,new THREE.Vector3(0,0,a||1));b.colors.push(new THREE.Color(16711680),new THREE.Color(16755200),new THREE.Color(65280),new THREE.Color(11206400),new THREE.Color(255),new THREE.Color(43775));a=new THREE.LineBasicMaterial({vertexColors:THREE.VertexColors});THREE.Line.call(this,b,a,THREE.LinePieces)};
THREE.AxisHelper.prototype=Object.create(THREE.Line.prototype);
THREE.ArrowHelper=function(a,b,c,d){THREE.Object3D.call(this);d===void 0&&(d=16776960);c===void 0&&(c=20);var e=new THREE.Geometry;e.vertices.push(new THREE.Vector3(0,0,0));e.vertices.push(new THREE.Vector3(0,1,0));this.line=new THREE.Line(e,new THREE.LineBasicMaterial({color:d}));this.add(this.line);e=new THREE.CylinderGeometry(0,0.05,0.25,5,1);this.cone=new THREE.Mesh(e,new THREE.MeshBasicMaterial({color:d}));this.cone.position.set(0,1,0);this.add(this.cone);if(b instanceof THREE.Vector3)this.position=
b;this.setDirection(a);this.setLength(c)};THREE.ArrowHelper.prototype=Object.create(THREE.Object3D.prototype);THREE.ArrowHelper.prototype.setDirection=function(a){var b=(new THREE.Vector3(0,1,0)).crossSelf(a),a=Math.acos((new THREE.Vector3(0,1,0)).dot(a.clone().normalize()));this.matrix=(new THREE.Matrix4).makeRotationAxis(b.normalize(),a);this.rotation.setEulerFromRotationMatrix(this.matrix,this.eulerOrder)};THREE.ArrowHelper.prototype.setLength=function(a){this.scale.set(a,a,a)};
THREE.ArrowHelper.prototype.setColor=function(a){this.line.material.color.setHex(a);this.cone.material.color.setHex(a)};
THREE.CameraHelper=function(a){function b(a,b,d){c(a,d);c(b,d)}function c(a,b){d.geometry.vertices.push(new THREE.Vector3);d.geometry.colors.push(new THREE.Color(b));d.pointMap[a]===void 0&&(d.pointMap[a]=[]);d.pointMap[a].push(d.geometry.vertices.length-1)}THREE.Line.call(this);var d=this;this.geometry=new THREE.Geometry;this.material=new THREE.LineBasicMaterial({color:16777215,vertexColors:THREE.FaceColors});this.type=THREE.LinePieces;this.matrixWorld=a.matrixWorld;this.matrixAutoUpdate=false;this.pointMap=
{};b("n1","n2",16755200);b("n2","n4",16755200);b("n4","n3",16755200);b("n3","n1",16755200);b("f1","f2",16755200);b("f2","f4",16755200);b("f4","f3",16755200);b("f3","f1",16755200);b("n1","f1",16755200);b("n2","f2",16755200);b("n3","f3",16755200);b("n4","f4",16755200);b("p","n1",16711680);b("p","n2",16711680);b("p","n3",16711680);b("p","n4",16711680);b("u1","u2",43775);b("u2","u3",43775);b("u3","u1",43775);b("c","t",16777215);b("p","c",3355443);b("cn1","cn2",3355443);b("cn3","cn4",3355443);b("cf1",
"cf2",3355443);b("cf3","cf4",3355443);this.camera=a;this.update(a)};THREE.CameraHelper.prototype=Object.create(THREE.Line.prototype);
THREE.CameraHelper.prototype.update=function(){function a(a,d,e,f){THREE.CameraHelper.__v.set(d,e,f);THREE.CameraHelper.__projector.unprojectVector(THREE.CameraHelper.__v,THREE.CameraHelper.__c);a=b.pointMap[a];if(a!==void 0){d=0;for(e=a.length;d<e;d++)b.geometry.vertices[a[d]].copy(THREE.CameraHelper.__v)}}var b=this;THREE.CameraHelper.__c.projectionMatrix.copy(this.camera.projectionMatrix);a("c",0,0,-1);a("t",0,0,1);a("n1",-1,-1,-1);a("n2",1,-1,-1);a("n3",-1,1,-1);a("n4",1,1,-1);a("f1",-1,-1,1);
a("f2",1,-1,1);a("f3",-1,1,1);a("f4",1,1,1);a("u1",0.7,1.1,-1);a("u2",-0.7,1.1,-1);a("u3",0,2,-1);a("cf1",-1,0,1);a("cf2",1,0,1);a("cf3",0,-1,1);a("cf4",0,1,1);a("cn1",-1,0,-1);a("cn2",1,0,-1);a("cn3",0,-1,-1);a("cn4",0,1,-1);this.geometry.verticesNeedUpdate=true};THREE.CameraHelper.__projector=new THREE.Projector;THREE.CameraHelper.__v=new THREE.Vector3;THREE.CameraHelper.__c=new THREE.Camera;
THREE.SubdivisionModifier=function(a){this.subdivisions=a===void 0?1:a;this.useOldVertexColors=false;this.supportUVs=true;this.debug=false};THREE.SubdivisionModifier.prototype.modify=function(a){for(var b=this.subdivisions;b-- >0;)this.smooth(a)};THREE.GeometryUtils.orderedKey=function(a,b){return Math.min(a,b)+"_"+Math.max(a,b)};
THREE.GeometryUtils.computeEdgeFaces=function(a){function b(a,b){g[a]===void 0&&(g[a]=[]);g[a].push(b)}var c,d,e,f,g={},h=THREE.GeometryUtils.orderedKey;c=0;for(d=a.faces.length;c<d;c++){e=a.faces[c];if(e instanceof THREE.Face3){f=h(e.a,e.b);b(f,c);f=h(e.b,e.c);b(f,c);f=h(e.c,e.a);b(f,c)}else if(e instanceof THREE.Face4){f=h(e.a,e.b);b(f,c);f=h(e.b,e.c);b(f,c);f=h(e.c,e.d);b(f,c);f=h(e.d,e.a);b(f,c)}}return g};
THREE.SubdivisionModifier.prototype.smooth=function(a){function b(){l.debug&&(console&&console.assert)&&console.assert.apply(console,arguments)}function c(){l.debug&&console.log.apply(console,arguments)}function d(){console&&console.log.apply(console,arguments)}function e(a,b,d,e,g,h,m){var n=new THREE.Face4(a,b,d,e,null,g.color,g.materialIndex);if(l.useOldVertexColors){n.vertexColors=[];for(var o,p,q,r=0;r<4;r++){q=h[r];o=new THREE.Color;o.setRGB(0,0,0);for(var s=0;s<q.length;s++){p=g.vertexColors[q[s]-
1];o.r=o.r+p.r;o.g=o.g+p.g;o.b=o.b+p.b}o.r=o.r/q.length;o.g=o.g/q.length;o.b=o.b/q.length;n.vertexColors[r]=o}}i.push(n);if(l.supportUVs){g=[f(a,""),f(b,m),f(d,m),f(e,m)];g[0]?g[1]?g[2]?g[3]?j.push(g):c("d :( ",e+":"+m):c("c :( ",d+":"+m):c("b :( ",b+":"+m):c("a :( ",a+":"+m)}}function f(a,b){var e=a+":"+b,f=u[e];if(!f){a>=q&&a<q+o.length?c("face pt"):c("edge pt");d("warning, UV not found for",e);return null}return f}function g(a,b,c){var e=a+":"+b;e in u?d("dup vertexNo",a,"oldFaceNo",b,"value",
c,"key",e,u[e]):u[e]=c}var h=[],i=[],j=[],l=this,m=THREE.GeometryUtils.orderedKey,n=THREE.GeometryUtils.computeEdgeFaces,p=a.vertices,o=a.faces,q=p.length,h=p.concat(),r=[],t={},B={},u={},s,z,A,v,y,C=a.faceVertexUvs[0],G;c("originalFaces, uvs, originalVerticesLength",o.length,C.length,q);if(l.supportUVs){s=0;for(z=C.length;s<z;s++){A=0;for(v=C[s].length;A<v;A++){G=o[s]["abcd".charAt(A)];g(G,s,C[s][A])}}}if(C.length==0)l.supportUVs=false;s=0;for(var H in u)s++;if(!s){l.supportUVs=false;c("no uvs")}s=
0;for(z=o.length;s<z;s++){y=o[s];r.push(y.centroid);h.push(y.centroid);if(l.supportUVs){v=new THREE.UV;if(y instanceof THREE.Face3){v.u=f(y.a,s).u+f(y.b,s).u+f(y.c,s).u;v.v=f(y.a,s).v+f(y.b,s).v+f(y.c,s).v;v.u=v.u/3;v.v=v.v/3}else if(y instanceof THREE.Face4){v.u=f(y.a,s).u+f(y.b,s).u+f(y.c,s).u+f(y.d,s).u;v.v=f(y.a,s).v+f(y.b,s).v+f(y.c,s).v+f(y.d,s).v;v.u=v.u/4;v.v=v.v/4}g(q+s,"",v)}}var n=n(a),J;z=0;var E,M;H={};C={};for(s in n){G=n[s];E=s.split("_");M=E[0];E=E[1];A=M;y=[M,E];H[A]===void 0&&(H[A]=
[]);H[A].push(y);A=E;y=[M,E];H[A]===void 0&&(H[A]=[]);H[A].push(y);A=0;for(v=G.length;A<v;A++){y=G[A];J=M;var K=y,F=s;C[J]===void 0&&(C[J]={});C[J][K]=F;J=E;K=s;C[J]===void 0&&(C[J]={});C[J][y]=K}G.length<2&&(B[s]=true)}for(s in n){G=n[s];y=G[0];J=G[1];E=s.split("_");M=E[0];E=E[1];v=new THREE.Vector3;b(G.length>0,"an edge without faces?!");if(G.length==1){v.addSelf(p[M]);v.addSelf(p[E]);v.multiplyScalar(0.5)}else{v.addSelf(r[y]);v.addSelf(r[J]);v.addSelf(p[M]);v.addSelf(p[E]);v.multiplyScalar(0.25)}t[s]=
q+o.length+z;h.push(v);z++;if(l.supportUVs){v=new THREE.UV;v.u=f(M,y).u+f(E,y).u;v.v=f(M,y).v+f(E,y).v;v.u=v.u/2;v.v=v.v/2;g(t[s],y,v);if(G.length>=2){b(G.length==2,"did we plan for more than 2 edges?");v=new THREE.UV;v.u=f(M,J).u+f(E,J).u;v.v=f(M,J).v+f(E,J).v;v.u=v.u/2;v.v=v.v/2;g(t[s],J,v)}}}c("-- Step 2 done");var I,L;v=["123","12","2","23"];J=["123","23","3","31"];var K=["123","31","1","12"],F=["1234","12","2","23"],R=["1234","23","3","34"],$=["1234","34","4","41"],Y=["1234","41","1","12"];s=
0;for(z=r.length;s<z;s++){y=o[s];G=q+s;if(y instanceof THREE.Face3){M=m(y.a,y.b);E=m(y.b,y.c);I=m(y.c,y.a);e(G,t[M],y.b,t[E],y,v,s);e(G,t[E],y.c,t[I],y,J,s);e(G,t[I],y.a,t[M],y,K,s)}else if(y instanceof THREE.Face4){M=m(y.a,y.b);E=m(y.b,y.c);I=m(y.c,y.d);L=m(y.d,y.a);e(G,t[M],y.b,t[E],y,F,s);e(G,t[E],y.c,t[I],y,R,s);e(G,t[I],y.d,t[L],y,$,s);e(G,t[L],y.a,t[M],y,Y,s)}else c("face should be a face!",y)}t=new THREE.Vector3;y=new THREE.Vector3;s=0;for(z=p.length;s<z;s++)if(H[s]!==void 0){t.set(0,0,0);
y.set(0,0,0);E=new THREE.Vector3(0,0,0);G=0;for(A in C[s]){t.addSelf(r[A]);G++}J=0;M=H[s].length;v=G!=M;for(A=0;A<M;A++)B[m(H[s][A][0],H[s][A][1])]&&J++;t.divideScalar(G);J=0;if(v){for(A=0;A<M;A++){G=H[s][A];if(K=n[m(G[0],G[1])].length==1){G=p[G[0]].clone().addSelf(p[G[1]]).divideScalar(2);y.addSelf(G);J++}}y.divideScalar(4);b(J==2,"should have only 2 boundary edges")}else{for(A=0;A<M;A++){G=H[s][A];G=p[G[0]].clone().addSelf(p[G[1]]).divideScalar(2);y.addSelf(G)}y.divideScalar(M)}E.addSelf(p[s]);
if(v){E.divideScalar(2);E.addSelf(y)}else{E.multiplyScalar(M-3);E.addSelf(t);E.addSelf(y.multiplyScalar(2));E.divideScalar(M)}h[s]=E}a.vertices=h;a.faces=i;a.faceVertexUvs[0]=j;delete a.__tmpVertices;a.computeCentroids();a.computeFaceNormals();a.computeVertexNormals()};THREE.ImmediateRenderObject=function(){THREE.Object3D.call(this);this.render=function(){}};THREE.ImmediateRenderObject.prototype=Object.create(THREE.Object3D.prototype);
THREE.LensFlare=function(a,b,c,d,e){THREE.Object3D.call(this);this.lensFlares=[];this.positionScreen=new THREE.Vector3;this.customUpdateCallback=void 0;a!==void 0&&this.add(a,b,c,d,e)};THREE.LensFlare.prototype=Object.create(THREE.Object3D.prototype);
THREE.LensFlare.prototype.add=function(a,b,c,d,e,f){b===void 0&&(b=-1);c===void 0&&(c=0);f===void 0&&(f=1);e===void 0&&(e=new THREE.Color(16777215));if(d===void 0)d=THREE.NormalBlending;c=Math.min(c,Math.max(0,c));this.lensFlares.push({texture:a,size:b,distance:c,x:0,y:0,z:0,scale:1,rotation:1,opacity:f,color:e,blending:d})};
THREE.LensFlare.prototype.updateLensFlares=function(){var a,b=this.lensFlares.length,c,d=-this.positionScreen.x*2,e=-this.positionScreen.y*2;for(a=0;a<b;a++){c=this.lensFlares[a];c.x=this.positionScreen.x+d*c.distance;c.y=this.positionScreen.y+e*c.distance;c.wantedRotation=c.x*Math.PI*0.25;c.rotation=c.rotation+(c.wantedRotation-c.rotation)*0.25}};
THREE.MorphBlendMesh=function(a,b){THREE.Mesh.call(this,a,b);this.animationsMap={};this.animationsList=[];var c=this.geometry.morphTargets.length;this.createAnimation("__default",0,c-1,c/1);this.setAnimationWeight("__default",1)};THREE.MorphBlendMesh.prototype=Object.create(THREE.Mesh.prototype);
THREE.MorphBlendMesh.prototype.createAnimation=function(a,b,c,d){b={startFrame:b,endFrame:c,length:c-b+1,fps:d,duration:(c-b)/d,lastFrame:0,currentFrame:0,active:false,time:0,direction:1,weight:1,directionBackwards:false,mirroredLoop:false};this.animationsMap[a]=b;this.animationsList.push(b)};
THREE.MorphBlendMesh.prototype.autoCreateAnimations=function(a){for(var b=/([a-z]+)(\d+)/,c,d={},e=this.geometry,f=0,g=e.morphTargets.length;f<g;f++){var h=e.morphTargets[f].name.match(b);if(h&&h.length>1){var i=h[1];d[i]||(d[i]={start:Infinity,end:-Infinity});h=d[i];if(f<h.start)h.start=f;if(f>h.end)h.end=f;c||(c=i)}}for(i in d){h=d[i];this.createAnimation(i,h.start,h.end,a)}this.firstAnimation=c};
THREE.MorphBlendMesh.prototype.setAnimationDirectionForward=function(a){if(a=this.animationsMap[a]){a.direction=1;a.directionBackwards=false}};THREE.MorphBlendMesh.prototype.setAnimationDirectionBackward=function(a){if(a=this.animationsMap[a]){a.direction=-1;a.directionBackwards=true}};THREE.MorphBlendMesh.prototype.setAnimationFPS=function(a,b){var c=this.animationsMap[a];if(c){c.fps=b;c.duration=(c.end-c.start)/c.fps}};
THREE.MorphBlendMesh.prototype.setAnimationDuration=function(a,b){var c=this.animationsMap[a];if(c){c.duration=b;c.fps=(c.end-c.start)/c.duration}};THREE.MorphBlendMesh.prototype.setAnimationWeight=function(a,b){var c=this.animationsMap[a];if(c)c.weight=b};THREE.MorphBlendMesh.prototype.setAnimationTime=function(a,b){var c=this.animationsMap[a];if(c)c.time=b};THREE.MorphBlendMesh.prototype.getAnimationTime=function(a){var b=0;if(a=this.animationsMap[a])b=a.time;return b};
THREE.MorphBlendMesh.prototype.getAnimationDuration=function(a){var b=-1;if(a=this.animationsMap[a])b=a.duration;return b};THREE.MorphBlendMesh.prototype.playAnimation=function(a){var b=this.animationsMap[a];if(b){b.time=0;b.active=true}else console.warn("animation["+a+"] undefined")};THREE.MorphBlendMesh.prototype.stopAnimation=function(a){if(a=this.animationsMap[a])a.active=false};
THREE.MorphBlendMesh.prototype.update=function(a){for(var b=0,c=this.animationsList.length;b<c;b++){var d=this.animationsList[b];if(d.active){var e=d.duration/d.length;d.time=d.time+d.direction*a;if(d.mirroredLoop){if(d.time>d.duration||d.time<0){d.direction=d.direction*-1;if(d.time>d.duration){d.time=d.duration;d.directionBackwards=true}if(d.time<0){d.time=0;d.directionBackwards=false}}}else{d.time=d.time%d.duration;if(d.time<0)d.time=d.time+d.duration}var f=d.startFrame+THREE.Math.clamp(Math.floor(d.time/
e),0,d.length-1),g=d.weight;if(f!==d.currentFrame){this.morphTargetInfluences[d.lastFrame]=0;this.morphTargetInfluences[d.currentFrame]=1*g;this.morphTargetInfluences[f]=0;d.lastFrame=d.currentFrame;d.currentFrame=f}e=d.time%e/e;d.directionBackwards&&(e=1-e);this.morphTargetInfluences[d.currentFrame]=e*g;this.morphTargetInfluences[d.lastFrame]=(1-e)*g}}};
THREE.LensFlarePlugin=function(){function a(a){var c=b.createProgram(),d=b.createShader(b.FRAGMENT_SHADER),e=b.createShader(b.VERTEX_SHADER);b.shaderSource(d,a.fragmentShader);b.shaderSource(e,a.vertexShader);b.compileShader(d);b.compileShader(e);b.attachShader(c,d);b.attachShader(c,e);b.linkProgram(c);return c}var b,c,d,e,f,g,h,i,j,l,m,n,p;this.init=function(o){b=o.context;c=o;d=new Float32Array(16);e=new Uint16Array(6);o=0;d[o++]=-1;d[o++]=-1;d[o++]=0;d[o++]=0;d[o++]=1;d[o++]=-1;d[o++]=1;d[o++]=
0;d[o++]=1;d[o++]=1;d[o++]=1;d[o++]=1;d[o++]=-1;d[o++]=1;d[o++]=0;d[o++]=1;o=0;e[o++]=0;e[o++]=1;e[o++]=2;e[o++]=0;e[o++]=2;e[o++]=3;f=b.createBuffer();g=b.createBuffer();b.bindBuffer(b.ARRAY_BUFFER,f);b.bufferData(b.ARRAY_BUFFER,d,b.STATIC_DRAW);b.bindBuffer(b.ELEMENT_ARRAY_BUFFER,g);b.bufferData(b.ELEMENT_ARRAY_BUFFER,e,b.STATIC_DRAW);h=b.createTexture();i=b.createTexture();b.bindTexture(b.TEXTURE_2D,h);b.texImage2D(b.TEXTURE_2D,0,b.RGB,16,16,0,b.RGB,b.UNSIGNED_BYTE,null);b.texParameteri(b.TEXTURE_2D,
b.TEXTURE_WRAP_S,b.CLAMP_TO_EDGE);b.texParameteri(b.TEXTURE_2D,b.TEXTURE_WRAP_T,b.CLAMP_TO_EDGE);b.texParameteri(b.TEXTURE_2D,b.TEXTURE_MAG_FILTER,b.NEAREST);b.texParameteri(b.TEXTURE_2D,b.TEXTURE_MIN_FILTER,b.NEAREST);b.bindTexture(b.TEXTURE_2D,i);b.texImage2D(b.TEXTURE_2D,0,b.RGBA,16,16,0,b.RGBA,b.UNSIGNED_BYTE,null);b.texParameteri(b.TEXTURE_2D,b.TEXTURE_WRAP_S,b.CLAMP_TO_EDGE);b.texParameteri(b.TEXTURE_2D,b.TEXTURE_WRAP_T,b.CLAMP_TO_EDGE);b.texParameteri(b.TEXTURE_2D,b.TEXTURE_MAG_FILTER,b.NEAREST);
b.texParameteri(b.TEXTURE_2D,b.TEXTURE_MIN_FILTER,b.NEAREST);if(b.getParameter(b.MAX_VERTEX_TEXTURE_IMAGE_UNITS)<=0){j=false;l=a(THREE.ShaderFlares.lensFlare)}else{j=true;l=a(THREE.ShaderFlares.lensFlareVertexTexture)}m={};n={};m.vertex=b.getAttribLocation(l,"position");m.uv=b.getAttribLocation(l,"uv");n.renderType=b.getUniformLocation(l,"renderType");n.map=b.getUniformLocation(l,"map");n.occlusionMap=b.getUniformLocation(l,"occlusionMap");n.opacity=b.getUniformLocation(l,"opacity");n.color=b.getUniformLocation(l,
"color");n.scale=b.getUniformLocation(l,"scale");n.rotation=b.getUniformLocation(l,"rotation");n.screenPosition=b.getUniformLocation(l,"screenPosition");p=false};this.render=function(a,d,e,t){var a=a.__webglFlares,B=a.length;if(B){var u=new THREE.Vector3,s=t/e,z=e*0.5,A=t*0.5,v=16/t,y=new THREE.Vector2(v*s,v),C=new THREE.Vector3(1,1,0),G=new THREE.Vector2(1,1),H=n,v=m;b.useProgram(l);if(!p){b.enableVertexAttribArray(m.vertex);b.enableVertexAttribArray(m.uv);p=true}b.uniform1i(H.occlusionMap,0);b.uniform1i(H.map,
1);b.bindBuffer(b.ARRAY_BUFFER,f);b.vertexAttribPointer(v.vertex,2,b.FLOAT,false,16,0);b.vertexAttribPointer(v.uv,2,b.FLOAT,false,16,8);b.bindBuffer(b.ELEMENT_ARRAY_BUFFER,g);b.disable(b.CULL_FACE);b.depthMask(false);var J,E,M,K,F;for(J=0;J<B;J++){v=16/t;y.set(v*s,v);K=a[J];u.set(K.matrixWorld.elements[12],K.matrixWorld.elements[13],K.matrixWorld.elements[14]);d.matrixWorldInverse.multiplyVector3(u);d.projectionMatrix.multiplyVector3(u);C.copy(u);G.x=C.x*z+z;G.y=C.y*A+A;if(j||G.x>0&&G.x<e&&G.y>0&&
G.y<t){b.activeTexture(b.TEXTURE1);b.bindTexture(b.TEXTURE_2D,h);b.copyTexImage2D(b.TEXTURE_2D,0,b.RGB,G.x-8,G.y-8,16,16,0);b.uniform1i(H.renderType,0);b.uniform2f(H.scale,y.x,y.y);b.uniform3f(H.screenPosition,C.x,C.y,C.z);b.disable(b.BLEND);b.enable(b.DEPTH_TEST);b.drawElements(b.TRIANGLES,6,b.UNSIGNED_SHORT,0);b.activeTexture(b.TEXTURE0);b.bindTexture(b.TEXTURE_2D,i);b.copyTexImage2D(b.TEXTURE_2D,0,b.RGBA,G.x-8,G.y-8,16,16,0);b.uniform1i(H.renderType,1);b.disable(b.DEPTH_TEST);b.activeTexture(b.TEXTURE1);
b.bindTexture(b.TEXTURE_2D,h);b.drawElements(b.TRIANGLES,6,b.UNSIGNED_SHORT,0);K.positionScreen.copy(C);K.customUpdateCallback?K.customUpdateCallback(K):K.updateLensFlares();b.uniform1i(H.renderType,2);b.enable(b.BLEND);E=0;for(M=K.lensFlares.length;E<M;E++){F=K.lensFlares[E];if(F.opacity>0.001&&F.scale>0.001){C.x=F.x;C.y=F.y;C.z=F.z;v=F.size*F.scale/t;y.x=v*s;y.y=v;b.uniform3f(H.screenPosition,C.x,C.y,C.z);b.uniform2f(H.scale,y.x,y.y);b.uniform1f(H.rotation,F.rotation);b.uniform1f(H.opacity,F.opacity);
b.uniform3f(H.color,F.color.r,F.color.g,F.color.b);c.setBlending(F.blending,F.blendEquation,F.blendSrc,F.blendDst);c.setTexture(F.texture,1);b.drawElements(b.TRIANGLES,6,b.UNSIGNED_SHORT,0)}}}}b.enable(b.CULL_FACE);b.enable(b.DEPTH_TEST);b.depthMask(true)}}};
THREE.ShadowMapPlugin=function(){var a,b,c,d,e,f,g=new THREE.Frustum,h=new THREE.Matrix4,i=new THREE.Vector3,j=new THREE.Vector3;this.init=function(g){a=g.context;b=g;var g=THREE.ShaderLib.depthRGBA,h=THREE.UniformsUtils.clone(g.uniforms);c=new THREE.ShaderMaterial({fragmentShader:g.fragmentShader,vertexShader:g.vertexShader,uniforms:h});d=new THREE.ShaderMaterial({fragmentShader:g.fragmentShader,vertexShader:g.vertexShader,uniforms:h,morphTargets:true});e=new THREE.ShaderMaterial({fragmentShader:g.fragmentShader,
vertexShader:g.vertexShader,uniforms:h,skinning:true});f=new THREE.ShaderMaterial({fragmentShader:g.fragmentShader,vertexShader:g.vertexShader,uniforms:h,morphTargets:true,skinning:true});c._shadowPass=true;d._shadowPass=true;e._shadowPass=true;f._shadowPass=true};this.render=function(a,c){b.shadowMapEnabled&&b.shadowMapAutoUpdate&&this.update(a,c)};this.update=function(l,m){var n,p,o,q,r,t,B,u,s,z=[];q=0;a.clearColor(1,1,1,1);a.disable(a.BLEND);a.enable(a.CULL_FACE);a.frontFace(a.CCW);b.shadowMapCullFrontFaces?
a.cullFace(a.FRONT):a.cullFace(a.BACK);b.setDepthTest(true);n=0;for(p=l.__lights.length;n<p;n++){o=l.__lights[n];if(o.castShadow)if(o instanceof THREE.DirectionalLight&&o.shadowCascade)for(r=0;r<o.shadowCascadeCount;r++){var A;if(o.shadowCascadeArray[r])A=o.shadowCascadeArray[r];else{s=o;B=r;A=new THREE.DirectionalLight;A.isVirtual=true;A.onlyShadow=true;A.castShadow=true;A.shadowCameraNear=s.shadowCameraNear;A.shadowCameraFar=s.shadowCameraFar;A.shadowCameraLeft=s.shadowCameraLeft;A.shadowCameraRight=
s.shadowCameraRight;A.shadowCameraBottom=s.shadowCameraBottom;A.shadowCameraTop=s.shadowCameraTop;A.shadowCameraVisible=s.shadowCameraVisible;A.shadowDarkness=s.shadowDarkness;A.shadowBias=s.shadowCascadeBias[B];A.shadowMapWidth=s.shadowCascadeWidth[B];A.shadowMapHeight=s.shadowCascadeHeight[B];A.pointsWorld=[];A.pointsFrustum=[];u=A.pointsWorld;t=A.pointsFrustum;for(var v=0;v<8;v++){u[v]=new THREE.Vector3;t[v]=new THREE.Vector3}u=s.shadowCascadeNearZ[B];s=s.shadowCascadeFarZ[B];t[0].set(-1,-1,u);
t[1].set(1,-1,u);t[2].set(-1,1,u);t[3].set(1,1,u);t[4].set(-1,-1,s);t[5].set(1,-1,s);t[6].set(-1,1,s);t[7].set(1,1,s);A.originalCamera=m;t=new THREE.Gyroscope;t.position=o.shadowCascadeOffset;t.add(A);t.add(A.target);m.add(t);o.shadowCascadeArray[r]=A;console.log("Created virtualLight",A)}B=o;u=r;s=B.shadowCascadeArray[u];s.position.copy(B.position);s.target.position.copy(B.target.position);s.lookAt(s.target);s.shadowCameraVisible=B.shadowCameraVisible;s.shadowDarkness=B.shadowDarkness;s.shadowBias=
B.shadowCascadeBias[u];t=B.shadowCascadeNearZ[u];B=B.shadowCascadeFarZ[u];s=s.pointsFrustum;s[0].z=t;s[1].z=t;s[2].z=t;s[3].z=t;s[4].z=B;s[5].z=B;s[6].z=B;s[7].z=B;z[q]=A;q++}else{z[q]=o;q++}}n=0;for(p=z.length;n<p;n++){o=z[n];if(!o.shadowMap){o.shadowMap=new THREE.WebGLRenderTarget(o.shadowMapWidth,o.shadowMapHeight,{minFilter:THREE.LinearFilter,magFilter:THREE.LinearFilter,format:THREE.RGBAFormat});o.shadowMapSize=new THREE.Vector2(o.shadowMapWidth,o.shadowMapHeight);o.shadowMatrix=new THREE.Matrix4}if(!o.shadowCamera){if(o instanceof
THREE.SpotLight)o.shadowCamera=new THREE.PerspectiveCamera(o.shadowCameraFov,o.shadowMapWidth/o.shadowMapHeight,o.shadowCameraNear,o.shadowCameraFar);else if(o instanceof THREE.DirectionalLight)o.shadowCamera=new THREE.OrthographicCamera(o.shadowCameraLeft,o.shadowCameraRight,o.shadowCameraTop,o.shadowCameraBottom,o.shadowCameraNear,o.shadowCameraFar);else{console.error("Unsupported light type for shadow");continue}l.add(o.shadowCamera);b.autoUpdateScene&&l.updateMatrixWorld()}if(o.shadowCameraVisible&&
!o.cameraHelper){o.cameraHelper=new THREE.CameraHelper(o.shadowCamera);o.shadowCamera.add(o.cameraHelper)}if(o.isVirtual&&A.originalCamera==m){r=m;q=o.shadowCamera;t=o.pointsFrustum;s=o.pointsWorld;i.set(Infinity,Infinity,Infinity);j.set(-Infinity,-Infinity,-Infinity);for(B=0;B<8;B++){u=s[B];u.copy(t[B]);THREE.ShadowMapPlugin.__projector.unprojectVector(u,r);q.matrixWorldInverse.multiplyVector3(u);if(u.x<i.x)i.x=u.x;if(u.x>j.x)j.x=u.x;if(u.y<i.y)i.y=u.y;if(u.y>j.y)j.y=u.y;if(u.z<i.z)i.z=u.z;if(u.z>
j.z)j.z=u.z}q.left=i.x;q.right=j.x;q.top=j.y;q.bottom=i.y;q.updateProjectionMatrix()}q=o.shadowMap;t=o.shadowMatrix;r=o.shadowCamera;r.position.copy(o.matrixWorld.getPosition());r.lookAt(o.target.matrixWorld.getPosition());r.updateMatrixWorld();r.matrixWorldInverse.getInverse(r.matrixWorld);if(o.cameraHelper)o.cameraHelper.visible=o.shadowCameraVisible;o.shadowCameraVisible&&o.cameraHelper.update();t.set(0.5,0,0,0.5,0,0.5,0,0.5,0,0,0.5,0.5,0,0,0,1);t.multiplySelf(r.projectionMatrix);t.multiplySelf(r.matrixWorldInverse);
if(!r._viewMatrixArray)r._viewMatrixArray=new Float32Array(16);if(!r._projectionMatrixArray)r._projectionMatrixArray=new Float32Array(16);r.matrixWorldInverse.flattenToArray(r._viewMatrixArray);r.projectionMatrix.flattenToArray(r._projectionMatrixArray);h.multiply(r.projectionMatrix,r.matrixWorldInverse);g.setFromMatrix(h);b.setRenderTarget(q);b.clear();s=l.__webglObjects;o=0;for(q=s.length;o<q;o++){B=s[o];t=B.object;B.render=false;if(t.visible&&t.castShadow&&(!(t instanceof THREE.Mesh)||!t.frustumCulled||
g.contains(t))){t._modelViewMatrix.multiply(r.matrixWorldInverse,t.matrixWorld);B.render=true}}o=0;for(q=s.length;o<q;o++){B=s[o];if(B.render){t=B.object;B=B.buffer;v=t.material instanceof THREE.MeshFaceMaterial?t.geometry.materials[0]:t.material;u=t.geometry.morphTargets.length>0&&v.morphTargets;v=t instanceof THREE.SkinnedMesh&&v.skinning;u=t.customDepthMaterial?t.customDepthMaterial:v?u?f:e:u?d:c;B instanceof THREE.BufferGeometry?b.renderBufferDirect(r,l.__lights,null,u,B,t):b.renderBuffer(r,l.__lights,
null,u,B,t)}}s=l.__webglObjectsImmediate;o=0;for(q=s.length;o<q;o++){B=s[o];t=B.object;if(t.visible&&t.castShadow){t._modelViewMatrix.multiply(r.matrixWorldInverse,t.matrixWorld);b.renderImmediateObject(r,l.__lights,null,c,t)}}}n=b.getClearColor();p=b.getClearAlpha();a.clearColor(n.r,n.g,n.b,p);a.enable(a.BLEND);b.shadowMapCullFrontFaces&&a.cullFace(a.BACK)}};THREE.ShadowMapPlugin.__projector=new THREE.Projector;
THREE.SpritePlugin=function(){function a(a,b){return b.z-a.z}var b,c,d,e,f,g,h,i,j,l;this.init=function(a){b=a.context;c=a;d=new Float32Array(16);e=new Uint16Array(6);a=0;d[a++]=-1;d[a++]=-1;d[a++]=0;d[a++]=0;d[a++]=1;d[a++]=-1;d[a++]=1;d[a++]=0;d[a++]=1;d[a++]=1;d[a++]=1;d[a++]=1;d[a++]=-1;d[a++]=1;d[a++]=0;d[a++]=1;a=0;e[a++]=0;e[a++]=1;e[a++]=2;e[a++]=0;e[a++]=2;e[a++]=3;f=b.createBuffer();g=b.createBuffer();b.bindBuffer(b.ARRAY_BUFFER,f);b.bufferData(b.ARRAY_BUFFER,d,b.STATIC_DRAW);b.bindBuffer(b.ELEMENT_ARRAY_BUFFER,
g);b.bufferData(b.ELEMENT_ARRAY_BUFFER,e,b.STATIC_DRAW);var a=THREE.ShaderSprite.sprite,n=b.createProgram(),p=b.createShader(b.FRAGMENT_SHADER),o=b.createShader(b.VERTEX_SHADER);b.shaderSource(p,a.fragmentShader);b.shaderSource(o,a.vertexShader);b.compileShader(p);b.compileShader(o);b.attachShader(n,p);b.attachShader(n,o);b.linkProgram(n);h=n;i={};j={};i.position=b.getAttribLocation(h,"position");i.uv=b.getAttribLocation(h,"uv");j.uvOffset=b.getUniformLocation(h,"uvOffset");j.uvScale=b.getUniformLocation(h,
"uvScale");j.rotation=b.getUniformLocation(h,"rotation");j.scale=b.getUniformLocation(h,"scale");j.alignment=b.getUniformLocation(h,"alignment");j.color=b.getUniformLocation(h,"color");j.map=b.getUniformLocation(h,"map");j.opacity=b.getUniformLocation(h,"opacity");j.useScreenCoordinates=b.getUniformLocation(h,"useScreenCoordinates");j.affectedByDistance=b.getUniformLocation(h,"affectedByDistance");j.screenPosition=b.getUniformLocation(h,"screenPosition");j.modelViewMatrix=b.getUniformLocation(h,"modelViewMatrix");
j.projectionMatrix=b.getUniformLocation(h,"projectionMatrix");l=false};this.render=function(d,e,p,o){var d=d.__webglSprites,q=d.length;if(q){var r=i,t=j,B=o/p,p=p*0.5,u=o*0.5,s=true;b.useProgram(h);if(!l){b.enableVertexAttribArray(r.position);b.enableVertexAttribArray(r.uv);l=true}b.disable(b.CULL_FACE);b.enable(b.BLEND);b.depthMask(true);b.bindBuffer(b.ARRAY_BUFFER,f);b.vertexAttribPointer(r.position,2,b.FLOAT,false,16,0);b.vertexAttribPointer(r.uv,2,b.FLOAT,false,16,8);b.bindBuffer(b.ELEMENT_ARRAY_BUFFER,
g);b.uniformMatrix4fv(t.projectionMatrix,false,e._projectionMatrixArray);b.activeTexture(b.TEXTURE0);b.uniform1i(t.map,0);for(var z,A=[],r=0;r<q;r++){z=d[r];if(z.visible&&z.opacity!==0)if(z.useScreenCoordinates)z.z=-z.position.z;else{z._modelViewMatrix.multiply(e.matrixWorldInverse,z.matrixWorld);z.z=-z._modelViewMatrix.elements[14]}}d.sort(a);for(r=0;r<q;r++){z=d[r];if(z.visible&&z.opacity!==0&&z.map&&z.map.image&&z.map.image.width){if(z.useScreenCoordinates){b.uniform1i(t.useScreenCoordinates,1);
b.uniform3f(t.screenPosition,(z.position.x-p)/p,(u-z.position.y)/u,Math.max(0,Math.min(1,z.position.z)))}else{b.uniform1i(t.useScreenCoordinates,0);b.uniform1i(t.affectedByDistance,z.affectedByDistance?1:0);b.uniformMatrix4fv(t.modelViewMatrix,false,z._modelViewMatrix.elements)}e=z.map.image.width/(z.scaleByViewport?o:1);A[0]=e*B*z.scale.x;A[1]=e*z.scale.y;b.uniform2f(t.uvScale,z.uvScale.x,z.uvScale.y);b.uniform2f(t.uvOffset,z.uvOffset.x,z.uvOffset.y);b.uniform2f(t.alignment,z.alignment.x,z.alignment.y);
b.uniform1f(t.opacity,z.opacity);b.uniform3f(t.color,z.color.r,z.color.g,z.color.b);b.uniform1f(t.rotation,z.rotation);b.uniform2fv(t.scale,A);if(z.mergeWith3D&&!s){b.enable(b.DEPTH_TEST);s=true}else if(!z.mergeWith3D&&s){b.disable(b.DEPTH_TEST);s=false}c.setBlending(z.blending,z.blendEquation,z.blendSrc,z.blendDst);c.setTexture(z.map,0);b.drawElements(b.TRIANGLES,6,b.UNSIGNED_SHORT,0)}}b.enable(b.CULL_FACE);b.enable(b.DEPTH_TEST);b.depthMask(true)}}};
THREE.DepthPassPlugin=function(){this.enabled=false;this.renderTarget=null;var a,b,c,d,e=new THREE.Frustum,f=new THREE.Matrix4;this.init=function(e){a=e.context;b=e;var e=THREE.ShaderLib.depthRGBA,f=THREE.UniformsUtils.clone(e.uniforms);c=new THREE.ShaderMaterial({fragmentShader:e.fragmentShader,vertexShader:e.vertexShader,uniforms:f});d=new THREE.ShaderMaterial({fragmentShader:e.fragmentShader,vertexShader:e.vertexShader,uniforms:f,morphTargets:true});c._shadowPass=true;d._shadowPass=true};this.render=
function(a,b){this.enabled&&this.update(a,b)};this.update=function(g,h){var i,j,l,m,n,p;a.clearColor(1,1,1,1);a.disable(a.BLEND);b.setDepthTest(true);b.autoUpdateScene&&g.updateMatrixWorld();if(!h._viewMatrixArray)h._viewMatrixArray=new Float32Array(16);if(!h._projectionMatrixArray)h._projectionMatrixArray=new Float32Array(16);h.matrixWorldInverse.getInverse(h.matrixWorld);h.matrixWorldInverse.flattenToArray(h._viewMatrixArray);h.projectionMatrix.flattenToArray(h._projectionMatrixArray);f.multiply(h.projectionMatrix,
h.matrixWorldInverse);e.setFromMatrix(f);b.setRenderTarget(this.renderTarget);b.clear();p=g.__webglObjects;i=0;for(j=p.length;i<j;i++){l=p[i];n=l.object;l.render=false;if(n.visible&&(!(n instanceof THREE.Mesh)||!n.frustumCulled||e.contains(n))){n._modelViewMatrix.multiply(h.matrixWorldInverse,n.matrixWorld);l.render=true}}i=0;for(j=p.length;i<j;i++){l=p[i];if(l.render){n=l.object;l=l.buffer;n.material&&b.setMaterialFaces(n.material);m=n.customDepthMaterial?n.customDepthMaterial:n.geometry.morphTargets.length?
d:c;l instanceof THREE.BufferGeometry?b.renderBufferDirect(h,g.__lights,null,m,l,n):b.renderBuffer(h,g.__lights,null,m,l,n)}}p=g.__webglObjectsImmediate;i=0;for(j=p.length;i<j;i++){l=p[i];n=l.object;if(n.visible&&n.castShadow){n._modelViewMatrix.multiply(h.matrixWorldInverse,n.matrixWorld);b.renderImmediateObject(h,g.__lights,null,c,n)}}i=b.getClearColor();j=b.getClearAlpha();a.clearColor(i.r,i.g,i.b,j);a.enable(a.BLEND)}};
THREE.ShaderFlares={lensFlareVertexTexture:{vertexShader:"uniform vec3 screenPosition;\nuniform vec2 scale;\nuniform float rotation;\nuniform int renderType;\nuniform sampler2D occlusionMap;\nattribute vec2 position;\nattribute vec2 uv;\nvarying vec2 vUV;\nvarying float vVisibility;\nvoid main() {\nvUV = uv;\nvec2 pos = position;\nif( renderType == 2 ) {\nvec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) ) +\ntexture2D( occlusionMap, vec2( 0.5, 0.1 ) ) +\ntexture2D( occlusionMap, vec2( 0.9, 0.1 ) ) +\ntexture2D( occlusionMap, vec2( 0.9, 0.5 ) ) +\ntexture2D( occlusionMap, vec2( 0.9, 0.9 ) ) +\ntexture2D( occlusionMap, vec2( 0.5, 0.9 ) ) +\ntexture2D( occlusionMap, vec2( 0.1, 0.9 ) ) +\ntexture2D( occlusionMap, vec2( 0.1, 0.5 ) ) +\ntexture2D( occlusionMap, vec2( 0.5, 0.5 ) );\nvVisibility = (       visibility.r / 9.0 ) *\n( 1.0 - visibility.g / 9.0 ) *\n(       visibility.b / 9.0 ) *\n( 1.0 - visibility.a / 9.0 );\npos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;\npos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;\n}\ngl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\n}",fragmentShader:"precision mediump float;\nuniform sampler2D map;\nuniform float opacity;\nuniform int renderType;\nuniform vec3 color;\nvarying vec2 vUV;\nvarying float vVisibility;\nvoid main() {\nif( renderType == 0 ) {\ngl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );\n} else if( renderType == 1 ) {\ngl_FragColor = texture2D( map, vUV );\n} else {\nvec4 texture = texture2D( map, vUV );\ntexture.a *= opacity * vVisibility;\ngl_FragColor = texture;\ngl_FragColor.rgb *= color;\n}\n}"},
lensFlare:{vertexShader:"uniform vec3 screenPosition;\nuniform vec2 scale;\nuniform float rotation;\nuniform int renderType;\nattribute vec2 position;\nattribute vec2 uv;\nvarying vec2 vUV;\nvoid main() {\nvUV = uv;\nvec2 pos = position;\nif( renderType == 2 ) {\npos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;\npos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;\n}\ngl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\n}",fragmentShader:"precision mediump float;\nuniform sampler2D map;\nuniform sampler2D occlusionMap;\nuniform float opacity;\nuniform int renderType;\nuniform vec3 color;\nvarying vec2 vUV;\nvoid main() {\nif( renderType == 0 ) {\ngl_FragColor = vec4( texture2D( map, vUV ).rgb, 0.0 );\n} else if( renderType == 1 ) {\ngl_FragColor = texture2D( map, vUV );\n} else {\nfloat visibility = texture2D( occlusionMap, vec2( 0.5, 0.1 ) ).a +\ntexture2D( occlusionMap, vec2( 0.9, 0.5 ) ).a +\ntexture2D( occlusionMap, vec2( 0.5, 0.9 ) ).a +\ntexture2D( occlusionMap, vec2( 0.1, 0.5 ) ).a;\nvisibility = ( 1.0 - visibility / 4.0 );\nvec4 texture = texture2D( map, vUV );\ntexture.a *= opacity * visibility;\ngl_FragColor = texture;\ngl_FragColor.rgb *= color;\n}\n}"}};
THREE.ShaderSprite={sprite:{vertexShader:"uniform int useScreenCoordinates;\nuniform int affectedByDistance;\nuniform vec3 screenPosition;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform float rotation;\nuniform vec2 scale;\nuniform vec2 alignment;\nuniform vec2 uvOffset;\nuniform vec2 uvScale;\nattribute vec2 position;\nattribute vec2 uv;\nvarying vec2 vUV;\nvoid main() {\nvUV = uvOffset + uv * uvScale;\nvec2 alignedPosition = position + alignment;\nvec2 rotatedPosition;\nrotatedPosition.x = ( cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y ) * scale.x;\nrotatedPosition.y = ( sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y ) * scale.y;\nvec4 finalPosition;\nif( useScreenCoordinates != 0 ) {\nfinalPosition = vec4( screenPosition.xy + rotatedPosition, screenPosition.z, 1.0 );\n} else {\nfinalPosition = projectionMatrix * modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\nfinalPosition.xy += rotatedPosition * ( affectedByDistance == 1 ? 1.0 : finalPosition.z );\n}\ngl_Position = finalPosition;\n}",
fragmentShader:"precision mediump float;\nuniform vec3 color;\nuniform sampler2D map;\nuniform float opacity;\nvarying vec2 vUV;\nvoid main() {\nvec4 texture = texture2D( map, vUV );\ngl_FragColor = vec4( color * texture.xyz, texture.a * opacity );\n}"}};

var IgeThree = IgeEventingClass.extend({
	classId: 'IgeThree',
	componentId: 'three',

	init: function(entity, options) {
		this._entity = entity;
		this._options = options;

		this._loader = new THREE.JSONLoader();
		this._geometryLoader = new THREE.GeometryLoader();

		// Override a number of prototypes to inject Three-based
		// processing code into them instead of their standard 2d
		// or isometric processing
		IgeEngine.prototype._frontBufferSetup = this.IgeEngine_frontBufferSetup;

		// Alter entity methods
		IgeEntity.prototype._transformContext = this.IgeEntity_transformContext;
		IgeEntity.prototype._renderEntity = this.IgeEntity_renderEntity;
		IgeEntity.prototype.material = this.IgeEntity_material;
		IgeEntity.prototype.model = this.IgeEntity_model;
		IgeEntity.prototype.mesh = this.IgeEntity_mesh;
		IgeEntity.prototype._$mount = IgeEntity.prototype.mount;
		IgeEntity.prototype.mount = this.IgeEntity_mount;
		IgeEntity.prototype._$unMount = IgeEntity.prototype.unMount;
		IgeEntity.prototype.unMount = this.IgeEntity_unMount;

		// Alter scene methods
		IgeScene2d.prototype._$init = IgeScene2d.prototype.init;
		IgeScene2d.prototype.init = this.IgeScene2d_init;

		// Alter camera methods
		IgeCamera.prototype._$init = IgeCamera.prototype.init;
		IgeCamera.prototype.init = this.IgeCamera_init;
		IgeCamera.prototype.tick = this.IgeCamera_tick;

		// Alter viewport methods
		IgeViewport.prototype.tick = this.IgeViewport_tick;
	},

	IgeCamera_init: function(entity) {
		this._$init(entity);
		this._threeObj = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.01, 10000);
	},

	IgeCamera_tick: function(ctx) {
		// Check if we are tracking the translate value of a target

		if (this._trackTranslateTarget) {
			var targetEntity = this._trackTranslateTarget,
				//targetMatrix = targetEntity._worldMatrix.matrix,
				targetX = targetEntity._translate.x,//targetMatrix[2],
				targetY =  targetEntity._translate.y,//targetMatrix[5],
				sourceX, sourceY, distX, distY;

			if (!this._trackTranslateSmoothing) {
				// Copy the target's world matrix translate data
				this.lookAt(this._trackTranslateTarget);
			} else {
				// Ease between the current and target values
				sourceX = this._translate.x;
				sourceY = this._translate.y;

				distX = targetX - sourceX;
				distY = targetY - sourceY;

				this._translate.x += distX / this._trackTranslateSmoothing;
				this._translate.y += distY / this._trackTranslateSmoothing;
			}
		}

		// Check if we are tracking the rotation values of a target
		if (this._trackRotateTarget) {
			var targetParentRZ = this._trackRotateTarget._parent !== undefined ? this._trackRotateTarget._parent._rotate.z : 0,
				targetZ = -(targetParentRZ + this._trackRotateTarget._rotate.z),
				sourceZ, distZ;

			if (!this._trackRotateSmoothing) {
				// Copy the target's rotate data
				this._rotate.z = targetZ;
			} else {
				// Interpolate between the current and target values
				sourceZ = this._rotate.z;
				distZ = targetZ - sourceZ;

				this._rotate.z += distZ / this._trackRotateSmoothing;
			}
		}

		this._threeObj.position.x = this._translate.x;
		this._threeObj.position.y = -this._translate.y;
		this._threeObj.position.z = this._translate.z;

		this._threeObj.rotation.x = this._rotate.x;
		this._threeObj.rotation.y = this._rotate.y;
		this._threeObj.rotation.z = this._rotate.z;

		// Updated local transform matrix and then transform the context
		//this.updateTransform();
		//this._localMatrix.transformRenderingContext(ctx);
	},

	IgeViewport_tick: function(ctx, scene) {
		// Check if we have a scene attached to this viewport
		if (this._scene) {
			// Store the viewport camera in the main ige so that
			// down the scenegraph we can choose to negate the camera
			// transform effects
			ige._currentCamera = this.camera;
			ige._currentViewport = this;

			this._scene._parent = this;

			// Process child ticks
			IgeEntity.prototype.tick.apply(this, [ctx]);

			// Process the camera's tick method
			this.camera.tick(ctx);

			// Process scene's child ticks
			this._scene.tick(ctx, scene);

			// Draw the scene
			ige._threeRenderer.clear();
			ige._threeRenderer.render(this._scene._threeObj, this.camera._threeObj);
		}
	},

	IgeScene2d_init: function(options) {
		this._$init(options);
		this._threeObj = new THREE.Scene();

		var ambient = new THREE.AmbientLight(0x242424);
		this._threeObj.add(ambient);

		var light = new THREE.SpotLight(0xd6e2ff, 1, 0, Math.PI, 1);
		light.position.set(600, 400, 1000);
		light.target.position.set(0, 0, 0);

		light.castShadow = true;
		light.shadowCameraNear = 200;
		light.shadowCameraFar = 1800;
		light.shadowCameraFov = 45;
		//light.shadowCameraVisible = true;

		light.shadowBias = 0.0005;
		light.shadowDarkness = 0.55;

		light.shadowMapWidth = 2048;
		light.shadowMapHeight = 2048;
		light.shadowMapSoft = true;
		this._threeObj.add(light);

		/*var specLight = new THREE.PointLight( 0x058ee4, 0.2, 0, Math.PI, 1 );
		 ////flameLight.position.set( 600, 400, 1000 );
		 //specLight.target.position.set( 0, 0, 0 );
		 this._threeObj.add(specLight);*/
	},

	IgeEngine_frontBufferSetup: function(autoSize, dontScale) {
		// Run the IGE in "headless" mode and allow Three.js to handle
		// all rendering instead
		var i, il,
			self = this;

		//this._threeObj = new THREE.Scene();
		//this._threeObj = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.01, 10000);
		//this._threeObj.position.x = 0;
		//this._threeObj.position.y = 0;
		//this._threeObj.position.z = 200;
		/*this._threeObj.rotation.x = 45 * Math.PI / 180;
		 this._threeObj.rotation.y = 35 * Math.PI / 180;
		 this._threeObj.rotation.z = 30 * Math.PI / 180;*/

		/*this._threeObj = new THREE.OrthographicCamera( window.innerWidth / - 2, window.innerWidth / 2, window.innerHeight / 2, window.innerHeight / - 2, -2000, 10000 );
		 this._threeObj.position.x = 0;
		 this._threeObj.position.y = 0;
		 this._threeObj.position.z = 0;*/
		/*this._threeObj.rotation.x = 45 * Math.PI / 180;
		 this._threeObj.rotation.y = 35 * Math.PI / 180;
		 this._threeObj.rotation.z = 30 * Math.PI / 180;*/

		/*var geometry = new THREE.CubeGeometry(1, 1, 1),
		 material = new THREE.MeshBasicMaterial( { color: 0xff0000, wireframe: false }),
		 //texture = THREE.ImageUtils.loadTexture('../assets/textures/particles/star1.png'),
		 //material = new THREE.MeshBasicMaterial({map: texture, wireframe: false}),
		 mesh1 = new THREE.Mesh(geometry, material);

		 geometry.dynamic = true;*/

		/*for (i = 0, il = geometry.vertices.length; i < il; i++) {
		 geometry.vertices[i].y += -100;
		 }*/

		//material.envMap = textureCube;
		//material.combine = THREE.MixOperation;
		//material.reflectivity = 0.55;
		//material.opacity = 1;

		//mesh1.position.z = 0;
		//this._threeObj.add(mesh1);

		/*var geometry = new THREE.PlaneGeometry(500, 500),
		 //material = new THREE.MeshBasicMaterial( { color: 0x0000ff, wireframe: false }),
		 texture = THREE.ImageUtils.loadTexture('../assets/textures/backgrounds/greyGradient.png'),
		 material = new THREE.MeshBasicMaterial({map: texture, wireframe: false}),
		 mesh2 = new THREE.Mesh( geometry, material );

		 mesh2.position.z = 0;
		 //this._threeObj.add( mesh2 );*/
		this._threeRenderer = new THREE.WebGLRenderer({antialias: false});
		this._threeRenderer.setSize(window.innerWidth, window.innerHeight);
		this._threeRenderer.autoClear = false;
		//this._threeRenderer.shadowMapEnabled = true;
		//this._threeRenderer.shadowMapSoft = true;

		// Add canvas element to DOM
		this.three._canvas = this._threeRenderer.domElement;
		document.body.appendChild(this.three._canvas);
		ige._bounds2d = new IgePoint2d(this.three._canvas.width, this.three._canvas.height);

		/*controls = new THREE.TrackballControls(this._threeObj, this._threeRenderer.domElement);
		 controls.rotateSpeed = 0.20;*/

		/*self._camX = 45;
		 self._camY = 35;
		 self._camZ = 30;*/

		/*var renderModel = new THREE.RenderPass( this._threeObj, this._threeObj );
		 var effectBloom = new THREE.BloomPass( .9 );
		 var effectVignette = new THREE.ShaderPass(THREE.ShaderExtras["colorCorrection"]);
		 var effectFilm = new THREE.FilmPass( .3, .3,1024,false );
		 var effectFXAA = new THREE.ShaderPass( THREE.ShaderExtras[ "sepia" ] );

		 effectFilm.renderToScreen = true;
		 this._threeComposer = new THREE.EffectComposer( this._threeRenderer );
		 this._threeComposer.addPass( renderModel );
		 //composer.addPass( effectFocus );
		 //composer.addPass( effectFXAA );
		 this._threeComposer.addPass( effectBloom );
		 this._threeComposer.addPass( effectVignette );
		 this._threeComposer.addPass( effectFilm );*/

		/*this._postTick.push(function () {
		 //ige._threeRenderer.clear();
		 //ige._threeRenderer.render( ige._threeObj, ige._threeObj );

		 //ige._threeRenderer.setViewport(10, 10, 400, 200);
		 //ige._threeRenderer.render( ige._threeObj, ige._threeObj );
		 //ige._threeRenderer.setViewport(400, 10, 400, 200);
		 //ige._threeComposer.render(0.1);
		 });*/
	},

	IgeEntity_transformContext: function(ctx) {

	},

	IgeEntity_renderEntity: function(ctx, dontTransform) {
		var m = this._threeObj;
		if (m) {
			// Update the translate, rotate and scale of the mesh
			if (m.position) {
				m.position.x = this._translate.x;
				m.position.y = -this._translate.y;
				m.position.z = this._translate.z;
			}

			if (m.rotation) {
				m.rotation.x = this._rotate.x;
				m.rotation.y = this._rotate.y;
				m.rotation.z = -this._rotate.z;
			}

			if (m.scale) {
				m.scale.x = this._scale.x;
				m.scale.y = this._scale.y;
				m.scale.z = this._scale.z;
			}
		}
	},

	IgeEntity_material: function(material) {
		if (material !== undefined) {
			this._material = material;
			return this;
		}

		return this._material;
	},

	IgeEntity_model: function(model) {
		if (model !== undefined) {
			ige.three._geometryLoader.path = './models';
			this._threeObj = new THREE.Mesh(
				ige.three._geometryLoader.parse(model),
				this._material || new THREE.MeshFaceMaterial()
			);

			this._threeObj.receiveShadow = true;
			this._threeObj.castShadow = true;
			return this;
		}

		return this._threeObj;
	},

	IgeEntity_mesh: function(mesh) {
		if (mesh !== undefined) {
			this._threeObj = new THREE.Mesh(
				mesh,
				this._material || new THREE.MeshBasicMaterial({color: 0x0000ff, wireframe: true})
			);
			return this;
		}

		return this._threeObj;
	},

	IgeEntity_mount: function(obj) {
		var self = this;

		if (this._threeObj) {
			obj._threeObj.add(this._threeObj);
			this._threeObj._igeEntity = this;
		}

		return this._$mount(obj);
	},

	IgeEntity_unMount: function() {
		var self = this;

		if (this._threeObj) {
			delete this._threeObj._igeEntity;
			this._parent._threeObj.remove(this._threeObj);
		}

		return this._$unMount();
	}
});

/**
 * The base engine class definition.
 */
var IgeEngine = IgeEntity.extend({
	classId: 'IgeEngine',

	init: function () {
		// Deal with some debug settings first
		if (igeConfig.debug) {
			if (!igeConfig.debug._enabled) {
				// Debug is not enabled so ensure that
				// timing debugs are disabled
				igeConfig.debug._timing = false;
			}
		}

		this._alwaysInView = true;

		this._id = 'ige';
		this.basePath = '';

		// Determine the environment we are executing in
		this.isServer = (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined');
		this.isClient = !this.isServer;

		// Assign ourselves to the global variable
		ige = this;

		IgeEntity.prototype.init.call(this);

		// Check if we are running client-side
		if (this.isClient) {
			// Enable cocoonJS support because we are running client-side
			this.addComponent(IgeCocoonJsComponent);
		}

		// Create storage
		this._textureStore = [];

		// Set the initial id as the current time in milliseconds. This ensures that under successive
		// restarts of the engine, new ids will still always be created compared to earlier runs -
		// which is important when storing persistent data with ids etc
		this._idCounter = new Date().getTime();

		// Setup components
		this.addComponent(IgeInputComponent);
		this.addComponent(IgeTweenComponent);
		this.addComponent(IgeTimeComponent);
		
		if (this.isClient) {
			// Enable UI element (virtual DOM) support
			this.addComponent(IgeUiManagerComponent);
		}

		// Set some defaults
		this._renderModes = [
			'2d',
			'three'
		];
		
		this._requireScriptTotal = 0;
		this._requireScriptLoading = 0;
		this._loadingPreText = undefined; // The text to put in front of the loading percent on the loading progress screen
		this._enableUpdates = true;
		this._enableRenders = true;
		this._showSgTree = false;
		this._debugEvents = {}; // Holds debug event booleans for named events
		this._renderContext = '2d'; // The rendering context, default is 2d
		this._renderMode = this._renderModes[this._renderContext]; // Integer representation of the render context
		this._tickTime = 'NA'; // The time the tick took to process
		this._updateTime = 'NA'; // The time the tick update section took to process
		this._renderTime = 'NA'; // The time the tick render section took to process
		this._tickDelta = 0; // The time between the last tick and the current one
		this._fpsRate = 60; // Sets the frames per second to execute engine tick's at
		this._state = 0; // Currently stopped
		this._textureImageStore = {};
		this._texturesLoading = 0; // Holds a count of currently loading textures
		this._texturesTotal = 0; // Holds total number of textures loading / loaded
		this._dependencyQueue = []; // Holds an array of functions that must all return true for the engine to start
		this._drawCount = 0; // Holds the number of draws since the last frame (calls to drawImage)
		this._dps = 0; // Number of draws that occurred last tick
		this._dpf = 0;
		this._frames = 0; // Number of frames looped through since last second tick
		this._fps = 0; // Number of frames per second
		this._clientNetDiff = 0; // The difference between the server and client comms (only non-zero on clients)
		this._frameAlternator = false; // Is set to the boolean not of itself each frame
		this._viewportDepth = false;
		this._mousePos = new IgePoint3d(0, 0, 0);
		this._currentViewport = null; // Set in IgeViewport.js tick(), holds the current rendering viewport
		this._currentCamera = null; // Set in IgeViewport.js tick(), holds the current rendering viewport's camera
		this._currentTime = 0; // The current engine time
		this._globalSmoothing = false; // Determines the default smoothing setting for new textures
		this._register = {
			'ige': this
		}; // Holds a reference to every item in the scenegraph by it's ID
		this._categoryRegister = {}; // Holds reference to every item with a category
		this._groupRegister = {}; // Holds reference to every item with a group
		this._postTick = []; // An array of methods that are called upon tick completion
		this._timeSpentInUpdate = {}; // An object holding time-spent-in-update (total time spent in this object's update method)
		this._timeSpentLastUpdate = {}; // An object holding time-spent-last-update (time spent in this object's update method last tick)
		this._timeSpentInTick = {}; // An object holding time-spent-in-tick (total time spent in this object's tick method)
		this._timeSpentLastTick = {}; // An object holding time-spent-last-tick (time spent in this object's tick method last tick)
		this._timeScale = 1; // The default time scaling factor to speed up or slow down engine time
		this._globalScale = new IgePoint3d(1, 1, 1);
		this._graphInstances = []; // Holds an array of instances of graph classes
		this._spawnQueue = []; // Holds an array of entities that are yet to be born

		// Set the context to a dummy context to start
		// with in case we are in "headless" mode and
		// a replacement context never gets assigned
		this._ctx = IgeDummyContext;
		this._headless = true;

		this.dependencyTimeout(30000); // Wait 30 seconds to load all dependencies then timeout

		// Add the textures loaded dependency
		this._dependencyQueue.push(this.texturesLoaded);
		//this._dependencyQueue.push(this.canvasReady);

		// Start a timer to record every second of execution
		this._secondTimer = setInterval(this._secondTick, 1000);
	},

	/**
	 * Returns an object from the engine's object register by
	 * the object's id. If the item passed is not a string id
	 * then the item is returned as is. If no item is passed
	 * the engine itself is returned.
	 * @param {String || Object} item The id of the item to return,
	 * or if an object, returns the object as-is.
	 */
	$: function (item) {
		if (typeof(item) === 'string') {
			return this._register[item];
		} else if (typeof(item) === 'object') {
			return item;
		}

		return this;
	},

	/**
	 * Returns an array of all objects that have been assigned
	 * the passed category name.
	 * @param {String} categoryName The name of the category to return
	 * all objects for.
	 */
	$$: function (categoryName) {
		return this._categoryRegister[categoryName] || new IgeArray();
	},

	/**
	 * Returns an array of all objects that have been assigned
	 * the passed group name.
	 * @param {String} groupName The name of the group to return
	 * all objects for.
	 */
	$$$: function (groupName) {
		return this._groupRegister[groupName] || new IgeArray();
	},

	/**
	 * Register an object with the engine object register. The
	 * register allows you to access an object by it's id with
	 * a call to ige.$(objectId).
	 * @param {Object} obj The object to register.
	 * @return {*}
	 */
	register: function (obj) {
		if (obj !== undefined) {
			if (!this._register[obj.id()]) {
				this._register[obj.id()] = obj;
				obj._registered = true;

				return this;
			} else {
				obj._registered = false;

				this.log('Cannot add object id "' + obj.id() + '" to scenegraph because there is already another object in the graph with the same ID!', 'error');
				return false;
			}
		}

		return this._register;
	},

	/**
	 * Un-register an object with the engine object register. The
	 * object will no longer be accessible via ige.$().
	 * @param {Object} obj The object to un-register.
	 * @return {*}
	 */
	unRegister: function (obj) {
		if (obj !== undefined) {
			// Check if the object is registered in the ID lookup
			if (this._register[obj.id()]) {
				delete this._register[obj.id()];
				obj._registered = false;
			}
		}

		return this;
	},

	/**
	 * Register an object with the engine category register. The
	 * register allows you to access an object by it's category with
	 * a call to ige.$$(categoryName).
	 * @param {Object} obj The object to register.
	 * @return {*}
	 */
	categoryRegister: function (obj) {
		if (obj !== undefined) {
			this._categoryRegister[obj._category] = this._categoryRegister[obj._category] || new IgeArray();
			this._categoryRegister[obj._category].push(obj);
			obj._categoryRegistered = true;
		}

		return this._register;
	},

	/**
	 * Un-register an object with the engine category register. The
	 * object will no longer be accessible via ige.$$().
	 * @param {Object} obj The object to un-register.
	 * @return {*}
	 */
	categoryUnRegister: function (obj) {
		if (obj !== undefined) {
			if (this._categoryRegister[obj._category]) {
				this._categoryRegister[obj._category].pull(obj);
				obj._categoryRegistered = false;
			}
		}

		return this;
	},

	/**
	 * Register an object with the engine group register. The
	 * register allows you to access an object by it's groups with
	 * a call to ige.$$$(groupName).
	 * @param {Object} obj The object to register.
	 * @param {String} groupName The name of the group to register
	 * the object in.
	 * @return {*}
	 */
	groupRegister: function (obj, groupName) {
		if (obj !== undefined) {
			this._groupRegister[groupName] = this._groupRegister[groupName] || new IgeArray();
			this._groupRegister[groupName].push(obj);
			obj._groupRegistered = true;
		}

		return this._register;
	},

	/**
	 * Un-register an object with the engine group register. The
	 * object will no longer be accessible via ige.$$$().
	 * @param {Object} obj The object to un-register.
	 * @param {String} groupName The name of the group to un-register
	 * the object from.
	 * @return {*}
	 */
	groupUnRegister: function (obj, groupName) {
		if (obj !== undefined) {
			if (groupName !== undefined) {
				if (this._groupRegister[groupName]) {
					this._groupRegister[groupName].pull(obj);

					if (!obj.groupCount()) {
						obj._groupRegister = false;
					}
				}
			} else {
				// Call the removeAllGroups() method which will loop
				// all the groups that the object belongs to and
				// automatically un-register them
				obj.removeAllGroups();
			}
		}

		return this;
	},
	
	sync: function (method, attrArr) {
		if (typeof(attrArr) === 'string') {
			attrArr = [attrArr];
		}
		
		this._syncArr = this._syncArr || [];
		this._syncArr.push({method: method, attrArr: attrArr});
		
		if (this._syncArr.length === 1) {
			// Start sync waterfall
			this._syncIndex = 0;
			this._processSync();
		}
	},
	
	_processSync: function () {
		var syncEntry;
		
		if (ige._syncIndex < ige._syncArr.length) {
			syncEntry = ige._syncArr[ige._syncIndex];
			
			// Add the callback to the last attribute
			syncEntry.attrArr.push(function () {
				ige._syncIndex++;
				setTimeout(ige._processSync, 1);
			});
			
			// Call the method
			syncEntry.method.apply(ige, syncEntry.attrArr);
		} else {
			// Reached end of sync cycle
			delete ige._syncArr;
			delete ige._syncIndex;
			
			ige.emit('syncComplete');
		}
	},

	/**
	 * Load a js script file into memory via a path or url. 
	 * @param {String} url The file's path or url.
	 * @param {Function=} callback Optional callback when script loads.
	 */
	requireScript: function (url, callback) {
		if (url !== undefined) {
			var self = this;
			
			// Add to the load counter
			self._requireScriptTotal++;
			self._requireScriptLoading++;
			
			// Create the script element
			var elem = document.createElement('script');
			elem.addEventListener('load', function () {
				self._requireScriptLoaded(this);
				
				if (callback) {
					setTimeout(function () { callback(); }, 100);
				}
			});
			
			// For compatibility with CocoonJS
			document.body.appendChild(elem);
			
			// Set the source to load the url
			elem.src = url;
			
			this.log('Loading script from: ' + url);
			this.emit('requireScriptLoading', url);
		}
	},

	/**
	 * Called when a js script has been loaded via the requireScript
	 * method.
	 * @param {Element} elem The script element added to the DOM.
	 * @private
	 */
	_requireScriptLoaded: function (elem) {
		this._requireScriptLoading--;
		
		this.emit('requireScriptLoaded', elem.src);
		
		if (this._requireScriptLoading === 0) {
			// All scripts have loaded, fire the engine event
			this.emit('allRequireScriptsLoaded');
		}
	},
	
	/**
	 * Load a css style file into memory via a path or url. 
	 * @param {String} url The file's path or url.
	 */
	requireStylesheet: function (url) {
		if (url !== undefined) {
			var self = this;
			
			// Load the engine stylesheet
			var css = document.createElement('link');
			css.rel = 'stylesheet';
			css.type = 'text/css';
			css.media = 'all';
			css.href = url;
			
			document.getElementsByTagName('head')[0].appendChild(css);
			
			this.log('Load css stylesheet from: ' + url);
		}
	},

	/**
	 * Adds a scenegraph class into memory.
	 * @param {String} className The name of the scenegraph class.
	 * @param {Object=} options Optional object to pass to the scenegraph class graph() method.
	 * @returns {*}
	 */
	addGraph: function (className, options) {
		if (className !== undefined) {
			var classObj = this.getClass(className),
				classInstance;
			
			if (classObj) {
				this.log('Loading SceneGraph data class: ' + className);
				classInstance = this.newClassInstance(className);
				
				// Make sure the graph class implements the required methods "addGraph" and "removeGraph"
				if (typeof(classInstance.addGraph) === 'function' && typeof(classInstance.removeGraph) === 'function') {
					// Call the class's graph() method passing the options in
					classInstance.addGraph(options);
					
					// Add the graph instance to the holding array
					this._graphInstances[className] = classInstance;
				} else {
					this.log('Could not load graph for class name "' + className + '" because the class does not implement both the require methods "addGraph()" and "removeGraph()".', 'error');
				}
			} else {
				this.log('Cannot load graph for class name "' + className + '" because the class could not be found. Have you included it in your server/clientConfig.js file?', 'error');
			}
		}
		
		return this;
	},
	
	/**
	 * Removes a scenegraph class into memory.
	 * @param {String} className The name of the scenegraph class.
	 * @param {Object=} options Optional object to pass to the scenegraph class graph() method.
	 * @returns {*}
	 */
	removeGraph: function (className, options) {
		if (className !== undefined) {
			var classInstance = this._graphInstances[className];
			
			if (classInstance) {
				this.log('Removing SceneGraph data class: ' + className);
				
				// Call the class's graph() method passing the options in
				classInstance.removeGraph(options);
				
				// Now remove the graph instance from the graph instance array
				delete this._graphInstances[className];
			} else {
				this.log('Cannot remove graph for class name "' + className + '" because the class instance could not be found. Did you add it via ige.addGraph() ?', 'error');
			}
		}
		
		return this;
	},

	/**
	 * Allows the update() methods of the entire scenegraph to
	 * be temporarily enabled or disabled. Useful for debugging.
	 * @param {Boolean=} val If false, will disable all update() calls. 
	 * @returns {*}
	 */
	enableUpdates: function (val) {
		if (val !== undefined) {
			this._enableUpdates = val;
			return this;
		}
		
		return this._enableUpdates;
	},

	/**
	 * Allows the tick() methods of the entire scenegraph to
	 * be temporarily enabled or disabled. Useful for debugging.
	 * @param {Boolean=} val If false, will disable all tick() calls. 
	 * @returns {*}
	 */
	enableRenders: function (val) {
		if (val !== undefined) {
			this._enableRenders = val;
			return this;
		}

		return this._enableRenders;
	},

	/**
	 * Enables or disables the engine's debug mode. Enabled by default.
	 * @param {Boolean=} val If true, will enable debug mode. 
	 * @returns {*}
	 */
	debugEnabled: function (val) {
		if (val !== undefined) {
			if (igeConfig.debug) {
				igeConfig.debug._enabled = val;
			}
			return this;
		}

		return igeConfig.debug._enabled;
	},
	
	/**
	 * Enables or disables the engine's debug timing system. The
	 * timing system will time all update and rendering code down
	 * the scenegraph and is useful for tracking long-running code
	 * but comes with a small performance penalty when enabled.
	 * Enabled by default.
	 * @param {Boolean=} val If true, will enable debug timing mode. 
	 * @returns {*}
	 */
	debugTiming: function (val) {
		if (val !== undefined) {
			if (igeConfig.debug) {
				igeConfig.debug._timing = val;
			}
			return this;
		}

		return igeConfig.debug._timing;
	},

	debug: function (eventName) {
		if (this._debugEvents[eventName] === true || this._debugEvents[eventName] === ige._frames) {
			debugger;
		}
	},

	debugEventOn: function (eventName) {
		this._debugEvents[eventName] = true;
	},

	debugEventOff: function (eventName) {
		this._debugEvents[eventName] = false;
	},

	triggerDebugEventFrame: function (eventName) {
		this._debugEvents[eventName] = ige._frames;
	},

	/**
	 * Sets the opacity of every object on the scenegraph to
	 * zero *except* the one specified by the given id argument.
	 * @param {String} id The id of the object not to hide.
	 */
	hideAllExcept: function (id) {
		var i,
			arr = this._register;

		for (i in arr) {
			if (i !== id) {
				arr[i].opacity(0);
			}
		}
	},

	/**
	 * Calls the show() method for every object on the scenegraph.
	 */
	showAll: function () {
		var i,
			arr = this._register;

		for (i in arr) {
			arr[i].show();
		}
	},

	/**
	 * Sets the frame rate at which new engine steps are fired.
	 * Setting this rate will override the default requestAnimFrame()
	 * method as defined in IgeBase.js and on the client-side, will
	 * stop usage of any available requestAnimationFrame() method
	 * and will use a setTimeout()-based version instead.
	 * @param {Number} fpsRate
	 */
	setFps: function (fpsRate) {
		if (fpsRate !== undefined) {
			// Override the default requestAnimFrame handler and set
			// our own method up so that we can control the frame rate
			if (this.isServer) {
				// Server-side implementation
				requestAnimFrame = function(callback, element){
					setTimeout(function () { callback(new Date().getTime()); }, 1000 / fpsRate);
				};
			} else {
				// Client-side implementation
				window.requestAnimFrame = function(callback, element){
					setTimeout(function () { callback(new Date().getTime()); }, 1000 / fpsRate);
				};
			}
		}
	},

	showStats: function () {
		this.log('showStats has been removed from the ige in favour of the new editor component, please remove this call from your code.');
	},

	/**
	 * Defines a class in the engine's class repository.
	 * @param {String} id The unique class ID or name.
	 * @param {Object} obj The class definition.
	 */
	defineClass: function (id, obj) {
		igeClassStore[id] = obj;
	},

	/**
	 * Retrieves a class by it's ID that was defined with
	 * a call to defineClass().
	 * @param {String} id The ID of the class to retrieve.
	 * @return {Object} The class definition.
	 */
	getClass: function (id) {
		return igeClassStore[id];
	},

	/**
	 * Returns true if the class specified has been defined.
	 * @param {String} id The ID of the class to check for.
	 * @returns {*}
	 */
	classDefined: function (id) {
		return Boolean(igeClassStore[id]);
	},

	/**
	 * Generates a new instance of a class defined with a call
	 * to the defineClass() method. Passes the options
	 * parameter to the new class during it's constructor call.
	 * @param id
	 * @param options
	 * @return {*}
	 */
	newClassInstance: function (id, options) {
		return new igeClassStore[id](options);
	},

	/**
	 * Checks if all engine start dependencies have been satisfied.
	 * @return {Boolean}
	 */
	dependencyCheck: function () {
		var arr = this._dependencyQueue,
			arrCount = arr.length;

		while (arrCount--) {
			if (!this._dependencyQueue[arrCount]()) {
				return false;
			}
		}

		return true;
	},

	/**
	 * Gets / sets the flag that determines if viewports should be sorted by depth
	 * like regular entities, before they are processed for rendering each frame.
	 * Depth-sorting viewports increases processing requirements so if you do not
	 * need to stack viewports in a particular order, keep this flag false.
	 * @param {Boolean} val
	 * @return {Boolean}
	 */
	viewportDepth: function (val) {
		if (val !== undefined) {
			this._viewportDepth = val;
			return this;
		}

		return this._viewportDepth;
	},

	/**
	 * Sets the number of milliseconds before the engine gives up waiting for dependencies
	 * to be satisfied and cancels the startup procedure.
	 * @param val
	 */
	dependencyTimeout: function (val) {
		this._dependencyCheckTimeout = val;
	},

	/**
	 * Updates the loading screen DOM elements to show the update progress.
	 */
	updateProgress: function () {
		// Check for a loading progress bar DOM element
		if (typeof(document) !== 'undefined' && document.getElementById) {
			var elem = document.getElementById('loadingProgressBar'),
				textElem = document.getElementById('loadingText');
			
			if (elem) {
				// Calculate the width from progress
				var totalWidth = parseInt(elem.parentNode.offsetWidth),
					currentWidth = Math.floor((totalWidth / this._texturesTotal) * (this._texturesTotal - this._texturesLoading));
				
				// Set the current bar width
				elem.style.width = currentWidth + 'px';
				
				if (textElem) {
					if (this._loadingPreText === undefined) {
						// Fill the text to use
						this._loadingPreText = textElem.innerHTML;
					}
					textElem.innerHTML = this._loadingPreText + ' ' + Math.floor((100 / this._texturesTotal) * (this._texturesTotal - this._texturesLoading)) + '%';
				}
			}
		}
	},

	/**
	 * Adds one to the number of textures currently loading.
	 */
	textureLoadStart: function (url, textureObj) {
		this._texturesLoading++;
		this._texturesTotal++;
		
		this.updateProgress();
		
		this.emit('textureLoadStart', textureObj);
	},

	/**
	 * Subtracts one from the number of textures currently loading and if no more need
	 * to load, it will also call the _allTexturesLoaded() method.
	 */
	textureLoadEnd: function (url, textureObj) {
		var self = this;
		
		if (!textureObj._destroyed) {
			// Add the texture to the _textureStore array
			this._textureStore.push(textureObj);
		}

		// Decrement the overall loading number
		this._texturesLoading--;
		
		this.updateProgress();
		
		this.emit('textureLoadEnd', textureObj);

		// If we've finished...
		if (this._texturesLoading === 0) {
			// All textures have finished loading
			this.updateProgress();
			
			setTimeout(function () {
				self._allTexturesLoaded();
			}, 100);
		}
	},

	/**
	 * Returns a texture from the texture store by it's url.
	 * @param {String} url
	 * @return {IgeTexture}
	 */
	textureFromUrl: function (url) {
		var arr = this._textureStore,
			arrCount = arr.length,
			item;

		while (arrCount--) {
			item = arr[arrCount];
			if (item._url === url) {
				return item;
			}
		}
	},

	/**
	 * Checks if all textures have finished loading and returns true if so.
	 * @return {Boolean}
	 */
	texturesLoaded: function () {
		return ige._texturesLoading === 0;
	},

	/**
	 * Emits the "texturesLoaded" event.
	 * @private
	 */
	_allTexturesLoaded: function () {
		if (!this._loggedATL) {
			this._loggedATL = true;
			this.log('All textures have loaded');
		}

		// Fire off an event about this
		this.emit('texturesLoaded');
	},

	/**
	 * Gets / sets the default smoothing value for all new
	 * IgeTexture class instances. If set to true, all newly
	 * created textures will have smoothing enabled by default.
	 * @param val
	 * @return {*}
	 */
	globalSmoothing: function (val) {
		if (val !== undefined) {
			this._globalSmoothing = val;
			return this;
		}

		return this._globalSmoothing;
	},

	/**
	 * Checks to ensure that a canvas has been assigned to the engine or that the
	 * engine is in server mode.
	 * @return {Boolean}
	 */
	canvasReady: function () {
		return (ige._canvas !== undefined || ige.isServer);
	},

	/**
	 * Generates a new unique ID
	 * @return {String}
	 */
	newId: function () {
		this._idCounter++;
		return String(this._idCounter + (Math.random() * Math.pow(10, 17) + Math.random() * Math.pow(10, 17) + Math.random() * Math.pow(10, 17) + Math.random() * Math.pow(10, 17)));
	},

	/**
	 * Generates a new 16-character hexadecimal unique ID
	 * @return {String}
	 */
	newIdHex: function () {
		this._idCounter++;
		return (this._idCounter + (Math.random() * Math.pow(10, 17) + Math.random() * Math.pow(10, 17) + Math.random() * Math.pow(10, 17) + Math.random() * Math.pow(10, 17))).toString(16);
	},

	/**
	 * Generates a new 16-character hexadecimal ID based on
	 * the passed string. Will always generate the same ID
	 * for the same string.
	 * @param {String} str A string to generate the ID from.
	 * @return {String}
	 */
	newIdFromString: function (str) {
		if (str !== undefined) {
			var id,
				val = 0,
				count = str.length,
				i;

			for (i = 0; i < count; i++) {
				val += str.charCodeAt(i) * Math.pow(10, 17);
			}

			id = (val).toString(16);

			// Check if the ID is already in use
			while (ige.$(id)) {
				val += Math.pow(10, 17);
				id = (val).toString(16);
			}

			return id;
		}
	},

	/**
	 * Starts the engine.
	 * @param callback
	 */
	start: function (callback) {
		if (!ige._state) {
			// Check if we are able to start based upon any registered dependencies
			if (ige.dependencyCheck()) {
				// Start the engine
				ige.log('Starting engine...');
				ige._state = 1;

				// Check if we have a DOM, that there is an igeLoading element
				// and if so, remove it from the DOM now
				if (this.isClient) {
					if (document.getElementsByClassName && document.getElementsByClassName('igeLoading')) {
						var arr = document.getElementsByClassName('igeLoading'),
							arrCount = arr.length;

						while (arrCount--) {
							arr[arrCount].parentNode.removeChild(arr[arrCount]);
						}
					}
				}

				requestAnimFrame(ige.engineStep);

				ige.log('Engine started');

				// Fire the callback method if there was one
				if (typeof(callback) === 'function') {
					callback(true);
				}
			} else {
				// Get the current timestamp
				var curTime = new Date().getTime();

				// Record when we first started checking for dependencies
				if (!ige._dependencyCheckStart) {
					ige._dependencyCheckStart = curTime;
				}

				// Check if we have timed out
				if (curTime - ige._dependencyCheckStart > this._dependencyCheckTimeout) {
					this.log('Engine start failed because the dependency check timed out after ' + (this._dependencyCheckTimeout / 1000) + ' seconds', 'error');
					if (typeof(callback) === 'function') {
						callback(false);
					}
				} else {
					// Start a timer to keep checking dependencies
					setTimeout(function () { ige.start(callback); }, 200);
				}
			}
		}
	},

	/**
	 * Stops the engine.
	 * @return {Boolean}
	 */
	stop: function () {
		// If we are running, stop the engine
		if (this._state) {
			this.log('Stopping engine...');
			this._state = 0;

			return true;
		} else {
			return false;
		}
	},

	/**
	 * Gets / sets the _autoSize property. If set to true, the engine will listen
	 * for any change in screen size and resize the front-buffer (canvas) element
	 * to match the new screen size.
	 * @param val
	 * @return {Boolean}
	 */
	autoSize: function (val) {
		if (val !== undefined) {
			this._autoSize = val;
			return this;
		}

		return this._autoSize;
	},

	pixelRatioScaling: function (val) {
		if (val !== undefined) {
			this._pixelRatioScaling = val;
			return this;
		}

		return this._pixelRatioScaling;
	},

	/**
	 * Gets / sets the rendering context that will be used when getting the
	 * context from canvas elements.
	 * @param {String=} contextId The context such as '2d'. Defaults to '2d'.
	 * @return {*}
	 */
	renderContext: function (contextId) {
		if (contextId !== undefined) {
			this._renderContext = contextId;
			this._renderMode = this._renderModes[contextId];

			this.log('Rendering mode set to: ' + contextId);

			return this;
		}

		return this._renderContext;
	},

	/**
	 * Creates a front-buffer or "drawing surface" for the renderer.
	 *
	 * @param {Boolean} autoSize Determines if the canvas will auto-resize
	 * when the browser window changes dimensions. If true the canvas will
	 * automatically fill the window when it is resized.
	 *
	 * @param {Boolean=} dontScale If set to true, IGE will ignore device
	 * pixel ratios when setting the width and height of the canvas and will
	 * therefore not take into account "retina", high-definition displays or
	 * those whose pixel ratio is different from 1 to 1.
	 */
	createFrontBuffer: function (autoSize, dontScale) {
		var self = this;
		if (this.isClient) {
			if (!this._canvas) {
				this._createdFrontBuffer = true;
				this._pixelRatioScaling = !dontScale;

				this._frontBufferSetup(autoSize, dontScale);
			}
		}
	},

	_frontBufferSetup: function (autoSize, dontScale) {
		// Create a new canvas element to use as the
		// rendering front-buffer
		var tempCanvas = document.createElement('canvas');

		// Set the canvas element id
		tempCanvas.id = 'igeFrontBuffer';

		this.canvas(tempCanvas, autoSize);
		document.body.appendChild(tempCanvas);
	},

	/**
	 * Sets the canvas element that will be used as the front-buffer.
	 * @param elem The canvas element.
	 * @param autoSize If set to true, the engine will automatically size
	 * the canvas to the width and height of the window upon window resize.
	 */
	canvas: function (elem, autoSize) {
		if (elem !== undefined) {
			if (!this._canvas) {
				// Setup front-buffer canvas element
				this._canvas = elem;
				this._ctx = this._canvas.getContext(this._renderContext);

				// Handle pixel ratio settings
				if (this._pixelRatioScaling) {
					// Support high-definition devices and "retina" (stupid marketing name)
					// displays by adjusting for device and back store pixels ratios
					this._devicePixelRatio = window.devicePixelRatio || 1;
					this._backingStoreRatio = this._ctx.webkitBackingStorePixelRatio ||
						this._ctx.mozBackingStorePixelRatio ||
						this._ctx.msBackingStorePixelRatio ||
						this._ctx.oBackingStorePixelRatio ||
						this._ctx.backingStorePixelRatio || 1;

					this._deviceFinalDrawRatio = this._devicePixelRatio / this._backingStoreRatio;
				} else {
					// No auto-scaling
					this._devicePixelRatio = 1;
					this._backingStoreRatio = 1;
					this._deviceFinalDrawRatio = 1;
				}

				if (autoSize) {
					this._autoSize = autoSize;
				}
				
				// Add some event listeners even if autosize is off
				window.addEventListener('resize', this._resizeEvent);

				// Fire the resize event for the first time
				// which sets up initial canvas dimensions
				this._resizeEvent();
				this._ctx = this._canvas.getContext(this._renderContext);
				this._headless = false;

				// Ask the input component to setup any listeners it has
				this.input.setupListeners(this._canvas);
			}
		}

		return this._canvas;
	},

	/**
	 * Clears the entire canvas.
	 */
	clearCanvas: function () {
		if (this._ctx) {
			// Clear the whole canvas
			this._ctx.clearRect(
				0,
				0,
				this._canvas.width,
				this._canvas.height
			);
		}
	},

	/**
	 * Removes the engine's canvas from the DOM.
	 */
	removeCanvas: function () {
		// Stop listening for input events
		if (this.input) {
			this.input.destroyListeners();
		}

		// Remove event listener
		window.removeEventListener('resize', this._resizeEvent);

		if (this._createdFrontBuffer) {
			// Remove the canvas from the DOM
			document.body.removeChild(this._canvas);
		}

		// Clear internal references
		delete this._canvas;
		delete this._ctx;
		this._ctx = IgeDummyContext;
		this._headless = true;
	},

	/**
	 * Opens a new window to the specified url. When running in a
	 * native wrapper, will load the url in place of any existing
	 * page being displayed in the native web view.
	 * @param url
	 */
	openUrl: function (url) {
		if (url !== undefined) {

			if (ige.cocoonJs && ige.cocoonJs.detected) {
				// Open URL via CocoonJS webview
				ige.cocoonJs.openUrl(url);
			} else {
				// Open via standard JS open window
				window.open(url);
			}
		}
	},

	/**
	 * Loads the specified URL as an HTML overlay on top of the
	 * front buffer in an iFrame. If running in a native wrapper,
	 * will load the url in place of any existing page being
	 * displayed in the native web view.
	 *
	 * When the overlay is in use, no mouse or touch events will
	 * be fired on the front buffer. Once you are finished with the
	 * overlay, call hideOverlay() to re-enable interaction with
	 * the front buffer.
	 * @param {String=} url
	 */
	showWebView: function (url) {
		if (ige.cocoonJs && ige.cocoonJs.detected) {
			// Open URL via CocoonJS webview
			ige.cocoonJs.showWebView(url);
		} else {
			// Load the iFrame url
			var overlay = document.getElementById('igeOverlay');

			if (!overlay) {
				// No overlay was found, create one
				overlay = document.createElement('iframe');

				// Setup overlay styles
				overlay.id = 'igeOverlay';
				overlay.style.position = 'absolute';
				overlay.style.border = 'none';
				overlay.style.left = '0px';
				overlay.style.top = '0px';
				overlay.style.width = '100%';
				overlay.style.height = '100%';

				// Append overlay to body
				document.body.appendChild(overlay);
			}

			// If we have a url, set it now
			if (url !== undefined) {
				overlay.src = url;
			}

			// Show the overlay
			overlay.style.display = 'block';
		}

		return this;
	},

	/**
	 * Hides the web view overlay.
	 * @return {*}
	 */
	hideWebView: function () {
		if (ige.cocoonJs && ige.cocoonJs.detected) {
			// Hide the cocoonJS webview
			ige.cocoonJs.hideWebView();
		} else {
			var overlay = document.getElementById('igeOverlay');
			if (overlay) {
				overlay.style.display = 'none';
			}
		}

		return this;
	},

	/**
	 * Evaluates javascript sent from another frame.
	 * @param js
	 */
	layerCall: function (js) {
		if (js !== undefined) {
			eval(js);
		}
	},

	/**
	 * Returns the mouse position relative to the main front buffer. Mouse
	 * position is set by the ige.input component (IgeInputComponent)
	 * @return {IgePoint3d}
	 */
	mousePos: function () {
		return this._mousePos.clone();
	},

	/**
	 * Walks the scenegraph and returns an array of all entities that the mouse
	 * is currently over, ordered by their draw order from drawn last (above other
	 * entities) to first (underneath other entities).
	 */
	mouseOverList: function (obj, entArr) {
		var arr,
			arrCount,
			mp,
			mouseTriggerPoly,
			first = false;
		
		if (!obj) {
			obj = ige;
			entArr = [];
			first = true;
		}
		
		if (obj === ige) {
			// Loop viewports
			arr = obj._children;
	
			if (arr) {
				arrCount = arr.length;
	
				// Loop our children
				while (arrCount--) {
					if (arr[arrCount]._scene) {
						if (arr[arrCount]._scene._shouldRender) {
							this.mouseOverList(arr[arrCount]._scene, entArr);
						}
					}
				}
			}
		} else {
			// Check if the mouse is over this entity
			mp = this.mousePosWorld();

			if (mp && obj.aabb) {
				// Trigger mode is against the AABB
				mouseTriggerPoly = obj.aabb(); //this.localAabb();
				
				// Check if the current mouse position is inside this aabb
				if (mouseTriggerPoly.xyInside(mp.x, mp.y)) {
					entArr.push(obj);
				}
			}
			
			// Check if the entity has children
			arr = obj._children;

			if (arr) {
				arrCount = arr.length;

				// Loop our children
				while (arrCount--) {
					this.mouseOverList(arr[arrCount], entArr);
				}
			}
		}
		
		if (first) {
			entArr.reverse();
		}
		
		return entArr;
	},

	/**
	 * Handles the screen resize event.
	 * @param event
	 * @private
	 */
	_resizeEvent: function (event) {
		var canvasBoundingRect;
		
		if (ige._autoSize) {
			var newWidth = window.innerWidth,
				newHeight = window.innerHeight,
				arr = ige._children,
				arrCount = arr.length;

			// Only update canvas dimensions if it exists
			if (ige._canvas) {
				// Check if we can get the position of the canvas
				canvasBoundingRect = ige._canvasPosition();
				
				// Adjust the newWidth and newHeight by the canvas offset
				newWidth -= parseInt(canvasBoundingRect.left);
				newHeight -= parseInt(canvasBoundingRect.top);
				
				// Make sure we can divide the new width and height by 2...
				// otherwise minus 1 so we get an even number so that we
				// negate the blur effect of sub-pixel rendering
				if (newWidth % 2) { newWidth--; }
				if (newHeight % 2) { newHeight--; }

				ige._canvas.width = newWidth * ige._deviceFinalDrawRatio;
				ige._canvas.height = newHeight * ige._deviceFinalDrawRatio;

				if (ige._deviceFinalDrawRatio !== 1) {
					ige._canvas.style.width = newWidth + 'px';
					ige._canvas.style.height = newHeight + 'px';

					// Scale the canvas context to account for the change
					ige._ctx.scale(ige._deviceFinalDrawRatio, ige._deviceFinalDrawRatio);
				}
			}

			ige._bounds2d = new IgePoint3d(newWidth, newHeight, 0);

			// Loop any mounted children and check if
			// they should also get resized
			while (arrCount--) {
				arr[arrCount]._resizeEvent(event);
			}
		} else {
			if (ige._canvas) {
				ige._bounds2d = new IgePoint3d(ige._canvas.width, ige._canvas.height, 0);
			}
		}

		if (ige._showSgTree) {
			var sgTreeElem = document.getElementById('igeSgTree');
							
			canvasBoundingRect = ige._canvasPosition();
			
			sgTreeElem.style.top = (parseInt(canvasBoundingRect.top) + 5) + 'px';
			sgTreeElem.style.left = (parseInt(canvasBoundingRect.left) + 5) + 'px';
			sgTreeElem.style.height = (ige._bounds2d.y - 30) + 'px';
		}

		ige._resized = true;
	},

	/**
	 * Gets the bounding rectangle for the HTML canvas element being
	 * used as the front buffer for the engine. Uses DOM methods.
	 * @returns {ClientRect}
	 * @private
	 */
	_canvasPosition: function () {
		try {
			return ige._canvas.getBoundingClientRect();
		} catch (e) {
			return {
				top: ige._canvas.offsetTop,
				left: ige._canvas.offsetLeft
			};
		}
	},

	/**
	 * Toggles full-screen output of the main ige canvas. Only works
	 * if called from within a user-generated HTML event listener.
	 */
	toggleFullScreen: function () {
		var elem = this._canvas;
		
		if (elem.requestFullscreen) {
			elem.requestFullscreen();
		} else if (elem.mozRequestFullScreen) {
			elem.mozRequestFullScreen();
		} else if (elem.webkitRequestFullscreen) {
			elem.webkitRequestFullscreen();
		}
	},

	/**
	 * Adds a new watch expression to the watch list which will be
	 * displayed in the stats overlay during a call to _statsTick().
	 * @param {*} evalStringOrObject The expression to evaluate and
	 * display the result of in the stats overlay, or an object that
	 * contains a "value" property.
	 * @returns {Integer} The index of the new watch expression you
	 * just added to the watch array.
	 */
	watchStart: function (evalStringOrObject) {
		this._watch = this._watch || [];
		this._watch.push(evalStringOrObject);

		return this._watch.length - 1;
	},

	/**
	 * Removes a watch expression by it's array index.
	 * @param {Number} index The index of the watch expression to
	 * remove from the watch array.
	 */
	watchStop: function (index) {
		this._watch = this._watch || [];
		this._watch.splice(index, 1);
	},

	/**
	 * Sets a trace up on the setter of the passed object's
	 * specified property. When the property is set by any
	 * code the debugger line is activated and code execution
	 * will be paused allowing you to step through code or
	 * examine the call stack to see where the property set
	 * originated.
	 * @param {Object} obj The object whose property you want
	 * to trace.
	 * @param {String} propName The name of the property you
	 * want to put the trace on.
	 * @param {Number} sampleCount The number of times you
	 * want the trace to break with the debugger line before
	 * automatically switching off the trace.
	 * @param {Function=} callbackEvaluator Optional callback
	 * that if returns true, will fire debugger. Method is passed
	 * the setter value as first argument.
	 */
	traceSet: function (obj, propName, sampleCount, callbackEvaluator) {
		obj.___igeTraceCurrentVal = obj.___igeTraceCurrentVal || {};
		obj.___igeTraceCurrentVal[propName] = obj[propName];
		obj.___igeTraceMax = sampleCount || 1;
		obj.___igeTraceCount = 0;

		Object.defineProperty(obj, propName, {
			get: function () {
				return obj.___igeTraceCurrentVal[propName];
			},
			set: function (val) {
				if (callbackEvaluator){ 
					if (callbackEvaluator(val)) {
						debugger;
					}
				} else {
					debugger;
				}
				
				obj.___igeTraceCurrentVal[propName] = val;
				obj.___igeTraceCount++;

				if (obj.___igeTraceCount === obj.___igeTraceMax) {
					// Maximum amount of trace samples reached, turn off
					// the trace system
					ige.traceSetOff(obj, propName);
				}
			}
		});
	},

	/**
	 * Turns off a trace that was created by calling traceSet.
	 * @param {Object} object The object whose property you want
	 * to disable a trace against.
	 * @param {String} propName The name of the property you
	 * want to disable the trace for.
	 */
	traceSetOff: function (object, propName) {
		Object.defineProperty(object, propName, {set: function (val) { this.___igeTraceCurrentVal[propName] = val; }});
	},

	/**
	 * Finds the first Ige* based class that the passed object
	 * has been derived from.
	 * @param obj
	 * @return {*}
	 */
	findBaseClass: function (obj) {
		if (obj && obj._classId) {
			if (obj._classId.substr(0, 3) === 'Ige') {
				return obj._classId;
			} else {
				if (obj.__proto__._classId) { 
					return this.findBaseClass(obj.__proto__);
				} else {
					return '';
				}
			}
		} else {
			return '';
		}
	},

	/**
	 * Returns an array of all classes the passed object derives from
	 * in order from current to base.
	 * @param obj
	 * @param arr
	 * @return {*}
	 */
	getClassDerivedList: function (obj, arr) {
		if (!arr) {
			arr = [];
		} else {
			if (obj._classId) {
				arr.push(obj._classId);
			}
		}
		
		if (obj.__proto__._classId) {
			this.getClassDerivedList(obj.__proto__, arr);
		}
		
		return arr;
	},
	
	spawnQueue: function (ent) {
		if (ent !== undefined) {
			this._spawnQueue.push(ent);
			return this;
		}
		
		return this._spawnQueue;
	},

	/**
	 * Is called every second and does things like calculate the current FPS.
	 * @private
	 */
	_secondTick: function () {
		var self = ige;

		// Store frames per second
		self._fps = self._frames;

		// Store draws per second
		self._dps = self._dpf * self._fps;

		// Zero out counters
		self._frames = 0;
		self._drawCount = 0;
	},
	
	/**
	 * Gets / sets the current time scalar value. The engine's internal
	 * time is multiplied by this value and it's default is 1. You can set it to
	 * 0.5 to slow down time by half or 1.5 to speed up time by half. Negative
	 * values will reverse time but not all engine systems handle this well
	 * at the moment.
	 * @param {Number=} val The time scale value.
	 * @returns {*}
	 */
	timeScale: function (val) {
		if (val !== undefined) {
			this._timeScale = val;
			return this;
		}

		return this._timeScale;
	},

	/**
	 * Increments the engine's interal time by the passed number of milliseconds.
	 * @param {Number} val The number of milliseconds to increment time by.
	 * @param {Number=} lastVal The last internal time value, used to calculate
	 * delta internally in the method.
	 * @returns {Number}
	 */
	incrementTime: function (val, lastVal) {
		if (!this._pause) {
			if (!lastVal) { lastVal = val; }
			this._currentTime += ((val - lastVal) * this._timeScale);
		}
		return this._currentTime;
	},

	/**
	 * Get the current time from the engine.
	 * @return {Number} The current time.
	 */
	currentTime: function () {
		return this._currentTime;
	},

	/**
	 * Gets / sets the pause flag. If set to true then the engine's
	 * internal time will no longer increment and will instead stay static.
	 * @param val
	 * @returns {*}
	 */
	pause: function (val) {
		if (val !== undefined) {
			this._pause = val;
			return this;
		}
		
		return this._pause;
	},

	/**
	 * Gets / sets the option to determine if the engine should
	 * schedule it's own ticks or if you want to manually advance
	 * the engine by calling tick when you wish to.
	 * @param {Boolean=} val
	 * @return {*}
	 */
	useManualTicks: function (val) {
		if (val !== undefined) {
			this._useManualTicks = val;
			return this;
		}

		return this._useManualTicks;
	},

	/**
	 * Schedules a manual tick.
	 */
	manualTick: function () {
		if (this._manualFrameAlternator !== this._frameAlternator) {
			this._manualFrameAlternator = this._frameAlternator;
			requestAnimFrame(this.engineStep);
		}
	},

	/**
	 * Gets / sets the option to determine if the engine should
	 * render on every tick or wait for a manualRender() call.
	 * @param {Boolean=} val True to enable manual rendering, false
	 * to disable.
	 * @return {*}
	 */
	useManualRender: function (val) {
		if (val !== undefined) {
			this._useManualRender = val;
			return this;
		}

		return this._useManualRender;
	},

	/**
	 * Manually render a frame on demand. This is used in conjunction
	 * with the ige.useManualRender(true) call which will cause the
	 * engine to only render new graphics frames from the scenegraph
	 * once this method is called. You must call this method every time
	 * you wish to update the graphical output on screen.
	 * 
	 * Calling this method multiple times during a single engine tick
	 * will NOT make it draw more than one frame, therefore it is safe
	 * to call multiple times if required by different sections of game
	 * logic without incurring extra rendering cost.
	 */
	manualRender: function () {
		this._manualRender = true;
	},

	/**
	 * Called each frame to traverse and render the scenegraph.
	 */
	engineStep: function (timeStamp, ctx) {
		/* TODO:
			Make the scenegraph process simplified. Walk the scenegraph once and grab the order in a flat array
			then process updates and ticks. This will also allow a layered rendering system that can render the
			first x number of entities then stop, allowing a step through of the renderer in realtime.
		 */
		var st,
			et,
			updateStart,
			renderStart,
			self = ige,
			ptArr = self._postTick,
			ptCount = ptArr.length,
			ptIndex,
			unbornQueue,
			unbornCount,
			unbornIndex,
			unbornEntity;

		// Scale the timestamp according to the current
		// engine's time scaling factor
		self.incrementTime(timeStamp, self._timeScaleLastTimestamp);

		self._timeScaleLastTimestamp = timeStamp;
		timeStamp = Math.floor(self._currentTime);

		if (igeConfig.debug._timing) {
			st = new Date().getTime();
		}

		if (self._state) {
			// Check if we were passed a context to work with
			if (ctx === undefined) {
				ctx = self._ctx;
			}

			// Alternate the boolean frame alternator flag
			self._frameAlternator = !self._frameAlternator;

			// If the engine is not in manual tick mode...
			if (!ige._useManualTicks) {
				// Schedule a new frame
				requestAnimFrame(self.engineStep);
			} else {
				self._manualFrameAlternator = !self._frameAlternator;
			}

			// Get the current time in milliseconds
			self._tickStart = timeStamp;

			// Adjust the tickStart value by the difference between
			// the server and the client clocks (this is only applied
			// when running as the client - the server always has a
			// clientNetDiff of zero)
			self._tickStart -= self._clientNetDiff;

			if (!self.lastTick) {
				// This is the first time we've run so set some
				// default values and set the delta to zero
				self.lastTick = 0;
				self._tickDelta = 0;
			} else {
				// Calculate the frame delta
				self._tickDelta = self._tickStart - self.lastTick;
			}
			
			// Check for unborn entities that should be born now
			unbornQueue = ige._spawnQueue;
			unbornCount = unbornQueue.length;
			for (unbornIndex = unbornCount - 1; unbornIndex >= 0; unbornIndex--) {
				unbornEntity = unbornQueue[unbornIndex];
				
				if (ige._currentTime >= unbornEntity._bornTime) {
					// Now birth this entity
					unbornEntity.mount(ige.$(unbornEntity._birthMount));
					unbornQueue.splice(unbornIndex, 1);
				}
			}

			// Update the scenegraph
			if (self._enableUpdates) {
				if (igeConfig.debug._timing) {
					updateStart = new Date().getTime();
					self.updateSceneGraph(ctx);
					ige._updateTime = new Date().getTime() - updateStart;
				} else {
					self.updateSceneGraph(ctx);
				}
			}
			
			// Render the scenegraph
			if (self._enableRenders) {
				if (!self._useManualRender) {
					if (igeConfig.debug._timing) {
						renderStart = new Date().getTime();
						self.renderSceneGraph(ctx);
						ige._renderTime = new Date().getTime() - renderStart;
					} else {
						self.renderSceneGraph(ctx);
					}
				} else {
					if (self._manualRender) {
						if (igeConfig.debug._timing) {
							renderStart = new Date().getTime();
							self.renderSceneGraph(ctx);
							ige._renderTime = new Date().getTime() - renderStart;
						} else {
							self.renderSceneGraph(ctx);
						}
						self._manualRender = false;
					}
				}
			}

			// Call post-tick methods
			for (ptIndex = 0; ptIndex < ptCount; ptIndex++) {
				ptArr[ptIndex]();
			}

			// Record the lastTick value so we can
			// calculate delta on the next tick
			self.lastTick = self._tickStart;
			self._frames++;
			self._dpf = self._drawCount;
			self._drawCount = 0;

			// Call the input system tick to reset any flags etc
			self.input.tick();
		}

		self._resized = false;

		if (igeConfig.debug._timing) {
			et = new Date().getTime();
			ige._tickTime = et - st;
		}
	},
	
	updateSceneGraph: function (ctx) {
		var arr = this._children,
			arrCount, us, ud,
			tickDelta = ige._tickDelta;

		// Process any behaviours assigned to the engine
		this._processUpdateBehaviours(ctx, tickDelta);

		if (arr) {
			arrCount = arr.length;

			// Loop our viewports and call their update methods
			if (igeConfig.debug._timing) {
				while (arrCount--) {
					us = new Date().getTime();
					arr[arrCount].update(ctx, tickDelta);
					ud = new Date().getTime() - us;
					
					if (arr[arrCount]) {
						if (!ige._timeSpentInUpdate[arr[arrCount].id()]) {
							ige._timeSpentInUpdate[arr[arrCount].id()] = 0;
						}

						if (!ige._timeSpentLastUpdate[arr[arrCount].id()]) {
							ige._timeSpentLastUpdate[arr[arrCount].id()] = {};
						}

						ige._timeSpentInUpdate[arr[arrCount].id()] += ud;
						ige._timeSpentLastUpdate[arr[arrCount].id()].ms = ud;
					}
				}
			} else {
				while (arrCount--) {
					arr[arrCount].update(ctx, tickDelta);
				}
			}
		}
	},

	renderSceneGraph: function (ctx) {
		var ts, td;

		// Process any behaviours assigned to the engine
		this._processTickBehaviours(ctx);

		// Depth-sort the viewports
		if (this._viewportDepth) {
			if (igeConfig.debug._timing) {
				ts = new Date().getTime();
				this.depthSortChildren();
				td = new Date().getTime() - ts;

				if (!ige._timeSpentLastTick[this.id()]) {
					ige._timeSpentLastTick[this.id()] = {};
				}

				ige._timeSpentLastTick[this.id()].depthSortChildren = td;
			} else {
				this.depthSortChildren();
			}
		}

		ctx.save();
		ctx.translate(this._bounds2d.x2, this._bounds2d.y2);
		//ctx.scale(this._globalScale.x, this._globalScale.y);

		// Process the current engine tick for all child objects
		var arr = this._children,
			arrCount;

		if (arr) {
			arrCount = arr.length;

			// Loop our viewports and call their tick methods
			if (igeConfig.debug._timing) {
				while (arrCount--) {
					ctx.save();
					ts = new Date().getTime();
					arr[arrCount].tick(ctx);
					td = new Date().getTime() - ts;
					if (arr[arrCount]) {
						if (!ige._timeSpentInTick[arr[arrCount].id()]) {
							ige._timeSpentInTick[arr[arrCount].id()] = 0;
						}

						if (!ige._timeSpentLastTick[arr[arrCount].id()]) {
							ige._timeSpentLastTick[arr[arrCount].id()] = {};
						}

						ige._timeSpentInTick[arr[arrCount].id()] += td;
						ige._timeSpentLastTick[arr[arrCount].id()].ms = td;
					}
					ctx.restore();
				}
			} else {
				while (arrCount--) {
					ctx.save();
					arr[arrCount].tick(ctx);
					ctx.restore();
				}
			}
		}

		ctx.restore();
	},

	fps: function () {
		return this._fps;
	},

	dpf: function () {
		return this._dpf;
	},

	dps: function () {
		return this._dps;
	},

	analyseTiming: function () {
		if (igeConfig.debug._timing) {

		} else {
			this.log('Cannot analyse timing because the igeConfig.debug._timing flag is not enabled so no timing data has been recorded!', 'warning');
		}
	},

	saveSceneGraph: function (item) {
		var arr, arrCount, i;

		if (!item) {
			item = this.getSceneGraphData();
		}

		if (item.obj.stringify) {
			item.str = item.obj.stringify();
		} else {
			console.log('Class ' + item.classId + ' has no stringify() method! For object: ' + item.id, item.obj);
		}
		arr = item.items;

		if (arr) {
			arrCount = arr.length;

			for (i = 0; i < arrCount; i++) {
				this.saveSceneGraph(arr[i]);
			}
		}

		return item;
	},

	/**
	 * Walks the scene graph and outputs a console map of the graph.
	 */
	sceneGraph: function (obj, currentDepth, lastDepth) {
		var depthSpace = '',
			di,
			timingString,
			arr,
			arrCount;

		if (currentDepth === undefined) { currentDepth = 0; }

		if (!obj) {
			// Set the obj to the main ige instance
			obj = ige;
		}

		for (di = 0; di < currentDepth; di++) {
			depthSpace += '----';
		}

		if (igeConfig.debug._timing) {
			timingString = '';

			timingString += 'T: ' + ige._timeSpentInTick[obj.id()];
			if (ige._timeSpentLastTick[obj.id()]) {
				if (typeof(ige._timeSpentLastTick[obj.id()].ms) === 'number') {
					timingString += ' | LastTick: ' + ige._timeSpentLastTick[obj.id()].ms;
				}

				if (typeof(ige._timeSpentLastTick[obj.id()].depthSortChildren) === 'number') {
					timingString += ' | ChildDepthSort: ' + ige._timeSpentLastTick[obj.id()].depthSortChildren;
				}
			}

			console.log(depthSpace + obj.id() + ' (' + obj._classId + ') : ' + obj._inView + ' Timing(' + timingString + ')');
		} else {
			console.log(depthSpace + obj.id() + ' (' + obj._classId + ') : ' + obj._inView);
		}

		currentDepth++;

		if (obj === ige) {
			// Loop the viewports
			arr = obj._children;

			if (arr) {
				arrCount = arr.length;

				// Loop our children
				while (arrCount--) {
					if (arr[arrCount]._scene) {
						if (arr[arrCount]._scene._shouldRender) {
							if (igeConfig.debug._timing) {
								timingString = '';
	
								timingString += 'T: ' + ige._timeSpentInTick[arr[arrCount].id()];
								if (ige._timeSpentLastTick[arr[arrCount].id()]) {
									if (typeof(ige._timeSpentLastTick[arr[arrCount].id()].ms) === 'number') {
										timingString += ' | LastTick: ' + ige._timeSpentLastTick[arr[arrCount].id()].ms;
									}
	
									if (typeof(ige._timeSpentLastTick[arr[arrCount].id()].depthSortChildren) === 'number') {
										timingString += ' | ChildDepthSort: ' + ige._timeSpentLastTick[arr[arrCount].id()].depthSortChildren;
									}
								}
	
								console.log(depthSpace + '----' + arr[arrCount].id() + ' (' + arr[arrCount]._classId + ') : ' + arr[arrCount]._inView + ' Timing(' + timingString + ')');
							} else {
								console.log(depthSpace + '----' + arr[arrCount].id() + ' (' + arr[arrCount]._classId + ') : ' + arr[arrCount]._inView);
							}
							this.sceneGraph(arr[arrCount]._scene, currentDepth + 1);
						}
					}
				}
			}
		} else {
			arr = obj._children;

			if (arr) {
				arrCount = arr.length;

				// Loop our children
				while (arrCount--) {
					this.sceneGraph(arr[arrCount], currentDepth);
				}
			}
		}
	},

	/**
	 * Walks the scenegraph and returns a data object of the graph.
	 */
	getSceneGraphData: function (obj, noRef) {
		var item, items = [], tempItem, tempItem2, tempCam,
			arr, arrCount;

		if (!obj) {
			// Set the obj to the main ige instance
			obj = ige;
		}

		item = {
			text: '[' + obj._classId + '] ' + obj.id(),
			id: obj.id(),
			classId: obj.classId()
		};

		if (!noRef) {
			item.parent = obj._parent;
			item.obj = obj;
		} else {
			if (obj._parent) {
				item.parentId = obj._parent.id();
			} else {
				item.parentId = 'sceneGraph';
			}
		}

		if (obj === ige) {
			// Loop the viewports
			arr = obj._children;

			if (arr) {
				arrCount = arr.length;

				// Loop our children
				while (arrCount--) {
					tempItem = {
						text: '[' + arr[arrCount]._classId + '] ' + arr[arrCount].id(),
						id: arr[arrCount].id(),
						classId: arr[arrCount].classId()
					};

					if (!noRef) {
						tempItem.parent = arr[arrCount]._parent;
						tempItem.obj = arr[arrCount];
					} else {
						if (arr[arrCount]._parent) {
							tempItem.parentId = arr[arrCount]._parent.id();
						}
					}
					
					if (arr[arrCount].camera) {
						// Add the viewport camera as an object on the scenegraph
						tempCam = {
							text: '[IgeCamera] ' + arr[arrCount].id(),
							id: arr[arrCount].camera.id(),
							classId: arr[arrCount].camera.classId()
						};
						
						if (!noRef) {
							tempCam.parent = arr[arrCount];
							tempCam.obj = arr[arrCount].camera;
						} else {
							tempCam.parentId = arr[arrCount].id();
						}
	
						if (arr[arrCount]._scene) {
							tempItem2 = this.getSceneGraphData(arr[arrCount]._scene, noRef);
							tempItem.items = [tempCam, tempItem2];
						}
					} else {
						if (arr[arrCount]._scene) {
							tempItem2 = this.getSceneGraphData(arr[arrCount]._scene, noRef);
							tempItem.items = [tempItem2];
						}
					}
					
					items.push(tempItem);
				}
			}
		} else {
			arr = obj._children;

			if (arr) {
				arrCount = arr.length;

				// Loop our children
				while (arrCount--) {
					tempItem = this.getSceneGraphData(arr[arrCount], noRef);
					items.push(tempItem);
				}
			}
		}

		if (items.length > 0) {
			item.items = items;
		}

		return item;
	},
	
	_childMounted: function (child) {
		if (child.IgeViewport) {
			// The first mounted viewport gets set as the current
			// one before any rendering is done
			if (!ige._currentViewport) {
				ige._currentViewport = child;
				ige._currentCamera = child.camera;
			}
		}
		
		IgeEntity.prototype._childMounted.call(this, child);
	},

	destroy: function () {
		// Stop the engine and kill any timers
		this.stop();

		// Remove the front buffer (canvas) if we created it
		if (this.isClient) {
			this.removeCanvas();
		}

		// Call class destroy() super method
		IgeEntity.prototype.destroy.call(this);

		this.log('Engine destroy complete.');
	}
});
if (typeof(module) !== 'undefined' && typeof(module.exports) !== 'undefined') { module.exports = IgeEngine; }
